/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

wchar_t *sub_402CD0();
_DWORD *sub_402D01();
void sub_402E2D();
void sub_402EEC();
char __thiscall sub_402FCB(wchar_t *String1);
void __fastcall sub_4030A6(wchar_t *Control, int *a2, _DWORD *a3);
_WORD *__thiscall sub_403236(_DWORD *this);
char sub_4032FC();
void sub_403416();
void sub_40354D();
char __fastcall sub_40367D(wchar_t *Name, wchar_t *Block, int a3);
char __fastcall sub_4037A4(wchar_t *Name, wchar_t *a2, int a3);
void __fastcall sub_403907(wchar_t *Block, char a2, int a3);
void __thiscall sub_4039C8(_DWORD **this);
_DWORD *__thiscall sub_403AFE(_DWORD *this);
void *__thiscall sub_403B48(void *this);
bool __fastcall sub_403B50(wint_t C);
wchar_t *__fastcall sub_403B75(wchar_t *Str, wchar_t Ch);
__int16 __thiscall sub_403B80(_DWORD *this, __int16 a2);
int __thiscall sub_403BB0(_DWORD *this, __int16 *a2);
int __thiscall sub_403BE1(_DWORD *this, void *Src, int a3);
_DWORD *__thiscall sub_403C20(_DWORD *Src, _DWORD *a2, char *a3);
char *__thiscall sub_403CAC(_DWORD *Src, int a2);
void __noreturn sub_403D1E();
void *__fastcall sub_403D2A(unsigned int a1);
void *__fastcall sub_403D5C(void *Block, unsigned int a2);
int sub_403D9C();
int __fastcall sub_403EFA(wchar_t *a1, char a2, unsigned int *a3, int a4);
int __fastcall sub_403F66(wchar_t *a1, char a2, unsigned int *a3, wchar_t *a4, _DWORD *a5);
int __fastcall sub_403FBC(int a1, char a2, unsigned int *a3, char a4, wchar_t *a5, _DWORD *a6);
_DWORD *__fastcall sub_404DF3(int a1, int a2);
char __fastcall sub_4051DA(__int16 **a1, __int16 **a2);
int __thiscall sub_405322(_DWORD *this);
_DWORD *__fastcall sub_40534C(char *Src, char a2);
int __fastcall sub_405393(_DWORD *a1, int a2, int a3, int a4);
unsigned int __thiscall sub_40543F(_DWORD *this);
int __thiscall sub_405594(_DWORD *this);
void __thiscall sub_4055B2(_DWORD *this);
wchar_t *__fastcall sub_4055E1(wchar_t **a1, int *a2);
void *__fastcall sub_4056E9(char *a1, int a2, void **a3);
char *__fastcall sub_405757(wchar_t *Str, int *a2, void **a3);
void __fastcall sub_4057E3(wchar_t *a1, int *a2, void **a3);
void __thiscall sub_405994(wchar_t *FileName);
int sub_405B2C(int a1, unsigned int a2, ...);
void sub_405C06(unsigned int a1, ...);
int sub_405CA2();
void sub_405CCE();
size_t __fastcall sub_405D0D(_DWORD *a1, const wchar_t **a2, wchar_t *String);
unsigned int __fastcall sub_405E74(char *Src, _DWORD *a2, int a3, unsigned __int8 a4, const wchar_t *a5);
unsigned int __fastcall sub_405EB6(_DWORD *a1, _DWORD *a2, int a3, unsigned __int8 a4, const wchar_t *a5);
wchar_t **__fastcall sub_406334(wchar_t *a1, int a2, wchar_t **ArgList);
wchar_t *__fastcall sub_40644F(int a1, wchar_t **a2);
char *__thiscall sub_406A6C(wchar_t *Str);
char __fastcall sub_406B6A(int a1, wint_t **a2, int *a3);
char __fastcall sub_406D21(wchar_t *FileName, int a2);
char __fastcall sub_406E40(wchar_t *String, rsize_t a2, int *a3, int *a4);
bool __fastcall sub_40704E(_WORD *a1, _DWORD *a2);
char __fastcall sub_407105(wchar_t *FullPath, wchar_t *a2, int a3);
intptr_t __fastcall sub_40756C(wchar_t *Source, char a2, char a3, char a4, void **a5);
void *sub_407E09();
char __fastcall sub_407EA5(__int16 *a1, int a2, char a3, char a4, const wchar_t *a5, unsigned int *a6);
void __fastcall sub_408124(int a1, __int16 **a2);
void __fastcall sub_4081AE(int ArgList, char a2);
__int64 __thiscall sub_40823C(char *this);
WCHAR *__fastcall sub_408256(wchar_t *Str, LPWIN32_FIND_DATAW lpFindFileData, HANDLE *a3);
WCHAR *__fastcall sub_4083E1(LPWIN32_FIND_DATAW lpFindFileData, HANDLE hFindFile);
void *__fastcall sub_408404(wchar_t *a1, wchar_t *a2, struct _WIN32_FIND_DATAW *lpFindFileData, HANDLE *a4);
char __fastcall sub_4084F3(_WORD *Block, LPWIN32_FIND_DATAW lpFindFileData);
char __fastcall sub_408582(wchar_t *Str, _DWORD *a2);
int sub_4086F8();
wint_t *sub_4088A1();
wchar_t *__fastcall sub_4089DD(wchar_t *String1, char *a2);
int __thiscall sub_408B74(wint_t *this);
char __fastcall sub_408CF3(wchar_t *String1, int a2, wchar_t **a3);
// char __usercall sub_408ECF@<al>(char a1@<dl>, wchar_t *a2@<ecx>, int a3@<ebp>);
char sub_409117();
char __stdcall sub_409200(int a1);
wint_t *__fastcall sub_4092B2(wint_t *a1, int a2);
wchar_t *__fastcall sub_409321(const wchar_t *a1);
void *__thiscall sub_4093B5(__int16 **this);
wchar_t *__fastcall sub_4094E3(wchar_t *a1, _DWORD *a2, wchar_t **a3);
errno_t __fastcall sub_409808(void **a1, wchar_t *a2);
int __fastcall sub_4098EC(wchar_t *Source, const unsigned __int16 *a2, char a3);
wchar_t *__fastcall sub_409A5D(FILE *a1, int a2, const wchar_t **a3, char a4, _BYTE *a5);
char __fastcall sub_409C81(wchar_t *Str, int a2, wchar_t *a3, char a4);
int sub_40A0BF();
wint_t __fastcall sub_40A127(char a1);
unsigned __int8 __fastcall sub_40A1AC(wchar_t a1);
unsigned __int8 __fastcall sub_40A290(wint_t Character, _WORD *a2, int a3);
char __fastcall sub_40A4AD(int a1, char a2);
__int16 __fastcall sub_40A552(char a1);
wint_t __fastcall sub_40A62B(wint_t a1, char a2);
const unsigned __int16 *__fastcall sub_40A6DC(char a1, int a2, int a3);
const unsigned __int16 *__fastcall sub_40AD10(const unsigned __int16 *a1, unsigned int a2);
unsigned __int8 __thiscall sub_40AFB3(wchar_t *String);
wchar_t *__thiscall sub_40B45A(wchar_t *FullPath);
int __thiscall sub_40B534(const unsigned __int16 *this);
int sub_40B5C8();
void *__thiscall sub_40B5D9(size_t Size);
void *__thiscall sub_40B5FE(size_t Size);
void *__fastcall sub_40B61C(void *Block, size_t Size);
int __fastcall sub_40B652(wchar_t *Source, wchar_t *a2, int a3, int a4, int a5, int a6, int a7, int a8);
wchar_t **__thiscall sub_40BC3E(int this, wchar_t **String, int Radix, wchar_t ***a4);
void __cdecl Handler(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); // idb
void __thiscall sub_40BDA9(void *this);
BOOL __fastcall sub_40BDB0(const void **a1, void *a2, void *a3);
int __cdecl main(int argc, const char **argv, const char **envp);
char *sub_40C226();
int __fastcall sub_40C388(int a1, int a2, int a3);
int sub_40C58E();
char *sub_40C6D8();
void __fastcall sub_40C7A4(unsigned int a1, int a2);
void *sub_40CAA9();
int __fastcall sub_40CB79(wint_t C, char a2);
void __cdecl Function();
int sub_40CE64();
const unsigned __int16 *__fastcall sub_40CEA2(const unsigned __int16 *a1);
int __fastcall sub_40CEF8(unsigned int a1);
void *sub_40D019();
int sub_40D01F(wchar_t *Buffer, wchar_t *Format, ...);
bool __thiscall sub_40D049(FILE *Stream);
bool sub_40D088();
int sub_40D0B3();
int sub_40D0D1(wchar_t *Format, ...);
int sub_40D0E0();
bool __thiscall sub_40D10C(FILE *Stream);
int __fastcall sub_40D14A(wchar_t *Format, va_list ArgList); // idb
int sub_40D194();
int sub_40D1B2(wchar_t *Format, ...);
int sub_40D1C1();
int __fastcall sub_40D1ED(wchar_t *Format, va_list ArgList); // idb
void *sub_40D237();
int __thiscall sub_40D23D(void *this);
unsigned int __fastcall sub_40D421(int a1, _WORD *a2);
void __fastcall sub_40D450(int a1, int a2, FILETIME FileTime);
void __fastcall sub_40D50A(int a1, int a2);
int sub_40D740();
int sub_40D7B1();
int sub_40D851();
char __stdcall sub_40D9A6(char a1);
char __stdcall sub_40DBEE(char a1);
wchar_t *sub_40DC2C();
wchar_t *sub_40DCA7();
int __fastcall sub_40DD70(char a1, int a2);
wchar_t *sub_40DDDE();
int sub_40DEFF();
int sub_40E1EF();
bool sub_40E260();
bool __thiscall sub_40E38A(wchar_t *String);
bool __fastcall sub_40E3F9(wchar_t *String, char a2);
void **__fastcall sub_40E456(wchar_t *Destination, rsize_t a2, wchar_t *Str, int a4, LPWIN32_FIND_DATAW lpFindFileData);
void sub_40E8BD();
void **__fastcall sub_40EADD(int a1, wchar_t *a2, int a3, unsigned __int64 a4, _DWORD **a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, wchar_t **a9);
_DWORD *sub_40EC89();
void *__thiscall sub_40ECDB(char *Src);
_WORD *__thiscall sub_40ED1F(char *this);
wchar_t *__fastcall sub_40ED85(char *Block, const wchar_t *a2);
_DWORD *__fastcall sub_40EDE0(_DWORD **a1, _DWORD *a2);
int __thiscall sub_40EDF5(wint_t *this, int a2);
_DWORD *__thiscall sub_40EE2D(wchar_t *Source, int a2, int a3);
bool __fastcall sub_40EFD4(__int16 a1);
char __fastcall sub_40F012(wint_t **a1, int **a2, void **a3, const unsigned __int16 *a4, int a5, int a6, int a7, char a8);
char __fastcall sub_40F606(wint_t **this, int **edx0, void **a2, const unsigned __int16 *a3, int a4, int a5, int a6, int a7, char a8, unsigned int a9, unsigned int a10);
wint_t *__fastcall sub_40F779(__int16 *a1, wint_t *a2, bool *a3, int *a4);
_WORD *__thiscall sub_40F8B3(_WORD *this);
wint_t *__thiscall sub_40F94D(wchar_t *Str);
_DWORD *__fastcall sub_40F9D0(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5, int a6);
_DWORD *__fastcall sub_410022(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5, int a6);
// void __userpurge sub_41008C(__int16 **a1@<edx>, _DWORD *a2@<ecx>, int a3@<ebp>, int a4);
_DWORD *__fastcall sub_410488(_DWORD *a1, __int16 a2, _WORD *a3, unsigned int a4, unsigned int a5, unsigned int a6);
__int16 *__fastcall sub_4105D7(_DWORD *a1, __int16 **a2, void *Src, int a4);
// void __userpurge sub_4106C2(__int16 **a1@<edx>, _DWORD *a2@<ecx>, int a3@<ebp>, void *a4, int a5);
void **__thiscall sub_4108DD(_DWORD *this, void *Src, int a3, char *a4, void **a5, void *a6, int a7);
int __thiscall sub_410984(_DWORD *this, _WORD *Src, unsigned int a3, wchar_t *String2, size_t MaxCount, void *a6, int a7);
void __fastcall sub_410A63(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5);
void __fastcall sub_410B16(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4);
void __fastcall sub_410BA1(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5, char a6);
void __fastcall sub_410CBC(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5);
void __fastcall sub_410D61(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4);
void __fastcall sub_410E89(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4);
void __fastcall sub_410F77(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5);
void __fastcall sub_4110E3(_DWORD *Src, __int16 **a2, char a3, _DWORD *a4);
void __fastcall sub_411151(_DWORD *Src, __int16 **a2, char a3, _DWORD *a4);
char __stdcall sub_4111BF(wchar_t *String1, size_t MaxCount, int a3, unsigned int a4);
_WORD *__fastcall sub_41122D(_DWORD *a1, int *a2, _WORD *a3, int a4);
char __fastcall sub_4112D1(char a1, _DWORD *a2, int a3, unsigned int a4, int a5, unsigned int a6);
char __thiscall sub_41144B(int *this, int a2, unsigned int a3);
void *__fastcall sub_4114A5(wchar_t *FullPath, wchar_t *Filename);
char __thiscall sub_411519(_WORD *this);
char __fastcall sub_41168E(char *a1, int a2, unsigned __int16 *a3, const wchar_t *a4);
_DWORD *__thiscall sub_4119EC(wint_t *this, int a2);
int __fastcall sub_411AA4(_WORD *a1, int a2);
_WORD *__fastcall sub_411BBE(_WORD *a1);
FILE *__fastcall sub_411C33(wchar_t *FileName, wchar_t *Mode);
int __thiscall sub_411C7A(char **this, char *a2, unsigned int a3, int a4);
_DWORD *__thiscall sub_411CE1(_DWORD *this, _DWORD *a2, unsigned int a3, unsigned int a4);
bool __stdcall sub_411D11(char *a1, int a2, char *a3, int a4);
int __fastcall sub_411D36(int a1, unsigned int a2, unsigned int a3, __int16 *a4, int a5, int a6);
int __fastcall sub_411DF8(_WORD *a1, int a2, int a3, __int16 *a4, int a5, int a6);
char __thiscall sub_411ECF(_BYTE *this, __int16 *a2, __int16 *a3);
_WORD *__fastcall sub_411EFF(_WORD *a1, int a2, _WORD *a3);
int __fastcall sub_411F28(char *a1, char *a2, int a3);
void __noreturn sub_411F6F();
_DWORD *__thiscall sub_411F7B(_DWORD *this);
int __thiscall sub_411F93(_DWORD *this);
char *__thiscall sub_411FA5(char *Block, char a2);
_DWORD *__thiscall sub_411FD3(_DWORD *this, int a2);
_DWORD *__thiscall sub_411FFB(_DWORD *this, int a2);
void __noreturn sub_412028();
_DWORD *__thiscall sub_412044(void *this, unsigned int a2);
void __stdcall sub_41209A(_DWORD *Block, int a2);
_DWORD **__thiscall sub_4120D4(_DWORD **this, unsigned int a2, int a3, void *Src);
_DWORD **__thiscall sub_41215D(_DWORD **this, void *Src, unsigned int a3);
int sub_4121AD(wchar_t *Buffer, size_t BufferCount, wchar_t *Format, ...);
WCHAR *__thiscall sub_4121DB(wchar_t *FullPath);
// void __cdecl free(void *Block);
int sub_412318();
void __cdecl sub_4124CC(void *Block);
// void __noreturn __report_rangecheckfailure(void); weak
_DWORD *__thiscall sub_412706(_DWORD *Block, char a2);
int __cdecl UserMathErrorFunction();
int sub_412A15();
void sub_412A1F();
char sub_412A2B();
// int __scrt_initialize_default_local_stdio_options(void); weak
BOOL sub_412A6C();
void *sub_412A78();
void *sub_412A7E();
LPTOP_LEVEL_EXCEPTION_FILTER sub_412BE6();
// LONG __stdcall __scrt_unhandled_exception_filter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
void sub_412C48();
void sub_412C50();
void __cdecl sub_412C7C(); // idb
// void *__cdecl memset(void *, int Val, size_t Size);
int sub_412F7D();
// void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// void __cdecl std::_Xout_of_range(const char *); weak
// void __cdecl __noreturn std::_Xlength_error(const char *); weak
// int __cdecl _std_exception_copy(_DWORD, _DWORD); weak
// int __cdecl _std_exception_destroy(_DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

void *type_info::`vftable' = &sub_412706; // weak
const wchar_t Source[] = L"\""; // idb
char byte_401090[] = { '\0' }; // weak
char byte_4011A0[] = { '\x01' }; // weak
char byte_4012C0[] = { '\x01' }; // weak
char byte_4012C1[] = { '\x02' }; // weak
char byte_4012C6[] = { '@' }; // weak
char byte_4012C9[] = { '\x01' }; // weak
wchar_t **off_401390[12] =
{
  &off_401424,
  &off_401418,
  &off_40140C,
  &off_401400,
  &off_4013F4,
  &off_401400,
  &off_4013F4,
  &off_4013E8,
  &off_4013DC,
  &off_4013D0,
  &off_4013C4,
  &off_401384
}; // weak
void *const off_401460 = &aSuffixes_0; // idb
_UNKNOWN off_4014D0; // weak
char byte_401520[] = { '\x01' }; // weak
char byte_401540[] = { '\"' }; // weak
int (*funcs_40D2BD[6])() = { &sub_402CD0, &sub_402D01, &sub_40354D, &sub_4032FC, &sub_402EEC, &sub_403416 }; // weak
char byte_40159C[] = { '\0' }; // weak
char byte_4015C0[] = { '\0' }; // weak
wchar_t *off_4015E0 = L"abspath"; // weak
int dword_4017DC = 0; // weak
const wchar_t aPa[] = L"PA"; // idb
const wchar_t aPa_0[] = L"PA"; // idb
int dword_401A6C = 65279; // weak
void *off_402400 = (void *)0x41004D; // weak
void *off_40240C = (void *)0x41004D; // weak
const wchar_t aMa[] = L"MA"; // idb
int (__thiscall *off_402674)(void *Block, char) = &sub_411FA5; // weak
const _ThrowInfo _TI3_AVbad_array_new_length_std__ = { 0u, &sub_411F93, NULL, &_CTA3_AVbad_array_new_length_std__ }; // idb
int dword_414004 = 1; // weak
char byte_414020 = '\x01'; // weak
char byte_414021 = '\x01'; // weak
int dword_414024 = -1; // weak
int dword_414028 = -1; // weak
wchar_t aMakeflags[29] = L"MAKEFLAGS=                  "; // weak
int dword_414068 = 1; // weak
wchar_t *off_414070 = L"("; // weak
_UNKNOWN unk_414118; // weak
union _SLIST_HEADER ListHead; // idb
int dword_4144E8; // weak
int dword_414500; // weak
int dword_414504; // weak
wchar_t *dword_414508; // idb
char byte_41450C; // weak
char byte_41450D; // weak
char byte_41450E; // weak
char byte_41450F; // weak
wchar_t Destination; // idb
wchar_t Str; // idb
int dword_424510[128]; // weak
int dword_424710; // weak
void *dword_424714; // idb
int dword_424718; // idb
int dword_42471C; // weak
int dword_424720; // weak
int dword_424724; // weak
int dword_424728; // weak
void *dword_42472C; // idb
int dword_424730; // weak
char byte_424734; // weak
char byte_424735; // weak
char byte_424736; // weak
char byte_424737; // weak
wchar_t *Block; // idb
int dword_42473C; // weak
wchar_t Src; // idb
wchar_t word_424742; // idb
__int16 word_424F3C; // weak
int dword_424F40; // weak
int dword_424F44; // weak
int dword_424F48; // weak
void *dword_424F4C; // idb
int dword_424F50; // weak
wchar_t *dword_424F54; // idb
int dword_424F58; // weak
FILE *Stream; // idb
char byte_424F60; // weak
char byte_424F61; // weak
char byte_424F62; // weak
char byte_424F63; // weak
void *ArgList; // idb
wchar_t *dword_424F68; // idb
int dword_424F6C; // weak
wchar_t word_424F70[32768]; // weak
int dword_434F70; // weak
int dword_434F74; // weak
void *dword_434F78; // idb
wchar_t *dword_434F7C; // idb
char byte_434F80[]; // weak
_UNKNOWN unk_434F90; // weak
char byte_43538F[]; // weak
char byte_435390[]; // weak
char byte_435391[]; // weak
int dword_4353A0; // weak
int dword_4353A4; // weak
int dword_4353A8; // weak
int dword_4353AC; // weak
int dword_4353B0[]; // weak
int dword_4353B4[]; // weak
int dword_4353B8[]; // weak
int dword_435470; // weak
int dword_435474; // weak
char byte_435478; // weak
char byte_435479; // weak
char byte_43547A; // weak
char byte_43547B; // weak
char byte_43547C; // weak
char byte_43547D; // weak
char byte_43547E; // weak
char byte_43547F; // weak
_UNKNOWN unk_435480; // weak
char byte_435682; // weak
int dword_435684; // weak
int dword_435688; // weak
int dword_43568C; // weak
int dword_435690; // weak
wchar_t *EndPtr; // idb
int dword_435698; // weak
_UNKNOWN unk_4356A0; // weak
_UNKNOWN unk_437698; // weak
unsigned __int8 byte_4376A0[4088]; // weak
_UNKNOWN unk_438698; // weak
int dword_4386A0; // weak
int dword_4386A4; // weak
int dword_4386A8; // weak
char byte_4386AC; // weak
int dword_4386B0; // weak
_UNKNOWN unk_4386B8; // weak
PVOID dword_4386C0; // idb
PVOID Ptr; // idb
_UNKNOWN unk_4386C8; // weak
wchar_t word_4386E0[1024]; // weak
char byte_438EE0; // weak
HMODULE hModule; // idb
__int16 word_438EE8; // weak
_UNKNOWN unk_438EEC; // weak
_UNKNOWN unk_438EF0; // weak
// extern HRSRC (__stdcall *FindResourceExW)(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage);
// extern HGLOBAL (__stdcall *LoadResource)(HMODULE hModule, HRSRC hResInfo);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern BOOL (__stdcall *GetExitCodeProcess)(HANDLE hProcess, LPDWORD lpExitCode);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern UINT (__stdcall *GetTempFileNameW)(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
// extern BOOL (__stdcall *NeedCurrentDirectoryForExePathW)(LPCWSTR ExeName);
// extern DWORD (__stdcall *FormatMessageW)(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *SetFileTime)(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *GetFileTime)(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern HMODULE (__stdcall *LoadLibraryExW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// extern DWORD (__stdcall *GetLastError)();
// extern DWORD (__stdcall *GetEnvironmentVariableW)(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern PVOID (__stdcall *EncodePointer)(PVOID Ptr);
// extern PVOID (__stdcall *DecodePointer)(PVOID Ptr);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern LANGID (__stdcall *GetUserDefaultUILanguage)();
// extern UINT (__stdcall *SetErrorMode)(UINT uMode);
// extern BOOL (__stdcall *GetFileSizeEx)(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// extern DWORD (__stdcall *GetFileType)(HANDLE hFile);
// extern BOOL (__stdcall *GetConsoleMode)(HANDLE hConsoleHandle, LPDWORD lpMode);
// extern BOOL (__stdcall *FileTimeToLocalFileTime)(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
// extern BOOL (__stdcall *FileTimeToSystemTime)(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
// extern int (__stdcall *GetDateFormatW)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate);
// extern int (__stdcall *GetTimeFormatW)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime);
// extern DWORD (__stdcall *GetFullPathNameW)(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern wchar_t *(__cdecl *wcsstr)(const wchar_t *Str, const wchar_t *SubStr);
// extern wchar_t *(__cdecl *wcsrchr)(const wchar_t *Str, wchar_t Ch);
// extern wchar_t *(__cdecl *wcschr)(const wchar_t *Str, wchar_t Ch);
// extern int (__cdecl *_conio_common_vcwprintf)(unsigned __int64 Options, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern wint_t (__cdecl *putwch)(wchar_t Character);
// extern errno_t (__cdecl *itow_s)(int Value, wchar_t *Buffer, size_t BufferCount, int Radix);
// extern unsigned int (__cdecl *wcstoul)(const wchar_t *String, wchar_t **EndPtr, int Radix);
// extern int (__cdecl *wcstol)(const wchar_t *String, wchar_t **EndPtr, int Radix);
// extern wchar_t ***(__cdecl *_p__wenviron)();
// extern void (__cdecl *wsearchenv)(const wchar_t *Filename, const wchar_t *VarName, wchar_t *ResultPath);
// extern errno_t (__cdecl *wgetenv_s)(size_t *RequiredCount, wchar_t *Buffer, size_t BufferCount, const wchar_t *VarName);
// extern int (__cdecl *wputenv)(const wchar_t *EnvString);
// extern errno_t (__cdecl *wputenv_s)(const wchar_t *Name, const wchar_t *Value);
// extern wchar_t *(__cdecl *wgetcwd)(wchar_t *DstBuf, int SizeInWords);
// extern errno_t (__cdecl *wdupenv_s)(wchar_t **Buffer, size_t *BufferCount, const wchar_t *VarName);
// extern int (__cdecl *wremove)(const wchar_t *FileName);
// extern int (__cdecl *wchdir)(const wchar_t *Path);
// extern errno_t (__cdecl *wsplitpath_s)(const wchar_t *FullPath, wchar_t *Drive, size_t DriveCount, wchar_t *Dir, size_t DirCount, wchar_t *Filename, size_t FilenameCount, wchar_t *Ext, size_t ExtCount);
// extern errno_t (__cdecl *wmakepath_s)(wchar_t *Buffer, size_t BufferCount, const wchar_t *Drive, const wchar_t *Dir, const wchar_t *Filename, const wchar_t *Ext);
// extern errno_t (__cdecl *waccess_s)(const wchar_t *FileName, int AccessMode);
// extern int (__cdecl *chdrive)(int Drive);
// extern int (__cdecl *waccess)(const wchar_t *FileName, int AccessMode);
// extern int (__cdecl *wunlink)(const wchar_t *FileName);
// extern void *(__cdecl *realloc)(void *Block, size_t Size);
// extern void *(__cdecl *malloc)(size_t Size);
// extern void (__cdecl *free)(void *Block);
// extern char *(__cdecl *setlocale)(int Category, const char *Locale);
// extern intptr_t (__cdecl *wspawnvp)(int Mode, const wchar_t *FileName, const wchar_t *const *ArgList);
// extern _crt_signal_t (__cdecl *signal)(int Signal, _crt_signal_t Function);
// extern errno_t (__cdecl *wcserror_s)(wchar_t *Buffer, size_t SizeInWords, int ErrorNumber);
// extern wchar_t **(__cdecl *_p__wpgmptr)();
// extern _invalid_parameter_handler (__cdecl *set_invalid_parameter_handler)(_invalid_parameter_handler Handler);
// extern void (__cdecl __noreturn *exit)(int Code);
// extern int *(__cdecl *errno)();
// extern void (__cdecl __noreturn *invalid_parameter_noinfo_noreturn)();
// extern unsigned int *(__cdecl *_doserrno)();
// extern int (__cdecl *_stdio_common_vswprintf_s)(unsigned __int64 Options, wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern int (__cdecl *_stdio_common_vfwprintf)(unsigned __int64 Options, FILE *Stream, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern wint_t (__cdecl *fputwc)(wchar_t Character, FILE *Stream);
// extern int (__cdecl *fflush)(FILE *Stream);
// extern int (__cdecl *fcloseall)();
// extern errno_t (__cdecl *wfopen_s)(FILE **Stream, const wchar_t *FileName, const wchar_t *Mode);
// extern FILE *(__cdecl *_acrt_iob_func)(unsigned int Ix);
// extern int (__cdecl *setvbuf)(FILE *Stream, char *Buffer, int Mode, size_t Size);
// extern intptr_t (__cdecl *get_osfhandle)(int FileHandle);
// extern int (__cdecl *_stdio_common_vswscanf)(unsigned __int64 Options, const wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern wchar_t *(__cdecl *fgetws)(wchar_t *Buffer, int BufferCount, FILE *Stream);
// extern FILE *(__cdecl *wfsopen)(const wchar_t *FileName, const wchar_t *Mode, int ShFlag);
// extern size_t (__cdecl *fwrite)(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// extern int (__cdecl *fclose)(FILE *Stream);
// extern int (__cdecl *feof)(FILE *Stream);
// extern wint_t (__cdecl *ungetwc)(wint_t Character, FILE *Stream);
// extern wint_t (__cdecl *getwc)(FILE *Stream);
// extern errno_t (__cdecl *wsopen_s)(int *FileHandle, const wchar_t *FileName, int OpenFlag, int ShareFlag, int PermissionFlag);
// extern int (__cdecl *dup2)(int FileHandleSrc, int FileHandleDst);
// extern int (__cdecl *dup)(int FileHandle);
// extern int (__cdecl *lseek)(int FileHandle, int Offset, int Origin);
// extern int (__cdecl *close)(int FileHandle);
// extern int (__cdecl *fileno)(FILE *Stream);
// extern wint_t (__cdecl *towlower)(wint_t C);
// extern errno_t (__cdecl *wcsncpy_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source, rsize_t MaxCount);
// extern int (__cdecl *wcsncmp)(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// extern errno_t (__cdecl *wcsncat_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source, rsize_t MaxCount);
// extern errno_t (__cdecl *wcscat_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// extern errno_t (__cdecl *wcscpy_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// extern errno_t (__cdecl *wcsupr_s)(wchar_t *String, size_t Size);
// extern int (__cdecl *wcsnicmp)(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// extern wint_t (__cdecl *towupper)(wint_t C);
// extern wchar_t *(__cdecl *wcstok_s)(wchar_t *String, const wchar_t *Delimiter, wchar_t **Context);
// extern int (__cdecl *iswalpha)(wint_t C);
// extern int (__cdecl *iswspace)(wint_t C);
// extern wchar_t *(__cdecl *wcspbrk)(const wchar_t *String, const wchar_t *Control);
// extern int (__cdecl *wcsicmp)(const wchar_t *String1, const wchar_t *String2);
// extern size_t (__cdecl *wcsspn)(const wchar_t *String, const wchar_t *Control);
// extern int (__cdecl *iswdigit)(wint_t C);


//----- (00402CD0) --------------------------------------------------------
wchar_t *sub_402CD0()
{
  wchar_t *result; // eax
  wint_t *v1; // [esp+4h] [ebp-4h] BYREF

  v1 = &Src;
  sub_40F012(&v1, (int **)&dword_42473C, 0, 0, 0, 0, 0, 0);
  result = (wchar_t *)sub_40ECDB((char *)&Src);
  Block = result;
  return result;
}
// 42473C: using guessed type int dword_42473C;

//----- (00402D01) --------------------------------------------------------
_DWORD *sub_402D01()
{
  _DWORD *v0; // eax
  char v1; // dl
  _DWORD *v2; // esi
  void *v3; // eax
  int *v4; // esi
  int v5; // ecx
  int *v6; // eax
  wint_t *v8; // [esp+Ch] [ebp-8h] BYREF
  _DWORD *v9; // [esp+10h] [ebp-4h] BYREF

  if ( Block )
  {
    byte_424734 |= 0x20u;
    sub_402E2D();
    Block = 0;
  }
  if ( (byte_424734 & 0x20) != 0 && sub_411519(&Src) )
  {
    if ( (byte_424734 & 0x10) != 0 )
      sub_405B2C(dword_424730, 0x444u);
    sub_405B2C(dword_424730, 0x43Du);
  }
  v0 = sub_40EC89();
  v1 = byte_424734;
  v2 = v0;
  if ( (byte_424734 & 0x40) != 0 )
  {
    v0[1] = dword_42472C;
    dword_42472C = 0;
  }
  else
  {
    v3 = sub_40ECDB((char *)&Src);
    v1 = byte_424734;
    v2[1] = v3;
  }
  v9 = v2;
  if ( (v1 & 0x30) != 16 )
  {
    v8 = (wint_t *)v2[1];
    sub_40F012(&v8, (int **)&dword_42473C, 0, 0, 0, 0, 0, 0);
    v1 = byte_424734;
  }
  if ( (v1 & 0x20) != 0 )
  {
    v4 = (int *)dword_42473C;
    sub_4030A6((wchar_t *)L"$", (int *)&v9, &dword_42473C);
    sub_4030A6((wchar_t *)L"*?", (int *)&v9, 0);
    dword_42473C = (int)v4;
    if ( v4 )
    {
      v5 = dword_435698;
      v6 = v4;
      do
      {
        v4 = (int *)*v4;
        *v6 = v5;
        v5 = (int)v6;
        dword_42473C = (int)v4;
        v6 = v4;
      }
      while ( v4 );
      dword_435698 = v5;
    }
  }
  return sub_40EDE0((_DWORD **)&dword_424728, v9);
}
// 424728: using guessed type int dword_424728;
// 424730: using guessed type int dword_424730;
// 424734: using guessed type char byte_424734;
// 42473C: using guessed type int dword_42473C;
// 435698: using guessed type int dword_435698;

//----- (00402E2D) --------------------------------------------------------
void sub_402E2D()
{
  _DWORD *v0; // eax
  int *v1; // esi
  int v2; // ecx
  int *v3; // eax
  int v4; // ecx

  byte_41450F = byte_41450E;
  v0 = sub_40EC89();
  v0[1] = Block;
  v1 = (int *)dword_42473C;
  dword_424728 = (int)v0;
  sub_4030A6((wchar_t *)L"$", &dword_424728, &dword_42473C);
  sub_4030A6((wchar_t *)L"*?", &dword_424728, 0);
  dword_42473C = (int)v1;
  if ( v1 )
  {
    v2 = dword_435698;
    v3 = v1;
    do
    {
      v1 = (int *)*v1;
      *v3 = v2;
      v2 = (int)v3;
      dword_42473C = (int)v1;
      v3 = v1;
    }
    while ( v1 );
    dword_435698 = v2;
  }
  v4 = dword_424728;
  if ( dword_424728 || (byte_424734 & 0x20) == 0 && (sub_405B2C(dword_424724, 0x43Bu, Block), (v4 = dword_424728) != 0) )
  {
    if ( sub_411519(*(_WORD **)(v4 + 4)) )
      byte_424734 |= 0x10u;
  }
}
// 41450E: using guessed type char byte_41450E;
// 41450F: using guessed type char byte_41450F;
// 424724: using guessed type int dword_424724;
// 424728: using guessed type int dword_424728;
// 424734: using guessed type char byte_424734;
// 42473C: using guessed type int dword_42473C;
// 435698: using guessed type int dword_435698;

//----- (00402EEC) --------------------------------------------------------
void sub_402EEC()
{
  char v0; // bl
  int v1; // esi
  _DWORD *v2; // eax
  int v3; // eax

  if ( Block )
  {
    sub_402E2D();
    Block = 0;
  }
  else
  {
    byte_424734 &= ~0x20u;
  }
  v0 = byte_41450F;
  if ( word_424742 )
  {
    v0 = byte_41450F | 0x20;
    byte_41450F |= 0x20u;
  }
  v1 = dword_424728;
  if ( !dword_424728 )
    sub_405B2C(dword_424730, 0x40Du);
  if ( (byte_424734 & 0x10) != 0 )
  {
    v2 = sub_40B5FE(0x18u);
    v2[2] = *(_DWORD *)(v1 + 4);
    *((_BYTE *)v2 + 20) = (v0 & 0x20) != 0;
    *v2 = dword_424714;
    dword_424714 = v2;
    if ( *v2 )
      *(_DWORD *)(*v2 + 4) = v2;
    goto LABEL_14;
  }
  if ( *(_DWORD *)v1 )
  {
LABEL_16:
    dword_414500 = v1;
    goto LABEL_17;
  }
  if ( !sub_402FCB(*(wchar_t **)(v1 + 4)) )
  {
    v1 = dword_424728;
    goto LABEL_16;
  }
  free(*(void **)(dword_424728 + 4));
LABEL_14:
  v3 = dword_435698;
  dword_435698 = dword_424728;
  *(_DWORD *)dword_424728 = v3;
LABEL_17:
  dword_424728 = 0;
  byte_424734 |= 0x80u;
}
// 414500: using guessed type int dword_414500;
// 41450F: using guessed type char byte_41450F;
// 424728: using guessed type int dword_424728;
// 424730: using guessed type int dword_424730;
// 424734: using guessed type char byte_424734;
// 435698: using guessed type int dword_435698;

//----- (00402FCB) --------------------------------------------------------
char __thiscall sub_402FCB(wchar_t *String1)
{
  wchar_t *v1; // esi
  int v2; // ebx
  int v3; // eax
  const wchar_t *v5; // eax
  bool v6; // cf
  wchar_t v7; // cx
  char v8; // [esp+Fh] [ebp-1h]

  v1 = String1;
  v2 = 0;
  v8 = 0;
  if ( !wcsicmp(String1, L".SILENT") )
  {
    byte_424734 |= 2u;
    sub_40CB79(0x73u, 1);
    v8 = 1;
  }
  if ( !wcsicmp(v1, L".IGNORE") )
  {
    byte_424734 |= 4u;
    sub_40CB79(0x69u, 1);
    return 1;
  }
  v3 = wcscmp(v1, L".SUFFIXES");
  if ( v3 )
    v3 = v3 < 0 ? -1 : 1;
  if ( !v3 )
  {
    byte_424734 |= 1u;
    return 1;
  }
  v5 = L".PRECIOUS";
  while ( 1 )
  {
    v6 = *v1 < *v5;
    if ( *v1 != *v5 )
      break;
    if ( !*v1 )
      goto LABEL_17;
    v7 = v1[1];
    v6 = v7 < v5[1];
    if ( v7 != v5[1] )
      break;
    v1 += 2;
    v5 += 2;
    if ( !v7 )
      goto LABEL_17;
  }
  v2 = v6 ? -1 : 1;
LABEL_17:
  if ( !v2 )
  {
    byte_424734 |= 8u;
    return 1;
  }
  return v8;
}
// 401154: using guessed type wchar_t aPrecious[10];
// 401168: using guessed type wchar_t aSuffixes[10];
// 424734: using guessed type char byte_424734;

//----- (004030A6) --------------------------------------------------------
void __fastcall sub_4030A6(wchar_t *Control, int *a2, _DWORD *a3)
{
  int v3; // esi
  _DWORD *v4; // edi
  int *v5; // ebx
  __int16 *v6; // ecx
  void *v7; // eax
  int v8; // eax
  int *v9; // edx
  int *v10; // eax
  void *v11; // eax
  int *v12; // ecx
  char *v13; // esi
  int *v14; // ecx
  void *v15; // [esp-4h] [ebp-3Ch]
  _DWORD *v16; // [esp+Ch] [ebp-2Ch] BYREF
  int *v17; // [esp+10h] [ebp-28h]
  void *v18; // [esp+14h] [ebp-24h] BYREF
  void *Block; // [esp+18h] [ebp-20h]
  wchar_t *v20; // [esp+1Ch] [ebp-1Ch]
  void *v21; // [esp+20h] [ebp-18h] BYREF
  void *v22; // [esp+24h] [ebp-14h]
  int v23; // [esp+28h] [ebp-10h]
  __int16 *v24; // [esp+2Ch] [ebp-Ch] BYREF
  int v25; // [esp+30h] [ebp-8h] BYREF

  Block = 0;
  v3 = *a2;
  v4 = 0;
  v22 = 0;
  v5 = 0;
  v17 = a2;
  v20 = Control;
  v16 = 0;
  while ( v3 )
  {
    if ( !wcspbrk(*(const wchar_t **)(v3 + 4), Control) )
      goto LABEL_24;
    v6 = *(__int16 **)(v3 + 4);
    if ( *v20 == 36 )
    {
      v18 = 0;
      v24 = v6;
      sub_40F9D0(&v25, &v24, 255, a3, 0, (int)&v18);
      v7 = v18;
      v15 = *(void **)(v3 + 4);
      v18 = 0;
      Block = v7;
      free(v15);
    }
    else
    {
      if ( sub_411519(v6) || (v4 = sub_4121DB(*(wchar_t **)(v3 + 4)), (v16 = v4) == 0) )
      {
LABEL_24:
        v5 = (int *)v3;
        v3 = *(_DWORD *)v3;
        goto LABEL_25;
      }
      v22 = *(void **)(v3 + 4);
    }
    v8 = *(_DWORD *)v3;
    v9 = v17;
    if ( v5 )
    {
      *v5 = v8;
      *(_DWORD *)v3 = dword_435698;
      v10 = v5;
    }
    else
    {
      *v17 = v8;
      *(_DWORD *)v3 = dword_435698;
      v10 = v9;
    }
    v23 = *v10;
    dword_435698 = v3;
    if ( *v20 == 36 )
    {
      v21 = Block;
      while ( 1 )
      {
        v13 = (char *)sub_403236(&v21);
        if ( !v13 )
          break;
        v4 = sub_40EC89();
        v16 = v4;
        v11 = sub_40ECDB(v13);
        v12 = v17;
        v4[1] = v11;
        *v4 = *v12;
        *v12 = (int)v4;
        if ( !v5 )
          v5 = v4;
      }
      free(Block);
    }
    else
    {
      if ( v4 )
      {
        if ( !v5 )
        {
          v14 = (int *)*v4;
          v5 = v4;
          if ( *v4 )
          {
            do
            {
              v5 = v14;
              v14 = (int *)*v14;
            }
            while ( v14 );
          }
        }
        sub_40EDE0(&v16, (_DWORD *)*v9);
        v4 = v16;
        *v17 = (int)v16;
      }
      free(v22);
    }
    v3 = v23;
LABEL_25:
    Control = v20;
  }
}
// 435698: using guessed type int dword_435698;

//----- (00403236) --------------------------------------------------------
_WORD *__thiscall sub_403236(_DWORD *this)
{
  _DWORD *v1; // edi
  _WORD *i; // ecx
  __int16 v3; // ax
  _WORD *v4; // ebx
  _WORD *result; // eax
  __int16 v6; // dx
  __int16 v7; // si
  _WORD *v8; // eax
  _WORD *v9; // [esp+10h] [ebp-8h]

  v1 = this;
  for ( i = (_WORD *)*this; ; ++i )
  {
    v3 = *i;
    if ( *i != 32 && v3 != 9 )
      break;
  }
  v4 = i;
  v9 = i;
  if ( !v3 )
    return 0;
  if ( v3 == 34 )
  {
    do
      ++i;
    while ( *i && *i != 34 );
    v6 = *i;
  }
  else
  {
    v7 = *i;
    do
    {
      v6 = v7;
      if ( v7 == 32 )
        break;
      v6 = v7;
      if ( v7 == 9 )
        break;
      v7 = *++i;
      v6 = *i;
    }
    while ( *i );
    v1 = this;
    v4 = v9;
  }
  v8 = i;
  if ( v6 == 32 || v6 == 9 )
    goto LABEL_23;
  if ( v6 != 34 )
  {
    if ( !v6 )
      --i;
    goto LABEL_24;
  }
  if ( *++i )
LABEL_23:
    *i = 0;
  else
    i = v8;
LABEL_24:
  result = v4;
  *v1 = i + 1;
  return result;
}

//----- (004032FC) --------------------------------------------------------
char sub_4032FC()
{
  char v0; // al
  const wchar_t *v1; // ecx
  int *v2; // ecx
  int v3; // esi
  int *v4; // ecx
  char result; // al

  v0 = byte_424734;
  v1 = 0;
  if ( byte_424734 < 0 )
  {
    v0 = byte_424734 & 0x7F;
    byte_424734 &= ~0x80u;
  }
  if ( (v0 & 0x10) == 0 )
  {
    if ( (v0 & 6) != 0 )
    {
      if ( dword_424728 )
      {
        if ( (v0 & 2) != 0 )
        {
          v1 = L".SILENT";
        }
        else if ( (v0 & 4) != 0 )
        {
          v1 = L".IGNORE";
        }
        sub_405B2C(dword_424730, 0x442u, v1);
        goto LABEL_24;
      }
      goto LABEL_25;
    }
    if ( (v0 & 1) != 0 )
    {
      if ( !dword_424728 )
      {
        v2 = (int *)dword_424720;
        v3 = dword_424720;
        if ( dword_424720 )
        {
          do
          {
            dword_424720 = *v2;
            free(*(void **)(v3 + 4));
            *(_DWORD *)v3 = dword_435698;
            v2 = (int *)dword_424720;
            dword_435698 = v3;
            v3 = dword_424720;
          }
          while ( dword_424720 );
          goto LABEL_24;
        }
        goto LABEL_25;
      }
      v4 = &dword_424720;
    }
    else
    {
      if ( (v0 & 8) == 0 )
      {
        dword_424718 = (int)sub_40B5FE(0x20u);
        *(_DWORD *)dword_424718 = dword_424728;
        *(_DWORD *)(dword_424718 + 4) = dword_42473C;
        goto LABEL_24;
      }
      if ( !dword_424728 )
        goto LABEL_25;
      v4 = &dword_42471C;
    }
    sub_4039C8((_DWORD **)v4);
    goto LABEL_24;
  }
  if ( dword_424728 )
  {
    sub_405B2C(dword_424730, 0x43Eu);
LABEL_24:
    v0 = byte_424734;
  }
LABEL_25:
  dword_424728 = 0;
  result = v0 | 0x40;
  dword_42473C = 0;
  byte_424734 = result;
  return result;
}
// 42471C: using guessed type int dword_42471C;
// 424720: using guessed type int dword_424720;
// 424728: using guessed type int dword_424728;
// 424730: using guessed type int dword_424730;
// 424734: using guessed type char byte_424734;
// 42473C: using guessed type int dword_42473C;
// 435698: using guessed type int dword_435698;

//----- (00403416) --------------------------------------------------------
void sub_403416()
{
  const wchar_t *v0; // ecx
  char v1; // bl
  int v2; // esi
  int v3; // ecx
  int v4; // ecx
  int v5; // [esp-4h] [ebp-10h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = 0;
  v1 = 1;
  v6 = 1;
  if ( (byte_424734 & 0x10) != 0 )
  {
    *((_DWORD *)dword_424714 + 3) = dword_424728;
  }
  else if ( (byte_424734 & 0xF) != 0 )
  {
    if ( dword_424728 )
    {
      if ( (byte_424734 & 2) != 0 )
      {
        v0 = L".SILENT";
      }
      else if ( (byte_424734 & 4) != 0 )
      {
        v0 = L".IGNORE";
      }
      else if ( (byte_424734 & 8) != 0 )
      {
        v0 = L".PRECIOUS";
      }
      else if ( (byte_424734 & 1) != 0 )
      {
        v0 = L".SUFFIXES";
      }
      sub_405B2C(dword_424730, 0x441u, v0);
    }
  }
  else
  {
    v2 = dword_414500;
    *(_DWORD *)(dword_424718 + 8) = dword_424728;
    *(_DWORD *)(dword_424718 + 12) = dword_42473C;
    *(_BYTE *)(dword_424718 + 16) = byte_41450F;
    if ( v2 )
    {
      do
      {
        if ( sub_402FCB(*(wchar_t **)(v2 + 4)) )
        {
          sub_405B2C(dword_424730, 0x445u);
          v3 = v5;
        }
        sub_403907(*(wchar_t **)(v2 + 4), v6, v3);
        if ( !dword_424710 )
        {
          dword_424710 = v2;
          v1 = 0;
        }
        v4 = *(_DWORD *)v2;
        dword_414500 = *(_DWORD *)v2;
        if ( v1 )
        {
          *(_DWORD *)v2 = dword_435698;
          dword_435698 = v2;
        }
        v6 = 0;
        v2 = v4;
      }
      while ( v4 );
    }
  }
  dword_414500 = 0;
  dword_424728 = 0;
  dword_42473C = 0;
  dword_424718 = 0;
  byte_424734 = 0;
}
// 40349D: variable 'v5' is possibly undefined
// 4034A5: variable 'v3' is possibly undefined
// 401154: using guessed type wchar_t aPrecious[10];
// 401168: using guessed type wchar_t aSuffixes[10];
// 414500: using guessed type int dword_414500;
// 41450F: using guessed type char byte_41450F;
// 424710: using guessed type int dword_424710;
// 424728: using guessed type int dword_424728;
// 424730: using guessed type int dword_424730;
// 424734: using guessed type char byte_424734;
// 42473C: using guessed type int dword_42473C;
// 435698: using guessed type int dword_435698;

//----- (0040354D) --------------------------------------------------------
void sub_40354D()
{
  int *v0; // esi
  wchar_t *v1; // ebx
  int v2; // ecx
  int *v3; // eax
  wchar_t *v4; // esi
  wint_t v5; // cx
  int v6; // [esp+Ch] [ebp-10h] BYREF
  wchar_t *v7; // [esp+14h] [ebp-8h] BYREF
  wchar_t *v8; // [esp+18h] [ebp-4h] BYREF

  if ( wcschr(Block, 0x24u) )
  {
    v0 = (int *)dword_42473C;
    v7 = Block;
    v8 = 0;
    sub_40F9D0(&v6, (__int16 **)&v7, 255, &dword_42473C, 0, (int)&v8);
    v1 = v8;
    v8 = 0;
    if ( !*v1 )
      sub_405B2C(dword_424730, 0x3ECu);
    dword_42473C = (int)v0;
    if ( v0 )
    {
      v2 = dword_435698;
      v3 = v0;
      do
      {
        v0 = (int *)*v0;
        *v3 = v2;
        v2 = (int)v3;
        dword_42473C = (int)v0;
        v3 = v0;
      }
      while ( v0 );
      dword_435698 = v2;
    }
    free(Block);
    Block = v1;
  }
  v4 = Block;
  if ( *Block )
  {
    v5 = *Block;
    do
    {
      if ( !sub_403B50(v5) )
        break;
      v5 = *++v4;
    }
    while ( *v4 );
  }
  if ( *v4 )
    sub_405B2C(dword_424730, 0x3E9u, *v4);
  byte_41450D = 1;
  if ( !sub_4037A4(Block, (wchar_t *)dword_42472C, 0) )
  {
    free(Block);
    free(dword_42472C);
  }
  dword_42472C = 0;
  Block = 0;
}
// 41450D: using guessed type char byte_41450D;
// 424730: using guessed type int dword_424730;
// 42473C: using guessed type int dword_42473C;
// 435698: using guessed type int dword_435698;

//----- (0040367D) --------------------------------------------------------
char __fastcall sub_40367D(wchar_t *Name, wchar_t *Block, int a3)
{
  wchar_t *v3; // ebx
  wchar_t *v4; // esi
  wint_t *v5; // edi
  wint_t v6; // cx
  int v7; // eax
  int v9; // edi
  wchar_t *v10; // eax
  wchar_t *v11; // ecx
  __int64 v13; // rax
  wchar_t *v14; // eax
  wchar_t v15; // cx
  wchar_t *v16; // edi
  wchar_t *v17; // edx
  wchar_t *v19; // [esp+14h] [ebp-8h]

  v3 = Name;
  v4 = Block;
  v5 = Name;
  v6 = *Name;
  if ( v6 )
  {
    do
    {
      if ( !sub_403B50(v6) )
        break;
      v6 = *++v5;
    }
    while ( *v5 );
    v3 = Name;
  }
  v7 = *v5;
  if ( (_WORD)v7 )
  {
    if ( (a3 & 4) != 0 )
      return 0;
    sub_405B2C(dword_424730, 0x3E9u, v7);
  }
  if ( (a3 & 0x40) != 0 )
  {
    v9 = 0;
    v10 = wcschr(v4, 0x24u);
    if ( v10 )
    {
      do
      {
        ++v9;
        v10 = wcschr(v10 + 1, 0x24u);
      }
      while ( v10 );
      if ( v9 )
      {
        v11 = v4;
        while ( *v11++ )
          ;
        v13 = 2i64 * (unsigned int)(v9 + v11 - (v4 + 1) + 1);
        v14 = (wchar_t *)sub_40B5D9(HIDWORD(v13) != 0 ? -1 : v13);
        v15 = *v4;
        v16 = v4 + 1;
        v19 = v14;
        v17 = v14;
        if ( *v4 )
        {
          do
          {
            *v17++ = v15;
            if ( v15 == 36 )
              *v17++ = 36;
            v15 = *v16++;
          }
          while ( v15 );
          v4 = Block;
          v3 = Name;
        }
        *v17 = 0;
        free(v4);
        v4 = v19;
      }
    }
  }
  return sub_4037A4(v3, v4, a3);
}
// 424730: using guessed type int dword_424730;

//----- (004037A4) --------------------------------------------------------
char __fastcall sub_4037A4(wchar_t *Name, wchar_t *a2, int a3)
{
  wchar_t *v5; // ecx
  int v6; // eax
  unsigned __int8 v7; // al
  wint_t *v8; // eax
  int v9; // eax
  _DWORD *v10; // esi
  unsigned __int8 v11; // al
  _DWORD *v13; // edx
  _DWORD *v14; // eax
  bool v15; // zf
  _DWORD *v16; // ecx
  char v17; // al
  size_t RequiredCount; // [esp+10h] [ebp-Ch] BYREF
  wchar_t *Str; // [esp+14h] [ebp-8h] BYREF
  char v20; // [esp+1Bh] [ebp-1h]
  int v21; // [esp+24h] [ebp+8h]

  Str = a2;
  v20 = 0;
  RequiredCount = 0;
  if ( (a3 & 2) != 0 )
  {
    if ( !*a2 )
      goto LABEL_14;
    v5 = a2;
  }
  else
  {
    if ( !byte_41450D || (byte_41450C & 4) != 0 || wgetenv_s(&RequiredCount, 0, 0, Name) || !RequiredCount )
      goto LABEL_14;
    v6 = sub_40B534(Name);
    if ( v6 )
    {
      v7 = *(_BYTE *)(v6 + 12);
      if ( (v7 & 2) != 0 || ((unsigned __int8)byte_41450C & v7 & 4) != 0 )
        return 0;
    }
    v5 = Str;
  }
  v8 = sub_40F94D(v5);
  if ( wputenv_s(Name, v8) )
    sub_405B2C(dword_424730, 0x41Fu);
LABEL_14:
  byte_41450D = 0;
  v9 = sub_40B534(Name);
  v10 = (_DWORD *)v9;
  if ( v9 )
  {
    v11 = *(_BYTE *)(v9 + 12);
    if ( (v11 & 2) != 0 || ((unsigned __int8)byte_41450C & v11 & 4) != 0 )
      return 0;
  }
  v13 = sub_40EC89();
  v21 = (int)v13;
  v13[1] = Str;
  if ( v10 )
  {
    v20 = 1;
  }
  else
  {
    v14 = sub_40B5FE(0x10u);
    v13 = (_DWORD *)v21;
    v10 = v14;
    v14[1] = Name;
  }
  v15 = v20 == 0;
  *((_BYTE *)v10 + 12) = a3 | v10[3] & 0xEF;
  *v13 = v10[2];
  v10[2] = v13;
  if ( v15 )
  {
    v16 = (_DWORD *)dword_4386A8;
    *v10 = *(_DWORD *)dword_4386A8;
    *v16 = v10;
    dword_4386A8 = 0;
  }
  if ( (a3 & 0x40) == 0 && wcschr(Str, 0x24u) )
  {
    *((_BYTE *)v10 + 12) |= 1u;
    v17 = sub_40F012(&Str, 0, 0, Name, 1, 0, a3, 0);
    *((_BYTE *)v10 + 12) &= ~1u;
    if ( !v17 )
    {
      *((_BYTE *)v10 + 12) |= 0x10u;
      v10[2] = 0;
    }
  }
  return 1;
}
// 41450C: using guessed type char byte_41450C;
// 41450D: using guessed type char byte_41450D;
// 424730: using guessed type int dword_424730;
// 4386A8: using guessed type int dword_4386A8;

//----- (00403907) --------------------------------------------------------
void __fastcall sub_403907(wchar_t *Block, char a2, int a3)
{
  _DWORD *v3; // eax
  _DWORD *v5; // eax
  int v6; // ecx
  _DWORD *v7; // edi
  _DWORD *v8; // eax
  _DWORD *v9; // esi
  int *v10; // eax
  int v11; // ecx
  int *v12; // esi
  int *v13; // ecx

  v3 = (_DWORD *)dword_424718;
  if ( !dword_424718 )
  {
    v3 = sub_40B5FE(0x20u);
    dword_424718 = (int)v3;
  }
  if ( a2 )
  {
    v5 = sub_40B5FE(8u);
    v6 = dword_424718;
    v7 = v5;
    v5[1] = dword_424718;
  }
  else
  {
    v7 = sub_403AFE(v3);
  }
  v8 = sub_40EE2D(Block, v6, v6);
  v9 = v8;
  if ( v8 )
  {
    if ( (((unsigned __int8)byte_41450F ^ *((_BYTE *)v8 + 8)) & 0x20) != 0 )
      sub_405B2C(dword_424730, 0x43Fu);
    sub_40EDE0((_DWORD **)v9 + 6, v7);
    free(Block);
  }
  else
  {
    *v7 = 0;
    v10 = (int *)sub_40B5FE(0x20u);
    LOBYTE(v11) = byte_41450F;
    v12 = v10;
    *((_BYTE *)v10 + 8) = byte_41450F;
    v10[1] = (int)Block;
    v10[6] = (int)v7;
    v13 = &dword_424510[sub_40EDF5(Block, v11)];
    *v12 = *v13;
    *v13 = (int)v12;
  }
}
// 403951: variable 'v6' is possibly undefined
// 4039AF: variable 'v11' is possibly undefined
// 41450F: using guessed type char byte_41450F;
// 424510: using guessed type int dword_424510[128];
// 424730: using guessed type int dword_424730;

//----- (004039C8) --------------------------------------------------------
void __thiscall sub_4039C8(_DWORD **this)
{
  int v1; // edi
  _DWORD **v2; // esi
  _DWORD *v3; // ebx
  __int16 *v4; // eax
  int *v5; // esi
  wchar_t *v6; // edx
  int v7; // ecx
  int *v8; // eax
  wchar_t *v9; // eax
  _DWORD **v10; // edi
  char *v11; // ebx
  _DWORD *v12; // esi
  int v13; // [esp+Ch] [ebp-28h] BYREF
  void *Block; // [esp+14h] [ebp-20h]
  wchar_t *v15; // [esp+18h] [ebp-1Ch]
  __int16 *v16; // [esp+1Ch] [ebp-18h] BYREF
  _DWORD *v17; // [esp+20h] [ebp-14h]
  _DWORD **v18; // [esp+24h] [ebp-10h]
  wchar_t *Context; // [esp+28h] [ebp-Ch] BYREF
  int v20; // [esp+2Ch] [ebp-8h]
  wchar_t *String; // [esp+30h] [ebp-4h] BYREF

  v1 = dword_424728;
  v2 = this;
  v3 = (_DWORD *)dword_424728;
  v18 = this;
  v20 = dword_424728;
  v17 = (_DWORD *)dword_424728;
  while ( v1 )
  {
    if ( wcschr(*(const wchar_t **)(v1 + 4), 0x24u) )
    {
      v4 = *(__int16 **)(v1 + 4);
      v5 = (int *)dword_42473C;
      String = 0;
      v16 = v4;
      sub_40F9D0(&v13, &v16, 255, &dword_42473C, 0, (int)&String);
      v6 = String;
      String = 0;
      Block = v6;
      if ( v5 != (int *)dword_42473C )
      {
        v7 = dword_435698;
        do
        {
          v8 = (int *)*v5;
          *v5 = v7;
          v7 = (int)v5;
          v5 = v8;
        }
        while ( v8 != (int *)dword_42473C );
        dword_435698 = v7;
      }
      Context = 0;
      v9 = wcstok_s(v6, L" \t", &Context);
      v15 = v9;
      if ( v9 )
      {
        v10 = v18;
        v11 = (char *)v9;
        do
        {
          v12 = sub_40EC89();
          v12[1] = sub_40ECDB(v11);
          sub_40EDE0(v10, v12);
          v11 = (char *)wcstok_s(0, L" \t", &Context);
        }
        while ( v11 );
        v1 = v20;
        v3 = v17;
      }
      free(Block);
      free(*(void **)(v1 + 4));
      v1 = *(_DWORD *)v1;
      v2 = v18;
      v20 = v1;
      *v3 = dword_435698;
      dword_435698 = (int)v3;
    }
    else
    {
      v1 = *(_DWORD *)v1;
      *v3 = 0;
      v20 = v1;
      sub_40EDE0(v2, v3);
    }
    v3 = (_DWORD *)v1;
    v17 = (_DWORD *)v1;
  }
}
// 424728: using guessed type int dword_424728;
// 42473C: using guessed type int dword_42473C;
// 435698: using guessed type int dword_435698;

//----- (00403AFE) --------------------------------------------------------
_DWORD *__thiscall sub_403AFE(_DWORD *this)
{
  _DWORD *v2; // ebx
  _DWORD *v3; // eax
  int v4; // edx
  _DWORD *v5; // esi
  int v6; // ecx
  _DWORD *result; // eax

  v2 = sub_40B5FE(8u);
  v3 = sub_40B5FE(0x20u);
  v4 = *this;
  v5 = v3;
  v2[1] = v3;
  *v3 = v4;
  v3[1] = this[1];
  v3[2] = this[2];
  v3[3] = this[3];
  *((_BYTE *)v3 + 16) = *((_BYTE *)this + 16);
  v6 = this[7];
  v3[6] = this[6];
  result = v2;
  v5[7] = v6;
  return result;
}

//----- (00403B48) --------------------------------------------------------
void *__thiscall sub_403B48(void *this)
{
  return sub_40B5D9((size_t)this);
}

//----- (00403B50) --------------------------------------------------------
bool __fastcall sub_403B50(wint_t C)
{
  if ( C >= 0x80u )
    return iswspace(C) == 0;
  else
    return byte_401090[C] & 1;
}

//----- (00403B75) --------------------------------------------------------
wchar_t *__fastcall sub_403B75(wchar_t *Str, wchar_t Ch)
{
  return wcschr(Str, Ch);
}

//----- (00403B80) --------------------------------------------------------
__int16 __thiscall sub_403B80(_DWORD *this, __int16 a2)
{
  __int16 result; // ax

  sub_403CAC(this, 1);
  result = a2;
  *(_WORD *)(this[512] + 2 * this[514]++) = a2;
  return result;
}

//----- (00403BB0) --------------------------------------------------------
int __thiscall sub_403BB0(_DWORD *this, __int16 *a2)
{
  __int16 *v2; // esi
  int result; // eax
  __int16 v5; // dx

  v2 = a2;
  result = (unsigned __int16)*a2;
  if ( (_WORD)result )
  {
    v5 = *a2;
    do
    {
      sub_403B80(this, v5);
      result = (unsigned __int16)*++v2;
      v5 = result;
    }
    while ( (_WORD)result );
  }
  return result;
}

//----- (00403BE1) --------------------------------------------------------
int __thiscall sub_403BE1(_DWORD *this, void *Src, int a3)
{
  int result; // eax

  sub_403CAC(this, a3);
  memcpy((void *)(this[512] + 2 * this[514]), Src, 2 * a3);
  result = a3;
  this[514] += a3;
  return result;
}

//----- (00403C20) --------------------------------------------------------
_DWORD *__thiscall sub_403C20(_DWORD *Src, _DWORD *a2, char *a3)
{
  _DWORD *v4; // esi
  unsigned int v5; // edx
  void *v6; // eax
  _DWORD *result; // eax
  char v8; // [esp+Ch] [ebp-4h] BYREF

  v4 = (_DWORD *)Src[512];
  Src[512] = 0;
  v5 = Src[514];
  if ( v4 == Src )
  {
    v4 = sub_403D2A(Src[514]);
    memcpy(v4, Src, 2 * Src[514]);
  }
  else if ( v5 != Src[513] )
  {
    v4 = sub_403D5C(v4, v5);
  }
  if ( a3 == &v8 )
  {
    if ( v4 )
      sub_4124CC(v4);
  }
  else
  {
    v6 = *(void **)a3;
    *(_DWORD *)a3 = v4;
    if ( v6 )
      sub_4124CC(v6);
  }
  result = a2;
  *a2 = *(_DWORD *)a3;
  a2[1] = Src[514] - 1;
  return result;
}

//----- (00403CAC) --------------------------------------------------------
char *__thiscall sub_403CAC(_DWORD *Src, int a2)
{
  char *result; // eax
  unsigned int v4; // ecx
  unsigned int v5; // edx
  _DWORD *v6; // ecx
  void *v7; // eax
  size_t v8; // ecx

  result = (char *)(Src[514] + a2);
  v4 = Src[513];
  if ( (unsigned int)result > v4 )
  {
    result -= v4;
    v5 = v4 + ((unsigned int)(result - 1) & 0xFFFFFC00) + 1024;
    if ( v5 != v4 )
    {
      v6 = (_DWORD *)Src[512];
      Src[513] = v5;
      if ( v6 == Src )
      {
        v7 = sub_403D2A(v5);
        v8 = 2 * Src[514];
        Src[512] = v7;
        return (char *)memcpy(v7, Src, v8);
      }
      else
      {
        result = (char *)sub_403D5C(v6, v5);
        Src[512] = result;
      }
    }
  }
  return result;
}

//----- (00403D1E) --------------------------------------------------------
void __noreturn sub_403D1E()
{
  std::_Xout_of_range("invalid string_view position");
  JUMPOUT(0x403D29);
}
// 403D23: control flows out of bounds to 403D29
// 4390C8: using guessed type void __cdecl std::_Xout_of_range(const char *);

//----- (00403D2A) --------------------------------------------------------
void *__fastcall sub_403D2A(unsigned int a1)
{
  void *v1; // esi

  v1 = 0;
  if ( a1 > 0x7FFFFFFC || (v1 = malloc(2 * a1)) == 0 )
    sub_405B2C(dword_424730, 0x41Bu);
  return v1;
}
// 424730: using guessed type int dword_424730;

//----- (00403D5C) --------------------------------------------------------
void *__fastcall sub_403D5C(void *Block, unsigned int a2)
{
  void *v2; // esi

  if ( !Block )
    return sub_403D2A(a2);
  v2 = 0;
  if ( a2 > 0x7FFFFFFC || (v2 = realloc(Block, 2 * a2)) == 0 )
    sub_405B2C(dword_424730, 0x41Bu);
  return v2;
}
// 424730: using guessed type int dword_424730;

//----- (00403D9C) --------------------------------------------------------
int sub_403D9C()
{
  int *v0; // ebx
  int v1; // eax
  WCHAR *v2; // eax
  wchar_t *v3; // edi
  int v4; // ecx
  int v5; // esi
  int v7; // esi
  int v8; // [esp-4h] [ebp-27Ch]
  __int64 v9; // [esp+10h] [ebp-268h] BYREF
  HANDLE hFindFile; // [esp+1Ch] [ebp-25Ch] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+20h] [ebp-258h] BYREF

  v0 = (int *)dword_424710;
  if ( !dword_424710 )
    return 0;
  v1 = dword_424710;
  while ( !wcspbrk(*(const wchar_t **)(v1 + 4), L"*?") )
  {
    v9 = 0i64;
    if ( sub_403EFA(*(wchar_t **)(dword_424710 + 4), byte_41450E, (unsigned int *)&v9, v8) < 0 && (byte_41450C & 8) != 0 )
    {
      v7 = 255;
      goto LABEL_16;
    }
LABEL_12:
    dword_424710 = *v0;
    *v0 = dword_435698;
    dword_435698 = (int)v0;
    v0 = (int *)dword_424710;
    v1 = dword_424710;
    if ( !dword_424710 )
      return 0;
  }
  v2 = sub_408256(*(wchar_t **)(dword_424710 + 4), &FindFileData, &hFindFile);
  if ( !v2 )
  {
    sub_405B2C(0, 0x42Du, *(_DWORD *)(dword_424710 + 4));
    goto LABEL_12;
  }
  while ( 1 )
  {
    v3 = (wchar_t *)sub_4114A5(*(wchar_t **)(dword_424710 + 4), v2);
    v9 = sub_40823C((char *)&FindFileData);
    v5 = sub_403EFA(v3, byte_41450E, (unsigned int *)&v9, v4);
    free(v3);
    if ( v5 < 0 && (byte_41450C & 8) != 0 )
      break;
    v2 = sub_4083E1(&FindFileData, hFindFile);
    if ( !v2 )
      goto LABEL_12;
  }
  v7 = -1;
LABEL_16:
  sub_405322(v0);
  return v7;
}
// 403E2D: variable 'v4' is possibly undefined
// 403E98: variable 'v8' is possibly undefined
// 41450C: using guessed type char byte_41450C;
// 41450E: using guessed type char byte_41450E;
// 424710: using guessed type int dword_424710;
// 435698: using guessed type int dword_435698;
// 403D9C: using guessed type __int64 var_268;

//----- (00403EFA) --------------------------------------------------------
int __fastcall sub_403EFA(wchar_t *a1, char a2, unsigned int *a3, int a4)
{
  int v4; // edi
  int v5; // eax
  _DWORD *v6; // esi
  int v7; // ebx
  unsigned int v8; // eax
  _DWORD *v9; // esi
  _DWORD *v10; // ecx
  void *v12; // [esp-4h] [ebp-14h]
  void *Block; // [esp+Ch] [ebp-4h] BYREF

  v4 = 0;
  Block = 0;
  v5 = sub_403F66(a1, a2, a3, 0, &Block);
  v6 = Block;
  v7 = v5;
  if ( Block )
  {
    do
    {
      v8 = sub_40543F(v6);
      v6 = (_DWORD *)*v6;
      v4 += v8;
    }
    while ( v6 );
    v9 = Block;
    v7 += v4;
    while ( v9 )
    {
      v10 = (_DWORD *)v9[3];
      v12 = v9;
      *v10 = dword_435698;
      dword_435698 = v9[4];
      *(_DWORD *)dword_435698 = v10;
      v9 = (_DWORD *)*v9;
      free(v12);
    }
  }
  return v7;
}
// 435698: using guessed type int dword_435698;

//----- (00403F66) --------------------------------------------------------
int __fastcall sub_403F66(wchar_t *a1, char a2, unsigned int *a3, wchar_t *a4, _DWORD *a5)
{
  _DWORD *v7; // eax
  int result; // eax
  char v9; // [esp+Ch] [ebp-4h]

  ++dword_414504;
  v9 = 1;
  v7 = sub_40EE2D(a1, (int)a1, (int)a1);
  if ( !v7 )
  {
    v7 = sub_40534C((char *)a1, a2);
    v9 = 0;
  }
  result = sub_403FBC((int)v7, a2, a3, v9, a4, a5);
  --dword_414504;
  return result;
}
// 414504: using guessed type int dword_414504;

//----- (00403FBC) --------------------------------------------------------
int __fastcall sub_403FBC(int a1, char a2, unsigned int *a3, char a4, wchar_t *a5, _DWORD *a6)
{
  int result; // eax
  bool v8; // zf
  int *v9; // esi
  _DWORD *v10; // ebx
  int v11; // esi
  unsigned int v12; // eax
  unsigned int v13; // ecx
  unsigned int *v14; // edx
  char v15; // al
  unsigned int *v16; // edx
  unsigned int v17; // ecx
  int *v18; // ebx
  __int64 v19; // rax
  wchar_t *v20; // ecx
  unsigned int v21; // eax
  int v22; // eax
  wchar_t **v23; // esi
  int v24; // edx
  _DWORD *v25; // esi
  int v26; // ecx
  int v27; // eax
  int v28; // ecx
  __int64 v29; // rax
  unsigned int v30; // ecx
  unsigned int v31; // esi
  _DWORD *v32; // esi
  void *v33; // eax
  _DWORD *v34; // edx
  _DWORD *v35; // ecx
  _DWORD *v36; // esi
  int *i; // ecx
  _DWORD *v38; // esi
  int v39; // ebx
  unsigned int v40; // eax
  _DWORD *v41; // esi
  _DWORD *v42; // ecx
  void **v43; // ebx
  void **v44; // esi
  unsigned __int8 v45; // dl
  int v46; // eax
  char v47; // cl
  _DWORD *v48; // ebx
  wchar_t *v49; // esi
  int v50; // eax
  wchar_t *v51; // eax
  unsigned int v52; // eax
  __int64 v53; // rax
  DWORD dwHighDateTime; // ecx
  int v55; // esi
  int v56; // esi
  _DWORD *v57; // ebx
  int v58; // esi
  int v59; // esi
  int *v60; // ebx
  unsigned int v61; // ebx
  unsigned int v62; // esi
  char v63; // al
  unsigned int v64; // ebx
  unsigned __int64 v65; // kr00_8
  unsigned __int64 v66; // kr08_8
  void **v67; // eax
  _DWORD *v68; // eax
  _DWORD *v69; // ebx
  _DWORD *v70; // esi
  int v71; // edx
  wchar_t *v72; // eax
  int v73; // eax
  char v74; // dl
  const wchar_t *v75; // eax
  unsigned int v76; // eax
  DWORD v77; // eax
  unsigned int v78; // ecx
  DWORD *v79; // edx
  unsigned int v80; // eax
  int v81; // edi
  int v82; // esi
  int v83; // edi
  char v84; // al
  char v85; // al
  char v86; // al
  unsigned int v87; // ecx
  unsigned int v88; // eax
  unsigned int *v89; // edx
  int v90; // edi
  int v91; // esi
  int v92; // edi
  int v93; // [esp-4h] [ebp-4FCh]
  void *v94; // [esp-4h] [ebp-4FCh]
  int v95; // [esp-4h] [ebp-4FCh]
  struct _FILETIME SystemTimeAsFileTime; // [esp+10h] [ebp-4E8h] BYREF
  DWORD *v97; // [esp+18h] [ebp-4E0h]
  void *v98; // [esp+1Ch] [ebp-4DCh]
  _DWORD *v99; // [esp+20h] [ebp-4D8h]
  unsigned int v100; // [esp+24h] [ebp-4D4h]
  wchar_t *v101; // [esp+28h] [ebp-4D0h]
  int v102; // [esp+2Ch] [ebp-4CCh] BYREF
  void *Block; // [esp+30h] [ebp-4C8h] BYREF
  _DWORD *v104; // [esp+34h] [ebp-4C4h]
  unsigned __int64 v105; // [esp+38h] [ebp-4C0h] BYREF
  unsigned int *v106; // [esp+40h] [ebp-4B8h]
  _DWORD *v107; // [esp+44h] [ebp-4B4h] BYREF
  unsigned int v108; // [esp+48h] [ebp-4B0h]
  int v109; // [esp+4Ch] [ebp-4ACh]
  unsigned __int64 v110; // [esp+50h] [ebp-4A8h] BYREF
  int v111; // [esp+58h] [ebp-4A0h]
  wchar_t *v112; // [esp+5Ch] [ebp-49Ch] BYREF
  int v113; // [esp+60h] [ebp-498h] BYREF
  unsigned int v114; // [esp+64h] [ebp-494h]
  _DWORD *v115; // [esp+68h] [ebp-490h]
  unsigned int v116; // [esp+6Ch] [ebp-48Ch]
  unsigned int v117; // [esp+70h] [ebp-488h]
  unsigned int v118; // [esp+74h] [ebp-484h]
  unsigned int v119; // [esp+78h] [ebp-480h]
  int v120; // [esp+7Ch] [ebp-47Ch] BYREF
  int v121; // [esp+80h] [ebp-478h]
  int *v122; // [esp+84h] [ebp-474h]
  unsigned __int64 v123; // [esp+88h] [ebp-470h]
  int v124; // [esp+90h] [ebp-468h]
  char v125; // [esp+97h] [ebp-461h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+98h] [ebp-460h] BYREF
  __int16 v127[262]; // [esp+2E8h] [ebp-210h] BYREF

  v101 = a5;
  v112 = a5;
  result = 0;
  v125 = a2;
  v106 = a3;
  v124 = 0;
  v120 = 0;
  if ( !a1 )
  {
    *a3 = 0;
    a3[1] = 0;
    return result;
  }
  v8 = (*(_BYTE *)(a1 + 9) & 1) == 0;
  v9 = (int *)(a1 + 4);
  v122 = (int *)(a1 + 4);
  if ( v8 )
  {
    v122 = (int *)(a1 + 4);
  }
  else
  {
    sub_405B2C(0, 0x42Fu, *v9);
    a2 = v125;
  }
  v10 = *(_DWORD **)(a1 + 28);
  if ( v10 )
  {
    v11 = sub_405594((_DWORD *)*v10);
    sub_4055B2(v10);
    *(_DWORD *)(a1 + 28) = 0;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a1 + 20);
    goto LABEL_8;
  }
  v15 = *(_BYTE *)(a1 + 9);
  if ( (v15 & 2) != 0 )
  {
    if ( (a2 & 1) != 0 )
      sub_40D450(2 * dword_414504, *v9, *(FILETIME *)(a1 + 16));
    v16 = v106;
    v17 = *(_DWORD *)(a1 + 20);
    *v106 = *(_DWORD *)(a1 + 16);
    v16[1] = v17;
    if ( (byte_41450C & 8) == 0 && dword_414504 == 1 && (*(_BYTE *)(a1 + 9) & 4) == 0 )
    {
      if ( sub_408256((wchar_t *)*v9, &FindFileData, (HANDLE *)&v102) )
        sub_405C06(2u, *v9);
    }
    return (*(unsigned __int8 *)(a1 + 9) >> 2) & 1;
  }
  v97 = 0;
  v18 = 0;
  Block = 0;
  HIDWORD(v19) = 0;
  *(_BYTE *)(a1 + 9) = v15 | 1;
  LODWORD(v19) = *(_DWORD *)(a1 + 24);
  v115 = 0;
  v107 = 0;
  v99 = 0;
  v111 = 0;
  v121 = 0;
  v123 = 0i64;
  v119 = 0;
  v117 = 0;
  v105 = 0i64;
  v100 = 0;
  v110 = 0i64;
  v108 = 0;
  v20 = (wchar_t *)*v9;
  v109 = 0;
  v113 = 0;
  dword_424F54 = v20;
  dword_424F58 = (int)v20;
  v118 = v19;
  if ( !(_DWORD)v19 )
  {
LABEL_124:
    dword_424F48 = 0;
    dword_424F4C = 0;
    v61 = *v106;
    v62 = v106[1];
    v8 = *(_QWORD *)v106 == 0i64;
    HIDWORD(v123) = *v106;
    v118 = v62;
    if ( v8 )
    {
      if ( *(_QWORD *)(a1 + 16) )
      {
        v61 = *(_DWORD *)(a1 + 16);
        v62 = *(_DWORD *)(a1 + 20);
        HIDWORD(v123) = v61;
        v118 = v62;
      }
      else if ( sub_408256(v20, &FindFileData, (HANDLE *)&v102) )
      {
        v65 = sub_40823C((char *)&FindFileData);
        v62 = HIDWORD(v65);
        v61 = v65;
        v66 = __PAIR64__(v62, v61);
        v118 = HIDWORD(v66);
        HIDWORD(v123) = v66;
      }
    }
    if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
      sub_40D450(2 * dword_414504, *v122, (FILETIME)__PAIR64__(v62, v61));
    v67 = sub_40EADD(a1, (wchar_t *)v127, (int)v20, __PAIR64__(v62, v61), &v107, &v113, &v120, &v110, &v112);
    v98 = v67;
    if ( v67 && !v111 )
    {
      v68 = v67[3];
      dword_424F4C = v127;
      v99 = v68;
    }
    v69 = v107;
    v70 = (_DWORD *)v113;
    v71 = v120;
    v72 = (wchar_t *)*v122;
    v108 = (unsigned int)v72;
    dword_424F54 = v72;
    dword_424F58 = (int)v72;
    dword_424F50 = (int)v107;
    dword_424F44 = v113;
    v124 = v120;
    if ( byte_424737 && (*(_BYTE *)(a1 + 9) & 8) == 0 || !v120 )
    {
      v73 = HIDWORD(v123);
      if ( __PAIR64__(v118, HIDWORD(v123)) < v110 || byte_424736 && __PAIR64__(v118, HIDWORD(v123)) == v110 )
      {
LABEL_153:
        v74 = byte_435478;
        v125 = byte_435478;
        byte_435478 = 1;
        if ( v111 )
        {
          v75 = v112;
          if ( !v112 )
          {
            if ( v113 )
              v75 = *(const wchar_t **)(v113 + 4);
            else
              v75 = 0;
          }
          v76 = sub_405E74((char *)*v122, *(_DWORD **)(v111 + 8), *(_DWORD *)(v111 + 12), *(_BYTE *)(v111 + 16), v75);
          goto LABEL_174;
        }
        if ( v99 )
        {
          if ( *((_BYTE *)v98 + 20) && (byte_41450C & 0x40) == 0 )
          {
            sub_405393(a6, (int)v98, a1, v118);
LABEL_163:
            byte_435478 = v125;
            goto LABEL_164;
          }
          v76 = sub_405E74((char *)*v122, v99, *((_DWORD *)v98 + 4), *(_BYTE *)(a1 + 8), v112);
LABEL_174:
          v124 = v76 + v120;
          goto LABEL_163;
        }
        if ( (byte_41450C & 0x10) != 0 )
        {
          if ( v121 )
          {
            v80 = sub_405E74((char *)*v122, *(_DWORD **)(v121 + 8), *(_DWORD *)(v121 + 12), *(_BYTE *)(v121 + 16), v112);
            v124 = v80 + v120;
            v74 = v125;
          }
        }
        else if ( !a4 && !(v118 | v73) )
        {
          if ( !byte_424737 )
          {
            sub_405B2C(0, 0x431u, *v122);
            byte_435478 = v125;
LABEL_179:
            if ( dword_424F44 )
            {
              v78 = HIDWORD(v110);
              v77 = v110;
LABEL_165:
              v79 = v97;
              v117 = v78;
              v119 = v77;
              if ( v97 && v111 )
              {
                *v97 = v77;
                v79[1] = v78;
              }
              v71 = v124;
LABEL_169:
              if ( byte_424737 && v71 )
              {
                v8 = (*(_BYTE *)(a1 + 9) & 8) == 0;
                byte_414020 = 0;
                if ( v8 )
                {
                  if ( dword_414504 == 1 )
                    sub_405B2C(0, 0xFAAu, *v122);
                }
                else
                {
                  sub_405B2C(0, 0xFABu, *v122);
                }
              }
              if ( (byte_41450C & 8) != 0 && dword_414504 == 1 )
              {
                if ( v70 == v69 )
                {
                  if ( v70 )
                  {
                    v83 = (int)v70;
                    do
                    {
                      v70 = (_DWORD *)*v70;
                      free(*(void **)(v83 + 4));
                      *(_DWORD *)v83 = dword_435698;
                      dword_435698 = v83;
                      v83 = (int)v70;
                    }
                    while ( v70 );
                  }
                }
                else
                {
                  if ( v70 )
                  {
                    v81 = (int)v70;
                    do
                    {
                      v70 = (_DWORD *)*v70;
                      free(*(void **)(v81 + 4));
                      *(_DWORD *)v81 = dword_435698;
                      dword_435698 = v81;
                      v81 = (int)v70;
                    }
                    while ( v70 );
                  }
                  if ( v69 )
                  {
                    v82 = (int)v69;
                    do
                    {
                      v69 = (_DWORD *)*v69;
                      free(*(void **)(v82 + 4));
                      *(_DWORD *)v82 = dword_435698;
                      dword_435698 = v82;
                      v82 = (int)v69;
                    }
                    while ( v69 );
                  }
                }
                return -(dword_424F40 != 0);
              }
              else
              {
                v84 = *(_BYTE *)(a1 + 9) & 0xFE;
                v8 = *(_DWORD *)(a1 + 28) == 0;
                *(_BYTE *)(a1 + 9) = v84;
                if ( v8 )
                {
                  v85 = v84 | 2;
                  if ( v124 <= 0 )
                    v86 = v85 & 0xFB;
                  else
                    v86 = v85 | 4;
                  *(_BYTE *)(a1 + 9) = v86;
                }
                v87 = v118;
                if ( v117 < v118 )
                {
                  v88 = HIDWORD(v123);
                }
                else if ( v117 > v118 || (v88 = HIDWORD(v123), v119 > HIDWORD(v123)) )
                {
                  v87 = v117;
                  v88 = v119;
                }
                v89 = v106;
                *(_DWORD *)(a1 + 16) = v88;
                *(_DWORD *)(a1 + 20) = v87;
                *v89 = v88;
                v89[1] = v87;
                if ( v70 == v69 )
                {
                  if ( v70 )
                  {
                    v92 = (int)v70;
                    do
                    {
                      v70 = (_DWORD *)*v70;
                      free(*(void **)(v92 + 4));
                      *(_DWORD *)v92 = dword_435698;
                      dword_435698 = v92;
                      v92 = (int)v70;
                    }
                    while ( v70 );
                  }
                }
                else
                {
                  if ( v70 )
                  {
                    v90 = (int)v70;
                    do
                    {
                      v70 = (_DWORD *)*v70;
                      free(*(void **)(v90 + 4));
                      *(_DWORD *)v90 = dword_435698;
                      dword_435698 = v90;
                      v90 = (int)v70;
                    }
                    while ( v70 );
                  }
                  if ( v69 )
                  {
                    v91 = (int)v69;
                    do
                    {
                      v69 = (_DWORD *)*v69;
                      free(*(void **)(v91 + 4));
                      *(_DWORD *)v91 = dword_435698;
                      dword_435698 = v91;
                      v91 = (int)v69;
                    }
                    while ( v69 );
                  }
                }
                return v124;
              }
            }
LABEL_164:
            GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
            v78 = (unsigned __int64)(*(_QWORD *)&SystemTimeAsFileTime + 2i64) >> 32;
            v77 = SystemTimeAsFileTime.dwLowDateTime + 2;
            goto LABEL_165;
          }
          v124 = 1;
        }
        byte_435478 = v74;
        goto LABEL_179;
      }
      if ( !(v118 | HIDWORD(v123)) && !v110 || (*(_BYTE *)(a1 + 8) & 0x10) != 0 )
      {
        v73 = HIDWORD(v123);
        goto LABEL_153;
      }
      v72 = (wchar_t *)v108;
    }
    if ( (byte_41450C & 8) == 0 && dword_414504 == 1 && (*(_BYTE *)(a1 + 9) & 8) == 0 )
    {
      sub_405C06(2u, v72);
      v71 = v120;
    }
    goto LABEL_169;
  }
  if ( (*(_BYTE *)(*(_DWORD *)(v19 + 4) + 16) & 0x20) != 0 )
  {
    if ( sub_408256(v20, &FindFileData, (HANDLE *)&v102) )
    {
      v19 = sub_40823C((char *)&FindFileData);
      v123 = v19;
    }
    else
    {
      HIDWORD(v19) = 0;
    }
  }
  v21 = v118;
  while ( 1 )
  {
    v22 = *(_DWORD *)(v21 + 4);
    v116 = 0;
    v114 = 0;
    v121 = v22;
    v23 = (wchar_t **)v122;
    if ( !*(_QWORD *)(v22 + 24) )
      break;
    if ( __PAIR64__(HIDWORD(v19), v123) <= *(_QWORD *)(v121 + 24) )
    {
      HIDWORD(v19) = *(_DWORD *)(v121 + 28);
      LODWORD(v123) = *(_DWORD *)(v121 + 24);
      HIDWORD(v123) = HIDWORD(v19);
    }
LABEL_122:
    v21 = *(_DWORD *)v118;
    v118 = v21;
    if ( !v21 )
    {
      v20 = *v23;
      goto LABEL_124;
    }
  }
  v24 = *v122;
  v97 = (DWORD *)(v121 + 24);
  v25 = sub_404DF3(v121, v24);
  v104 = v25;
  v98 = v25;
  if ( !v25 )
    goto LABEL_55;
  while ( 1 )
  {
    v26 = v25[3];
    LODWORD(v105) = v25[2];
    HIDWORD(v105) = v26;
    v27 = sub_403F66((wchar_t *)v25[1], *(_BYTE *)(v121 + 16), (unsigned int *)&v105, 0, &Block);
    v28 = v27 + v124;
    v124 = v28;
    v120 = v28;
    if ( byte_424737 && v27 )
    {
      if ( (*((_BYTE *)sub_40EE2D((wchar_t *)v25[1], v28, v28) + 9) & 8) == 0 )
      {
        v93 = v25[1];
        byte_414020 = 0;
        sub_405B2C(0, 0xFAAu, v93);
      }
      *(_BYTE *)(a1 + 9) |= 8u;
    }
    HIDWORD(v29) = HIDWORD(v105);
    v30 = v105;
    if ( __PAIR64__(v114, v116) <= v105 )
    {
      v114 = HIDWORD(v105);
      v116 = v105;
    }
    v31 = HIDWORD(v123);
    if ( !v123 && (*(_BYTE *)(v121 + 16) & 0x20) == 0 )
    {
      if ( sub_408256((wchar_t *)*v122, &FindFileData, (HANDLE *)&v102) )
      {
        v29 = sub_40823C((char *)&FindFileData);
        v30 = v105;
        v31 = HIDWORD(v29);
        HIDWORD(v29) = HIDWORD(v105);
        v123 = __PAIR64__(v31, v29);
        *(_DWORD *)(a1 + 16) = v29;
        *(_DWORD *)(a1 + 20) = v31;
        goto LABEL_41;
      }
      HIDWORD(v29) = HIDWORD(v105);
      v30 = v105;
    }
    LODWORD(v29) = v123;
LABEL_41:
    if ( (*(_BYTE *)(a1 + 8) & 0x10) != 0
      || v31 < HIDWORD(v29)
      || v31 <= HIDWORD(v29) && (unsigned int)v29 < v30
      || byte_424736 && __PAIR64__(v29, v31) == __PAIR64__(v30, HIDWORD(v29)) )
    {
      v32 = sub_40EC89();
      v33 = sub_40ECDB((char *)v104[1]);
      v34 = v115;
      v35 = &v107;
      for ( v32[1] = v33; v34; v34 = (_DWORD *)*v34 )
        v35 = v34;
      *v35 = v32;
      v115 = v107;
    }
    v36 = sub_40EC89();
    v36[1] = sub_40ECDB((char *)v104[1]);
    for ( i = &v113; v18; v18 = (int *)*v18 )
      i = v18;
    *i = (int)v36;
    v25 = (_DWORD *)*v104;
    v104 = v25;
    if ( !v25 )
      break;
    v18 = (int *)v113;
  }
  v109 = v113;
LABEL_55:
  v38 = Block;
  if ( Block )
  {
    v39 = 0;
    do
    {
      v40 = sub_40543F(v38);
      v38 = (_DWORD *)*v38;
      v39 += v40;
    }
    while ( v38 );
    v41 = Block;
    v124 += v39;
    v120 = v124;
    while ( v41 )
    {
      v42 = (_DWORD *)v41[3];
      v94 = v41;
      *v42 = dword_435698;
      dword_435698 = v41[4];
      *(_DWORD *)dword_435698 = v42;
      v41 = (_DWORD *)*v41;
      free(v94);
    }
    Block = 0;
  }
  v43 = (void **)v98;
  while ( 1 )
  {
    v44 = v43;
    if ( !v43 )
      break;
    free(v43[1]);
    v43 = (void **)*v43;
    free(v44);
  }
  v45 = *(_BYTE *)(v121 + 16);
  v46 = *(_DWORD *)(v121 + 8);
  if ( (v45 & 0x20) == 0 )
  {
    if ( v46 )
    {
      if ( v111 )
        sub_405B2C(0, 0xFA4u, *v122);
      else
        v111 = v121;
    }
    if ( v108 <= v114 && (v108 < v114 || v100 <= v116) )
    {
      v100 = v116;
      v108 = v114;
      v110 = __PAIR64__(v114, v116);
    }
LABEL_118:
    v11 = v124;
    goto LABEL_119;
  }
  if ( !v46 )
    goto LABEL_118;
  v47 = byte_424737;
  dword_424F48 = 0;
  dword_424F4C = 0;
  v48 = (_DWORD *)v109;
  dword_424F50 = (int)v115;
  dword_424F44 = v109;
  v49 = (wchar_t *)*v122;
  dword_424F54 = v49;
  dword_424F58 = (int)v49;
  if ( byte_424737 && (*(_BYTE *)(a1 + 9) & 8) == 0 || !v124 )
  {
    if ( HIDWORD(v123) >= v114 )
    {
      v50 = v123;
      if ( HIDWORD(v123) > v114 || (unsigned int)v123 >= v116 )
        goto LABEL_75;
    }
    goto LABEL_81;
  }
  v50 = v123;
LABEL_75:
  if ( byte_424736 && v50 == v116 && (v50 = v123, HIDWORD(v123) == v114)
    || !(HIDWORD(v123) | v50) && !(v114 | v116)
    || !*(_DWORD *)v121 )
  {
LABEL_81:
    v125 = byte_435478;
    v51 = v101;
    byte_435478 = 1;
    if ( !v101 )
    {
      if ( v109 )
        v51 = *(wchar_t **)(v109 + 4);
      else
        v51 = 0;
      v112 = v51;
      v101 = v51;
    }
    v52 = sub_405E74((char *)v49, *(_DWORD **)(v121 + 8), *(_DWORD *)(v121 + 12), v45, v51);
    v8 = (*(_BYTE *)(a1 + 8) & 4) == 0;
    v124 += v52;
    v120 = v124;
    if ( v8 && sub_408256((wchar_t *)*v122, &FindFileData, (HANDLE *)&v102) )
    {
      v53 = sub_40823C((char *)&FindFileData);
      dwHighDateTime = HIDWORD(v53);
      goto LABEL_92;
    }
    if ( v108 | v100 )
    {
      LODWORD(v53) = v100;
      v119 = v100;
      dwHighDateTime = v108;
      v117 = v108;
    }
    else
    {
      GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
      LODWORD(v53) = SystemTimeAsFileTime.dwLowDateTime;
      dwHighDateTime = SystemTimeAsFileTime.dwHighDateTime;
LABEL_92:
      v117 = dwHighDateTime;
      v119 = v53;
    }
    v55 = v121;
    *(_DWORD *)(v121 + 24) = v53;
    *(_DWORD *)(v55 + 28) = dwHighDateTime;
    if ( v48 == v115 )
    {
      if ( v48 )
      {
        v59 = (int)v48;
        do
        {
          v48 = (_DWORD *)*v48;
          free(*(void **)(v59 + 4));
          *(_DWORD *)v59 = dword_435698;
          dword_435698 = v59;
          v59 = (int)v48;
        }
        while ( v48 );
      }
    }
    else
    {
      if ( v48 )
      {
        v56 = (int)v48;
        do
        {
          v48 = (_DWORD *)*v48;
          free(*(void **)(v56 + 4));
          *(_DWORD *)v56 = dword_435698;
          dword_435698 = v56;
          v56 = (int)v48;
        }
        while ( v48 );
      }
      v57 = v115;
      if ( v115 )
      {
        v58 = (int)v115;
        do
        {
          v57 = (_DWORD *)*v57;
          free(*(void **)(v58 + 4));
          *(_DWORD *)v58 = dword_435698;
          dword_435698 = v58;
          v58 = (int)v57;
        }
        while ( v57 );
      }
    }
    v47 = byte_424737;
    v115 = 0;
    v107 = 0;
    v109 = 0;
    v113 = 0;
    byte_435478 = v125;
  }
  if ( !v47 )
    goto LABEL_118;
  v60 = v122;
  if ( (*(_BYTE *)(a1 + 9) & 8) != 0 )
  {
    sub_405B2C(0, 0xFABu, *v122);
    *(_BYTE *)(a1 + 9) &= ~8u;
  }
  v11 = v124;
  if ( v124 )
  {
    v95 = *v60;
    v11 = 0;
    byte_414020 = 0;
    v124 = 0;
    v120 = 0;
    sub_405B2C(0, 0xFAAu, v95);
  }
LABEL_119:
  if ( (*(_BYTE *)(v121 + 16) & 0x20) == 0 || *(_DWORD *)v118 )
  {
    HIDWORD(v19) = HIDWORD(v123);
    v23 = (wchar_t **)v122;
    v18 = (int *)v109;
    goto LABEL_122;
  }
  if ( v11 <= 0 )
    v63 = *(_BYTE *)(a1 + 9) & 0xF8 | 2;
  else
    v63 = *(_BYTE *)(a1 + 9) & 0xF8 | 6;
  v13 = HIDWORD(v123);
  v64 = v117;
  *(_BYTE *)(a1 + 9) = v63;
  if ( v64 < v13 )
  {
    v12 = v123;
  }
  else if ( v64 > v13 || (v12 = v123, v119 > (unsigned int)v123) )
  {
    v12 = v119;
    v13 = v64;
  }
  *(_DWORD *)(a1 + 16) = v12;
  *(_DWORD *)(a1 + 20) = v13;
LABEL_8:
  v14 = v106;
  *v106 = v12;
  result = v11;
  v14[1] = v13;
  return result;
}
// 404944: variable 'v20' is possibly undefined
// 414020: using guessed type char byte_414020;
// 414504: using guessed type int dword_414504;
// 41450C: using guessed type char byte_41450C;
// 424736: using guessed type char byte_424736;
// 424737: using guessed type char byte_424737;
// 424F40: using guessed type int dword_424F40;
// 424F44: using guessed type int dword_424F44;
// 424F48: using guessed type int dword_424F48;
// 424F50: using guessed type int dword_424F50;
// 424F58: using guessed type int dword_424F58;
// 435478: using guessed type char byte_435478;
// 435698: using guessed type int dword_435698;
// 403FBC: using guessed type wchar_t var_210[262];

//----- (00404DF3) --------------------------------------------------------
_DWORD *__fastcall sub_404DF3(int a1, int a2)
{
  _DWORD *v2; // ebx
  int v3; // edi
  int v4; // eax
  __int16 *v5; // ecx
  __int16 v6; // si
  __int16 v7; // dx
  __int16 *v8; // edi
  __int16 *v9; // esi
  __int16 *v10; // esi
  char *v11; // edi
  int v12; // ecx
  wchar_t *v13; // ebx
  wchar_t *v14; // esi
  wchar_t *v15; // esi
  _DWORD *v16; // ebx
  wchar_t *v17; // ecx
  rsize_t v19; // esi
  wchar_t *v20; // eax
  WCHAR *v21; // eax
  __int64 v22; // rax
  bool v23; // zf
  _DWORD *v24; // ecx
  int v26; // [esp+Ch] [ebp-29Ch] BYREF
  __int16 *v27; // [esp+14h] [ebp-294h]
  int v28; // [esp+18h] [ebp-290h]
  __int16 *v29; // [esp+1Ch] [ebp-28Ch] BYREF
  int v30; // [esp+20h] [ebp-288h] BYREF
  int v31; // [esp+24h] [ebp-284h]
  __int16 *v32; // [esp+28h] [ebp-280h]
  __int16 *v33; // [esp+2Ch] [ebp-27Ch] BYREF
  unsigned int v34; // [esp+30h] [ebp-278h]
  _DWORD *v35; // [esp+34h] [ebp-274h]
  HANDLE hFindFile; // [esp+38h] [ebp-270h] BYREF
  __int16 *v37; // [esp+3Ch] [ebp-26Ch] BYREF
  _DWORD *v38; // [esp+40h] [ebp-268h] BYREF
  unsigned __int16 *v39; // [esp+44h] [ebp-264h] BYREF
  wchar_t *Source; // [esp+48h] [ebp-260h]
  char v41; // [esp+4Fh] [ebp-259h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+50h] [ebp-258h] BYREF

  v2 = *(_DWORD **)a1;
  hFindFile = 0;
  v31 = a2;
  v35 = v2;
  v3 = 0;
  v4 = *(_DWORD *)(a1 + 4);
  v38 = 0;
  v30 = v4;
  if ( v2 )
  {
    do
    {
      v5 = (__int16 *)v2[1];
      v6 = *v5;
      if ( *v5 )
      {
        v7 = *v5;
        do
        {
          v6 = v7;
          if ( v7 == 36 )
            break;
          if ( v7 == 94 )
            ++v5;
          v7 = *++v5;
          v6 = *v5;
        }
        while ( *v5 );
        v2 = v35;
        a2 = v31;
      }
      v8 = (__int16 *)v2[1];
      v32 = v8;
      if ( v6 )
      {
        dword_424F48 = a2;
        v29 = v8;
        v37 = 0;
        sub_40F9D0(&v26, &v29, 1, &v30, 0, (int)&v37);
        v8 = v37;
        v32 = v37;
        v37 = 0;
      }
      v9 = (__int16 *)sub_40ECDB((char *)v8);
      v27 = v9;
      v33 = v9;
      if ( sub_4051DA(&v33, (__int16 **)&v39) )
      {
        do
        {
          v10 = (__int16 *)v39;
          v11 = (char *)v39;
          v12 = *v39;
          if ( v12 == 123 )
          {
            while ( (_WORD)v12 != 125 )
            {
              if ( (_WORD)v12 == 94 )
                v11 += 2;
              v11 += 2;
              LOWORD(v12) = *(_WORD *)v11;
              if ( !*(_WORD *)v11 )
                goto LABEL_21;
            }
            *(_WORD *)v11 = 0;
            v11 += 2;
            ++v10;
          }
          else
          {
            v10 = 0;
          }
          v39 = (unsigned __int16 *)v10;
LABEL_21:
          v41 = 0;
          FindFileData.ftCreationTime.dwLowDateTime = 0;
          FindFileData.ftCreationTime.dwHighDateTime = 0;
          FindFileData.ftLastWriteTime.dwLowDateTime = 0;
          FindFileData.ftLastWriteTime.dwHighDateTime = 0;
          v13 = (wchar_t *)sub_40ECDB(v11);
          Source = v13;
          if ( (wcspbrk((const wchar_t *)v11, L"*?") || v10)
            && (v14 = (wchar_t *)sub_408404((wchar_t *)v10, (wchar_t *)v11, &FindFileData, &hFindFile)) != 0 )
          {
            v41 = 1;
            free(v13);
            v11 = (char *)v14;
            v15 = (wchar_t *)sub_4114A5(v14, FindFileData.cFileName);
            Source = v15;
          }
          else
          {
            v15 = Source;
          }
          do
          {
            v16 = sub_40B5FE(0x10u);
            if ( !wcschr(v15, 0x20u) || wcschr(v15, 0x22u) )
            {
              v16[1] = sub_40ECDB((char *)v15);
            }
            else
            {
              v17 = v15 + 1;
              while ( *v15++ )
                ;
              v19 = v15 - v17 + 3;
              v20 = (wchar_t *)sub_40B5D9((unsigned __int64)v19 >> 31 != 0 ? -1 : 2 * v19);
              v16[1] = v20;
              wcscpy_s(v20, v19, ::Source);
              wcscat_s((wchar_t *)v16[1], v19, Source);
              wcscat_s((wchar_t *)v16[1], v19, ::Source);
              v15 = Source;
            }
            if ( !byte_424735 || (v21 = sub_408256(v15, &FindFileData, &hFindFile)) != 0 )
            {
              v22 = sub_40823C((char *)&FindFileData);
              v34 = HIDWORD(v22);
              v28 = v22;
              HIDWORD(v22) = v22;
              v16[3] = v34;
            }
            else
            {
              v22 = 0i64;
              v16[3] = 0;
              v34 = 0;
            }
            v23 = byte_424735 == 0;
            v16[2] = v22;
            if ( v23 )
            {
              sub_40EDE0(&v38, v16);
            }
            else
            {
              v24 = v38;
              if ( !v38 )
                goto LABEL_43;
              LODWORD(v22) = v38;
              do
              {
                if ( __PAIR64__(v34, HIDWORD(v22)) > *(_QWORD *)(v22 + 8) )
                  break;
                v24 = (_DWORD *)v22;
                LODWORD(v22) = *(_DWORD *)v22;
              }
              while ( (_DWORD)v22 );
              v15 = Source;
              if ( v24 == (_DWORD *)v22 )
              {
LABEL_43:
                v38 = v16;
              }
              else
              {
                *v24 = v16;
                *v16 = v22;
              }
            }
            free(v15);
            if ( !v41 )
              break;
            if ( !wcspbrk((const wchar_t *)v11, L"*?") )
              break;
            if ( !sub_4083E1(&FindFileData, hFindFile) )
              break;
            v15 = (wchar_t *)sub_4114A5((wchar_t *)v11, FindFileData.cFileName);
            Source = v15;
          }
          while ( v15 );
        }
        while ( sub_4051DA(&v33, (__int16 **)&v39) );
        v2 = v35;
        v8 = v32;
        v9 = v27;
      }
      if ( v8 != (__int16 *)v2[1] )
        free(v8);
      free(v9);
      v2 = (_DWORD *)*v2;
      a2 = v31;
      v35 = v2;
    }
    while ( v2 );
    return v38;
  }
  return (_DWORD *)v3;
}
// 424735: using guessed type char byte_424735;
// 424F48: using guessed type int dword_424F48;

//----- (004051DA) --------------------------------------------------------
char __fastcall sub_4051DA(__int16 **a1, __int16 **a2)
{
  __int16 **v2; // ebx
  __int16 *v3; // esi
  __int16 v4; // di
  __int16 v5; // cx
  __int16 v7; // cx
  __int16 v8; // dx
  bool v9; // zf
  __int16 v10; // ax
  __int16 v11; // ax
  int v12; // eax
  __int16 v13; // cx
  __int16 v14; // dx
  __int16 v15; // cx

  v2 = a1;
  v3 = *a1;
  v4 = **a1;
  if ( v4 )
  {
    v5 = **a1;
    do
    {
      if ( v5 != 32 )
      {
        v4 = v5;
        if ( v5 != 9 )
          break;
      }
      v5 = *++v3;
      v4 = *v3;
    }
    while ( *v3 );
    v2 = a1;
  }
  *a2 = v3;
  if ( !v4 )
    return 0;
  v7 = 34;
  if ( v4 == 34 )
  {
    do
    {
      v8 = v7;
      if ( !v7 )
        break;
      v7 = *++v3;
      v8 = *v3;
    }
    while ( *v3 != 34 );
LABEL_12:
    if ( !v8 )
      sub_405B2C(0, 0x40Eu);
    v9 = *++v3 == 0;
    goto LABEL_33;
  }
  v10 = v4;
  if ( v4 == 123 )
  {
    while ( 1 )
    {
      if ( *++v3 == 34 )
      {
        ++v3;
        do
        {
          v11 = *v3;
          if ( !*v3 )
            break;
          ++v3;
        }
        while ( v11 != 34 );
      }
      v12 = (unsigned __int16)*v3;
      if ( v12 == 125 )
        break;
      if ( !(_WORD)v12 )
      {
        sub_405B2C(0, 0x423u);
        break;
      }
    }
    v13 = *++v3;
    v10 = *v3;
    if ( *v3 == 34 )
    {
      do
      {
        v8 = v13;
        if ( !v13 )
          break;
        v13 = *++v3;
        v8 = *v3;
      }
      while ( *v3 != 34 );
      goto LABEL_12;
    }
  }
  v14 = v10;
  if ( v10 )
  {
    v15 = v10;
    while ( v15 != 32 )
    {
      v14 = v15;
      if ( v15 != 9 )
      {
        v15 = *++v3;
        v14 = *v3;
        if ( *v3 )
          continue;
      }
      goto LABEL_32;
    }
    goto LABEL_34;
  }
LABEL_32:
  v9 = v14 == 0;
LABEL_33:
  if ( !v9 )
LABEL_34:
    *v3++ = 0;
  *v2 = v3;
  return 1;
}

//----- (00405322) --------------------------------------------------------
int __thiscall sub_405322(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // edi
  int result; // eax

  v1 = this;
  v2 = (int)this;
  while ( v1 )
  {
    v1 = (_DWORD *)*v1;
    free(*(void **)(v2 + 4));
    result = dword_435698;
    *(_DWORD *)v2 = dword_435698;
    dword_435698 = v2;
    v2 = (int)v1;
  }
  return result;
}
// 435698: using guessed type int dword_435698;

//----- (0040534C) --------------------------------------------------------
_DWORD *__fastcall sub_40534C(char *Src, char a2)
{
  _DWORD *v4; // edi
  int v5; // ecx
  int *v6; // ecx
  _DWORD *result; // eax

  v4 = sub_40B5FE(0x20u);
  v4[1] = sub_40ECDB(Src);
  *((_BYTE *)v4 + 8) = a2;
  *((_BYTE *)v4 + 9) = 0;
  v4[4] = 0;
  v4[5] = 0;
  v4[6] = 0;
  v6 = &dword_424510[sub_40EDF5((wint_t *)Src, v5)];
  *v4 = *v6;
  result = v4;
  *v6 = (int)v4;
  return result;
}
// 40537B: variable 'v5' is possibly undefined
// 424510: using guessed type int dword_424510[128];

//----- (00405393) --------------------------------------------------------
int __fastcall sub_405393(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // eax
  _DWORD *v6; // esi
  _DWORD *v7; // edi
  _DWORD *v8; // esi
  _DWORD *v9; // esi
  int result; // eax

  v5 = a2;
  v6 = 0;
  v7 = (_DWORD *)*a1;
  if ( !*a1 )
    goto LABEL_7;
  do
  {
    if ( v7[1] == v5 )
    {
      if ( *((_BYTE *)v7 + 8) == *(_BYTE *)(a3 + 8) )
        break;
      v5 = a2;
    }
    v6 = v7;
    v7 = (_DWORD *)*v7;
  }
  while ( v7 );
  if ( !v7 )
  {
LABEL_7:
    v7 = sub_40B5FE(0x14u);
    v7[1] = a2;
    *((_BYTE *)v7 + 8) = *(_BYTE *)(a3 + 8);
    if ( v6 )
    {
      *v6 = v7;
    }
    else if ( *a1 )
    {
      *(_DWORD *)*a1 = v7;
    }
    else
    {
      *a1 = v7;
    }
  }
  v8 = sub_40EC89();
  v8[1] = sub_40ECDB(*(char **)(a3 + 4));
  sub_40EDE0((_DWORD **)v7 + 3, v8);
  v9 = sub_40EC89();
  v9[1] = sub_40ECDB((char *)dword_424F4C);
  sub_40EDE0((_DWORD **)v7 + 4, v9);
  result = a3;
  *(_DWORD *)(a3 + 28) = a1;
  return result;
}

//----- (0040543F) --------------------------------------------------------
unsigned int __thiscall sub_40543F(_DWORD *this)
{
  _DWORD *v1; // ebx
  int v2; // edi
  _DWORD *v3; // esi
  const unsigned __int16 *v4; // edx
  wchar_t *v5; // edi
  int **v6; // esi
  const wchar_t *v7; // eax
  const wchar_t *v8; // eax
  int v9; // edx
  _DWORD *v10; // ecx
  _DWORD *v11; // edx
  int v12; // ecx
  int **i; // esi
  _DWORD *v14; // eax
  int v16; // [esp-Ch] [ebp-2Ch]
  unsigned __int8 v17; // [esp-8h] [ebp-28h]
  rsize_t SizeInWords; // [esp+10h] [ebp-10h]
  unsigned int SizeInWordsa; // [esp+10h] [ebp-10h]
  char v21; // [esp+1Fh] [ebp-1h]

  v1 = this;
  v2 = 0;
  v3 = (_DWORD *)this[4];
  if ( v3 )
  {
    do
    {
      v4 = (const unsigned __int16 *)v3[1];
      v2 += wcslen(v4) + 1;
      if ( *v4 != 34 && wcschr(v4, 0x20u) )
        v2 += 2;
      v3 = (_DWORD *)*v3;
    }
    while ( v3 );
    v1 = this;
  }
  SizeInWords = v2 + 1;
  v5 = (wchar_t *)sub_40B5D9((unsigned __int64)(unsigned int)(v2 + 1) >> 31 != 0 ? -1 : 2 * (v2 + 1));
  *v5 = 0;
  v6 = (int **)v1[4];
  if ( v6 )
  {
    do
    {
      v7 = (const wchar_t *)v6[1];
      if ( *v7 == 34 || !wcschr(v7, 0x20u) )
      {
        v21 = 0;
      }
      else
      {
        v21 = 1;
        wcscat_s(v5, SizeInWords, Source);
      }
      wcscat_s(v5, SizeInWords, (const wchar_t *)v6[1]);
      v8 = L"\" ";
      if ( !v21 )
        v8 = L" ";
      wcscat_s(v5, SizeInWords, v8);
      v6 = (int **)*v6;
    }
    while ( v6 );
    v1 = this;
  }
  v9 = v1[1];
  v10 = (_DWORD *)v1[3];
  v17 = *((_BYTE *)v1 + 8);
  v16 = *(_DWORD *)(v9 + 16);
  v11 = *(_DWORD **)(v9 + 12);
  dword_424F4C = v5;
  SizeInWordsa = sub_405EB6(v10, v11, v16, v17, 0);
  if ( !SizeInWordsa )
  {
    for ( i = (int **)v1[3]; i; i = (int **)*i )
    {
      v14 = sub_40EE2D((wchar_t *)i[1], v12, v12);
      LOBYTE(v12) = *((_BYTE *)v14 + 9) & 0xFB;
      v14[7] = 0;
      LOBYTE(v12) = v12 | 2;
      *((_BYTE *)v14 + 9) = v12;
    }
  }
  free(v5);
  return SizeInWordsa;
}
// 405567: variable 'v12' is possibly undefined

//----- (00405594) --------------------------------------------------------
int __thiscall sub_405594(_DWORD *this)
{
  int v2; // edi
  unsigned int v3; // eax

  v2 = 0;
  while ( this )
  {
    v3 = sub_40543F(this);
    this = (_DWORD *)*this;
    v2 += v3;
  }
  return v2;
}

//----- (004055B2) --------------------------------------------------------
void __thiscall sub_4055B2(_DWORD *this)
{
  _DWORD *v2; // esi
  _DWORD *v3; // ecx
  void *v4; // [esp-4h] [ebp-Ch]

  v2 = (_DWORD *)*this;
  while ( v2 )
  {
    v3 = (_DWORD *)v2[3];
    v4 = v2;
    *v3 = dword_435698;
    dword_435698 = v2[4];
    *(_DWORD *)dword_435698 = v3;
    v2 = (_DWORD *)*v2;
    free(v4);
  }
  *this = 0;
}
// 435698: using guessed type int dword_435698;

//----- (004055E1) --------------------------------------------------------
wchar_t *__fastcall sub_4055E1(wchar_t **a1, int *a2)
{
  wchar_t *result; // eax
  unsigned int v5; // ecx
  int v6; // esi
  unsigned int v7; // kr00_4
  wchar_t *v8; // ecx
  wchar_t *v9; // ecx
  int v10; // eax

  for ( result = *a1; (*a1)[*a2 - 1] != 10; result = *a1 )
  {
    result = fgetws(&Src, 1024, Stream);
    if ( !result )
      break;
    v5 = wcslen(&Src);
    if ( *((_WORD *)&dword_42473C + v5) == 92 && *((_WORD *)&dword_42473C + v5 + 1) == 10 )
    {
      *((_WORD *)&dword_42473C + v5 + 1) = 0;
      *((_WORD *)&dword_42473C + v5) = 32;
    }
    v6 = *a2;
    v7 = wcslen(&Src);
    v8 = *a1;
    *a2 += v7;
    v9 = (wchar_t *)sub_40B61C(v8, 2 * (v7 + v6) + 2);
    if ( !v9 )
    {
      sub_405B2C(dword_424724, 0x419u);
      v9 = 0;
    }
    v10 = *a2 - v6;
    *a1 = v9;
    wcscpy_s(&v9[v6], v10 + 1, &Src);
  }
  return result;
}
// 424724: using guessed type int dword_424724;
// 42473C: using guessed type int dword_42473C;

//----- (004056E9) --------------------------------------------------------
void *__fastcall sub_4056E9(char *a1, int a2, void **a3)
{
  void *v4; // edi
  void *result; // eax

  if ( *a3 )
  {
    if ( (a2 & 7) == 0 )
    {
      v4 = 0;
      if ( (unsigned int)(a2 + 8) > 0x3FFFFFFE || (v4 = realloc(*a3, 4 * (a2 + 8))) == 0 )
        sub_405B2C(dword_424730, 0x41Bu);
      *a3 = v4;
    }
  }
  else
  {
    *a3 = sub_40B5D9(0x20u);
  }
  result = sub_40ECDB(a1);
  *((_DWORD *)*a3 + a2) = result;
  return result;
}
// 424730: using guessed type int dword_424730;

//----- (00405757) --------------------------------------------------------
char *__fastcall sub_405757(wchar_t *Str, int *a2, void **a3)
{
  wchar_t *v5; // eax
  int v6; // ecx
  char *result; // eax
  wchar_t *Context; // [esp+8h] [ebp-4h] BYREF

  v5 = wcschr(Str, 0x5Cu);
  if ( v5 )
  {
    v6 = *(v5 - 1);
    if ( (v6 == 32 || v6 == 9) && v5[1] == 10 )
      *v5 = 0;
  }
  Context = 0;
  for ( result = (char *)wcstok_s(Str, L" \t\n", &Context); result; result = (char *)wcstok_s(0, L" \t\n", &Context) )
  {
    if ( *(_WORD *)result == 64 )
      return (char *)sub_405B2C(0, 0xFA1u, result + 2);
    sub_4056E9(result, *a2, a3);
    ++*a2;
  }
  return result;
}

//----- (004057E3) --------------------------------------------------------
void __fastcall sub_4057E3(wchar_t *a1, int *a2, void **a3)
{
  int *v4; // esi
  wchar_t *v5; // eax
  wchar_t *v6; // ebx
  wchar_t *v7; // esi
  bool v8; // zf
  wchar_t v9; // ax
  int *v10; // edx
  unsigned int v11; // ebx
  wchar_t *v12; // edi
  wchar_t v13; // cx
  wchar_t *v14; // ecx
  wchar_t v15; // ax
  __int16 v16; // ax
  int v17; // ebx
  int *v18; // eax
  int v19; // [esp+Ch] [ebp-10h] BYREF
  wchar_t *v20; // [esp+10h] [ebp-Ch] BYREF
  int *v21; // [esp+14h] [ebp-8h]
  char v22; // [esp+1Bh] [ebp-1h]

  v22 = 0;
  v4 = a2;
  v21 = a2;
  v5 = wcschr(a1, 0x22u);
  v6 = v5;
  if ( !v5 )
  {
    sub_405757(a1, v4, a3);
    return;
  }
  if ( v5 == a1 )
    goto LABEL_14;
  v7 = v5 - 1;
  if ( *(v5 - 1) != 61 )
  {
    v4 = v21;
LABEL_14:
    *v5 = 0;
    sub_405757(a1, v4, a3);
    v7 = v6 + 1;
    goto LABEL_15;
  }
  *v5 = 32;
  v8 = v7 == a1;
  if ( v7 > a1 )
  {
    while ( 1 )
    {
      v9 = *v7;
      if ( *v7 == 32 )
        goto LABEL_12;
      if ( v9 != 9 && v9 != 10 && --v7 > a1 )
        continue;
      v8 = v7 == a1;
      break;
    }
  }
  if ( !v8 )
  {
LABEL_12:
    v10 = v21;
    *v7++ = 0;
    sub_405757(a1, v10, a3);
  }
LABEL_15:
  v20 = v7;
  v11 = wcslen(v7);
  v12 = v7;
  if ( !*v7 )
    goto LABEL_32;
  v13 = *v7;
  while ( 1 )
  {
    if ( v13 != 34 )
    {
      if ( v13 == 92 )
      {
        v16 = *(v12 - 1);
        if ( (v16 == 32 || v16 == 9) && v12[1] == 10 )
        {
          v17 = v11 - 2;
          *v12 = 0;
          v19 = v17;
          if ( !v22 )
          {
            v22 = 1;
            v20 = (wchar_t *)sub_40ECDB((char *)v7);
          }
          sub_4055E1(&v20, &v19);
          v7 = v20;
          v12 = &v20[v17];
          v11 = v19;
        }
      }
      goto LABEL_29;
    }
    if ( v12[1] != 34 )
      break;
    v14 = v12;
    *v12 = 34;
    do
    {
      ++v14;
      v15 = v14[1];
      *v14 = v15;
    }
    while ( v15 );
LABEL_29:
    v13 = *++v12;
    if ( !*v12 )
      goto LABEL_32;
  }
  v18 = v21;
  *v12++ = 0;
  sub_4056E9((char *)v7, *v18, a3);
  ++*v21;
  sub_4057E3(a3);
LABEL_32:
  if ( v12 == &v7[v11] )
    sub_405B2C(0, 0x3EEu);
  if ( v22 )
    free(v7);
}

//----- (00405994) --------------------------------------------------------
void __thiscall sub_405994(wchar_t *FileName)
{
  void **v2; // edi
  unsigned int v3; // esi
  FILE *v4; // eax
  wchar_t *v5; // esi
  unsigned int v6; // ecx
  unsigned int v7; // edx
  void **v8; // [esp+10h] [ebp-10h] BYREF
  unsigned int v9; // [esp+14h] [ebp-Ch] BYREF
  wchar_t *v10; // [esp+18h] [ebp-8h] BYREF
  unsigned int v11; // [esp+1Ch] [ebp-4h] BYREF

  v2 = 0;
  v3 = 0;
  v9 = 0;
  v4 = wfsopen(FileName, L"rt,ccs=unicode", 32);
  Stream = v4;
  if ( !v4 )
    v4 = (FILE *)sub_405B2C(0, 0x41Cu, FileName);
  v8 = 0;
  if ( fgetws(&Src, 1024, v4) )
  {
    v5 = &Src;
    do
    {
      v6 = wcslen(&Src);
      v11 = v6;
      if ( v6 == 1023 && word_424F3C != 10
        || *((_WORD *)&dword_42473C + v6 + 1) == 10 && *((_WORD *)&dword_42473C + v6) == 92 )
      {
        if ( *((_WORD *)&dword_42473C + v6 + 1) == 10 && *((_WORD *)&dword_42473C + v6) == 92 )
        {
          v7 = 2 * (v6 - 1);
          if ( v7 >= 0x800 )
            __report_rangecheckfailure();
          v11 = v6 - 1;
          *(wchar_t *)((char *)&Src + v7) = 0;
          *((_WORD *)&dword_42473C + v6) = 32;
        }
        v10 = (wchar_t *)sub_40ECDB((char *)&Src);
        sub_4055E1(&v10, (int *)&v11);
        v5 = v10;
      }
      sub_4057E3(v5, (int *)&v9, (void **)&v8);
      if ( v5 != &Src )
        free(v5);
      v5 = &Src;
    }
    while ( fgetws(&Src, 1024, Stream) );
    v3 = v9;
    v2 = v8;
  }
  if ( fclose(Stream) == -1 )
    sub_405B2C(0, 0x424u, FileName);
  sub_40C7A4(v3, (int)v2);
  while ( v3 )
  {
    if ( v2[--v3] )
      free(v2[v3]);
  }
}
// 4125FC: using guessed type void __noreturn __report_rangecheckfailure(void);
// 42473C: using guessed type int dword_42473C;
// 424F3C: using guessed type __int16 word_424F3C;

//----- (00405B2C) --------------------------------------------------------
int sub_405B2C(int a1, unsigned int a2, ...)
{
  int v2; // esi
  int result; // eax
  unsigned int v4; // edi
  wchar_t *v5; // eax
  va_list ArgList; // [esp+18h] [ebp+10h] BYREF

  va_start(ArgList, a2);
  v2 = 2;
  if ( (byte_41450C & 0x20) == 0 || (result = a2 - 4000, a2 - 4000 >= 0x3E8) )
  {
    sub_405CA2();
    if ( a1 )
      sub_40D0D1((wchar_t *)L"%s(%u) : ", ::ArgList, a1);
    else
      sub_40D0D1((wchar_t *)L"NMAKE : ");
    v4 = a2 / 0x3E8;
    if ( a2 / 0x3E8 == 1 )
    {
      sub_405C06(0x14u);
      if ( a2 == 1051 )
        v2 = 4;
    }
    else if ( v4 == 2 )
    {
      sub_405C06(0x15u);
    }
    else if ( v4 == 4 )
    {
      sub_405C06(0x16u);
    }
    sub_40D0D1((wchar_t *)L" U%04d: ", a2);
    v5 = (wchar_t *)sub_40CEF8(a2);
    sub_40D14A(v5, ArgList);
    sub_40D0E0();
    result = sub_40D0B3();
    if ( v4 == 1 )
    {
      sub_40D0D1((wchar_t *)L"Stop.\n");
      sub_40CE64();
      exit(v2);
    }
  }
  return result;
}
// 41450C: using guessed type char byte_41450C;
// 405B2C: using guessed type unsigned int arg_4;

//----- (00405C06) --------------------------------------------------------
void sub_405C06(unsigned int a1, ...)
{
  unsigned int v1; // ecx
  unsigned int v2; // esi
  wchar_t *v3; // eax
  wchar_t *v4; // eax
  va_list va; // [esp+14h] [ebp+Ch] BYREF

  va_start(va, a1);
  if ( a1 != 13 && (byte_41450C & 0x20) != 0 )
    return;
  sub_405CA2();
  v1 = a1;
  v2 = a1 - 20;
  if ( a1 == 24 )
  {
    if ( v2 > 5 )
    {
      sub_40D1C1();
      v1 = 24;
LABEL_14:
      v4 = (wchar_t *)sub_40CEF8(v1);
      sub_40D1ED(v4, va);
      goto LABEL_8;
    }
    sub_40D0E0();
    v1 = 24;
  }
  else if ( v2 > 5 )
  {
    goto LABEL_14;
  }
  v3 = (wchar_t *)sub_40CEF8(v1);
  sub_40D14A(v3, va);
LABEL_8:
  if ( a1 >= 0xA && a1 <= 0x17 || a1 == 124 )
  {
    if ( v2 > 5 )
      goto LABEL_19;
  }
  else
  {
    if ( v2 > 5 )
    {
      sub_40D1C1();
LABEL_19:
      sub_40D194();
      return;
    }
    sub_40D0E0();
  }
  sub_40D0B3();
}
// 41450C: using guessed type char byte_41450C;

//----- (00405CA2) --------------------------------------------------------
int sub_405CA2()
{
  int result; // eax

  if ( !byte_424F60 )
  {
    byte_424F60 = 1;
    sub_405C06(0x18u, L"14.32.31333.0");
    sub_405C06(0x19u);
    return sub_40D0B3();
  }
  return result;
}
// 4017A8: using guessed type wchar_t a1432313330[14];
// 424F60: using guessed type char byte_424F60;

//----- (00405CCE) --------------------------------------------------------
void sub_405CCE()
{
  unsigned int v0; // edi
  unsigned int v1; // esi
  int v2; // [esp-4h] [ebp-Ch]

  v0 = 100;
  v1 = 103;
  do
    sub_405C06(v0++, L"NMAKE");
  while ( v0 < 0x67 );
  do
  {
    if ( v1 == 113 )
    {
      v2 = 114;
    }
    else
    {
      if ( v1 != 121 )
        goto LABEL_8;
      v2 = 122;
    }
    v1 = v2;
LABEL_8:
    sub_405C06(v1++);
  }
  while ( v1 <= 0x7C );
}
// 4017C4: using guessed type wchar_t aNmake_1[6];

//----- (00405D0D) --------------------------------------------------------
size_t __fastcall sub_405D0D(_DWORD *a1, const wchar_t **a2, wchar_t *String)
{
  wchar_t *v3; // esi
  size_t result; // eax
  wchar_t *i; // edi
  const wchar_t *v7; // esi
  int v8; // eax
  char v10; // [esp+13h] [ebp-1h]

  v3 = String;
  result = (size_t)a1;
  v10 = 1;
  for ( i = String; *i; ++i )
    ;
  *a1 = 0;
  if ( String < i )
  {
    while ( 1 )
    {
      result = wcsspn(v3, L" \t");
      v7 = &v3[result];
      if ( v7 >= i )
        goto LABEL_36;
      if ( a2 )
        *a2++ = v7;
      if ( *v7 == 34 )
        break;
      v3 = wcspbrk(v7, L" \t\"/");
      if ( v3 )
      {
        while ( v3 < i )
        {
          if ( *v3 == 47 )
          {
            if ( v10 )
              break;
            v3 = wcspbrk(v3 + 1, L" \t\"/");
            if ( v3 )
              continue;
          }
          if ( !v3 )
            goto LABEL_26;
          break;
        }
        if ( *v3 == 34 )
        {
          do
            ++v3;
          while ( v3 < i && *v3 != 34 );
          v3 = wcspbrk(v3, L" \t");
        }
      }
LABEL_26:
      if ( !v10 )
        goto LABEL_31;
      v10 = 0;
      if ( !v3 )
        goto LABEL_32;
      if ( *v3 != 47 )
        goto LABEL_33;
      if ( a2 )
      {
        *v3 = 0;
        *(a2 - 1) = (const wchar_t *)sub_40ECDB((char *)*(a2 - 1));
        *v3-- = 47;
        goto LABEL_31;
      }
LABEL_35:
      result = (size_t)a1;
      ++*a1;
      if ( v3 >= i )
        goto LABEL_36;
    }
    v3 = (wchar_t *)(v7 + 1);
    if ( v3 >= i )
      goto LABEL_35;
    do
    {
      v8 = *v3;
      if ( v8 == 92 )
      {
        ++v3;
      }
      else if ( (_WORD)v8 == 34 )
      {
        break;
      }
      ++v3;
    }
    while ( v3 < i );
    if ( v3 >= i )
      goto LABEL_35;
    v3 = wcspbrk(v3 + 1, L" \t");
LABEL_31:
    if ( !v3 )
LABEL_32:
      v3 = i;
LABEL_33:
    if ( a2 )
      *v3++ = 0;
    goto LABEL_35;
  }
LABEL_36:
  if ( a2 )
    *a2 = 0;
  return result;
}

//----- (00405E74) --------------------------------------------------------
unsigned int __fastcall sub_405E74(char *Src, _DWORD *a2, int a3, unsigned __int8 a4, const wchar_t *a5)
{
  _DWORD *v7; // ebx
  unsigned int result; // eax

  v7 = sub_40EC89();
  v7[1] = sub_40ECDB(Src);
  result = sub_405EB6(v7, a2, a3, a4, a5);
  *v7 = dword_435698;
  dword_435698 = (int)v7;
  return result;
}
// 435698: using guessed type int dword_435698;

//----- (00405EB6) --------------------------------------------------------
unsigned int __fastcall sub_405EB6(_DWORD *a1, _DWORD *a2, int a3, unsigned __int8 a4, const wchar_t *a5)
{
  unsigned int v5; // esi
  int v6; // eax
  _DWORD *v7; // ebx
  _DWORD *v8; // edi
  bool v9; // bl
  unsigned int v11; // eax
  char v12; // bl
  char v13; // bh
  wchar_t *v14; // ecx
  wchar_t i; // ax
  BOOL v16; // eax
  wchar_t *v17; // esi
  wchar_t *v18; // eax
  bool v19; // zf
  wchar_t *v20; // esi
  int j; // eax
  wchar_t *v22; // edx
  unsigned int v24; // esi
  wchar_t *v25; // edi
  __int16 *v26; // ecx
  char v27; // bl
  char v28; // al
  char v29; // dl
  intptr_t v30; // eax
  int v31; // [esp-Ch] [ebp-70h]
  int v32; // [esp+Ch] [ebp-58h] BYREF
  int v33; // [esp+14h] [ebp-50h] BYREF
  unsigned int v34; // [esp+1Ch] [ebp-48h]
  wchar_t *v35; // [esp+20h] [ebp-44h]
  wchar_t *v36; // [esp+24h] [ebp-40h] BYREF
  int v37; // [esp+28h] [ebp-3Ch]
  _DWORD *v38; // [esp+2Ch] [ebp-38h]
  wchar_t *v39; // [esp+30h] [ebp-34h] BYREF
  wchar_t *v40; // [esp+34h] [ebp-30h] BYREF
  int v41; // [esp+38h] [ebp-2Ch]
  int v42; // [esp+3Ch] [ebp-28h]
  int v43; // [esp+40h] [ebp-24h]
  int v44; // [esp+44h] [ebp-20h]
  int v45; // [esp+48h] [ebp-1Ch] BYREF
  unsigned int v46; // [esp+4Ch] [ebp-18h]
  int v47; // [esp+50h] [ebp-14h]
  unsigned int v48; // [esp+54h] [ebp-10h] BYREF
  wchar_t *Str; // [esp+58h] [ebp-Ch] BYREF
  char v50; // [esp+5Fh] [ebp-5h]

  ++dword_424F40;
  v5 = 0;
  v46 = 0;
  v6 = (unsigned __int8)byte_41450C;
  v7 = a2;
  v38 = a2;
  v48 = 0;
  v8 = a1;
  if ( (byte_41450C & 8) != 0 )
    return 0;
  if ( (byte_41450C & 0x10) != 0 )
  {
    if ( a1 )
    {
      v9 = (a4 & 4) != 0;
      do
      {
        sub_4081AE(v8[1], v9);
        v8 = (_DWORD *)*v8;
      }
      while ( v8 );
    }
    return 0;
  }
  if ( !a2 )
    goto LABEL_36;
  LOBYTE(v6) = a4 >> 6;
  v11 = v6 & 0xFFFFFF01;
  v44 = 45;
  v34 = v11;
  v43 = 64;
  v37 = 94;
  v42 = 32;
  v41 = 9;
  do
  {
    v12 = sub_409C81((wchar_t *)v7[1], (int)&v39, (wchar_t *)&a3, v11);
    v13 = 0;
    dword_434F70 = 0;
    v14 = v39;
    LOBYTE(v47) = 0;
    Str = v39;
    for ( i = *v39; ; i = *v14 )
    {
      if ( i == 33 )
      {
        v13 |= 4u;
LABEL_52:
        LOBYTE(v47) = v13;
        goto LABEL_53;
      }
      if ( i != (_WORD)v44 )
      {
        if ( i == (_WORD)v43 )
          goto LABEL_40;
        if ( i == (_WORD)v37 )
          goto LABEL_19;
        if ( i == (_WORD)v42 )
          goto LABEL_53;
        if ( i != (_WORD)v41 )
          goto LABEL_24;
        if ( i != (_WORD)v44 )
          break;
      }
      v13 |= 2u;
      Str = v14 + 1;
      LOBYTE(v47) = v13;
      if ( iswdigit(v14[1]) )
      {
        v20 = Str;
        dword_434F70 = wcstoul(Str, &Str, 10);
        if ( *errno() == 34 )
        {
          v31 = dword_424724;
          *Str = 0;
          sub_405B2C(v31, 0x436u, v20);
        }
        for ( j = iswspace(*Str); j; j = iswspace(*Str) )
          ++Str;
      }
      else
      {
        dword_434F70 = -1;
      }
      v14 = Str - 1;
LABEL_53:
      Str = ++v14;
    }
    if ( i == (_WORD)v43 )
    {
LABEL_40:
      if ( (byte_41450E & 4) != 0 )
        goto LABEL_53;
      v13 |= 1u;
      goto LABEL_52;
    }
    if ( i != 94 )
      goto LABEL_53;
LABEL_19:
    Str = ++v14;
    v16 = *v14 == (_WORD)v42 || *v14 == (_WORD)v41;
    if ( (v16 ? 0xFFC2 : 0) != 0 )
      goto LABEL_53;
LABEL_24:
    if ( (v13 & 4) != 0 )
    {
      if ( sub_407EA5((__int16 *)v14, a3, a4, v47, a5, &v48) )
      {
        v17 = Str;
        v19 = wcschr(Str, 0x24u) == 0;
        v18 = Str;
        if ( !v19 )
        {
          v36 = Str;
          v40 = 0;
          sub_40F9D0(&v33, (__int16 **)&v36, 255, &a3, 0, (int)&v40);
          v18 = v40;
          Str = v40;
        }
        if ( v17 != v18 )
          free(v18);
        v5 = v48;
        v19 = (a4 & 2) == 0;
        goto LABEL_31;
      }
      v14 = Str;
    }
    v35 = v14;
    if ( !v12 )
    {
      if ( wcschr(v14, 0x24u) )
      {
        v36 = Str;
        v40 = 0;
        sub_40F9D0(&v32, (__int16 **)&v36, 255, &a3, 0, (int)&v40);
        v14 = v40;
        Str = v40;
      }
      else
      {
        v14 = Str;
      }
    }
    v22 = v14 + 1;
    while ( *v14++ )
      ;
    v24 = v14 - v22 + 1;
    if ( v24 <= 0x8000 )
      v24 = 0x8000;
    v25 = (wchar_t *)sub_40B5D9((unsigned __int64)v24 >> 31 != 0 ? -1 : 2 * v24);
    wcscpy_s(v25, v24, Str);
    if ( sub_41168E((char *)v25, v24, Str, a5) )
      sub_405B2C(0, 0x447u, Str, &dword_4017DC, &dword_4017DC);
    v27 = a4 & 4;
    LOBYTE(v26) = (v13 & 2) != 0;
    v36 = (wchar_t *)v26;
    v50 = a4 & 2;
    while ( 2 )
    {
      if ( v27 && (v13 & 8) == 0 )
      {
        v28 = 0;
        goto LABEL_69;
      }
      v28 = 1;
      if ( !v27 && ((a4 & 8) != 0 || (v13 & 1) != 0) )
      {
        v28 = 1;
        v29 = 0;
      }
      else
      {
LABEL_69:
        v29 = 1;
      }
      v30 = sub_40756C(v25, v29, v28, (char)v26, (void **)&v45);
      v5 = v30;
      v48 = v30;
      if ( v50 )
        goto LABEL_84;
      if ( v30 != 259 )
        goto LABEL_80;
      if ( byte_435479 )
      {
        if ( v46 >= 0xA )
          goto LABEL_81;
        sub_405B2C(0, 0xFADu, v45);
        LOBYTE(v26) = (_BYTE)v36;
        ++v46;
        continue;
      }
      break;
    }
    sub_405B2C(0, 0xFACu, v45);
    v5 = 0;
    v48 = 0;
LABEL_80:
    if ( !v5 )
      goto LABEL_84;
LABEL_81:
    if ( v5 > dword_434F70 && !byte_424737 )
      sub_405B2C(0, 0x435u, v45, v5);
LABEL_84:
    if ( v35 != Str )
      free(Str);
    free(v39);
    free(v25);
    v19 = v50 == 0;
LABEL_31:
    if ( v19 && byte_424737 && v5 && v5 > dword_434F70 )
    {
LABEL_37:
      if ( !byte_424737 || v5 <= dword_434F70 )
        return 0;
      return v5;
    }
    LOBYTE(v11) = v34;
    v7 = (_DWORD *)*v38;
    v38 = v7;
  }
  while ( v7 );
LABEL_36:
  if ( (a4 & 2) == 0 )
    goto LABEL_37;
  return 0;
}
// 40624D: variable 'v26' is possibly undefined
// 4017DC: using guessed type int dword_4017DC;
// 41450C: using guessed type char byte_41450C;
// 41450E: using guessed type char byte_41450E;
// 424724: using guessed type int dword_424724;
// 424737: using guessed type char byte_424737;
// 424F40: using guessed type int dword_424F40;
// 434F70: using guessed type int dword_434F70;
// 435479: using guessed type char byte_435479;

//----- (00406334) --------------------------------------------------------
wchar_t **__fastcall sub_406334(wchar_t *a1, int a2, wchar_t **ArgList)
{
  unsigned int v3; // ebx
  int v4; // esi
  wchar_t **v5; // edi
  char v6; // cl
  wchar_t *v7; // edx
  wchar_t *v8; // ecx
  int v10; // eax
  const wchar_t *v11; // eax
  wchar_t **result; // eax
  wchar_t **v13; // esi
  int v14; // [esp+Ch] [ebp-8h]

  v3 = 0;
  v4 = a2;
  v5 = ArgList;
  if ( a1 )
  {
    ArgList[a2] = L">";
    v5[a2 + 1] = a1;
    v4 = a2 + 2;
    v5[a2 + 2] = 0;
LABEL_3:
    v5[v4] = (wchar_t *)Source;
    v6 = 1;
    v5[++v4] = 0;
    goto LABEL_13;
  }
  v7 = *ArgList;
  if ( **ArgList == 34 )
  {
    v8 = *ArgList;
    ArgList = (wchar_t **)(v7 + 1);
    while ( *v8++ )
      ;
    if ( v7[(((char *)v8 - (char *)ArgList) >> 1) - 1] == 34 )
    {
      v10 = v4 - 1;
      v14 = v4 - 1;
      if ( v4 - 1 >= 1 )
      {
        while ( !wcspbrk(v5[v10], Source) )
        {
          v10 = v14 - 1;
          v14 = v10;
          if ( v10 < 1 )
          {
            v6 = 0;
            goto LABEL_14;
          }
        }
        goto LABEL_3;
      }
    }
  }
  v6 = 0;
LABEL_13:
  while ( v4 >= 0 )
  {
LABEL_14:
    v5[v4 + 2] = v5[v4];
    --v4;
  }
  *v5 = (wchar_t *)dword_424F6C;
  v11 = L"/c \"";
  if ( !v6 )
    v11 = L"/c";
  v5[1] = (wchar_t *)v11;
  *errno() = 0;
  result = (wchar_t **)wspawnvp(1, *v5, (const wchar_t *const *)v5);
  v13 = result;
  if ( result != (wchar_t **)-1 )
  {
    WaitForSingleObject(result, 0xFFFFFFFF);
    ArgList = 0;
    do
    {
      GetExitCodeProcess(v13, (LPDWORD)&ArgList);
      if ( ArgList != (wchar_t **)259 )
        break;
      Sleep(0x3E8u);
      ++v3;
    }
    while ( v3 < 0xA );
    CloseHandle(v13);
    return ArgList;
  }
  return result;
}
// 4017E0: using guessed type wchar_t asc_4017E0[2];
// 4017E4: using guessed type wchar_t aC[5];
// 4017F0: using guessed type wchar_t aC_0[3];
// 424F6C: using guessed type int dword_424F6C;

//----- (0040644F) --------------------------------------------------------
wchar_t *__fastcall sub_40644F(int a1, wchar_t **a2)
{
  char v2; // bl
  wchar_t *v3; // edi
  wchar_t *i; // esi
  wchar_t v5; // ax
  wchar_t v6; // ax
  wchar_t v8; // cx
  int v9; // eax
  __int16 v10; // dx
  wchar_t *v11; // edi
  unsigned int v12; // kr00_4
  FILE *v13; // esi
  wchar_t v14; // cx
  char *v15; // ecx
  wchar_t v16; // bx
  wchar_t v17; // dx
  wchar_t *v18; // ecx
  __int16 v19; // ax
  wchar_t *v20; // ebx
  unsigned int v21; // kr0C_4
  wchar_t *v22; // ebx
  unsigned int v23; // kr10_4
  wchar_t *v25; // [esp+10h] [ebp-106B8h]
  size_t RequiredCount; // [esp+18h] [ebp-106B0h] BYREF
  wchar_t *v28; // [esp+1Ch] [ebp-106ACh] BYREF
  wchar_t Destination[4]; // [esp+20h] [ebp-106A8h] BYREF
  wchar_t v30; // [esp+28h] [ebp-106A0h] BYREF
  char v31; // [esp+2Ah] [ebp-1069Eh] BYREF
  WCHAR TempFileName[260]; // [esp+10020h] [ebp-6A8h] BYREF
  wchar_t VarName[257]; // [esp+10228h] [ebp-4A0h] BYREF
  char v34; // [esp+1042Ah] [ebp-29Eh] BYREF
  wchar_t Source[64]; // [esp+10430h] [ebp-298h] BYREF
  wchar_t Buffer; // [esp+104B0h] [ebp-218h] BYREF
  __int16 v37[265]; // [esp+104B2h] [ebp-216h] BYREF

  v2 = 0;
  RequiredCount = 0;
  v28 = 0;
  wcscpy_s(Destination, 0x8000u, L"set ");
  v3 = &v30;
  for ( i = &Str; ; ++i )
  {
    v5 = *i;
    if ( *i != 32 && v5 != 9 )
      break;
  }
  if ( v5 == 47 && i[1] == 65 )
  {
    v6 = i[2];
    if ( v6 == 32 || v6 == 9 )
    {
      v2 = 1;
      i += 3;
    }
  }
  if ( !wcschr(i, 0x3Du) )
    return (wchar_t *)&dword_4017DC;
  v25 = &v30;
  if ( *i != 61 )
  {
    v8 = *i;
    do
    {
      *v3++ = v8;
      if ( v3 >= TempFileName )
        return 0;
      v8 = *++i;
    }
    while ( *i != 61 );
  }
  if ( v2 )
  {
    v9 = *(v3 - 1);
    if ( v9 == 42 || (_WORD)v9 == 47 || v9 == 37 || v9 == 43 || v9 == 45 || v9 == 38 || v9 == 94 || v9 == 124 )
    {
      --v3;
    }
    else
    {
      v10 = 62;
      if ( (_WORD)v9 == 62 || (v10 = 60, (_WORD)v9 == 60) )
      {
        if ( *(v3 - 2) == v10 )
          v3 -= 2;
      }
    }
    if ( v30 == 34 )
      v25 = (wchar_t *)&v31;
    *v3 = 61;
    v11 = v3 + 1;
    if ( v11 < TempFileName )
    {
      RequiredCount = 0;
      if ( wgetenv_s(&RequiredCount, &Buffer, 0x106u, L"TMP") || !RequiredCount )
        wcscpy_s(&Buffer, 0x106u, L".");
      if ( !GetTempFileNameW(&Buffer, L"nm", 0, TempFileName) )
        sub_405B2C(dword_424724, 0x43Cu, &Buffer);
      wcscpy_s(&Buffer, 0x106u, TempFileName);
      if ( wcschr(&Buffer, 0x20u) && !wcschr(&Buffer, 0x22u) )
      {
        v12 = wcslen(&Buffer);
        memmove(v37, &Buffer, 2 * v12);
        Buffer = 34;
        v37[v12] = 34;
        if ( 2 * v12 + 4 >= 0x20C )
          __report_rangecheckfailure();
        v37[v12 + 1] = 0;
      }
      if ( !sub_406334(&Buffer, a1, a2) )
      {
        v13 = wfsopen(&Buffer, L"rt", 32);
        if ( !v13 )
          sub_405B2C(0, 0x41Cu, &Buffer);
        if ( !fgetws(Source, 64, v13) )
          sub_405B2C(0, 0x41Du, &Buffer);
        if ( fclose(v13) == -1 )
          sub_405B2C(0, 0x424u, &Buffer);
        if ( wremove(&Buffer) == -1 )
          sub_405B2C(0, 0x421u, &Buffer);
        if ( &v11[wcslen(Source) + 1] <= TempFileName )
        {
          wcscpy_s(v11, TempFileName - v11, Source);
          goto LABEL_62;
        }
      }
    }
    return 0;
  }
  if ( !*i )
    goto LABEL_61;
  v14 = *i;
  while ( 1 )
  {
    ++i;
    if ( v14 != 94 )
      break;
    v14 = *i;
    if ( *i )
    {
      ++i;
LABEL_59:
      *v3++ = v14;
      if ( v3 >= TempFileName )
        return 0;
    }
LABEL_60:
    v14 = *i;
    if ( !*i )
      goto LABEL_61;
  }
  if ( v14 != 37 )
    goto LABEL_59;
  v15 = (char *)VarName;
  v16 = *i;
  if ( *i != 37 )
  {
    v17 = *i;
    do
    {
      v16 = v17;
      if ( !v17 )
        break;
      *(_WORD *)v15 = v17;
      v15 += 2;
      if ( v15 == &v34 )
        return 0;
      v17 = *++i;
      v16 = *i;
    }
    while ( *i != 37 );
  }
  ++i;
  *(_WORD *)v15 = 0;
  if ( v16 )
  {
    wdupenv_s(&v28, 0, VarName);
    if ( v28 )
    {
      v18 = v28;
      do
        v19 = *v18++;
      while ( v19 != (_WORD)RequiredCount );
      v20 = &v3[v18 - (v28 + 1)];
      if ( v20 >= TempFileName )
        return 0;
      wcscpy_s(v3, TempFileName - v3, v28);
      v3 = v20;
      free(v28);
      v28 = 0;
    }
    else
    {
      v21 = wcslen(VarName);
      v22 = &v3[v21 + 2];
      if ( v22 >= TempFileName )
        return 0;
      *v3 = 37;
      wcscpy_s(v3 + 1, TempFileName - (v3 + 1), VarName);
      v3 += v21 + 2;
      *(v22 - 1) = 37;
    }
    goto LABEL_60;
  }
  v23 = wcslen(VarName);
  if ( &v3[v23 + 1] >= TempFileName )
    return 0;
  *v3 = 37;
  wcscpy_s(v3 + 1, TempFileName - (v3 + 1), VarName);
  v3 += v23 + 1;
LABEL_61:
  *v3 = 0;
LABEL_62:
  wcscpy_s(&::Destination, 0x8000u, Destination);
  *v25 = 0;
  return &::Destination + wcslen(Destination);
}
// 4017DC: using guessed type int dword_4017DC;
// 4125FC: using guessed type void __noreturn __report_rangecheckfailure(void);
// 424724: using guessed type int dword_424724;
// 40644F: using guessed type __int16 var_216[265];

//----- (00406A6C) --------------------------------------------------------
char *__thiscall sub_406A6C(wchar_t *Str)
{
  char *v2; // ebx
  wchar_t *v3; // edi
  wchar_t *v4; // eax
  char *v5; // esi
  char *v6; // eax
  wchar_t *v8; // [esp+10h] [ebp-8h]
  wchar_t *Buffer; // [esp+14h] [ebp-4h] BYREF

  v2 = (char *)sub_40ECDB((char *)&dword_4017DC);
  while ( *Str )
  {
    v3 = wcschr(Str, 0x25u);
    if ( v3 && (v4 = wcschr(v3 + 1, 0x25u), (v8 = v4) != 0) )
    {
      *v3 = 0;
      Buffer = 0;
      *v4 = 0;
      v5 = (char *)sub_40ED85(v2, Str);
      wdupenv_s(&Buffer, 0, v3 + 1);
      if ( Buffer )
      {
        v2 = (char *)sub_40ED85(v5, Buffer);
        free(Buffer);
        Buffer = 0;
      }
      else
      {
        *v3 = 37;
        v6 = (char *)sub_40ED85(v5, v3);
        v2 = (char *)sub_40ED85(v6, L"%");
      }
      *v3 = 37;
      *v8 = 37;
      Str = v8 + 1;
    }
    else
    {
      v2 = (char *)sub_40ED85(v2, Str);
      Str += wcslen(Str);
    }
  }
  return v2;
}
// 4017DC: using guessed type int dword_4017DC;
// 401820: using guessed type wchar_t asc_401820[2];

//----- (00406B6A) --------------------------------------------------------
char __fastcall sub_406B6A(int a1, wint_t **a2, int *a3)
{
  wint_t *v3; // esi
  wint_t *v5; // edi
  wint_t v6; // ax
  char *v8; // eax
  const wchar_t *v9; // eax
  int v10; // eax
  int *v11; // edi
  wchar_t *v12; // esi
  int v13; // eax
  char *v14; // esi
  char *v15; // esi
  int v16; // [esp-4h] [ebp-18h]

  v3 = *a2;
  v5 = a2[1];
  if ( iswalpha(**a2) && v3[1] == 58 && !v3[2] )
  {
    v6 = towupper(*v3);
    chdrive(v6 - 64);
    *a3 = 0;
    return 1;
  }
  if ( wcsicmp(v3, L"set") )
  {
    if ( wcsnicmp(v3, L"cd", 2u) )
    {
      if ( wcsnicmp(v3, L"chdir", 5u) )
        return 0;
      v16 = 5;
    }
    else
    {
      v16 = 2;
    }
    v12 = &v3[v16];
    if ( a1 <= 2 )
    {
      sub_408124(a1, (__int16 **)a2);
      v13 = *v12;
      if ( (_WORD)v13 )
      {
        if ( v13 != 46 && v13 != 92 && v13 != 47 )
          return 0;
        v15 = sub_406A6C(v12);
        v11 = a3;
        *a3 = wchdir((const wchar_t *)v15);
        free(v15);
      }
      else
      {
        if ( !v5 || iswalpha(*v5) && v5[1] == 58 && !v5[2] )
          return 0;
        v14 = sub_406A6C(v5);
        v11 = a3;
        *a3 = wchdir((const wchar_t *)v14);
        free(v14);
      }
LABEL_28:
      if ( *v11 )
        *v11 = 1;
      return 1;
    }
  }
  else if ( a1 != 1 )
  {
    if ( Destination )
    {
      v8 = (char *)sub_40644F(a1, a2);
      if ( v8 )
      {
        if ( *(_WORD *)v8 )
        {
          v9 = (const wchar_t *)sub_40ECDB(v8);
          v10 = wputenv(v9);
          v11 = a3;
          *a3 = v10;
          if ( v10 == -1 )
            sub_405B2C(dword_424730, 0x41Fu);
          goto LABEL_28;
        }
      }
    }
  }
  return 0;
}
// 424730: using guessed type int dword_424730;

//----- (00406D21) --------------------------------------------------------
char __fastcall sub_406D21(wchar_t *FileName, int a2)
{
  int v4; // eax
  wchar_t *v5; // eax
  wchar_t *v6; // edi
  FILE *v7; // eax
  int v8; // ecx
  errno_t v9; // eax
  char v10; // dl
  int v11; // eax
  int v12; // eax
  wchar_t v14; // [esp+10h] [ebp-10h]
  FILE *Stream; // [esp+14h] [ebp-Ch]
  int FileHandle; // [esp+18h] [ebp-8h] BYREF
  bool v17; // [esp+1Fh] [ebp-1h]

  while ( 1 )
  {
    v4 = *FileName;
    if ( (_WORD)v4 != 32 && v4 != 9 )
      break;
    ++FileName;
  }
  v14 = 0;
  v5 = wcspbrk(FileName, L" \t<>\r");
  v6 = v5;
  if ( v5 )
  {
    v14 = *v5;
    *v5 = 0;
  }
  if ( a2 == 4 )
  {
    v7 = _acrt_iob_func(0);
    v8 = 0;
  }
  else
  {
    v7 = _acrt_iob_func(1u);
    v8 = a2 != 2 ? 265 : 769;
  }
  FileHandle = 0;
  Stream = v7;
  v9 = wsopen_s(&FileHandle, FileName, v8, 64, 384);
  v10 = v9 == 0;
  v17 = v9 == 0;
  if ( !v9 )
  {
    v11 = fileno(Stream);
    if ( dup2(FileHandle, v11) == -1 )
      sub_405B2C(0, 0x411u);
    close(FileHandle);
    v10 = v17;
  }
  if ( v10 && a2 == 3 )
  {
    v12 = fileno(Stream);
    lseek(v12, 0, 2);
    v10 = v17;
  }
  for ( ; *FileName; ++FileName )
    *FileName = 32;
  if ( v6 )
    *v6 = v14;
  return v10;
}

//----- (00406E40) --------------------------------------------------------
char __fastcall sub_406E40(wchar_t *String, rsize_t a2, int *a3, int *a4)
{
  char v4; // bh
  char v5; // bl
  wchar_t *v6; // edi
  wchar_t *v7; // esi
  wchar_t *v8; // esi
  FILE *v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // edx
  FILE *v13; // eax
  int v14; // eax
  int v15; // eax
  FILE *v16; // eax
  int v17; // eax
  FILE *v18; // eax
  int v19; // eax
  int v23; // [esp+14h] [ebp-Ch]
  wchar_t *Stringa; // [esp+18h] [ebp-8h]
  char v25; // [esp+1Fh] [ebp-1h]

  v4 = 0;
  v25 = 0;
  v5 = 0;
  Stringa = String;
  v6 = 0;
  v7 = wcspbrk(String, L"<>|");
  if ( !v7 )
    return v5;
  while ( *v7 != 60 )
  {
    if ( *v7 != 62 )
    {
      if ( *v7 == 124 )
        goto LABEL_22;
      sub_405B2C(0, 0x411u);
      goto LABEL_20;
    }
    if ( v25 )
      goto LABEL_22;
    if ( !v6 )
      v6 = (wchar_t *)sub_40ECDB((char *)Stringa);
    *v7 = 32;
    v8 = v7 + 1;
    Stringa = v8;
    v25 = 1;
    if ( *v8 == 62 )
    {
      *v8++ = 32;
      v23 = 3;
    }
    else
    {
      v23 = 2;
    }
    v9 = _acrt_iob_func(1u);
    v10 = fileno(v9);
    v11 = dup(v10);
    *a4 = v11;
    if ( v11 == -1 )
      goto LABEL_22;
    v12 = v23;
LABEL_19:
    if ( !sub_406D21(v8, v12) )
      goto LABEL_22;
LABEL_20:
    v7 = wcspbrk(Stringa, L"<>|");
    if ( !v7 )
      return v5;
  }
  if ( !v4 )
  {
    if ( !v6 )
      v6 = (wchar_t *)sub_40ECDB((char *)Stringa);
    *v7 = 32;
    v4 = 1;
    v8 = v7 + 1;
    Stringa = v8;
    v13 = _acrt_iob_func(0);
    v14 = fileno(v13);
    v15 = dup(v14);
    *a3 = v15;
    if ( v15 != -1 )
    {
      v12 = 4;
      goto LABEL_19;
    }
  }
LABEL_22:
  v5 = 1;
  if ( v6 )
  {
    wcscpy_s(String, a2, v6);
    free(v6);
  }
  if ( v4 && *a3 != -1 )
  {
    v16 = _acrt_iob_func(0);
    v17 = fileno(v16);
    if ( dup2(*a3, v17) == -1 )
      sub_405B2C(0, 0x411u);
    close(*a3);
    *a3 = -1;
  }
  if ( v25 && *a4 != -1 )
  {
    v18 = _acrt_iob_func(1u);
    v19 = fileno(v18);
    if ( dup2(*a4, v19) == -1 )
      sub_405B2C(0, 0x411u);
    close(*a4);
    *a4 = -1;
  }
  return v5;
}

//----- (0040704E) --------------------------------------------------------
bool __fastcall sub_40704E(_WORD *a1, _DWORD *a2)
{
  _WORD *v2; // edi
  _WORD *v4; // edx
  __int16 v5; // si
  __int16 v6; // bx
  __int16 v7; // si
  _WORD *v9; // [esp+8h] [ebp-4h]

  v2 = a1;
  v9 = a1;
  if ( !a1 )
    return 0;
  v4 = a1;
  v5 = *a1;
  if ( *a1 == 59 )
  {
    do
      ++a1;
    while ( *a1 == 59 );
    v5 = *a1;
  }
  v6 = v5;
  if ( v5 )
  {
    do
    {
      v6 = v5;
      if ( v5 == 59 )
        break;
      ++a1;
      if ( v5 == 34 )
      {
        if ( *a1 )
        {
          v7 = *a1;
          do
          {
            ++a1;
            if ( v7 == 34 )
              break;
            *v4++ = v7;
            v7 = *a1;
          }
          while ( *a1 );
        }
      }
      else
      {
        *v4++ = v5;
      }
      v5 = *a1;
      v6 = *a1;
    }
    while ( *a1 );
    v2 = v9;
  }
  *a2 = v6 != 0 ? a1 + 1 : 0;
  *v4 = 0;
  return v4 != v2;
}

//----- (00407105) --------------------------------------------------------
char __fastcall sub_407105(wchar_t *FullPath, wchar_t *a2, int a3)
{
  wchar_t *v3; // ebx
  unsigned int v4; // eax
  wchar_t *v5; // ebx
  size_t v6; // eax
  wchar_t *v7; // edi
  wchar_t *v8; // esi
  size_t v9; // eax
  wchar_t *v10; // esi
  wchar_t *v11; // ecx
  size_t v12; // esi
  wchar_t *v13; // ecx
  unsigned int v15; // edi
  wchar_t *v16; // eax
  wchar_t *v17; // [esp+10h] [ebp-63Ch]
  wchar_t *v18; // [esp+14h] [ebp-638h] BYREF
  wchar_t *v19; // [esp+18h] [ebp-634h]
  wchar_t *v20; // [esp+1Ch] [ebp-630h]
  wchar_t *v21; // [esp+20h] [ebp-62Ch]
  BOOL v22; // [esp+24h] [ebp-628h] BYREF
  wchar_t *Buffer; // [esp+28h] [ebp-624h]
  size_t RequiredCount; // [esp+2Ch] [ebp-620h] BYREF
  size_t SizeInWords; // [esp+30h] [ebp-61Ch] BYREF
  char v26; // [esp+37h] [ebp-615h]
  wchar_t Filename[256]; // [esp+38h] [ebp-614h] BYREF
  wchar_t Dir[256]; // [esp+238h] [ebp-414h] BYREF
  wchar_t Ext[258]; // [esp+438h] [ebp-214h] BYREF
  wchar_t Drive[4]; // [esp+63Ch] [ebp-10h] BYREF

  Buffer = a2;
  v21 = 0;
  v26 = 0;
  if ( *FullPath == 34 )
  {
    v3 = &FullPath[wcslen(FullPath) - 1];
    v21 = v3;
    if ( *v3 == 34 )
    {
      v26 = 1;
      do
        ++FullPath;
      while ( *FullPath == 34 );
      if ( v3 > FullPath )
      {
        do
        {
          v4 = (unsigned int)(v3 - 1);
          if ( *(v3 - 1) != 34 )
            break;
          --v3;
        }
        while ( v4 > (unsigned int)FullPath );
        v21 = v3;
      }
      *v3 = 0;
    }
  }
  wsplitpath_s(FullPath, Drive, 3u, Dir, 0x100u, Filename, 0x100u, Ext, 0x100u);
  if ( !Ext[0] )
  {
    if ( !wgetenv_s(&RequiredCount, 0, 0, aPa) && RequiredCount )
    {
      v5 = (wchar_t *)sub_40B5D9((unsigned __int64)RequiredCount >> 31 != 0 ? -1 : 2 * RequiredCount);
      if ( wgetenv_s(&RequiredCount, v5, RequiredCount, aPa) )
      {
        free(v5);
      }
      else if ( v5 )
      {
        goto LABEL_18;
      }
    }
    RequiredCount = 33;
    v5 = (wchar_t *)sub_40B5D9(0x42u);
    wcscpy_s(v5, RequiredCount, L".COM;.EXE;.BAT;.CMD;.VBS;.JS;.WS");
    goto LABEL_18;
  }
  v5 = Ext;
  RequiredCount = wcslen(Ext) + 1;
LABEL_18:
  if ( Drive[0] || Dir[0] )
  {
    v12 = wcslen(Drive) + wcslen(Dir) + 1;
    v7 = (wchar_t *)sub_40B5D9((unsigned __int64)v12 >> 31 != 0 ? -1 : 2 * v12);
    v20 = v7;
    if ( wmakepath_s(v7, v12, Drive, Dir, 0, 0) )
    {
      free(v7);
      v10 = 0;
      v7 = 0;
      v20 = 0;
      goto LABEL_32;
    }
  }
  else
  {
    if ( wgetenv_s(&SizeInWords, 0, 0, aPa_0) || !SizeInWords )
      SizeInWords = 1;
    v22 = NeedCurrentDirectoryForExePathW(Filename);
    v6 = SizeInWords;
    if ( v22 )
    {
      v6 = SizeInWords + 2;
      SizeInWords += 2;
    }
    v7 = (wchar_t *)sub_40B5D9((unsigned __int64)v6 >> 31 != 0 ? -1 : 2 * v6);
    v20 = v7;
    v8 = v7;
    if ( v22 )
    {
      wcscpy_s(v7, SizeInWords, L".;");
      v8 = v7 + 2;
      v9 = SizeInWords - 2;
      SizeInWords -= 2;
    }
    else
    {
      v9 = SizeInWords;
    }
    if ( wgetenv_s(&SizeInWords, v8, v9, aPa_0) || !SizeInWords )
      *v8 = 0;
  }
  v10 = 0;
LABEL_32:
  v17 = v7;
  v11 = v7;
LABEL_41:
  if ( sub_40704E(v11, &v22) )
  {
    v10 = (wchar_t *)sub_40B5D9((unsigned __int64)RequiredCount >> 31 != 0 ? -1 : 2 * RequiredCount);
    wcscpy_s(v10, RequiredCount, v5);
    v19 = v10;
    v13 = v10;
    while ( 1 )
    {
      if ( !sub_40704E(v13, &v18) )
      {
        v11 = (wchar_t *)v22;
        v17 = (wchar_t *)v22;
        goto LABEL_41;
      }
      if ( !wmakepath_s(Buffer, 0x104u, 0, v17, Filename, v19) && !waccess_s(Buffer, 0) )
        break;
      v13 = v18;
      v19 = v18;
    }
    if ( v26 )
    {
      v15 = wcslen(Buffer);
      memmove(Buffer + 1, Buffer, 2 * v15);
      v16 = Buffer;
      *Buffer = 34;
      v16[v15 + 1] = 34;
      v16[v15 + 2] = 0;
      v7 = v20;
      *v21 = 34;
    }
    free(v10);
    free(v7);
    if ( v5 != Ext )
      free(v5);
    return 1;
  }
  else
  {
    free(v10);
    free(v7);
    if ( v5 != Ext )
      free(v5);
    return 0;
  }
}

//----- (0040756C) --------------------------------------------------------
intptr_t __fastcall sub_40756C(wchar_t *Source, char a2, char a3, char a4, void **a5)
{
  char v5; // bl
  void *v7; // eax
  int v8; // eax
  wchar_t *v9; // esi
  wchar_t *v11; // eax
  wchar_t *v12; // edi
  const wchar_t **v13; // ebx
  intptr_t v14; // edi
  const wchar_t **v15; // eax
  int v16; // esi
  const wchar_t *v17; // edi
  unsigned int v18; // kr00_4
  void **v19; // esi
  wchar_t *v20; // ecx
  int v21; // eax
  const wchar_t *v22; // esi
  wchar_t *v23; // esi
  wchar_t *v24; // ecx
  __int16 v25; // ax
  const wchar_t *v26; // eax
  unsigned int v27; // edi
  wchar_t *v28; // edx
  __int16 v29; // ax
  unsigned int v30; // ecx
  unsigned int v31; // kr04_4
  unsigned int v32; // esi
  FILE *v33; // eax
  int v34; // eax
  FILE *v35; // eax
  int v36; // eax
  wchar_t *v37; // ecx
  __int16 v38; // ax
  int v39; // esi
  int v40; // eax
  wchar_t **v41; // eax
  int v42; // eax
  int v43; // eax
  signed int v44; // esi
  int v45; // esi
  wchar_t **v46; // ecx
  void *v47; // esi
  int v48; // eax
  char v49; // al
  char v50; // [esp+14h] [ebp-448h]
  int FileHandleSrc; // [esp+18h] [ebp-444h] BYREF
  intptr_t v52; // [esp+1Ch] [ebp-440h] BYREF
  WCHAR Buffer[2]; // [esp+20h] [ebp-43Ch] BYREF
  void *Block; // [esp+24h] [ebp-438h]
  size_t v55; // [esp+28h] [ebp-434h] BYREF
  size_t Size; // [esp+2Ch] [ebp-430h]
  int FileHandle; // [esp+30h] [ebp-42Ch] BYREF
  char v58; // [esp+37h] [ebp-425h]
  wchar_t *String; // [esp+38h] [ebp-424h] BYREF
  char v60; // [esp+3Fh] [ebp-41Dh]
  wchar_t v61; // [esp+40h] [ebp-41Ch] BYREF
  wchar_t Destination[59]; // [esp+42h] [ebp-41Ah] BYREF
  wchar_t v63[200]; // [esp+B8h] [ebp-3A4h] BYREF
  wchar_t Str; // [esp+248h] [ebp-214h] BYREF
  char Src[522]; // [esp+24Ah] [ebp-212h] BYREF

  v5 = a2;
  String = Source;
  if ( !dword_424F6C )
  {
    v7 = sub_407E09();
    Source = String;
    dword_424F6C = (int)v7;
  }
  v8 = *Source;
  v50 = 1;
  *(_DWORD *)Buffer = 0;
  if ( v8 == 45 )
  {
    v58 = 1;
    String = Source + 1;
    if ( iswdigit(Source[1]) )
    {
      v9 = String;
      dword_434F70 = wcstoul(String, &String, 10);
      if ( *errno() == 34 )
      {
        *String = 0;
        sub_405B2C(0, 0x436u, v9);
      }
      for ( ; iswspace(*String); ++String )
        ;
    }
    else
    {
      dword_434F70 = -1;
    }
    Source = String;
  }
  else
  {
    if ( v8 == 64 )
    {
      String = ++Source;
      v5 = a3 != 0 ? 0 : a2;
    }
    v58 = a4;
  }
  if ( !*Source )
    return 0;
  if ( wcslen(Source) >= 0x8000 )
  {
    ::Destination = 0;
  }
  else
  {
    wcscpy_s(&::Destination, 0x8000u, Source);
    Source = String;
  }
  v11 = (wchar_t *)sub_40ECDB((char *)Source);
  v12 = v11;
  Block = v11;
  if ( v5 )
  {
    sub_40D1B2((wchar_t *)L"\t%s\n", v11);
    sub_40D194();
  }
  v13 = 0;
  sub_405D0D(&v55, 0, v12);
  if ( !v55 )
    goto LABEL_23;
  Size = (unsigned __int64)(v55 + 8) >> 30 != 0 ? -1 : 4 * (v55 + 8);
  v15 = (const wchar_t **)sub_40B5D9(Size);
  v13 = v15;
  if ( v15 )
    memset(v15, 0, Size);
  else
    v13 = 0;
  v16 = v55;
  Size = v55;
  sub_405D0D(&v55, v13, v12);
  if ( *v13 && dword_424F68 && !wcsicmp(*v13, dword_424F68) )
  {
    if ( !dword_414508 )
    {
      dword_414508 = *_p__wpgmptr();
      v17 = dword_414508;
      if ( wcspbrk(dword_414508, L" ") )
      {
        v18 = wcslen(dword_414508);
        dword_414508 = (wchar_t *)sub_40B5D9((unsigned __int64)(v18 + 3) >> 31 != 0 ? -1 : 2 * (v18 + 3));
        wcscpy_s(dword_414508, v18 + 3, ::Source);
        wcscat_s(dword_414508, v18 + 3, v17);
        wcscat_s(dword_414508, v18 + 3, ::Source);
        v16 = Size;
      }
      v12 = (wchar_t *)Block;
    }
    *v13 = dword_414508;
  }
  if ( a3 )
  {
    v21 = -(int)wcspbrk(String, L"<>|&%");
    LOBYTE(v21) = v21 == 0;
    FileHandle = v21;
    Size = 0;
    if ( sub_406B6A(v16, (wint_t **)v13, &v52) )
    {
      v22 = *v13;
      v14 = v52;
      v60 = 0;
      FileHandle = (int)v22;
      goto LABEL_85;
    }
    v23 = String;
    v24 = String;
    do
      v25 = *v24++;
    while ( v25 != Buffer[0] );
    if ( (unsigned int)(v24 - (String + 1)) < 0x1000 && !(_BYTE)FileHandle )
    {
      v26 = *v13;
      v60 = 1;
      v27 = 16;
      FileHandle = (int)v26;
      goto LABEL_79;
    }
    FileHandleSrc = -1;
    v28 = String;
    FileHandle = -1;
    do
      v29 = *v28++;
    while ( v29 != Buffer[0] );
    v60 = sub_406E40(String, v28 - (String + 1) + 1, &FileHandleSrc, &FileHandle);
    if ( v60 )
    {
      v14 = v52;
      Size = 17;
    }
    else
    {
      v30 = wcslen(String);
      if ( v30 >= 0x8000 )
        sub_405B2C(0, 0x447u, String, &dword_4017DC, &dword_4017DC);
      if ( FileHandleSrc != -1 || FileHandle != -1 )
      {
        free(v12);
        Block = sub_40ECDB((char *)String);
        sub_405D0D(&v55, v13, (wchar_t *)Block);
      }
      if ( sub_407105((wchar_t *)*v13, &Str, v30) )
      {
        if ( Str == 34 )
        {
          v31 = wcslen(&Str);
          if ( v63[v31 + 199] == 34 )
          {
            memmove(&Str, Src, 2 * v31);
            v32 = 2 * v31 - 4;
            if ( v32 >= 0x208 )
              __report_rangecheckfailure();
            *(_WORD *)&Src[v32 - 2] = 0;
          }
        }
        *v13 = &Str;
        if ( wcschr(&Str, 0x20u) )
        {
          v61 = 34;
          wcscpy_s(Destination, 0x103u, &Str);
          wcscat_s(&v61, 0x104u, ::Source);
          *v13 = &v61;
        }
        *errno() = 0;
        *_doserrno() = 0;
        v14 = wspawnvp(0, &Str, v13);
        if ( v14 != -1 || *errno() == 12 || *_doserrno() != 193 )
          goto LABEL_69;
        Size = 19;
      }
      else
      {
        v14 = v52;
        Size = 18;
      }
      v60 = 1;
    }
LABEL_69:
    if ( FileHandleSrc != -1 )
    {
      v33 = _acrt_iob_func(0);
      v34 = fileno(v33);
      if ( dup2(FileHandleSrc, v34) == -1 )
        sub_405B2C(0, 0x411u);
      close(FileHandleSrc);
    }
    if ( FileHandle != -1 )
    {
      v35 = _acrt_iob_func(1u);
      v36 = fileno(v35);
      if ( dup2(FileHandle, v36) == -1 )
        sub_405B2C(0, 0x411u);
      close(FileHandle);
    }
    v22 = *v13;
    FileHandle = (int)*v13;
    if ( !v60 )
    {
LABEL_85:
      if ( v14 == -1 )
      {
        if ( v58 )
          goto LABEL_23;
        v42 = *errno();
        if ( !v42 )
        {
LABEL_98:
          v19 = a5;
          if ( !a5 )
            goto LABEL_103;
          v46 = (wchar_t **)(v13 + 2);
          if ( !v60 )
            v46 = (wchar_t **)v13;
          v20 = *v46;
          goto LABEL_102;
        }
        v43 = v42 - 2;
        if ( v43 )
        {
          if ( v43 == 10 )
          {
            sub_405B2C(0, 0x43Au, v22);
          }
          else if ( *_doserrno() )
          {
            *(_DWORD *)Buffer = 0;
            v44 = *_doserrno();
            FormatMessageW(0x1300u, 0, v44, 0x400u, Buffer, 0, 0);
            if ( v44 > 0 )
              v44 = (unsigned __int16)v44 | 0x80070000;
            sub_405B2C(0, 0x415u, FileHandle, v44, *(_DWORD *)Buffer);
          }
          else
          {
            v45 = *errno();
            wcserror_s(v63, 0xC8u, v45);
            sub_405B2C(0, 0x415u, FileHandle, v45, v63);
          }
          goto LABEL_98;
        }
        sub_405B2C(0, 0x439u, v22);
      }
      if ( !v14 )
        goto LABEL_103;
      goto LABEL_98;
    }
    v23 = String;
    v27 = Size;
LABEL_79:
    v37 = v23;
    do
      v38 = *v37++;
    while ( v38 != Buffer[0] );
    if ( (unsigned int)(v37 - (v23 + 1)) >= 0x1000 )
    {
      v39 = sub_40CEF8(v27);
      v40 = sub_40CEF8(0xFu);
      sub_405B2C(0, 0x447u, String, v40, v39);
    }
    else
    {
      wcscpy_s(&::Destination, 0x8000u, v23);
    }
    v41 = sub_406334(0, v55, (wchar_t **)v13);
    v22 = (const wchar_t *)FileHandle;
    v14 = (intptr_t)v41;
    goto LABEL_85;
  }
  if ( !sub_406B6A(v16, (wint_t **)v13, &v52) )
  {
LABEL_23:
    v14 = 0;
    goto LABEL_103;
  }
  v14 = v52;
  if ( v52 )
  {
    v19 = a5;
    if ( a5 )
    {
      v20 = (wchar_t *)*v13;
LABEL_102:
      *v19 = sub_40ECDB((char *)v20);
    }
  }
LABEL_103:
  v47 = Block;
  if ( v55 == -8 )
  {
    v49 = 1;
    v50 = 1;
    if ( !v13 )
      goto LABEL_113;
    goto LABEL_111;
  }
  v48 = 0;
  if ( v13 )
  {
    while ( v13[v48] )
    {
      if ( v13[v48] == Block )
      {
        v50 = 0;
        break;
      }
      if ( ++v48 >= v55 + 8 )
        break;
    }
LABEL_111:
    free(v13);
    v49 = v50;
    goto LABEL_113;
  }
  v49 = 1;
LABEL_113:
  if ( v47 && v49 )
    free(v47);
  if ( !v14 )
  {
    if ( a5 )
      *a5 = 0;
  }
  return v14;
}
// 407A0B: variable 'v30' is possibly undefined
// 4017DC: using guessed type int dword_4017DC;
// 4125FC: using guessed type void __noreturn __report_rangecheckfailure(void);
// 424F6C: using guessed type int dword_424F6C;
// 434F70: using guessed type int dword_434F70;
// 40756C: using guessed type char Src[522];
// 40756C: using guessed type wchar_t Destination[59];

//----- (00407E09) --------------------------------------------------------
void *sub_407E09()
{
  void *v0; // esi
  wchar_t *Buffer; // [esp+4h] [ebp-214h] BYREF
  wchar_t ResultPath[262]; // [esp+8h] [ebp-210h] BYREF

  Buffer = 0;
  wdupenv_s(&Buffer, 0, L"COMSPEC");
  if ( Buffer )
  {
    v0 = sub_40ECDB((char *)Buffer);
    free(Buffer);
    return v0;
  }
  else
  {
    wsearchenv(L"CMD.EXE", aPa_0, ResultPath);
    if ( !ResultPath[0] )
      sub_405B2C(0, 0x420u);
    return sub_40ECDB((char *)ResultPath);
  }
}

//----- (00407EA5) --------------------------------------------------------
char __fastcall sub_407EA5(__int16 *a1, int a2, char a3, char a4, const wchar_t *a5, unsigned int *a6)
{
  int v6; // ebx
  __int16 *v7; // edx
  __int16 *v8; // esi
  __int16 v9; // di
  __int16 v10; // ax
  __int16 v11; // cx
  __int16 v12; // dx
  __int16 *v13; // edi
  __int16 v14; // cx
  __int16 v15; // si
  char v17; // bh
  char v18; // bl
  int *v19; // eax
  int v20; // edi
  void *v21; // eax
  char v22; // al
  char v23; // dl
  unsigned int v24; // eax
  int *v25; // eax
  void *v26; // [esp-4h] [ebp-3Ch]
  int v27; // [esp+Ch] [ebp-2Ch] BYREF
  int v28; // [esp+14h] [ebp-24h] BYREF
  char v29[4]; // [esp+18h] [ebp-20h]
  __int16 *v30; // [esp+1Ch] [ebp-1Ch] BYREF
  int v31; // [esp+20h] [ebp-18h]
  void *Block; // [esp+24h] [ebp-14h]
  int v33; // [esp+28h] [ebp-10h]
  __int16 *v34; // [esp+2Ch] [ebp-Ch]
  int v35; // [esp+30h] [ebp-8h] BYREF

  v31 = a2;
  v6 = 0;
  v7 = a1;
  v35 = 0;
  v34 = a1;
  v8 = a1;
  v9 = *a1;
  v33 = 0;
  v10 = v9;
  if ( !v9 )
  {
LABEL_12:
    v15 = v35;
    goto LABEL_13;
  }
  v11 = v9;
  v35 = 63;
  while ( 1 )
  {
    if ( v11 != 36 )
      goto LABEL_21;
    v12 = v8[1];
    if ( v12 == 40 )
      ++v8;
    v13 = v8 + 1;
    v14 = v8[1];
    if ( v14 != 63 )
      break;
    if ( v12 != 40 || wcschr(L"DFBR", v8[2]) && v8[3] == 41 || v8[2] == 41 )
    {
      v6 = dword_424F50;
      v10 = *v8;
      v7 = v34;
      v33 = dword_424F50;
      goto LABEL_12;
    }
LABEL_21:
    v11 = *++v8;
    if ( !*v8 )
      return 0;
  }
  ++v8;
  if ( v14 != 42 || v13[1] != 42 || v12 == 40 && (!wcschr(L"DFBR", v13[2]) || v13[3] != 41) && v13[2] != 41 )
    goto LABEL_21;
  v6 = dword_424F44;
  v10 = *v13;
  v7 = v34;
  v33 = dword_424F44;
  v15 = 42;
LABEL_13:
  if ( !v10 )
    return 0;
  if ( !v6 )
    goto LABEL_52;
  v29[0] = (a4 & 2) != 0;
  v17 = a3 & 2;
  v18 = a3 & 4;
  while ( 2 )
  {
    dword_42473C = v31;
    v19 = (int *)dword_424F44;
    if ( v15 != 42 )
      v19 = (int *)dword_424F50;
    v20 = *v19;
    *v19 = 0;
    v35 = 0;
    v30 = v7;
    sub_40F9D0(&v27, &v30, 255, &dword_42473C, 0, (int)&v35);
    v21 = (void *)v35;
    v35 = 0;
    Block = v21;
    if ( sub_41168E((char *)word_424F70, 0x8000, (unsigned __int16 *)v21, a5) )
      sub_405B2C(0, 0x447u, Block, &dword_4017DC, &dword_4017DC);
    if ( v18 && (a4 & 8) == 0 )
    {
      v22 = 0;
      goto LABEL_33;
    }
    v22 = 1;
    if ( !v18 && ((a3 & 8) != 0 || (a4 & 1) != 0) )
    {
      v23 = 0;
      v22 = 1;
    }
    else
    {
LABEL_33:
      v23 = 1;
    }
    v24 = sub_40756C(word_424F70, v23, v22, v29[0], (void **)&v28);
    *a6 = v24;
    if ( !v17 && v24 && v24 > dword_434F70 && !byte_424737 )
      sub_405B2C(0, 0x435u, v28, v24);
    if ( v15 == 42 )
    {
      v25 = (int *)dword_424F44;
      dword_424F44 = v20;
    }
    else
    {
      v25 = (int *)dword_424F50;
      dword_424F50 = v20;
    }
    v26 = Block;
    *v25 = v20;
    free(v26);
    if ( v17 || !byte_424737 || !*a6 || *a6 <= dword_434F70 )
    {
      v7 = v34;
      if ( v20 )
        continue;
    }
    break;
  }
  v6 = v33;
LABEL_52:
  if ( v15 == 42 )
    dword_424F44 = v6;
  else
    dword_424F50 = v6;
  return 1;
}
// 4017DC: using guessed type int dword_4017DC;
// 424737: using guessed type char byte_424737;
// 42473C: using guessed type int dword_42473C;
// 424F44: using guessed type int dword_424F44;
// 424F50: using guessed type int dword_424F50;
// 424F70: using guessed type wchar_t word_424F70[32768];
// 434F70: using guessed type int dword_434F70;

//----- (00408124) --------------------------------------------------------
void __fastcall sub_408124(int a1, __int16 **a2)
{
  int v2; // esi
  __int16 **v3; // ebx
  __int16 *v4; // ecx
  __int16 *v5; // edi
  __int16 v6; // dx
  __int16 *v7; // eax
  __int16 v8; // ax
  __int16 **v9; // [esp+10h] [ebp-4h]

  v2 = a1;
  v3 = a2;
  v9 = a2;
  if ( !a1 )
    return;
  do
  {
    v4 = *v3;
    --v2;
    v5 = *v3;
    if ( !**v3 )
      goto LABEL_15;
    v6 = *v4;
    do
    {
      if ( v6 == 92 || v6 == 94 )
      {
        v7 = v5 + 1;
        if ( v5[1] == 34 )
        {
          *v4 = v6;
          ++v5;
          v8 = *v7;
          ++v4;
        }
        else
        {
          v8 = v6;
        }
        *v4 = v8;
      }
      else
      {
        if ( v6 == 34 )
          goto LABEL_13;
        *v4 = v6;
      }
      ++v4;
LABEL_13:
      v6 = *++v5;
    }
    while ( *v5 );
    v3 = v9;
LABEL_15:
    ++v3;
    *v4 = 0;
    v9 = v3;
  }
  while ( v2 );
}

//----- (004081AE) --------------------------------------------------------
void __fastcall sub_4081AE(int ArgList, char a2)
{
  _WORD *v4; // ecx
  __int16 v5; // ax
  HANDLE FileW; // esi
  struct _FILETIME SystemTimeAsFileTime; // [esp+10h] [ebp-8h] BYREF

  if ( *(_WORD *)ArgList == 34 )
  {
    *wcsrchr((const wchar_t *)ArgList, 0x22u) = 0;
    v4 = (_WORD *)ArgList;
    v5 = *(_WORD *)(ArgList + 2);
    *(_WORD *)ArgList = v5;
    while ( v5 )
    {
      ++v4;
      v5 = v4[1];
      *v4 = v5;
    }
  }
  sub_405C06(5u, ArgList);
  if ( !a2 )
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    FileW = CreateFileW((LPCWSTR)ArgList, 0x100u, 0, 0, 3u, 0x80u, 0);
    if ( FileW != (HANDLE)-1 )
    {
      SetFileTime(FileW, 0, 0, &SystemTimeAsFileTime);
      CloseHandle(FileW);
    }
  }
}

//----- (0040823C) --------------------------------------------------------
__int64 __thiscall sub_40823C(char *this)
{
  __int64 result; // rax

  if ( (*this & 0x10) == 0 )
    return *(_QWORD *)(this + 20);
  result = *(_QWORD *)(this + 4);
  if ( !result )
    return *(_QWORD *)(this + 20);
  return result;
}

//----- (00408256) --------------------------------------------------------
WCHAR *__fastcall sub_408256(wchar_t *Str, LPWIN32_FIND_DATAW lpFindFileData, HANDLE *a3)
{
  unsigned __int16 *v3; // ebx
  LPWIN32_FIND_DATAW v4; // edi
  char *v5; // esi
  wchar_t *v6; // eax
  unsigned int v7; // ecx
  unsigned __int16 *v8; // edx
  unsigned __int16 v9; // cx
  HANDLE FirstFileW; // eax
  bool v13; // [esp+1Fh] [ebp-215h]
  char Block[524]; // [esp+20h] [ebp-214h] BYREF

  v3 = Str;
  v4 = lpFindFileData;
  v5 = Block;
  v6 = wcspbrk(Str, L"\"^*?");
  v13 = v6 != 0;
  if ( v6 )
  {
    v7 = wcslen(v3);
    if ( v7 + 1 > 0x104 )
    {
      v5 = (char *)sub_40B5D9((unsigned __int64)(v7 + 1) >> 31 != 0 ? -1 : 2 * (v7 + 1));
      if ( !v5 )
        sub_405B2C(dword_424730, 0x41Bu);
    }
    v8 = (unsigned __int16 *)v5;
    if ( *v3 )
    {
      v9 = *v3;
      do
      {
        if ( v9 != 94 && v9 != 34 )
          *v8++ = v9;
        v9 = *++v3;
      }
      while ( *v3 );
      v4 = lpFindFileData;
    }
    v3 = (unsigned __int16 *)v5;
    *v8 = 0;
  }
  FirstFileW = FindFirstFileW(v3, v4);
  *a3 = FirstFileW;
  if ( FirstFileW != (HANDLE)-1 && sub_408582(v3, v4) )
  {
    if ( !v13 || !wcschr(v3, 0x2Au) && !wcschr(v3, 0x3Fu) )
    {
      FindClose(*a3);
      *a3 = (HANDLE)-1;
    }
    if ( v5 != Block )
      free(v5);
    if ( (v4->dwFileAttributes & 0x10) == 0 && !v4->ftLastWriteTime.dwLowDateTime && !v4->ftLastWriteTime.dwHighDateTime )
    {
      v4->ftLastWriteTime.dwLowDateTime = -1;
      v4->ftLastWriteTime.dwHighDateTime = -1;
    }
    return v4->cFileName;
  }
  else
  {
    if ( v5 != Block )
      free(v5);
    return 0;
  }
}
// 424730: using guessed type int dword_424730;

//----- (004083E1) --------------------------------------------------------
WCHAR *__fastcall sub_4083E1(LPWIN32_FIND_DATAW lpFindFileData, HANDLE hFindFile)
{
  if ( FindNextFileW(hFindFile, lpFindFileData) )
    return lpFindFileData->cFileName;
  FindClose(hFindFile);
  return 0;
}

//----- (00408404) --------------------------------------------------------
void *__fastcall sub_408404(wchar_t *a1, wchar_t *a2, struct _WIN32_FIND_DATAW *lpFindFileData, HANDLE *a4)
{
  char *v6; // ecx
  wchar_t *v8; // esi
  wchar_t v9; // ax
  wchar_t v10; // cx
  int v11; // eax

  if ( sub_408256(a2, lpFindFileData, a4) )
  {
    v6 = (char *)a2;
    return sub_40ECDB(v6);
  }
  if ( a1 )
  {
LABEL_5:
    v8 = &Src;
    do
    {
LABEL_6:
      v9 = *a1;
      while ( 1 )
      {
        if ( v9 )
        {
          v10 = v9;
          while ( 1 )
          {
            ++a1;
            if ( v10 != 34 )
              break;
            v10 = *a1;
            if ( !*a1 )
              goto LABEL_11;
          }
          *v8 = v10;
          if ( v10 != 59 )
          {
            ++v8;
            goto LABEL_6;
          }
        }
LABEL_11:
        if ( v8 != &Src )
          break;
        v9 = *a1;
        if ( !*a1 )
          return 0;
      }
      v11 = *(v8 - 1);
      if ( (_WORD)v11 != 92 && v11 != 47 )
        *v8++ = 92;
      *v8 = 0;
      if ( wcspbrk(&Src, L"*?") )
        goto LABEL_5;
      wcscpy_s(v8, 1024 - (v8 - &Src), a2);
      v8 = &Src;
    }
    while ( !sub_408256(&Src, lpFindFileData, a4) );
    v6 = (char *)&Src;
    return sub_40ECDB(v6);
  }
  return 0;
}

//----- (004084F3) --------------------------------------------------------
char __fastcall sub_4084F3(_WORD *Block, LPWIN32_FIND_DATAW lpFindFileData)
{
  WCHAR *v3; // esi
  char *v4; // edx
  char v5; // bl
  int v7; // ecx
  HANDLE hFindFile; // [esp+Ch] [ebp-4h]

  v3 = Block;
  v4 = (char *)(Block + 1);
  v5 = 0;
  while ( *Block++ )
    ;
  v7 = ((char *)Block - v4) >> 1;
  if ( *v3 == 34 && v3[v7 - 1] == 34 )
  {
    v3 = sub_411BBE(v3);
    v5 = 1;
  }
  hFindFile = FindFirstFileW(v3, lpFindFileData);
  if ( hFindFile != (HANDLE)-1 && sub_408582(v3, lpFindFileData) )
  {
    FindClose(hFindFile);
    if ( (lpFindFileData->dwFileAttributes & 0x10) == 0
      && !lpFindFileData->ftLastWriteTime.dwLowDateTime
      && !lpFindFileData->ftLastWriteTime.dwHighDateTime )
    {
      lpFindFileData->ftLastWriteTime.dwLowDateTime = -1;
      lpFindFileData->ftLastWriteTime.dwHighDateTime = -1;
    }
    return 1;
  }
  else
  {
    if ( v5 )
      free(v3);
    return 0;
  }
}

//----- (00408582) --------------------------------------------------------
char __fastcall sub_408582(wchar_t *Str, _DWORD *a2)
{
  _DWORD *v2; // ebx
  const unsigned __int16 *v3; // edi
  WCHAR *v4; // esi
  wchar_t *v5; // edx
  unsigned int v6; // ecx
  _WORD *v8; // ebx
  int v9; // edx
  __int64 v11; // rax
  WCHAR *v12; // eax
  unsigned __int16 *v13; // ecx
  unsigned __int16 v14; // ax
  WCHAR *v15; // ecx
  WCHAR v16; // dx
  HANDLE FileW; // edi
  wchar_t *v19; // [esp+10h] [ebp-10h]
  wchar_t *v20; // [esp+14h] [ebp-Ch]
  WCHAR *v22; // [esp+1Ch] [ebp-4h]

  v2 = a2;
  v3 = Str;
  if ( (*a2 & 0x400) != 0 && a2[9] == -1610612724 )
  {
    v4 = (WCHAR *)(a2 + 11);
    v5 = wcsrchr(Str, 0x5Cu);
    v20 = v5;
    if ( v5 )
    {
      v6 = wcslen(v3);
      v19 = v5 + 1;
      while ( *v5++ )
        ;
      v8 = v2 + 11;
      v9 = v5 - v19;
      while ( *v8++ )
        ;
      v11 = 2i64 * (v6 + 2 + v8 - (v4 + 1) - v9);
      v12 = (WCHAR *)sub_40B5D9(HIDWORD(v11) != 0 ? -1 : v11);
      v2 = a2;
      v22 = v12;
      if ( !v12 )
      {
        sub_405B2C(dword_424730, 0x41Bu);
        v12 = 0;
      }
      v13 = v12;
      if ( v3 != v20 )
      {
        do
        {
          v14 = *v3++;
          *v13++ = v14;
        }
        while ( v3 != v20 );
        v2 = a2;
      }
      *v13 = 92;
      v15 = v13 + 1;
      if ( *v4 )
      {
        v16 = *v4;
        do
        {
          ++v4;
          *v15++ = v16;
          v16 = *v4;
        }
        while ( *v4 );
      }
      v4 = v22;
      *v15 = 0;
    }
    FileW = CreateFileW(v4, 0x80000000, 1u, 0, 3u, 0, 0);
    if ( v20 )
      free(v4);
    if ( FileW == (HANDLE)-1 )
      return 0;
    if ( !GetFileTime(FileW, (LPFILETIME)(v2 + 1), (LPFILETIME)(v2 + 3), (LPFILETIME)(v2 + 5)) )
    {
      CloseHandle(FileW);
      return 0;
    }
    CloseHandle(FileW);
  }
  return 1;
}
// 424730: using guessed type int dword_424730;

//----- (004086F8) --------------------------------------------------------
int sub_4086F8()
{
  int result; // eax
  wchar_t *v1; // edi
  wchar_t *v2; // eax
  wchar_t *v3; // esi
  wchar_t *v4; // esi
  int v5; // eax
  char v6; // [esp+Ah] [ebp-6h] BYREF
  bool v7; // [esp+Bh] [ebp-5h]
  wchar_t *Context; // [esp+Ch] [ebp-4h] BYREF
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  while ( 1 )
  {
    result = getwc(Stream);
    if ( !dword_434F78 && (!byte_414021 || (_WORD)result != 33) )
      break;
    byte_414021 = 0;
    if ( dword_434F78 )
    {
      ungetwc(result, Stream);
      v1 = (wchar_t *)dword_434F78;
      dword_434F78 = 0;
    }
    else
    {
      v1 = sub_4088A1();
    }
    v7 = v1 != dword_434F7C;
    v2 = sub_4089DD(v1, &v6);
    v3 = v2;
    switch ( v6 )
    {
      case 9:
        if ( byte_424F61 )
          sub_405B2C(dword_424724, 0x409u, v1);
        if ( sub_40AFB3(v3) == 18 )
          return 32;
        break;
      case 10:
        sub_408B74(v2);
        break;
      case 11:
        sub_405B2C(dword_424724, 0x41Au, v2);
        break;
      case 12:
        if ( !wcsnicmp(v2, L"\\t", 2u) )
        {
          sub_40D1B2((wchar_t *)L"\t");
          v3 += 2;
        }
        sub_405C06(0xDu, v3);
        break;
      case 13:
        Context = 0;
        v4 = wcstok_s(v2, L" \t", &Context);
        if ( wcstok_s(0, L" \t", &Context) )
          sub_405B2C(dword_424724, 0x409u, v4);
        v5 = sub_40B534(v4);
        if ( v5 )
          *(_BYTE *)(v5 + 12) |= 0x10u;
        break;
      default:
        sub_408ECF(v6, v2, (int)&savedregs);
        break;
    }
    byte_414021 = 1;
    if ( v7 )
      free(v1);
    ++dword_424724;
  }
  return result;
}
// 414021: using guessed type char byte_414021;
// 424724: using guessed type int dword_424724;
// 424F61: using guessed type char byte_424F61;

//----- (004088A1) --------------------------------------------------------
wint_t *sub_4088A1()
{
  __int16 v0; // si
  unsigned int v1; // edi
  wint_t i; // ax
  wchar_t *v3; // eax
  int v4; // edx
  wint_t v5; // ax
  wint_t v6; // si
  wint_t v7; // ax
  FILE *v9; // [esp-4h] [ebp-10h]

  v0 = sub_40A552(1);
  if ( v0 == 10 || v0 == -1 )
    sub_405B2C(dword_424724, 0x3FAu);
  v1 = 0;
  for ( i = sub_40A62B(v0, 1); ; i = sub_40A62B(v5, 1) )
  {
    v6 = i;
    if ( i == 35 || i == 10 || i == 0xFFFF )
      break;
    if ( (unsigned int)dword_434F74 < 2 || v1 > dword_434F74 - 2 )
    {
      v4 = dword_434F74 + 1024;
      dword_434F74 += 1024;
      if ( dword_434F7C )
        v3 = (wchar_t *)sub_40B61C(dword_434F7C, 2 * v4 + 2);
      else
        v3 = (wchar_t *)sub_40B5D9((unsigned __int64)(unsigned int)(v4 + 1) >> 31 != 0 ? -1 : 2 * (v4 + 1));
      dword_434F7C = v3;
    }
    else
    {
      v3 = dword_434F7C;
    }
    v9 = Stream;
    v3[v1++] = v6;
    v5 = getwc(v9);
  }
  dword_434F7C[v1] = 0;
  if ( i == 35 )
  {
    while ( 1 )
    {
      v7 = getwc(Stream);
      v6 = v7;
      if ( v7 == 10 )
        break;
      if ( v7 == 0xFFFF )
        goto LABEL_21;
    }
  }
  if ( v6 == 0xFFFF )
LABEL_21:
    ungetwc(v6, Stream);
  return sub_40F94D(dword_434F7C);
}
// 424724: using guessed type int dword_424724;
// 434F74: using guessed type int dword_434F74;

//----- (004089DD) --------------------------------------------------------
wchar_t *__fastcall sub_4089DD(wchar_t *String1, char *a2)
{
  wchar_t *v2; // edi
  wchar_t *v3; // ebx
  wchar_t *v4; // esi
  wchar_t v5; // dx
  wchar_t *v6; // eax
  wchar_t v7; // di
  wchar_t v8; // cx
  bool v9; // zf
  int v10; // esi
  wchar_t v11; // cx
  char v12; // al
  wchar_t *v14; // [esp+14h] [ebp-14h]
  int v15; // [esp+20h] [ebp-8h] BYREF
  char *v16; // [esp+24h] [ebp-4h]

  v2 = String1;
  v16 = a2;
  v3 = String1;
  v14 = String1;
  *a2 = 0;
  v4 = String1;
  v15 = (int)String1;
  v5 = *String1;
  if ( *String1 )
  {
    v6 = String1;
    v7 = *String1;
    do
    {
      v5 = v7;
      if ( v7 == 32 )
        break;
      v4 = v6;
      v5 = v7;
      if ( v7 == 9 )
        break;
      v3 = String1 + 1;
      v4 = v3;
      v8 = String1[1];
      v15 = (int)v3;
      v7 = v8;
      v5 = v8;
      v9 = v8 == 0;
      v6 = v3;
      String1 = v3;
    }
    while ( !v9 );
    v2 = v14;
  }
  v10 = v4 - v2;
  if ( v5 )
  {
    v11 = v5;
    do
    {
      if ( v11 != 32 && v11 != 9 )
        break;
      v15 = (int)++v3;
      v11 = *v3;
    }
    while ( *v3 );
    v2 = v14;
  }
  if ( wcsnicmp(v2, L"INCLUDE", 7u) || v10 != 7 )
  {
    if ( wcsnicmp(v2, L"CMDSWITCHES", 0xBu) || v10 != 11 )
    {
      if ( wcsnicmp(v2, L"ERROR", 5u) || v10 != 5 )
      {
        if ( wcsnicmp(v2, L"MESSAGE", 7u) || v10 != 7 )
        {
          if ( wcsnicmp(v2, L"UNDEF", 5u) || v10 != 5 )
          {
            v12 = sub_408CF3(v2, v10, (wchar_t **)&v15);
            *v16 = v12;
            if ( !v12 )
              sub_405B2C(dword_424724, 0x3F9u, dword_434F7C);
            return (wchar_t *)v15;
          }
          else
          {
            *v16 = 13;
          }
        }
        else
        {
          *v16 = 12;
        }
      }
      else
      {
        *v16 = 11;
      }
    }
    else
    {
      *v16 = 10;
    }
  }
  else
  {
    *v16 = 9;
  }
  return v3;
}
// 424724: using guessed type int dword_424724;

//----- (00408B74) --------------------------------------------------------
int __thiscall sub_408B74(wint_t *this)
{
  wint_t *v1; // esi
  int result; // eax
  wint_t v3; // dx
  wint_t v4; // cx
  wint_t v5; // dx
  wint_t v6; // cx
  wchar_t v7; // ax
  wchar_t v8; // ax
  wint_t v9; // dx
  wchar_t v10; // ax
  wchar_t v11; // ax

  v1 = this;
  result = *this;
  if ( (_WORD)result )
  {
    v3 = *this;
    do
    {
      if ( v3 == 43 )
      {
        result = *++v1;
        v5 = result;
        if ( (_WORD)result )
        {
          v6 = *v1;
          do
          {
            v5 = v6;
            if ( v6 == 45 )
              break;
            v7 = towupper(v6);
            if ( wcschr(L"DINSU", v7) || byte_424F61 && (v8 = towupper(*v1), wcschr(L"ABCEKLPQRTY", v8)) )
              sub_40CB79(*v1, 1);
            else
              sub_405B2C(dword_424724, 0x400u);
            result = *++v1;
            v6 = result;
            v5 = *v1;
          }
          while ( (_WORD)result );
        }
        v4 = v5;
        if ( !v5 )
          goto LABEL_27;
      }
      else
      {
        result = v3 - 45;
        if ( v3 != 45 )
        {
          v4 = v3;
          if ( v3 != 32 )
          {
            v4 = v3;
            if ( v3 != 9 )
            {
              result = sub_405B2C(dword_424724, 0x400u);
              v4 = *v1;
            }
          }
LABEL_27:
          if ( !v4 )
            return result;
          goto LABEL_28;
        }
      }
      result = *++v1;
      v4 = result;
      if ( !(_WORD)result )
        goto LABEL_27;
      v9 = *v1;
      while ( v9 != 43 )
      {
        v10 = towupper(v9);
        if ( wcschr(L"DINSU", v10) || byte_424F61 && (v11 = towupper(*v1), wcschr(L"ABCEKLMPQRTV", v11)) )
          sub_40CB79(*v1, 0);
        else
          sub_405B2C(dword_424724, 0x400u);
        result = *++v1;
        v9 = result;
        v4 = *v1;
        if ( !(_WORD)result )
          goto LABEL_27;
      }
LABEL_28:
      result = *++v1;
      v3 = result;
    }
    while ( (_WORD)result );
  }
  return result;
}
// 424724: using guessed type int dword_424724;
// 424F61: using guessed type char byte_424F61;

//----- (00408CF3) --------------------------------------------------------
char __fastcall sub_408CF3(wchar_t *String1, int a2, wchar_t **a3)
{
  char v4; // bl
  wchar_t *v5; // ecx
  wchar_t v6; // dx
  wchar_t v7; // ax
  int (__cdecl *v8)(const wchar_t *, const wchar_t *, size_t); // edi
  int v9; // esi
  wchar_t v10; // di
  wchar_t *String1b; // [esp+10h] [ebp-4h]

  v4 = 0;
  if ( !wcsnicmp(String1, L"IF", 2u) && a2 == 2 )
    return 1;
  if ( !wcsnicmp(String1, L"IFDEF", 5u) && a2 == 5 )
    return 6;
  if ( !wcsnicmp(String1, L"IFNDEF", 6u) && a2 == 6 )
    return 7;
  if ( wcsnicmp(String1, L"ELSE", 4u) || a2 != 4 )
  {
    if ( wcsnicmp(String1, L"ELSEIF", 6u) || a2 != 6 )
    {
      if ( wcsnicmp(String1, L"ELSEIFDEF", 9u) || a2 != 9 )
      {
        if ( !wcsnicmp(String1, L"ELSEIFNDEF", 0xAu) && a2 == 10 )
          return 5;
        if ( !wcsnicmp(String1, L"ENDIF", 5u) && a2 == 5 )
          return 8;
        return v4;
      }
      return 4;
    }
    return 3;
  }
  v5 = *a3;
  if ( !**a3 )
    return 2;
  String1b = *a3;
  v6 = **a3;
  do
  {
    v7 = v6;
    if ( v6 == 32 )
      break;
    v7 = v6;
    if ( v6 == 9 )
      break;
    v7 = *++v5;
    v6 = *v5;
  }
  while ( *v5 );
  v8 = wcsnicmp;
  v9 = v5 - String1b;
  if ( v7 )
  {
    v10 = v7;
    do
    {
      if ( v10 != 32 && v10 != 9 )
        break;
      v10 = *++v5;
    }
    while ( *v5 );
    v8 = wcsnicmp;
  }
  *a3 = v5;
  if ( !v8(String1b, L"IF", 2u) && v9 == 2 )
    return 3;
  if ( !v8(String1b, L"IFDEF", 5u) && v9 == 5 )
    return 4;
  if ( !v8(String1b, L"IFNDEF", 6u) && v9 == 6 )
    return 5;
  return v4;
}

//----- (00408ECF) --------------------------------------------------------
char __usercall sub_408ECF@<al>(char a1@<dl>, wchar_t *a2@<ecx>, int a3@<ebp>)
{
  int v3; // eax
  wchar_t *v4; // esi
  int v5; // eax
  int v6; // eax
  char v7; // al
  char v8; // al
  bool v9; // zf
  char v10; // al
  char v11; // al
  wint_t v12; // ax
  _DWORD v14[2]; // [esp-4h] [ebp-8h] BYREF

  LOBYTE(v3) = a1 - 1;
  v4 = a2;
  switch ( a1 )
  {
    case 1:
    case 6:
    case 7:
      v5 = dword_414024;
      if ( dword_414024 != 15 )
        goto LABEL_5;
      v5 = sub_405B2C(dword_424724, 0x3FBu);
      goto LABEL_4;
    case 2:
      if ( dword_414024 < 0 )
        goto LABEL_21;
      a2 = (wchar_t *)&byte_434F80[dword_414024];
      v7 = byte_434F80[dword_414024];
      if ( (v7 & 9) == 0 )
        goto LABEL_21;
      v8 = v7 & 0xF6;
      *(_BYTE *)a2 = v8;
      if ( (v8 & 4) != 0 )
        goto LABEL_8;
      if ( (v8 & 2) != 0 )
        LOBYTE(v3) = v8 & 0xFD;
      else
        LOBYTE(v3) = v8 | 2;
      v9 = (v3 & 2) == 0;
      *(_BYTE *)a2 = v3;
      goto LABEL_19;
    case 3:
    case 4:
    case 5:
      a2 = (wchar_t *)dword_414024;
      if ( dword_414024 < 0 || (v10 = byte_434F80[dword_414024], (v10 & 9) == 0) )
      {
LABEL_21:
        v5 = sub_405B2C(dword_424724, 0x3FDu);
        goto LABEL_4;
      }
      v11 = v10 & 0xF6 | 8;
      byte_434F80[dword_414024] = v11;
      if ( (v11 & 4) != 0 )
        goto LABEL_8;
      if ( (v11 & 2) != 0 )
      {
        byte_434F80[(_DWORD)a2] = v11 & 0xF9 | 4;
        goto LABEL_8;
      }
      a2 = v4;
      goto LABEL_9;
    case 8:
      if ( dword_414024 >= 0 )
      {
        v3 = dword_414024 - 1;
        dword_414024 = v3;
        if ( v3 < 0 )
          return v3;
        v9 = (byte_434F80[v3] & 2) == 0;
LABEL_19:
        if ( !v9 )
          return v3;
      }
      else
      {
        v5 = sub_405B2C(dword_424724, 0x401u);
LABEL_4:
        a2 = (wchar_t *)v14[0];
LABEL_5:
        v9 = v5 == -1;
        v6 = v5 + 1;
        dword_414024 = v6;
        byte_434F80[v6] = 1;
        if ( v9 || (*((_BYTE *)&dword_434F7C + v6 + 3) & 2) != 0 )
        {
LABEL_9:
          if ( sub_40E3F9(a2, a1) )
          {
            LOBYTE(v3) = dword_414024;
            byte_434F80[dword_414024] |= 2u;
            return v3;
          }
        }
        else
        {
          byte_434F80[v6] = 5;
        }
      }
LABEL_8:
      v14[1] = a3;
      HIBYTE(v14[0]) = HIBYTE(a2);
      while ( 1 )
      {
        v12 = getwc(Stream);
        if ( v12 != 33 )
        {
          do
          {
            if ( v12 == 0xFFFF )
              goto LABEL_52;
            ++dword_424724;
            while ( 1 )
            {
              if ( v12 == 92 )
              {
                v12 = sub_40A62B(0x5Cu, 1);
                if ( v12 == 33 && byte_414021 )
                  goto LABEL_47;
                byte_414021 = 0;
              }
              if ( v12 == 35 )
                break;
              if ( v12 == 10 )
                goto LABEL_45;
              if ( v12 == 0xFFFF )
                goto LABEL_46;
              v12 = getwc(Stream);
            }
            while ( 1 )
            {
              v12 = getwc(Stream);
              if ( v12 == 10 )
                break;
              if ( v12 == 0xFFFF )
                goto LABEL_46;
            }
LABEL_45:
            v12 = getwc(Stream);
          }
          while ( v12 != 33 );
LABEL_46:
          if ( v12 != 33 )
          {
LABEL_52:
            LOBYTE(v3) = sub_405B2C(dword_424724, 0x3FCu);
            return v3;
          }
        }
LABEL_47:
        if ( dword_434F78 && dword_434F78 != dword_434F7C )
          free(dword_434F78);
        dword_434F78 = sub_4088A1();
        LOBYTE(v3) = (unsigned __int8)sub_4089DD((wchar_t *)dword_434F78, (char *)v14 + 3);
        if ( HIBYTE(v14[0]) <= 8u )
          return v3;
        ++dword_424724;
      }
    default:
      return v3;
  }
}
// 408ECF: could not find valid save-restore pair for ebp
// 40909C: conditional instruction was optimized away because ax.2==A
// 4090A1: conditional instruction was optimized away because ax.2==A
// 4090FE: conditional instruction was optimized away because ax.2==FFFF
// 409002: variable 'a2' is possibly undefined
// 408F25: variable 'a1' is possibly undefined
// 414021: using guessed type char byte_414021;
// 414024: using guessed type int dword_414024;
// 424724: using guessed type int dword_424724;

//----- (00409117) --------------------------------------------------------
char sub_409117()
{
  char v0; // bl
  wchar_t *i; // eax
  const wchar_t *v2; // ecx
  wchar_t *v3; // edx
  int v5; // edx
  wchar_t *v7; // [esp+4h] [ebp-Ch]
  wchar_t *Context; // [esp+Ch] [ebp-4h] BYREF

  v0 = 0;
  for ( dword_424724 = 0; ; ++dword_424724 )
  {
    if ( !fgetws(&Src, 1024, Stream) )
    {
      if ( !feof(Stream) )
      {
        dword_424730 = dword_424724;
        sub_405B2C(0, 0x41Du);
      }
      return 0;
    }
    if ( Src == 91 )
      break;
LABEL_13:
    ;
  }
  Context = 0;
  for ( i = wcstok_s(&word_424742, L" \t\n", &Context); ; i = wcstok_s(0, L" \t\n", &Context) )
  {
    v2 = i;
    if ( !i || v0 )
    {
      v0 = 0;
      goto LABEL_13;
    }
    v3 = i;
    v7 = i + 1;
    while ( *v3++ )
      ;
    v5 = v3 - v7;
    if ( v2[v5 - 1] == 93 )
    {
      v0 = 1;
      v2[v5 - 1] = 0;
    }
    if ( !wcsicmp(v2, L"nmake") )
      break;
  }
  return 1;
}
// 424724: using guessed type int dword_424724;
// 424730: using guessed type int dword_424730;

//----- (00409200) --------------------------------------------------------
char __stdcall sub_409200(int a1)
{
  wchar_t ResultPath[260]; // [esp+0h] [ebp-20Ch] BYREF

  wsearchenv(L"tools.ini", L"INIT", ResultPath);
  if ( ResultPath[0] )
  {
    Stream = wfsopen(ResultPath, L"rt,ccs=unicode", 32);
    if ( !Stream )
      sub_405B2C(0, 0x41Du, ResultPath);
    if ( sub_409117() )
      return 1;
    if ( fclose(Stream) == -1 )
      sub_405B2C(0, 0x424u, ResultPath);
  }
  return 0;
}

//----- (004092B2) --------------------------------------------------------
wint_t *__fastcall sub_4092B2(wint_t *a1, int a2)
{
  wint_t *v2; // esi
  wint_t *v3; // edi
  wint_t *v4; // ecx
  wint_t v5; // ax
  wint_t *result; // eax
  FILE *v7; // [esp-4h] [ebp-Ch]

  v2 = a1;
  v3 = &a1[a2];
  while ( 1 )
  {
    v5 = sub_4086F8();
    if ( !v5 )
      return v2;
    v4 = v2;
    if ( v5 == 0xFFFF )
      break;
    *v2++ = v5;
    if ( v2 == v3 )
    {
      v7 = Stream;
      *v4 = 0;
      ungetwc(v5, v7);
      return v2;
    }
    if ( v5 == 10 )
    {
      ++dword_424724;
      byte_414021 = 1;
      *v2 = 0;
      return v2;
    }
    byte_414021 = 0;
  }
  result = 0;
  *v2 = 0;
  return result;
}
// 414021: using guessed type char byte_414021;
// 424724: using guessed type int dword_424724;

//----- (00409321) --------------------------------------------------------
wchar_t *__fastcall sub_409321(const wchar_t *a1)
{
  wchar_t *result; // eax
  const wchar_t *v3; // esi

  for ( result = wcschr(a1, 0xAu); result && (result <= a1 || *(result - 1) == 94); result = wcschr(v3, 0xAu) )
  {
    v3 = result + 1;
    if ( !fgetws(result + 1, 1024 - (result + 1 - a1), Stream) )
    {
      if ( feof(Stream) )
        sub_405B2C(dword_424724, 0x409u, L"EOF");
      sub_405B2C(dword_424724, 0x41Du);
    }
    ++dword_424724;
  }
  return result;
}
// 4019DC: using guessed type wchar_t aEof[4];
// 424724: using guessed type int dword_424724;

//----- (004093B5) --------------------------------------------------------
void *__thiscall sub_4093B5(__int16 **this)
{
  __int16 **v1; // ebx
  _WORD *v2; // edi
  const wchar_t *v3; // edx
  wchar_t *v4; // eax
  __int16 *v5; // edx
  __int16 v6; // ax
  bool v7; // bl
  __int16 v8; // si
  bool v9; // zf
  __int16 v10; // cx
  void *result; // eax

  v1 = this;
  v2 = &unk_435480;
  v3 = (const wchar_t *)*this;
  do
  {
    v4 = wcschr(v3, 0x3Cu);
    if ( !v4 )
      return 0;
    v3 = v4 + 1;
  }
  while ( v4[1] != 60 );
  v5 = (__int16 *)(v4 + 2);
  v6 = *v5;
  if ( *v5 )
  {
    v7 = 0;
LABEL_6:
    v8 = v6;
    do
    {
      if ( v8 == 62 || v8 == 60 || v8 == 94 || v8 == 44 || v8 == 9 || v8 == 10 )
        break;
      if ( v8 == 34 )
        v7 = !v7;
      if ( v8 == 32 && !v7 )
        break;
      if ( v8 == 36 )
      {
        v9 = v5[1] == 40;
        ++v5;
        if ( v9 )
        {
          *v2++ = 36;
          *v2 = 40;
          if ( *v5 == 10 )
            break;
          v10 = *v5;
          while ( 1 )
          {
            v6 = v10;
            if ( v10 == 41 )
              goto LABEL_6;
            ++v5;
            *v2++ = v10;
            v10 = *v5;
            if ( *v5 == 10 )
              goto LABEL_27;
          }
        }
      }
      else
      {
        ++v5;
      }
      *v2++ = v8;
      v8 = *v5;
    }
    while ( *v5 );
LABEL_27:
    v1 = this;
  }
  result = &unk_435480;
  *v2 = 0;
  *v1 = v5;
  return result;
}

//----- (004094E3) --------------------------------------------------------
wchar_t *__fastcall sub_4094E3(wchar_t *a1, _DWORD *a2, wchar_t **a3)
{
  _DWORD *v4; // ebx
  int *v5; // edx
  int *v6; // ecx
  char *v7; // esi
  wchar_t v8; // cx
  wchar_t *v9; // ebx
  _WORD *v10; // esi
  char *v11; // eax
  int v12; // esi
  char *v13; // eax
  char *v16; // [esp+1Ch] [ebp-820h]
  unsigned int v17; // [esp+20h] [ebp-81Ch]
  wchar_t *v18; // [esp+24h] [ebp-818h] BYREF
  void *Block; // [esp+28h] [ebp-814h]
  char v20; // [esp+2Fh] [ebp-80Dh]
  wchar_t Destination[2]; // [esp+30h] [ebp-80Ch] BYREF
  wint_t v22[1024]; // [esp+34h] [ebp-808h] BYREF

  v16 = 0;
  v17 = 0;
  v20 = 0;
  Block = 0;
  wcscpy_s(Destination, 0x400u, L"<<");
  if ( !sub_4092B2(v22, 1022) )
  {
    if ( feof(Stream) )
      sub_405B2C(dword_424724, 0x409u, L"EOF");
    sub_405B2C(dword_424724, 0x41Du);
  }
  v18 = Destination;
  sub_409321(Destination);
  while ( 1 )
  {
    v7 = (char *)sub_4093B5((__int16 **)&v18);
    if ( !v7 )
      break;
    v4 = sub_40B5FE(0xCu);
    v4[1] = sub_40ECDB(v7);
    v5 = &dword_4353A0;
    v6 = (int *)dword_4353A0;
    if ( dword_4353A0 )
    {
      do
      {
        v5 = v6;
        v6 = (int *)*v6;
      }
      while ( v6 );
    }
    *v5 = (int)v4;
  }
  if ( dword_4353A0 )
  {
    v18 = (wchar_t *)wcsncpy_s;
    do
    {
      while ( 1 )
      {
        v8 = Destination[0];
        v9 = Destination;
        do
        {
          ++v9;
          *a1++ = v8;
          if ( a1 == *a3 )
          {
            if ( Block )
            {
              v12 = 2 * v17;
              if ( v17 + 1024 < v17 || (v13 = (char *)sub_40B61C(Block, v12 + 2048), (v16 = v13) == 0) )
              {
                sub_405B2C(dword_424724, 0x419u);
                v13 = v16;
              }
              Block = v13;
              a1 = (wchar_t *)&v13[v12];
              v10 = v13;
              v17 += 1024;
              v11 = &v13[2 * v17];
            }
            else
            {
              v10 = sub_40B5D9(0x1000u);
              Block = v10;
              ((void (__cdecl *)(_WORD *, int, _DWORD, int))v18)(v10, 2048, *a2, 1024);
              a1 = v10 + 1024;
              v17 = 2048;
              v11 = (char *)(v10 + 2048);
            }
            *a3 = (wchar_t *)v11;
            *a2 = v10;
          }
          v8 = *v9;
        }
        while ( *v9 );
        if ( v20 && Destination[0] == 60 && Destination[1] == 60 )
          break;
        v20 = 1;
        if ( !sub_4092B2(Destination, 1024) )
        {
          if ( feof(Stream) )
            sub_405B2C(dword_424724, 0x409u, L"EOF");
          sub_405B2C(dword_424724, 0x41Du);
        }
      }
      if ( *(_DWORD *)dword_4353A0 && !sub_4092B2(Destination, 1024) )
      {
        if ( feof(Stream) )
          sub_405B2C(dword_424724, 0x409u, L"EOF");
        sub_405B2C(dword_424724, 0x41Du);
      }
      dword_4353A0 = *(_DWORD *)dword_4353A0;
    }
    while ( dword_4353A0 );
  }
  *a1 = 0;
  return a1;
}
// 4019DC: using guessed type wchar_t aEof[4];
// 424724: using guessed type int dword_424724;
// 4353A0: using guessed type int dword_4353A0;
// 4094E3: using guessed type wint_t var_808[1024];

//----- (00409808) --------------------------------------------------------
errno_t __fastcall sub_409808(void **a1, wchar_t *a2)
{
  char *v2; // edi
  _WORD *v3; // esi
  int v4; // ecx
  int v6; // esi
  wchar_t *v7; // ecx
  int v8; // esi
  wchar_t *v9; // edx
  void *v11; // esp
  wchar_t *i; // eax
  __int16 v13; // dx
  unsigned int v14; // kr00_4
  void **v15; // edi
  wchar_t *v16; // eax
  rsize_t v18; // [esp-8h] [ebp-28h]
  wchar_t *v19; // [esp-4h] [ebp-24h]
  wchar_t v20[8]; // [esp+0h] [ebp-20h] BYREF
  void **v21; // [esp+10h] [ebp-10h]
  wchar_t *Source; // [esp+14h] [ebp-Ch]
  rsize_t SizeInWords; // [esp+18h] [ebp-8h]

  Source = a2;
  v21 = a1;
  v2 = (char *)*a1;
  v3 = *a1;
  v4 = (int)*a1 + 2;
  while ( *v3++ )
    ;
  v6 = (int)v3 - v4;
  v7 = a2;
  v8 = v6 >> 1;
  v9 = a2 + 1;
  while ( *v7++ )
    ;
  SizeInWords = v7 - v9 - 1 + v8;
  v11 = alloca(2 * SizeInWords);
  for ( i = v20; ; ++i )
  {
    if ( *(_WORD *)v2 != 60 )
    {
      v13 = *(_WORD *)v2;
      goto LABEL_10;
    }
    if ( *((_WORD *)v2 + 1) == 60 )
      break;
    v13 = 60;
LABEL_10:
    v2 += 2;
    *i = v13;
  }
  v19 = Source;
  v18 = SizeInWords;
  *i = 0;
  wcscat_s(v20, v18, v19);
  wcscat_s(v20, SizeInWords, (const wchar_t *)v2 + 2);
  v14 = wcslen(v20);
  v15 = v21;
  v16 = (wchar_t *)sub_40B61C(*v21, 2 * (v14 + 1));
  *v15 = v16;
  return wcscpy_s(v16, v14 + 1, v20);
}

//----- (004098EC) --------------------------------------------------------
int __fastcall sub_4098EC(wchar_t *Source, const unsigned __int16 *a2, char a3)
{
  const wchar_t *v3; // edi
  wint_t *v4; // esi
  wint_t v5; // cx
  const wchar_t *v6; // eax
  int result; // eax
  int v8; // esi
  int v9; // edi
  wint_t v10; // cx
  unsigned int v11; // esi
  const wchar_t *v12; // eax
  unsigned int v13; // [esp+Ch] [ebp-10h]
  wchar_t *v14; // [esp+10h] [ebp-Ch]
  wint_t *v15; // [esp+14h] [ebp-8h]
  const unsigned __int16 *v16; // [esp+18h] [ebp-4h]
  char v17; // [esp+27h] [ebp+Bh]

  v3 = Source;
  v14 = Source;
  v16 = a2;
  v4 = Source;
  v5 = *Source;
  if ( v5 )
  {
    while ( iswspace(v5) )
    {
      v5 = *++v4;
      if ( !*v4 )
      {
        a2 = v16;
        goto LABEL_5;
      }
    }
    result = 1012 - wcslen(v16);
    v13 = result;
    if ( *v3 )
    {
      v17 = a3;
      do
      {
        wcsncpy_s(word_4386E0, 0x400u, v3, result);
        v8 = wcslen(word_4386E0);
        if ( v13 < wcslen(v3) )
        {
          v15 = word_4386E0;
          if ( word_4386E0[0] )
          {
            v9 = 0;
            v10 = word_4386E0[0];
            do
            {
              if ( iswspace(v10) )
                v8 = (v9 >> 1) + 1;
              v9 += 2;
              v10 = *++v15;
            }
            while ( *v15 );
            v3 = v14;
          }
        }
        v11 = v8;
        if ( v11 >= 1024 )
          __report_rangecheckfailure();
        word_4386E0[v11] = 0;
        v12 = L">>";
        if ( !v17 )
          v12 = L">";
        sub_40D1B2((wchar_t *)L"\techo %s %s %s\n", word_4386E0, v12, v16);
        v3 = (const wchar_t *)((char *)v3 + v11 * 2);
        v17 = 1;
        v14 = (wchar_t *)v3;
        result = v13;
      }
      while ( *v3 );
    }
  }
  else
  {
LABEL_5:
    v6 = L">>";
    if ( !a3 )
      v6 = L">";
    return sub_40D1B2((wchar_t *)L"\techo. %s %s\n", v6, a2);
  }
  return result;
}
// 4017E0: using guessed type wchar_t asc_4017E0[2];
// 4019F4: using guessed type wchar_t asc_4019F4[3];
// 4125FC: using guessed type void __noreturn __report_rangecheckfailure(void);
// 4386E0: using guessed type wchar_t word_4386E0[1024];

//----- (00409A5D) --------------------------------------------------------
wchar_t *__fastcall sub_409A5D(FILE *a1, int a2, const wchar_t **a3, char a4, _BYTE *a5)
{
  const wchar_t **v5; // edi
  const unsigned __int16 *v6; // esi
  wchar_t *v7; // eax
  char *v8; // ebx
  wchar_t *v9; // esi
  void *v10; // eax
  wchar_t *v11; // esi
  wchar_t *result; // eax
  wchar_t *v13; // ebx
  wchar_t *v14; // ecx
  const wchar_t *v15; // esi
  FILE *v16; // edi
  int v17; // eax
  void *Block; // [esp+10h] [ebp-14h] BYREF
  wchar_t *Context; // [esp+14h] [ebp-10h] BYREF
  const unsigned __int16 *v20; // [esp+18h] [ebp-Ch]
  FILE *Stream; // [esp+1Ch] [ebp-8h]
  char v22; // [esp+23h] [ebp-1h]
  char v23; // [esp+34h] [ebp+10h]

  v5 = a3;
  v6 = (const unsigned __int16 *)a2;
  v20 = (const unsigned __int16 *)a2;
  Stream = a1;
  v7 = wcsstr(*a3, L"<<");
  v22 = 0;
  if ( v7 && (v7 == *a3 || *(v7 - 1) == 10) )
  {
    v8 = (char *)(v7 + 2);
    v9 = wcschr(v7 + 2, 0xAu);
    if ( v9 )
      *v9 = 0;
    v10 = sub_40ECDB(v8);
    Block = v10;
    if ( v9 )
      *v9 = 10;
    Context = 0;
    v11 = wcstok_s((wchar_t *)v10, L", \t", &Context);
    if ( v11 )
    {
      do
      {
        if ( wcsicmp(v11, L"keep") )
        {
          if ( wcsicmp(v11, L"nokeep") )
          {
            if ( wcsicmp(v11, L"unicode") )
              sub_405B2C(dword_424724, 0x446u);
            else
              v22 = 1;
          }
          else
          {
            *a5 = 0;
          }
        }
        else
        {
          *a5 = 1;
        }
        v11 = wcstok_s(0, L", \t", &Context);
      }
      while ( v11 );
      v5 = a3;
    }
    free(Block);
    if ( v22 )
      fwrite(&dword_401A6C, 2u, 1u, Stream);
    v6 = v20;
  }
  result = (wchar_t *)wcsncmp(*v5, L"<<", 2u);
  if ( result )
  {
    v23 = 0;
    while ( 1 )
    {
      result = wcschr(*v5, 0xAu);
      v13 = result;
      if ( !result )
        break;
      if ( a4 )
      {
        v14 = (wchar_t *)*v5;
        *result = 0;
        sub_4098EC(v14, v6, v23);
        *v13 = 10;
      }
      v15 = *v5;
      if ( v22 )
      {
        fwrite(v15, v13 - v15, 2u, Stream);
        fwrite("\r", 4u, 1u, Stream);
      }
      else
      {
        if ( v15 < v13 )
        {
          v16 = Stream;
          do
          {
            v17 = WideCharToMultiByte(0, 0, v15, 1, (LPSTR)&Block, 4, 0, 0);
            if ( v17 )
              fwrite(&Block, v17, 1u, v16);
            ++v15;
          }
          while ( v15 < v13 );
          v5 = a3;
        }
        fwrite("\r\n", 2u, 1u, Stream);
      }
      v23 = 1;
      *v5 = v13 + 1;
      result = (wchar_t *)wcsncmp(v13 + 1, L"<<", 2u);
      v6 = v20;
      if ( !result )
        goto LABEL_36;
    }
  }
  else
  {
LABEL_36:
    *v5 += 2;
  }
  return result;
}
// 401A6C: using guessed type int dword_401A6C;
// 424724: using guessed type int dword_424724;

//----- (00409C81) --------------------------------------------------------
char __fastcall sub_409C81(wchar_t *Str, int a2, wchar_t *a3, char a4)
{
  const wchar_t **v5; // edi
  wchar_t *v6; // eax
  wchar_t *v7; // ebx
  __int16 *v9; // ebx
  __int16 *v10; // esi
  char *v11; // eax
  _WORD *v12; // esi
  FILE *v13; // eax
  unsigned int v14; // kr00_4
  wchar_t *i; // eax
  wchar_t *v16; // edx
  __int16 *v17; // ecx
  __int16 v18; // ax
  wchar_t *v19; // esi
  wchar_t *v20; // eax
  wchar_t *v21; // eax
  wchar_t *v22; // ecx
  __int16 v23; // ax
  _DWORD *v24; // esi
  int v25; // [esp+10h] [ebp-450h] BYREF
  int v26; // [esp+18h] [ebp-448h] BYREF
  wchar_t *v27; // [esp+1Ch] [ebp-444h]
  const wchar_t **v28; // [esp+20h] [ebp-440h]
  __int16 *v29; // [esp+24h] [ebp-43Ch] BYREF
  int v30; // [esp+28h] [ebp-438h]
  void *v31; // [esp+2Ch] [ebp-434h] BYREF
  size_t RequiredCount; // [esp+30h] [ebp-430h] BYREF
  void *Block; // [esp+34h] [ebp-42Ch]
  FILE *Stream; // [esp+38h] [ebp-428h]
  wchar_t *Stra; // [esp+3Ch] [ebp-424h] BYREF
  const wchar_t *v36; // [esp+40h] [ebp-420h] BYREF
  char v37; // [esp+47h] [ebp-419h] BYREF
  WCHAR TempFileName[260]; // [esp+48h] [ebp-418h] BYREF
  wchar_t Buffer; // [esp+250h] [ebp-210h] BYREF
  __int16 v40[261]; // [esp+252h] [ebp-20Eh] BYREF

  Stra = a3;
  v5 = (const wchar_t **)a2;
  v28 = (const wchar_t **)a2;
  v6 = wcschr(Str, 0xAu);
  v7 = v6;
  if ( v6 )
  {
    RequiredCount = (size_t)Str;
    *v6 = 0;
    v30 = 0;
    v36 = 0;
    sub_40F9D0(&v26, (__int16 **)&RequiredCount, 255, Stra, 0, (int)&v36);
    *v5 = v36;
    *v7 = 10;
    v9 = (__int16 *)(v7 + 1);
    if ( *v5 == Str )
      *v5 = (const wchar_t *)sub_40ECDB((char *)Str);
    v36 = *v5;
    v31 = 0;
    v29 = v9;
    sub_40F9D0(&v25, &v29, 255, Stra, 0, (int)&v31);
    v10 = (__int16 *)v31;
    v27 = (wchar_t *)v31;
    v31 = 0;
    Stra = v27;
    v11 = (char *)sub_4093B5((__int16 **)&v36);
    if ( v11 )
    {
      do
      {
        v37 = 0;
        v12 = sub_40ECDB(v11);
        Block = v12;
        if ( *v12 )
        {
          Stream = sub_411C33(v12, (wchar_t *)L"wb");
          if ( Stream )
          {
            for ( i = wcschr(*v5, 0x3Cu); ; i = wcschr(i + 1, 0x3Cu) )
            {
              v16 = i;
              if ( !i )
                break;
              if ( i[1] == 60 )
              {
                v17 = (__int16 *)(i + 2);
                v36 = i + 3;
                do
                  v18 = *v17++;
                while ( v18 != (_WORD)v30 );
                memmove(v16, v16 + 2, 2 * (((char *)v17 - (char *)v36) >> 1) + 2);
                v12 = Block;
                break;
              }
            }
          }
          else
          {
            sub_405B2C(dword_424724, 0x41Eu, v12);
          }
        }
        else
        {
          RequiredCount = 0;
          if ( wgetenv_s(&RequiredCount, &Buffer, 0x103u, L"TMP") || !RequiredCount )
            wcscpy_s(&Buffer, 0x103u, L".");
          Stream = 0;
          if ( GetTempFileNameW(&Buffer, L"nm", 0, TempFileName) )
          {
            wcscpy_s(&Buffer, 0x103u, TempFileName);
            v13 = wfsopen(&Buffer, L"wb", 32);
            Stream = v13;
          }
          else
          {
            v13 = Stream;
          }
          if ( !v13 )
            sub_405B2C(dword_424724, 0x41Eu, &Buffer);
          if ( wcschr(&Buffer, 0x20u) && !wcschr(&Buffer, 0x22u) )
          {
            v14 = wcslen(&Buffer);
            memmove(v40, &Buffer, 2 * v14);
            Buffer = 34;
            v40[v14] = 34;
            if ( 2 * v14 + 4 >= 0x206 )
              __report_rangecheckfailure();
            v12 = Block;
            v40[v14 + 1] = 0;
            v5 = v28;
          }
          sub_409808((void **)v5, &Buffer);
          free(v12);
          v12 = sub_40ECDB((char *)&Buffer);
          Block = v12;
        }
        v36 = *v5;
        sub_409A5D(Stream, (int)v12, (const wchar_t **)&Stra, a4, &v37);
        v19 = Stra;
        v20 = wcschr(Stra, 0xAu);
        if ( v20 )
        {
          v21 = v20 + 1;
        }
        else
        {
          v22 = v19;
          do
            v23 = *v22++;
          while ( v23 != (_WORD)v30 );
          v21 = &v19[v22 - (v19 + 1)];
        }
        Stra = v21;
        fclose(Stream);
        if ( !v37 )
        {
          v24 = sub_40EC89();
          v24[1] = sub_40ECDB((char *)Block);
          sub_40EDE0((_DWORD **)&dword_435474, v24);
        }
        free(Block);
        v11 = (char *)sub_4093B5((__int16 **)&v36);
      }
      while ( v11 );
      v10 = (__int16 *)v27;
    }
    if ( v10 != v9 )
      free(v10);
    return 1;
  }
  else
  {
    *v5 = (const wchar_t *)sub_40ECDB((char *)Str);
    return 0;
  }
}
// 4125FC: using guessed type void __noreturn __report_rangecheckfailure(void);
// 424724: using guessed type int dword_424724;
// 435474: using guessed type int dword_435474;
// 409C81: using guessed type const wchar_t *var_420;
// 409C81: using guessed type __int16 var_20E[261];

//----- (0040A0BF) --------------------------------------------------------
int sub_40A0BF()
{
  int v0; // ecx
  int result; // eax

  if ( fclose(Stream) == 0xFFFF )
    sub_405B2C(0, 0x424u, ArgList);
  free(ArgList);
  v0 = 3 * --dword_4353A4;
  Stream = (FILE *)dword_4353B8[v0];
  ArgList = (void *)dword_4353B4[v0];
  result = dword_4353B0[v0];
  dword_424724 = result;
  return result;
}
// 424724: using guessed type int dword_424724;
// 4353A4: using guessed type int dword_4353A4;
// 4353B0: using guessed type int dword_4353B0[];
// 4353B4: using guessed type int dword_4353B4[];
// 4353B8: using guessed type int dword_4353B8[];

//----- (0040A127) --------------------------------------------------------
wint_t __fastcall sub_40A127(char a1)
{
  wint_t result; // ax
  wint_t v3; // ax

LABEL_1:
  byte_414021 = 0;
  while ( 1 )
  {
    result = a1 ? getwc(Stream) : sub_4086F8();
    if ( result == 0xFFFF )
      return result;
    if ( result == 10 )
    {
      byte_414021 = 1;
      if ( a1 )
        v3 = getwc(Stream);
      else
        v3 = sub_4086F8();
      if ( v3 == 59 && byte_424F61 || v3 == 35 )
      {
        ++dword_424724;
        goto LABEL_1;
      }
      return ungetwc(v3, Stream);
    }
  }
}
// 414021: using guessed type char byte_414021;
// 424724: using guessed type int dword_424724;
// 424F61: using guessed type char byte_424F61;

//----- (0040A1AC) --------------------------------------------------------
unsigned __int8 __fastcall sub_40A1AC(wchar_t a1)
{
  wchar_t *v2; // ecx
  unsigned int v3; // edx
  int v4; // eax

  if ( a1 == 10 || a1 == 0xFFFF )
    sub_405B2C(dword_424724, 0x407u);
  Src = a1;
  if ( !fgetws(&word_424742, 1023, Stream) )
  {
    if ( feof(Stream) )
      sub_405B2C(dword_424724, 0x409u, L"EOF");
    sub_405B2C(dword_424724, 0x41Du);
  }
  v2 = &Src;
  v3 = 2 * wcslen(&Src) - 2;
  if ( *(wchar_t *)((char *)&Src + v3) == 10 )
  {
    if ( v3 >= 0x800 )
      __report_rangecheckfailure();
    *(wchar_t *)((char *)&Src + v3) = 0;
  }
  while ( 1 )
  {
    v4 = *v2;
    if ( v4 != 32 && v4 != 9 )
      break;
    ++v2;
  }
  return sub_40AFB3(v2);
}
// 4019DC: using guessed type wchar_t aEof[4];
// 4125FC: using guessed type void __noreturn __report_rangecheckfailure(void);
// 424724: using guessed type int dword_424724;

//----- (0040A290) --------------------------------------------------------
unsigned __int8 __fastcall sub_40A290(wint_t Character, _WORD *a2, int a3)
{
  char v4; // dl
  wint_t v5; // ax
  char v6; // bl
  unsigned __int8 result; // al
  __int16 v8; // ax
  wchar_t v9; // si

  v4 = byte_414021;
  while ( 1 )
  {
    switch ( Character )
    {
      case 0xAu:
        goto LABEL_15;
      case 0x3Au:
        byte_414021 = 0;
        Character = sub_4086F8();
        if ( Character == 58 )
        {
          *a2 = 58;
          result = 21;
          a2[1] = 0;
          return result;
        }
        v6 = 20;
LABEL_23:
        ungetwc(Character, Stream);
        return v6;
      case 0x3Bu:
        result = 19;
LABEL_44:
        byte_414021 = 0;
        return result;
      case 0x3Du:
        result = 22;
        goto LABEL_44;
    }
    if ( Character == 91 )
      break;
    if ( Character == 94 )
      goto LABEL_27;
    if ( Character != 0xFFFF )
      goto LABEL_28;
    if ( !feof(Stream) )
      sub_405B2C(dword_424724, 0x40Eu);
    if ( dword_4353A4 )
    {
      sub_40A0BF();
    }
    else
    {
      if ( dword_414024 < 0 )
        return 23;
      sub_405B2C(dword_424724, 0x3FCu);
    }
LABEL_15:
    ++dword_424724;
    byte_414021 = 1;
    v5 = sub_4086F8();
    Character = v5;
    if ( v5 == 59 && byte_424F61 || v5 == 35 )
    {
      sub_40A127(0);
      ++dword_424724;
      byte_414021 = 1;
      Character = sub_4086F8();
    }
    if ( Character == 32 || Character == 9 )
    {
      result = 18;
      goto LABEL_44;
    }
    v4 = 1;
    byte_414021 = 1;
    if ( Character != 0xFFFF )
    {
      v6 = 17;
      goto LABEL_23;
    }
  }
  if ( byte_424F61 && v4 )
    return 23;
LABEL_27:
  ungetwc(Character, Stream);
  --a2;
LABEL_28:
  sub_40AD10(a2 - 1, a3);
  if ( !byte_414021 || wcsicmp(&Src, L"include") )
  {
    byte_414021 = 0;
    return 16;
  }
  byte_414021 = 0;
  v8 = sub_40A552(0);
  v9 = v8;
  if ( v8 == 58 || v8 == 61 )
  {
    ungetwc(v8, Stream);
    return 16;
  }
  if ( byte_424F61 )
    sub_405B2C(dword_424724, 0x409u, a2);
  return sub_40A1AC(v9);
}
// 414021: using guessed type char byte_414021;
// 414024: using guessed type int dword_414024;
// 424724: using guessed type int dword_424724;
// 424F61: using guessed type char byte_424F61;
// 4353A4: using guessed type int dword_4353A4;

//----- (0040A4AD) --------------------------------------------------------
char __fastcall sub_40A4AD(int a1, char a2)
{
  wint_t v3; // ax
  __int16 v4; // cx
  wchar_t *v5; // edx

  if ( byte_424F62 )
  {
    ++dword_424724;
    byte_424F62 = 0;
    v3 = sub_4086F8();
    if ( v3 == 32 || v3 == 9 )
    {
      byte_414021 = 0;
      return 18;
    }
    else
    {
      v4 = -1;
      byte_414021 = 1;
      if ( v3 == 0xFFFF )
      {
        v5 = &Src;
        return sub_40A290(v4, v5, (int)&dword_424F40);
      }
      ungetwc(v3, Stream);
      return 17;
    }
  }
  else
  {
    if ( a2 != 24 && a2 != 25 )
    {
      v4 = sub_40A552(0);
      v5 = &word_424742;
      Src = v4;
      word_424742 = 0;
      return sub_40A290(v4, v5, (int)&dword_424F40);
    }
    sub_40A6DC(a2, a2, (int)&dword_424F40);
    return a2;
  }
}
// 414021: using guessed type char byte_414021;
// 424724: using guessed type int dword_424724;
// 424F40: using guessed type int dword_424F40;
// 424F62: using guessed type char byte_424F62;

//----- (0040A552) --------------------------------------------------------
__int16 __fastcall sub_40A552(char a1)
{
  __int16 v2; // si
  wint_t v3; // ax

  v2 = 94;
  do
  {
    if ( a1 )
      v3 = getwc(Stream);
    else
      v3 = sub_4086F8();
    if ( v3 != 32 && v3 != 9 )
    {
      if ( v3 != 94 )
        goto LABEL_14;
      if ( a1 )
        v3 = getwc(Stream);
      else
        v3 = sub_4086F8();
      if ( v3 != 32 && v3 != 9 )
      {
        ungetwc(v3, Stream);
        return v2;
      }
    }
    byte_414021 = 0;
LABEL_14:
    if ( v3 == 92 )
      v3 = sub_40A62B(0x5Cu, a1);
  }
  while ( v3 == 32 || v3 == 9 );
  v2 = v3;
  if ( v3 == 59 )
  {
    if ( !byte_414021 )
      return v2;
    if ( byte_424F61 )
      goto LABEL_22;
  }
  if ( v3 == 35 )
  {
LABEL_22:
    sub_40A127(a1);
    v2 = 10;
    byte_414021 = 1;
  }
  return v2;
}
// 414021: using guessed type char byte_414021;
// 424F61: using guessed type char byte_424F61;

//----- (0040A62B) --------------------------------------------------------
wint_t __fastcall sub_40A62B(wint_t a1, char a2)
{
  wint_t v3; // ax
  wint_t v4; // ax
  wint_t v5; // ax

  if ( a1 != 92 )
    return a1;
  while ( 1 )
  {
    v3 = a2 ? getwc(Stream) : sub_4086F8();
    if ( v3 != 10 )
      break;
    ++dword_424724;
    byte_414021 = 1;
    if ( a2 )
      v4 = getwc(Stream);
    else
      v4 = sub_4086F8();
    a1 = v4;
    if ( v4 == 59 && byte_424F61 || v4 == 35 )
    {
      sub_40A127(a2);
      ++dword_424724;
      if ( a2 )
        v5 = getwc(Stream);
      else
        v5 = sub_4086F8();
      a1 = v5;
    }
    if ( a1 != 92 )
      return a1;
  }
  ungetwc(v3, Stream);
  return 92;
}
// 414021: using guessed type char byte_414021;
// 424724: using guessed type int dword_424724;
// 424F61: using guessed type char byte_424F61;

//----- (0040A6DC) --------------------------------------------------------
const unsigned __int16 *__fastcall sub_40A6DC(char a1, int a2, int a3)
{
  wchar_t *v3; // edi
  char v5; // bl
  int v6; // esi
  unsigned __int8 v7; // bh
  wint_t v8; // ax
  wchar_t *v9; // eax
  unsigned int v10; // edi
  unsigned int v11; // esi
  char *v12; // eax
  unsigned __int8 v13; // dl
  wint_t v14; // ax
  int v15; // ecx
  char v16; // bl
  int v17; // esi
  unsigned __int8 v18; // bl
  wint_t v19; // ax
  int v20; // ecx
  int v21; // eax
  char *v22; // eax
  wchar_t *v23; // ecx
  unsigned int v24; // edi
  unsigned int v25; // esi
  wint_t v26; // ax
  char *v27; // ebx
  void *v28; // ecx
  const unsigned __int16 *result; // eax
  unsigned int v30; // edx
  const unsigned __int16 *v31; // [esp-4h] [ebp-30h]
  char *v32; // [esp+Ch] [ebp-20h]
  wchar_t *v33; // [esp+10h] [ebp-1Ch] BYREF
  unsigned int v34; // [esp+14h] [ebp-18h]
  wchar_t *Source; // [esp+18h] [ebp-14h]
  wchar_t *v36; // [esp+1Ch] [ebp-10h]
  int v37; // [esp+20h] [ebp-Ch]
  int v38; // [esp+24h] [ebp-8h]
  unsigned __int8 v39; // [esp+29h] [ebp-3h]
  char v40; // [esp+2Ah] [ebp-2h]
  bool v41; // [esp+2Bh] [ebp-1h]

  v32 = 0;
  v3 = &Src;
  v37 = 0;
  v40 = a1;
  v5 = 0;
  v34 = 0;
  v41 = 0;
  Source = &Src;
  v33 = &Src;
  v6 = (unsigned __int16)sub_4086F8();
  v38 = v6;
  if ( a1 != 24 )
  {
    if ( (_WORD)v6 == 32 || (_WORD)v6 == 9 )
      goto LABEL_10;
    if ( (_WORD)v6 != 94 )
    {
      v7 = 1;
      goto LABEL_12;
    }
    v8 = sub_4086F8();
    if ( v8 == 32 || v8 == 9 )
    {
LABEL_10:
      v7 = 2;
      v6 = (unsigned __int16)sub_40A552(0);
    }
    else
    {
      ungetwc(v8, Stream);
      v7 = 1;
      v6 = 94;
    }
    v38 = v6;
    goto LABEL_12;
  }
  v7 = 2;
LABEL_12:
  v36 = (wchar_t *)a3;
  while ( 1 )
  {
    if ( (_WORD)v6 == 34 )
    {
      v41 = !v41;
    }
    else
    {
      v41 = v5;
      if ( (_WORD)v6 == 94 )
      {
        if ( v5 || v40 != 25 )
        {
          v14 = sub_4086F8();
          ungetwc(v14, Stream);
          LOWORD(v6) = 94;
          v38 = 94;
          v41 = v5;
        }
        else
        {
          LOWORD(v6) = sub_4086F8();
          v38 = (unsigned __int16)v6;
          if ( (unsigned __int16)v6 > 0x29u )
          {
            v41 = 0;
            switch ( (unsigned __int16)v6 )
            {
              case '-':
              case '@':
                goto LABEL_33;
              case '\\':
                goto LABEL_41;
              case '^':
              case '{':
              case '}':
LABEL_33:
                *v3++ = 94;
                if ( v3 == v36 )
                {
                  if ( dword_42472C )
                  {
                    v10 = v34;
                    v11 = v34 + 1024;
                    if ( v34 + 1024 < v34 || (v12 = (char *)sub_40B61C(dword_42472C, 2 * v11), (v32 = v12) == 0) )
                    {
                      sub_405B2C(dword_424724, 0x419u);
                      v12 = v32;
                    }
                    dword_42472C = v12;
                    v3 = (wchar_t *)&v12[2 * v10];
                    v34 = v11;
                    v9 = (wchar_t *)&v12[2 * v11];
                  }
                  else
                  {
                    dword_42472C = sub_40B5D9(0x1000u);
                    wcsncpy_s((wchar_t *)dword_42472C, 0x800u, Source, 0x400u);
                    v34 = 2048;
                    v3 = (wchar_t *)((char *)dword_42472C + 2048);
                    v9 = (wchar_t *)((char *)dword_42472C + 4096);
                  }
                  v36 = v9;
                  a3 = (int)v9;
                  Source = (wchar_t *)dword_42472C;
                  v33 = (wchar_t *)dword_42472C;
                }
LABEL_41:
                v13 = 0;
                v41 = 0;
                goto LABEL_78;
            }
          }
          else
          {
            if ( (unsigned __int16)v6 == 41 )
              goto LABEL_33;
            v41 = 0;
            switch ( (unsigned __int16)v6 )
            {
              case 0xAu:
                goto LABEL_41;
              case 0x21u:
                goto LABEL_33;
              case 0x22u:
              case 0x23u:
                goto LABEL_41;
              case 0x24u:
              case 0x28u:
                goto LABEL_33;
            }
          }
        }
      }
    }
    if ( (unsigned __int16)v6 > 0x3Bu )
    {
      if ( (unsigned __int16)v6 > 0x44u )
      {
        if ( (unsigned __int16)v6 == 70 || (unsigned __int16)v6 == 82 )
        {
LABEL_77:
          v13 = 13;
          goto LABEL_78;
        }
        if ( (unsigned __int16)v6 != 92 )
        {
          if ( (unsigned __int16)v6 != 0xFFFF )
            goto LABEL_95;
LABEL_96:
          v13 = 6;
          goto LABEL_78;
        }
        v13 = 3;
      }
      else
      {
        if ( (unsigned __int16)v6 == 68 )
          goto LABEL_77;
        if ( (unsigned __int16)v6 != 60 )
        {
          if ( (unsigned __int16)v6 == 61 )
          {
            v13 = 2;
            goto LABEL_78;
          }
          if ( (unsigned __int16)v6 != 63 && (unsigned __int16)v6 != 64 )
          {
            if ( (unsigned __int16)v6 == 66 )
              goto LABEL_77;
            goto LABEL_95;
          }
        }
        v18 = 12;
        v13 = 12;
        if ( v40 == 24 && (_WORD)v6 == 60 )
        {
          v19 = sub_4086F8();
          if ( v19 == 60 )
          {
            v3 = sub_4094E3(v3, &v33, (wchar_t **)&a3);
            v38 = 10;
            v18 = 6;
            --dword_424724;
            v36 = (wchar_t *)a3;
            Source = v33;
          }
          else
          {
            ungetwc(v19, Stream);
          }
          v20 = 15 * v7;
          v21 = v18;
          goto LABEL_103;
        }
      }
    }
    else
    {
      if ( (unsigned __int16)v6 != 59 )
      {
        if ( (unsigned __int16)v6 > 0x28u )
        {
          switch ( (unsigned __int16)v6 )
          {
            case ')':
              v13 = 9;
              goto LABEL_78;
            case '*':
              v13 = 11;
              goto LABEL_78;
            case ',':
              v13 = 14;
              goto LABEL_78;
            case ':':
              v13 = 4;
              goto LABEL_78;
          }
          goto LABEL_95;
        }
        if ( (unsigned __int16)v6 == 40 )
        {
          v13 = 8;
          goto LABEL_78;
        }
        if ( (unsigned __int16)v6 == 9 )
          goto LABEL_56;
        if ( (unsigned __int16)v6 != 10 )
        {
          switch ( (unsigned __int16)v6 )
          {
            case ' ':
LABEL_56:
              v13 = 5;
              goto LABEL_78;
            case '#':
              if ( !v7 )
                goto LABEL_68;
              if ( v40 == 25 )
                goto LABEL_129;
              v7 = byte_4012C1[15 * v7];
              goto LABEL_104;
            case '$':
              v13 = 7;
              goto LABEL_78;
          }
LABEL_95:
          v13 = sub_403B50(v6) ? 0xA : 0;
          goto LABEL_78;
        }
        goto LABEL_96;
      }
      if ( !v7 && byte_424F61 )
      {
LABEL_68:
        v5 = 0;
        v41 = 0;
        sub_40A127(0);
        ++dword_424724;
        goto LABEL_127;
      }
      v13 = 0;
    }
LABEL_78:
    v15 = v37;
    if ( v37 > 0 )
      break;
LABEL_102:
    v20 = 15 * v7;
    v21 = v13;
LABEL_103:
    v7 = byte_4012C0[v20 + v21];
LABEL_104:
    v15 = v37;
LABEL_105:
    v16 = v7;
    v17 = v15;
    if ( v7 )
      goto LABEL_106;
    ++dword_424724;
    *(v3 - 1) = 32;
    v38 = (int)v3;
    byte_414021 = 1;
    v26 = sub_4086F8();
    byte_414021 = 0;
    if ( v26 == 32 || v26 == 9 )
    {
      v7 = 2;
      do
      {
        do
          v26 = sub_4086F8();
        while ( v26 == 32 );
      }
      while ( v26 == 9 );
      v3 = (wchar_t *)v38;
    }
    ungetwc(v26, Stream);
LABEL_126:
    v5 = v41;
LABEL_127:
    v6 = (unsigned __int16)sub_4086F8();
    v38 = v6;
  }
  if ( v13 != 14 )
  {
    if ( v13 == 9 )
    {
      v7 = byte_4012C9[15 * v7];
      if ( v7 != 1 )
        goto LABEL_105;
      v15 = --v37;
      goto LABEL_101;
    }
    goto LABEL_102;
  }
  v7 = byte_4012C6[15 * v7];
  if ( (v7 & 0x20) != 0 )
    goto LABEL_105;
  if ( !v7 || v7 == 64 )
  {
LABEL_101:
    v7 = 2;
    goto LABEL_105;
  }
  sub_405B2C(dword_424724, 0x40Eu);
  v15 = v37;
  v16 = v7;
  v17 = v37;
LABEL_106:
  if ( v7 == 13 )
  {
    v7 = 2;
    v37 = v15 + 1;
LABEL_111:
    v39 = v7;
LABEL_112:
    *v3++ = v38;
    if ( v3 == v36 )
    {
      if ( dword_42472C )
      {
        v24 = v34;
        v25 = v34 + 1024;
        if ( v34 + 1024 < v34 || (v22 = (char *)sub_40B61C(dword_42472C, 2 * v25), (v32 = v22) == 0) )
        {
          sub_405B2C(dword_424724, 0x419u);
          return sub_40AD10(v31, v30);
        }
        v3 = (wchar_t *)&v22[2 * v24];
        dword_42472C = v22;
        v34 = v25;
        v23 = (wchar_t *)&v22[2 * v25];
      }
      else
      {
        dword_42472C = sub_40B5D9(0x1000u);
        wcsncpy_s((wchar_t *)dword_42472C, 0x800u, Source, 0x400u);
        v22 = (char *)dword_42472C;
        v34 = 2048;
        v3 = (wchar_t *)((char *)dword_42472C + 2048);
        v23 = (wchar_t *)((char *)dword_42472C + 4096);
      }
      v7 = v39;
      v36 = v23;
      Source = (wchar_t *)v22;
      a3 = (int)v23;
      v33 = (wchar_t *)v22;
    }
    goto LABEL_126;
  }
  if ( v7 != 64 )
  {
    v37 = v17;
    v7 = v16;
    v39 = v16;
    if ( (v16 & 0x20) != 0 )
    {
      sub_405B2C(dword_424724, (v16 & 0xDF) + 1000, (unsigned __int16)v38);
      v37 = v17;
      goto LABEL_111;
    }
    goto LABEL_112;
  }
  LOWORD(v6) = v38;
LABEL_129:
  ungetwc(v6, Stream);
  v27 = (char *)Source;
  while ( v3 > (wchar_t *)v27 && iswspace(*(v3 - 1)) )
    --v3;
  v28 = dword_42472C;
  *v3 = 0;
  if ( v28 )
  {
    result = (const unsigned __int16 *)sub_40B61C(v28, 2 * (((char *)v3 - (_BYTE *)v28) >> 1) + 2);
    if ( !result )
      return result;
  }
  else
  {
    result = (const unsigned __int16 *)sub_40ECDB(v27);
  }
  dword_42472C = (void *)result;
  return result;
}
// 40AD0F: variable 'v31' is possibly undefined
// 40AD0F: variable 'v30' is possibly undefined
// 414021: using guessed type char byte_414021;
// 424724: using guessed type int dword_424724;
// 424F61: using guessed type char byte_424F61;

//----- (0040AD10) --------------------------------------------------------
const unsigned __int16 *__fastcall sub_40AD10(const unsigned __int16 *a1, unsigned int a2)
{
  char v2; // bh
  wchar_t *v3; // edi
  unsigned __int8 v4; // bl
  wint_t v5; // si
  wint_t v6; // ax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  unsigned __int8 v10; // dl
  int v11; // eax
  int v12; // eax
  int v13; // eax
  unsigned __int16 *v17; // [esp+18h] [ebp-8h]
  char v18; // [esp+1Fh] [ebp-1h]

  v2 = 0;
  v3 = (wchar_t *)(a1 + 1);
  v18 = 0;
  v17 = (unsigned __int16 *)(a1 + 1);
  switch ( *a1 )
  {
    case '"':
      v18 = 1;
      v4 = 16;
      break;
    case '$':
      v4 = 2;
      break;
    case '{':
      v4 = 8;
      break;
    default:
      v4 = 0;
      break;
  }
  while ( 1 )
  {
    v5 = sub_4086F8();
    if ( v5 == 94 )
    {
      v6 = sub_4086F8();
      v5 = v6;
      if ( v6 > 0x29u )
      {
        v11 = v6 - 92;
        if ( !v11 )
          goto LABEL_30;
        v12 = v11 - 2;
        if ( !v12 || (v13 = v12 - 29) == 0 || v13 == 2 )
        {
LABEL_29:
          *v3++ = 94;
          v17 = v3;
          goto LABEL_30;
        }
      }
      else
      {
        if ( v6 == 41 )
          goto LABEL_29;
        v7 = v6 - 10;
        if ( !v7 )
          goto LABEL_30;
        v8 = v7 - 25;
        if ( !v8 )
          goto LABEL_30;
        v9 = v8 - 1;
        if ( !v9 || v9 == 4 )
          goto LABEL_29;
      }
    }
    if ( v5 > 0x29u )
    {
      switch ( v5 )
      {
        case 0x3Au:
          v10 = 4;
          goto LABEL_57;
        case 0x3Bu:
          v10 = 3;
          goto LABEL_57;
        case 0x3Du:
          v10 = 2;
          goto LABEL_57;
        case 0x5Cu:
          v10 = 13;
          goto LABEL_57;
        case 0x7Bu:
          v10 = 11;
          goto LABEL_57;
        case 0x7Du:
          v10 = 12;
          goto LABEL_57;
        case 0xFFFFu:
LABEL_50:
          v10 = 6;
          goto LABEL_57;
      }
LABEL_44:
      if ( byte_424734 >= 0 )
      {
        v10 = sub_403B50(v5) ? 0xA : 0;
        goto LABEL_57;
      }
      if ( sub_403B50(v5) || v5 == 42 || v5 == 64 )
      {
        v10 = 10;
        goto LABEL_57;
      }
LABEL_30:
      v10 = 0;
      goto LABEL_57;
    }
    switch ( v5 )
    {
      case 0x29u:
        v10 = 9;
        break;
      case 9u:
        goto LABEL_35;
      case 0xAu:
        goto LABEL_50;
      case 0x20u:
LABEL_35:
        v10 = v18 != 0 ? 0 : 5;
        break;
      case 0x22u:
        v10 = 14;
        if ( v4 == 18 )
          v18 = 1;
        break;
      case 0x23u:
        v10 = 1;
        break;
      case 0x24u:
        v10 = 7;
        break;
      case 0x28u:
        v10 = 8;
        break;
      default:
        goto LABEL_44;
    }
LABEL_57:
    v4 = byte_4011A0[15 * v4 + v10];
    if ( v18 && v4 == 1 )
      v4 = 16;
    if ( v2 )
    {
      if ( v10 == 6 )
      {
        ++dword_424724;
        byte_414021 = 1;
        v5 = sub_4086F8();
        byte_414021 = 0;
        if ( v5 == 32 || v5 == 9 )
        {
          v4 = 64;
          do
          {
            do
              v5 = sub_4086F8();
            while ( v5 == 32 );
          }
          while ( v5 == 9 );
          v3 = v17;
        }
        else
        {
          v4 = v3 != &word_424742;
        }
      }
      else
      {
        *v3++ = 92;
        v17 = v3;
      }
    }
    v2 = 0;
    if ( (unsigned int)v3 >= a2 )
      sub_405B2C(dword_424724, 0x434u);
    if ( v4 == 64 )
      break;
    if ( (v4 & 0x20) != 0 )
      sub_405B2C(dword_424724, (v4 & 0xDF) + 1000, v5);
    if ( v4 == 15 )
    {
      v2 = 1;
    }
    else
    {
      *v3++ = v5;
      v17 = v3;
    }
  }
  ungetwc(v5, Stream);
  *v3 = 0;
  return sub_40CEA2(a1);
}
// 414021: using guessed type char byte_414021;
// 424724: using guessed type int dword_424724;
// 424734: using guessed type char byte_424734;

//----- (0040AFB3) --------------------------------------------------------
unsigned __int8 __thiscall sub_40AFB3(wchar_t *String)
{
  unsigned __int16 *v1; // edi
  wchar_t *v2; // eax
  unsigned __int16 *v3; // esi
  wchar_t v4; // cx
  __int16 *i; // ebx
  __int16 v6; // ax
  wchar_t *j; // ebx
  unsigned __int16 *v8; // ecx
  __int16 v9; // ax
  int v10; // ecx
  wchar_t *v11; // edi
  wchar_t *v12; // esi
  int v13; // eax
  char *v14; // ecx
  wchar_t *v15; // edi
  wchar_t *v16; // ebx
  int v17; // edx
  int v18; // eax
  wchar_t **v19; // ecx
  wchar_t *v20; // ecx
  wchar_t *v21; // eax
  wchar_t *v22; // ecx
  wchar_t *v23; // edx
  int v25; // ecx
  wchar_t *v26; // edx
  int v27; // ecx
  __int16 v28; // ax
  rsize_t v29; // esi
  wchar_t *v30; // esi
  int v31; // edx
  int v32; // esi
  const wchar_t **v33; // ebx
  int v34; // ecx
  bool v35; // zf
  wint_t v36; // ax
  rsize_t v38; // [esp-8h] [ebp-288h]
  wchar_t *v39; // [esp-4h] [ebp-284h]
  int v40; // [esp+10h] [ebp-270h] BYREF
  wchar_t *v41; // [esp+14h] [ebp-26Ch]
  int v42; // [esp+18h] [ebp-268h]
  wchar_t *Source; // [esp+1Ch] [ebp-264h]
  int v44; // [esp+20h] [ebp-260h]
  wchar_t *Destination; // [esp+24h] [ebp-25Ch]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+28h] [ebp-258h] BYREF

  v1 = String;
  if ( !*String || *String == 35 )
  {
    sub_405B2C(dword_424724, 0x407u);
    return (unsigned __int8)sub_40B45A(v39);
  }
  else
  {
    Destination = (wchar_t *)wcspbrk;
    v2 = wcspbrk(String, L"\t#");
    v41 = 0;
    v3 = v2;
    v44 = 32;
    if ( !v2 )
      goto LABEL_28;
    v4 = *v2;
    *v2 = 0;
    if ( v4 != 35 )
    {
      for ( i = (__int16 *)(v2 + 1); ; ++i )
      {
        v6 = *i;
        if ( !*i || v6 == 35 )
          break;
        if ( v6 != 32 && v6 != 9 )
          sub_405B2C(dword_424724, 0x409u, i);
      }
    }
    for ( j = 0; ; j = 0 )
    {
      if ( v3 > v1 )
      {
        do
        {
          v8 = v3 - 1;
          v9 = *(v3 - 1);
          if ( v9 != (_WORD)v44 && v9 != 9 )
            break;
          --v3;
        }
        while ( v8 > v1 );
        j = v41;
      }
      *v3 = 0;
      v10 = *v1;
      if ( v10 != 60 || *(v3 - 1) != 62 )
        break;
      *(v3 - 1) = 0;
      v11 = v1 + 1;
      v12 = sub_40F94D(v11);
      if ( v12 == v11 )
        v12 = (wchar_t *)sub_40ECDB((char *)v11);
      v13 = sub_40B534(L"INCLUDE");
      if ( v13 )
      {
        v14 = *(char **)(*(_DWORD *)(v13 + 8) + 4);
        if ( v14 )
        {
          v15 = (wchar_t *)sub_40ECDB(v14);
          j = sub_40F94D(v15);
          if ( j != v15 )
            free(v15);
        }
      }
      v1 = (unsigned __int16 *)sub_408404(j, v12, &FindFileData, (HANDLE *)&v40);
      if ( v1 )
      {
        if ( j )
          free(j);
        free(v12);
        goto LABEL_57;
      }
      sub_405B2C(dword_424724, 0x41Cu, v12);
LABEL_28:
      v3 = &v1[wcslen(v1)];
    }
    if ( (_WORD)v10 == 34 && *(v3 - 1) == 34 )
    {
      *(v3 - 1) = 0;
      ++v1;
    }
    v16 = sub_40F94D(v1);
    if ( v16 == v1 )
      v16 = (wchar_t *)sub_40ECDB((char *)v1);
    if ( !sub_408256(v16, &FindFileData, (HANDLE *)&v40) )
    {
      if ( ((int (__cdecl *)(wchar_t *, const wchar_t *))Destination)(v16, L"\\/:") )
      {
        sub_405B2C(dword_424724, 0x41Cu, v16);
      }
      else
      {
        v17 = dword_4353A4;
        v18 = dword_4353A4;
        v42 = dword_4353A4;
        if ( dword_4353A4 >= 0 )
        {
          v19 = (wchar_t **)&dword_4353B4[3 * dword_4353A4];
          v44 = (int)v19;
          while ( 1 )
          {
            if ( v18 == v17 )
              v20 = (wchar_t *)ArgList;
            else
              v20 = *v19;
            v21 = sub_40B45A(v20);
            Source = v21;
            if ( v21 )
            {
              v22 = v21;
              v23 = v21 + 1;
              while ( *v22++ )
                ;
              v25 = (char *)v22 - (char *)v23;
              v26 = v16;
              v27 = v25 >> 1;
              do
                v28 = *v26++;
              while ( v28 != (_WORD)v41 );
              v29 = v27 + v26 - (v16 + 1) + 2;
              Destination = (wchar_t *)sub_40B5D9((unsigned __int64)v29 >> 31 != 0 ? -1 : 2 * v29);
              wcscpy_s(Destination, v29, Source);
              wcscat_s(Destination, v29, L"\\");
              v38 = v29;
              v30 = Destination;
              wcscat_s(Destination, v38, v16);
              if ( sub_408256(v30, &FindFileData, (HANDLE *)&v40) )
              {
                v1 = v30;
                free(Source);
                break;
              }
              free(Source);
              free(v30);
            }
            v18 = v42 - 1;
            v19 = (wchar_t **)(v44 - 12);
            v42 = v18;
            v44 -= 12;
            if ( v18 < 0 )
              break;
            v17 = dword_4353A4;
          }
        }
        free(v16);
        if ( v42 < 0 )
          sub_405B2C(dword_424724, 0x41Cu, v1);
      }
    }
LABEL_57:
    v31 = dword_4353A4;
    v32 = 0;
    if ( dword_4353A4 > 0 )
    {
      v33 = (const wchar_t **)dword_4353B4;
      do
      {
        if ( !wcsicmp(v1, *v33) )
          sub_405B2C(dword_424724, 0x430u, v1);
        v31 = dword_4353A4;
        ++v32;
        v33 += 3;
      }
      while ( v32 < dword_4353A4 );
    }
    v34 = 3 * v31;
    v35 = byte_424F63 == 0;
    dword_4353A4 = v31 + 1;
    dword_424730 = 0;
    dword_4353B8[v34] = (int)Stream;
    dword_4353B0[v34] = dword_424724;
    dword_4353B4[v34] = (int)ArgList;
    if ( !v35 )
      sub_40D1B2((wchar_t *)L"Included: %s\n", v1);
    Stream = sub_411C33(v1, (wchar_t *)L"rt,ccs=unicode");
    if ( !Stream )
      sub_405B2C(dword_424724, 0x41Cu, v1);
    ArgList = sub_40ECDB((char *)v1);
    dword_424724 = 1;
    byte_414021 = 1;
    v36 = sub_4086F8();
    if ( v36 == 32 || v36 == 9 )
    {
      byte_414021 = 0;
      return 18;
    }
    else
    {
      byte_414021 = 1;
      ungetwc(v36, Stream);
      --dword_424724;
      return 17;
    }
  }
}
// 40B459: variable 'v39' is possibly undefined
// 401A90: using guessed type wchar_t asc_401A90[4];
// 414021: using guessed type char byte_414021;
// 424724: using guessed type int dword_424724;
// 424730: using guessed type int dword_424730;
// 424F63: using guessed type char byte_424F63;
// 4353A4: using guessed type int dword_4353A4;
// 4353B0: using guessed type int dword_4353B0[];
// 4353B4: using guessed type int dword_4353B4[];
// 4353B8: using guessed type int dword_4353B8[];

//----- (0040B45A) --------------------------------------------------------
wchar_t *__thiscall sub_40B45A(wchar_t *FullPath)
{
  size_t v1; // esi
  wchar_t *v2; // edi
  unsigned int v3; // ecx
  wchar_t v4; // dx
  wchar_t Dir[258]; // [esp+10h] [ebp-210h] BYREF
  wchar_t Drive[4]; // [esp+214h] [ebp-Ch] BYREF

  wsplitpath_s(FullPath, Drive, 3u, Dir, 0x100u, 0, 0, 0, 0);
  v1 = wcslen(Drive) + wcslen(Dir) + 1;
  v2 = (wchar_t *)sub_40B5D9((unsigned __int64)v1 >> 31 != 0 ? -1 : 2 * v1);
  wmakepath_s(v2, v1, Drive, Dir, 0, 0);
  v3 = wcslen(v2);
  v4 = v2[v3 - 1];
  if ( v4 == 92 || v4 == 47 )
    v2[v3 - 1] = 0;
  return v2;
}

//----- (0040B534) --------------------------------------------------------
int __thiscall sub_40B534(const unsigned __int16 *this)
{
  const unsigned __int16 *v2; // edx
  unsigned __int16 v3; // ax
  unsigned __int8 v4; // cl
  unsigned __int16 v5; // di
  int ***v6; // eax
  int **v7; // ecx
  int v8; // eax

  v2 = this;
  v3 = *this;
  if ( *this )
  {
    v4 = 0;
    LOBYTE(v5) = v3;
    do
    {
      ++v2;
      v4 += v5;
      v5 = *v2;
    }
    while ( *v2 );
    v6 = (int ***)((char *)&unk_434F90 + 4 * v4);
    v7 = *v6;
    dword_4386A8 = (int)v6;
    while ( v7 )
    {
      v8 = wcscmp((const unsigned __int16 *)v7[1], this);
      if ( v8 )
        v8 = v8 < 0 ? -1 : 1;
      if ( !v8 )
        return ((_BYTE)v7[3] & 0x10) == 0 ? (unsigned int)v7 : 0;
      v7 = (int **)*v7;
    }
  }
  else
  {
    dword_4386A8 = (int)&unk_434F90;
  }
  return 0;
}
// 4386A8: using guessed type int dword_4386A8;

//----- (0040B5C8) --------------------------------------------------------
int sub_40B5C8()
{
  int result; // eax

  result = 0;
  memset(&unk_434F90, 0, 0x400u);
  return result;
}

//----- (0040B5D9) --------------------------------------------------------
void *__thiscall sub_40B5D9(size_t Size)
{
  void *v1; // esi

  v1 = malloc(Size);
  if ( !v1 )
    sub_405B2C(dword_424730, 0x41Bu);
  return v1;
}
// 424730: using guessed type int dword_424730;

//----- (0040B5FE) --------------------------------------------------------
void *__thiscall sub_40B5FE(size_t Size)
{
  void *v2; // edi

  v2 = sub_40B5D9(Size);
  memset(v2, 0, Size);
  return v2;
}

//----- (0040B61C) --------------------------------------------------------
void *__fastcall sub_40B61C(void *Block, size_t Size)
{
  void *v2; // esi

  if ( !Block )
    return sub_40B5D9(Size);
  v2 = realloc(Block, Size);
  if ( !v2 )
    sub_405B2C(dword_424730, 0x41Bu);
  return v2;
}
// 424730: using guessed type int dword_424730;

//----- (0040B652) --------------------------------------------------------
int __fastcall sub_40B652(wchar_t *Source, wchar_t *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // esi
  DWORD EnvironmentVariableW; // eax
  HMODULE ModuleHandleW; // eax
  BOOL (__stdcall *SetThreadPreferredUILanguages)(DWORD, PCZZWSTR, PULONG); // esi
  HMODULE v12; // eax
  BOOL (__stdcall *GetThreadPreferredUILanguages)(DWORD, PULONG, PZZWSTR, PULONG); // edi
  SIZE_T v14; // esi
  HANDLE ProcessHeap; // eax
  WCHAR *v16; // eax
  wchar_t **v17; // ebx
  int result; // eax
  wchar_t **v19; // esi
  int v20; // edi
  HANDLE v21; // eax
  LANGID UserDefaultUILanguage; // ax
  int v23; // ebx
  HANDLE FirstFileW; // edi
  unsigned int v25; // kr04_4
  int v26; // eax
  int v27; // eax
  HMODULE Library; // ecx
  int v29; // [esp+10h] [ebp-6D0h] BYREF
  char ArgList[4]; // [esp+14h] [ebp-6CCh] BYREF
  int v31; // [esp+18h] [ebp-6C8h] BYREF
  wchar_t *v32; // [esp+1Ch] [ebp-6C4h] BYREF
  int v33; // [esp+20h] [ebp-6C0h] BYREF
  wchar_t *Sourcea; // [esp+24h] [ebp-6BCh] BYREF
  DWORD dwFlags; // [esp+28h] [ebp-6B8h] BYREF
  HMODULE *v36; // [esp+2Ch] [ebp-6B4h] BYREF
  __int16 *v37; // [esp+30h] [ebp-6B0h] BYREF
  rsize_t SizeInWords; // [esp+34h] [ebp-6ACh] BYREF
  char v39[4]; // [esp+38h] [ebp-6A8h] BYREF
  int v40[7]; // [esp+3Ch] [ebp-6A4h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+58h] [ebp-688h] BYREF
  __int16 v42[4]; // [esp+2A8h] [ebp-438h]
  wchar_t *Buffer[3]; // [esp+2B0h] [ebp-430h] BYREF
  wchar_t String[6]; // [esp+2BCh] [ebp-424h] BYREF
  wchar_t FileName[260]; // [esp+2C8h] [ebp-418h] BYREF
  wchar_t Destination[262]; // [esp+4D0h] [ebp-210h] BYREF

  v8 = 0;
  Sourcea = a2;
  v37 = &word_438EE8;
  SizeInWords = 0;
  v32 = 0;
  v36 = &hModule;
  dwFlags = 96;
  if ( !Source || !*Source || !a2 || !*a2 )
    return -2147024809;
  hModule = 0;
  if ( wcsncpy_s(Destination, 0x104u, Source, 0xFFFFFFFF)
    || FileName[wcslen(Destination) + 259] != 92 && wcsncat_s(Destination, 0x104u, L"\\", 0xFFFFFFFF) )
  {
    return -2147467259;
  }
  v29 = -2147024894;
  v40[0] = (int)Destination;
  v40[1] = (int)&Sourcea;
  v40[2] = (int)&dwFlags;
  v40[3] = (int)&v36;
  v40[4] = (int)&v37;
  v40[5] = (int)&v32;
  v40[6] = (int)&SizeInWords;
  memset(Buffer, 0, sizeof(Buffer));
  EnvironmentVariableW = GetEnvironmentVariableW(L"VSLANG", (LPWSTR)Buffer, 6u);
  if ( EnvironmentVariableW )
  {
    if ( EnvironmentVariableW < 6 )
    {
      sub_40BC3E((int)v40, Buffer, 10, (wchar_t ***)&v29);
      if ( !v29 )
        return 0;
    }
  }
  if ( Ptr )
  {
    SetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PCZZWSTR, PULONG))DecodePointer(Ptr);
  }
  else
  {
    ModuleHandleW = GetModuleHandleW(L"kernel32.dll");
    if ( !ModuleHandleW )
    {
LABEL_35:
      UserDefaultUILanguage = GetUserDefaultUILanguage();
      if ( (UserDefaultUILanguage & 0x3FF) == 1 || (UserDefaultUILanguage & 0x3FF) == 13 )
        UserDefaultUILanguage = 1033;
      v42[0] = UserDefaultUILanguage;
      v42[2] = 1033;
      v42[1] = UserDefaultUILanguage & 0x3FF | 0x400;
      while ( 1 )
      {
        itow_s((unsigned __int16)v42[v8], String, 6u, 10);
        sub_40BC3E((int)v40, (wchar_t **)String, 10, (wchar_t ***)&v29);
        if ( !v29 )
          return 0;
        if ( (unsigned int)++v8 >= 3 )
          goto LABEL_41;
      }
    }
    SetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PCZZWSTR, PULONG))GetProcAddress(
                                                                                   ModuleHandleW,
                                                                                   "SetThreadPreferredUILanguages");
    Ptr = EncodePointer(SetThreadPreferredUILanguages);
  }
  if ( !SetThreadPreferredUILanguages )
  {
    v8 = 0;
    goto LABEL_35;
  }
  if ( !GetEnvironmentVariableW(L"VS_UNICODE_OUTPUT", 0, 0) && !SetThreadPreferredUILanguages(256, 0, 0) )
    return -2147467259;
  v31 = 0;
  v33 = 0;
  if ( dword_4386C0 )
  {
    GetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PULONG, PZZWSTR, PULONG))DecodePointer(dword_4386C0);
  }
  else
  {
    v12 = GetModuleHandleW(L"kernel32.dll");
    if ( !v12 )
      goto LABEL_41;
    GetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PULONG, PZZWSTR, PULONG))GetProcAddress(
                                                                                          v12,
                                                                                          "GetThreadPreferredUILanguages");
    dword_4386C0 = EncodePointer(GetThreadPreferredUILanguages);
  }
  if ( GetThreadPreferredUILanguages )
  {
    if ( GetThreadPreferredUILanguages(52, (PULONG)&v33, 0, (PULONG)&v31) )
    {
      v14 = 2 * v31;
      ProcessHeap = GetProcessHeap();
      v16 = (WCHAR *)HeapAlloc(ProcessHeap, 0, v14);
      v17 = (wchar_t **)v16;
      if ( !v16 )
        return -2147024882;
      if ( GetThreadPreferredUILanguages(52, (PULONG)&v33, v16, (PULONG)&v31) )
      {
        v19 = v17;
        if ( *(_WORD *)v17 )
        {
          do
          {
            sub_40BC3E((int)v40, v19, 16, (wchar_t ***)&v29);
            v20 = v29;
            if ( !v29 )
              break;
            v19 = (wchar_t **)((char *)v19 + 10);
          }
          while ( *(_WORD *)v19 );
        }
        else
        {
          v20 = v29;
        }
        v21 = GetProcessHeap();
        HeapFree(v21, 0, v17);
        if ( !v20 )
          return 0;
        goto LABEL_41;
      }
    }
    return -2147467259;
  }
LABEL_41:
  sub_40BC3E((int)v40, (wchar_t **)L"1033", 10, (wchar_t ***)&v29);
  v23 = v29;
  if ( !v29 )
    return 0;
  if ( wcsncpy_s(FileName, 0x104u, Destination, 0xFFFFFFFF) || wcsncat_s(FileName, 0x104u, L"*", 0xFFFFFFFF) )
    return -2147024893;
  FirstFileW = FindFirstFileW(FileName, &FindFileData);
  if ( FirstFileW == (HANDLE)-1 )
  {
    result = GetLastError();
    if ( result > 0 )
      return (unsigned __int16)result | 0x80070000;
  }
  else
  {
    v25 = wcslen(Destination);
    while ( FindNextFileW(FirstFileW, &FindFileData) )
    {
      if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
      {
        v26 = wcscmp(FindFileData.cFileName, L".");
        if ( v26 )
          v26 = v26 < 0 ? -1 : 1;
        if ( v26 )
        {
          v27 = wcscmp(FindFileData.cFileName, L"..");
          if ( v27 )
            v27 = v27 < 0 ? -1 : 1;
          if ( v27 && sub_40D01F(FindFileData.cFileName, (wchar_t *)L"%hu%c", ArgList, v39, 1) != -1 )
          {
            if ( 2 * v25 >= 0x208 )
              __report_rangecheckfailure();
            FileName[v25] = 0;
            if ( !wcsncat_s(FileName, 0x104u, FindFileData.cFileName, 0xFFFFFFFF)
              && !wcsncat_s(FileName, 0x104u, L"\\", 0xFFFFFFFF)
              && !wcsncat_s(FileName, 0x104u, Sourcea, 0xFFFFFFFF) )
            {
              Library = LoadLibraryExW(FileName, 0, dwFlags);
              if ( Library )
              {
                *v36 = Library;
                if ( v37 )
                  *v37 = *(_WORD *)ArgList;
                if ( v32 )
                  wcscpy_s(v32, SizeInWords, FileName);
                v23 = 0;
                break;
              }
            }
          }
        }
      }
    }
    FindClose(FirstFileW);
    return v23;
  }
  return result;
}
// 401B58: using guessed type wchar_t asc_401B58[3];
// 4125FC: using guessed type void __noreturn __report_rangecheckfailure(void);
// 438EE8: using guessed type __int16 word_438EE8;
// 40B652: using guessed type char var_6A8[4];

//----- (0040BC3E) --------------------------------------------------------
wchar_t **__thiscall sub_40BC3E(int this, wchar_t **String, int Radix, wchar_t ***a4)
{
  wchar_t **result; // eax
  _WORD *v6; // eax
  __int16 v7; // [esp+Ch] [ebp-220h]
  wchar_t *EndPtr; // [esp+10h] [ebp-21Ch] BYREF
  wchar_t Destination[260]; // [esp+14h] [ebp-218h] BYREF
  wchar_t Buffer[6]; // [esp+21Ch] [ebp-10h] BYREF

  result = String;
  if ( *(_WORD *)String )
  {
    result = (wchar_t **)wcstoul((const wchar_t *)String, &EndPtr, Radix);
    v7 = (__int16)result;
    if ( !*EndPtr )
    {
      itow_s((unsigned __int16)result, Buffer, 6u, 10);
      result = (wchar_t **)wcsncpy_s(Destination, 0x104u, *(const wchar_t **)this, 0xFFFFFFFF);
      if ( !result )
      {
        result = (wchar_t **)wcsncat_s(Destination, 0x104u, Buffer, 0xFFFFFFFF);
        if ( !result )
        {
          result = (wchar_t **)wcsncat_s(Destination, 0x104u, L"\\", 0xFFFFFFFF);
          if ( !result )
          {
            result = (wchar_t **)wcsncat_s(Destination, 0x104u, **(const wchar_t ***)(this + 4), 0xFFFFFFFF);
            if ( !result )
            {
              result = (wchar_t **)LoadLibraryExW(Destination, 0, **(_DWORD **)(this + 8));
              if ( result )
              {
                ***(_DWORD ***)(this + 12) = result;
                v6 = **(_WORD ***)(this + 16);
                if ( v6 )
                  *v6 = v7;
                result = *(wchar_t ***)(this + 20);
                if ( *result )
                  result = (wchar_t **)wcscpy_s(*result, **(_DWORD **)(this + 24), Destination);
                *a4 = 0;
              }
              else if ( *a4 == (wchar_t **)-2147024894 )
              {
                result = (wchar_t **)GetLastError();
                if ( (int)result > 0 )
                  result = (wchar_t **)((unsigned __int16)result | 0x80070000);
                *a4 = result;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (0040BDA9) --------------------------------------------------------
void __thiscall sub_40BDA9(void *this)
{
  dword_414068 = (int)this;
}
// 414068: using guessed type int dword_414068;

//----- (0040BDB0) --------------------------------------------------------
BOOL __fastcall sub_40BDB0(const void **a1, void *a2, void *a3)
{
  int v5; // ecx

  if ( !byte_424F60 )
    sub_405CA2();
  sub_40D1B2((wchar_t *)L"\nNMAKE : fatal error U1038: Internal error\n");
  sub_40D194();
  qmemcpy(a2, *a1, 0x50u);
  if ( a3 )
    qmemcpy(a3, a1[1], 0x2CCu);
  v5 = 0;
  if ( *(_DWORD *)*a1 != -2147483645 )
    return dword_414068 == 0;
  return v5;
}
// 414068: using guessed type int dword_414068;
// 424F60: using guessed type char byte_424F60;

//----- (0040BE1B) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl main(int argc, const char **argv, const char **envp)
{
  const char **v3; // edi
  int v4; // esi
  int v5; // ebx
  const char *v6; // ecx
  int v7; // eax
  const char **v8; // edi
  int v9; // ecx
  const void *v10; // eax
  wchar_t *v11; // esi
  wchar_t *v12; // ebx
  rsize_t v14; // ebx
  wchar_t *v15; // edi
  int v16; // esi
  int v18; // [esp-10h] [ebp-584h]
  int v19; // [esp-10h] [ebp-584h]
  int v20[179]; // [esp+10h] [ebp-564h] BYREF
  int v21; // [esp+2F8h] [ebp-27Ch]
  const char **v22; // [esp+2FCh] [ebp-278h]
  char ArgList[80]; // [esp+300h] [ebp-274h] BYREF
  CPPEH_RECORD ms_exc; // [esp+55Ch] [ebp-18h]

  v3 = argv;
  v22 = argv;
  SetErrorMode(1u);
  memset(ArgList, 0, sizeof(ArgList));
  memset(v20, 0, sizeof(v20));
  ms_exc.registration.TryLevel = 0;
  setlocale(2, ".ACP");
  sub_40D088();
  set_invalid_parameter_handler(Handler);
  v4 = 1;
  v5 = argc;
  while ( 1 )
  {
    v21 = v4;
    if ( v4 >= v5 )
    {
      if ( byte_43547B )
        MEMORY[0] = 0;
      sub_40B5C8();
      if ( !dword_424F68 )
      {
        v11 = *_p__wpgmptr();
        if ( sub_403B75(v11, 0x20u) )
        {
          v12 = v11;
          while ( *v12++ )
            ;
          v14 = v12 - (v11 + 1) + 3;
          v15 = (wchar_t *)sub_403B48((void *)((unsigned __int64)v14 >> 31 != 0 ? -1 : 2 * v14));
          wcscpy_s(v15, v14, Source);
          wcscat_s(v15, v14, v11);
          wcscat_s(v15, v14, Source);
          v11 = v15;
          v5 = argc;
          v3 = v22;
        }
        dword_424F68 = (wchar_t *)sub_40ECDB((char *)v11);
      }
      signal(2, (_crt_signal_t)Function);
      signal(15, (_crt_signal_t)Function);
      v16 = sub_40C388(v5, (int)v3, v19);
      sub_40CE64();
      if ( !byte_414020 )
        v16 = 1;
      exit(v16);
    }
    v6 = v3[v4];
    v7 = *(unsigned __int16 *)v6;
    if ( v7 == 45 || v7 == 47 )
    {
      v8 = &v3[v4];
      if ( !wcsicmp((const wchar_t *)v6 + 1, L"errorreport:none") )
      {
        v9 = 0;
        goto LABEL_7;
      }
      if ( !wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:prompt") )
      {
        v9 = 1;
        goto LABEL_7;
      }
      if ( !wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:queue") )
      {
        v18 = 2;
        goto LABEL_14;
      }
      if ( !wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:send") )
      {
        v18 = 3;
LABEL_14:
        v9 = v18;
LABEL_7:
        sub_40BDA9((void *)v9);
        memmove(v8, v8 + 1, 4 * (v5 - v4) - 4);
        argc = --v5;
        v21 = --v4;
LABEL_8:
        v3 = v22;
        goto LABEL_9;
      }
      if ( wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:test") )
      {
        if ( wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:internal") )
          goto LABEL_8;
        byte_43547A = 1;
        v3 = v22;
        memmove(&v22[v4], &v22[v4 + 1], 4 * (v5 - v4) - 4);
      }
      else
      {
        byte_43547B = 1;
        v10 = v8 + 1;
        v3 = v22;
        memmove(&v22[v4], v10, 4 * (v5 - v4) - 4);
      }
      argc = --v5;
      v21 = --v4;
    }
LABEL_9:
    ++v4;
  }
}
// 40C224: positive sp value C has been found
// 40C09B: variable 'v19' is possibly undefined
// 414020: using guessed type char byte_414020;
// 43547A: using guessed type char byte_43547A;
// 43547B: using guessed type char byte_43547B;

//----- (0040C226) --------------------------------------------------------
char *sub_40C226()
{
  wchar_t *v0; // esi
  wchar_t *v1; // eax
  int v2; // edi
  wchar_t *v3; // esi
  wchar_t *v4; // eax
  wchar_t *v5; // esi
  wchar_t *v6; // eax
  wchar_t *v7; // esi
  wchar_t *v8; // eax
  wchar_t *v9; // esi
  wchar_t *v10; // eax
  wchar_t *v11; // esi
  wchar_t *v12; // eax
  wchar_t *v13; // esi
  wchar_t *v14; // eax
  char *result; // eax
  int v16; // esi
  wchar_t *v17; // eax
  const wchar_t **v18; // esi
  const wchar_t **i; // esi

  v0 = (wchar_t *)sub_40ECDB((char *)L"CC");
  v1 = (wchar_t *)sub_40ECDB((char *)L"cl");
  v2 = 0;
  sub_40367D(v0, v1, 0);
  v3 = (wchar_t *)sub_40ECDB((char *)L"CXX");
  v4 = (wchar_t *)sub_40ECDB((char *)L"cl");
  sub_40367D(v3, v4, 0);
  v5 = (wchar_t *)sub_40ECDB((char *)L"CPP");
  v6 = (wchar_t *)sub_40ECDB((char *)L"cl");
  sub_40367D(v5, v6, 0);
  v7 = (wchar_t *)sub_40ECDB((char *)L"AS");
  v8 = (wchar_t *)sub_40ECDB((char *)L"ml");
  sub_40367D(v7, v8, 0);
  v9 = (wchar_t *)sub_40ECDB((char *)L"RC");
  v10 = (wchar_t *)sub_40ECDB((char *)L"rc");
  sub_40367D(v9, v10, 0);
  v11 = (wchar_t *)sub_40ECDB((char *)L"_NMAKE_VER");
  v12 = (wchar_t *)sub_40ECDB((char *)L"14.32.31333.0");
  sub_40367D(v11, v12, 2);
  v13 = (wchar_t *)sub_40ECDB((char *)&off_402400);
  v14 = (wchar_t *)sub_40ECDB((char *)dword_424F68);
  sub_40367D(v13, v14, 76);
  result = (char *)L".SUFFIXES";
  if ( L".SUFFIXES" )
  {
    v16 = 0;
    do
    {
      v17 = (wchar_t *)sub_40ECDB(result);
      v18 = (const wchar_t **)off_401390[v16];
      Block = v17;
      wcscpy_s(&Src, 0x400u, *v18);
      sub_402EEC();
      for ( i = v18 + 1; *i; ++i )
      {
        wcscpy_s(&Src, 0x400u, *i);
        sub_402D01();
      }
      if ( !v2 )
        sub_4032FC();
      sub_403416();
      v16 = ++v2;
      result = (char *)*((_DWORD *)&off_401460 + v2);
    }
    while ( result );
  }
  return result;
}
// 401390: using guessed type wchar_t **off_401390[12];
// 4017A8: using guessed type wchar_t a1432313330[14];
// 401B6C: using guessed type wchar_t aSuffixes_0[10];
// 4023A8: using guessed type wchar_t aCc[3];
// 4023B0: using guessed type wchar_t aCl[3];
// 4023B8: using guessed type wchar_t aCxx[4];
// 4023C0: using guessed type wchar_t aCpp[4];
// 4023C8: using guessed type wchar_t aAs[3];
// 4023D0: using guessed type wchar_t aMl[3];
// 4023D8: using guessed type wchar_t aRc[3];
// 4023E0: using guessed type wchar_t aRc_0[3];
// 4023E8: using guessed type wchar_t aNmakeVer[11];
// 402400: using guessed type void *off_402400;

//----- (0040C388) --------------------------------------------------------
int __fastcall sub_40C388(int a1, int a2, int a3)
{
  wchar_t *v3; // esi
  wchar_t *v4; // ebx
  wchar_t *v5; // edi
  wchar_t *v6; // esi
  wchar_t *v7; // eax
  int v8; // ecx
  void *v9; // ecx
  const wchar_t *v10; // eax
  int v11; // esi
  size_t RequiredCount; // [esp+18h] [ebp-8h] BYREF
  wchar_t *Buffer; // [esp+1Ch] [ebp-4h] BYREF

  Buffer = 0;
  v3 = (wchar_t *)sub_40ECDB((char *)&off_40240C);
  v4 = wgetcwd(0, 0);
  if ( !v4 )
    sub_405B2C(0, 0x41Bu);
  sub_40367D(v3, v4, 66);
  wdupenv_s(&Buffer, 0, aMa);
  v5 = Buffer;
  if ( Buffer )
    wcsncpy_s(&aMakeflags[10], wcslen(aMakeflags) - 9, Buffer, 0xFFFFFFFF);
  byte_41450D = 1;
  v6 = (wchar_t *)sub_40ECDB((char *)&aMakeflags[10]);
  v7 = (wchar_t *)sub_40ECDB((char *)aMa);
  sub_40367D(v7, v6, 6);
  for ( ; v5; ++v5 )
  {
    if ( !*v5 )
      break;
    sub_40CB79(*v5, 1);
  }
  free(Buffer);
  Buffer = 0;
  if ( !wgetenv_s(&RequiredCount, 0, 0, L"NTMAKEENV") && RequiredCount )
    byte_435479 = 1;
  sub_40C7A4(a1 - 1, a2 + 4);
  if ( !byte_424F60 )
    sub_405CA2();
  if ( (byte_41450C & 2) == 0 )
  {
    sub_40C226();
    ArgList = (void *)L"tools.ini";
    if ( sub_409200(v8) )
    {
      ++dword_424724;
      byte_424F61 = 1;
      sub_40D23D(v9);
      if ( fclose(Stream) == -1 )
        sub_405B2C(0, 0x424u, ArgList);
    }
  }
  v10 = (const wchar_t *)sub_40ECDB((char *)&aMakeflags[10]);
  if ( wputenv_s(aMa, v10) )
    sub_405B2C(0, 0x41Fu);
  if ( !dword_435470 )
    sub_40CAA9();
  sub_40C6D8();
  sub_40C58E();
  dword_424730 = 0;
  sub_40E8BD();
  if ( (byte_41450C & 1) != 0 )
  {
    sub_40D740();
    sub_40D7B1();
    sub_40D851();
  }
  if ( dword_434F7C )
    free(dword_434F7C);
  v11 = sub_403D9C();
  wchdir(v4);
  return v11;
}
// 40C4C5: variable 'v8' is possibly undefined
// 40C4DB: variable 'v9' is possibly undefined
// 40240C: using guessed type void *off_40240C;
// 41402C: using guessed type wchar_t aMakeflags[29];
// 41450C: using guessed type char byte_41450C;
// 41450D: using guessed type char byte_41450D;
// 424724: using guessed type int dword_424724;
// 424730: using guessed type int dword_424730;
// 424F60: using guessed type char byte_424F60;
// 424F61: using guessed type char byte_424F61;
// 435470: using guessed type int dword_435470;
// 435479: using guessed type char byte_435479;

//----- (0040C58E) --------------------------------------------------------
int sub_40C58E()
{
  _DWORD *v0; // esi
  int v1; // ecx
  FILE *v2; // eax
  void *v3; // ecx
  FILE *v4; // eax
  int v5; // eax
  void *osfhandle; // eax
  void *v8; // [esp-4h] [ebp-14h]
  void *v9; // [esp-4h] [ebp-14h]
  LARGE_INTEGER FileSize; // [esp+8h] [ebp-8h] BYREF

  v0 = (_DWORD *)dword_435470;
  if ( dword_435470 )
  {
    do
    {
      v1 = v0[1];
      if ( *(_WORD *)v1 != 45 || *(_WORD *)(v1 + 2) )
      {
        ArgList = sub_40ECDB((char *)v1);
        v4 = wfsopen((const wchar_t *)ArgList, L"rt,ccs=unicode", 32);
        Stream = v4;
        if ( !v4 )
        {
          sub_405B2C(0, 0x41Cu, ArgList);
          v4 = Stream;
        }
        FileSize.QuadPart = 0i64;
        v5 = fileno(v4);
        osfhandle = (void *)get_osfhandle(v5);
        v3 = v9;
        if ( osfhandle != (void *)-1 )
        {
          if ( GetFileSizeEx(osfhandle, &FileSize) )
          {
            v3 = (void *)(FileSize.LowPart + 1);
            if ( (unsigned __int64)(FileSize.QuadPart - 1) <= 0x7FFFFFFD )
              setvbuf(Stream, 0, 0, FileSize.LowPart + 1);
          }
        }
      }
      else
      {
        ArgList = sub_40ECDB((char *)L"STDIN");
        v2 = _acrt_iob_func(0);
        v3 = v8;
        Stream = v2;
      }
      dword_424724 = 0;
      byte_424F61 = 0;
      sub_40D23D(v3);
      if ( Stream != _acrt_iob_func(0) && fclose(Stream) == -1 )
        sub_405B2C(0, 0x424u, ArgList);
      v0 = (_DWORD *)*v0;
    }
    while ( v0 );
    v0 = (_DWORD *)dword_435470;
  }
  return sub_405322(v0);
}
// 40C5CD: variable 'v8' is possibly undefined
// 40C62C: variable 'v9' is possibly undefined
// 40C683: variable 'v3' is possibly undefined
// 402470: using guessed type wchar_t aStdin[6];
// 424724: using guessed type int dword_424724;
// 424F61: using guessed type char byte_424F61;
// 435470: using guessed type int dword_435470;

//----- (0040C6D8) --------------------------------------------------------
char *sub_40C6D8()
{
  char ***v0; // eax
  char **v1; // esi
  char *result; // eax
  wchar_t *v3; // edi
  wchar_t *v4; // eax
  wchar_t *v5; // ebx
  _WORD *v6; // edx
  wchar_t *v8; // eax
  wchar_t *Block; // [esp+4h] [ebp-8h]

  v0 = (char ***)_p__wenviron();
  v1 = *v0;
  result = **v0;
  if ( result )
  {
    do
    {
      v3 = wcschr((const wchar_t *)result, 0x3Du);
      if ( v3 )
      {
        if ( wcsnicmp((const wchar_t *)*v1, aMa, 8u) )
        {
          *v3 = 0;
          if ( *(_WORD *)*v1 )
          {
            v4 = (wchar_t *)sub_40ECDB(*v1);
            v5 = v4;
            v6 = v4 + 1;
            while ( *v4++ )
              ;
            wcsupr_s(v5, v4 - v6 + 1);
            v8 = (wchar_t *)sub_40ECDB((char *)v3 + 2);
            *v3 = 61;
            Block = v8;
            byte_41450D = 0;
            if ( !sub_40367D(v5, v8, 4) )
            {
              free(v5);
              free(Block);
            }
          }
        }
      }
      result = *++v1;
    }
    while ( *v1 );
  }
  return result;
}
// 41450D: using guessed type char byte_41450D;

//----- (0040C7A4) --------------------------------------------------------
void __fastcall sub_40C7A4(unsigned int a1, int a2)
{
  int v2; // edi
  int (__cdecl *v3)(const wchar_t *, const wchar_t *); // ecx
  wchar_t *(__cdecl *v4)(const wchar_t *, wchar_t); // esi
  wchar_t *v5; // ebx
  int v6; // eax
  wchar_t *v7; // eax
  wchar_t *v8; // esi
  wchar_t *v9; // eax
  const wchar_t *v10; // esi
  int v11; // ecx
  size_t v12; // eax
  wchar_t *v13; // esi
  size_t v14; // eax
  wchar_t *v15; // eax
  _DWORD *v16; // esi
  void *v17; // eax
  const wchar_t *v18; // esi
  int v19; // ecx
  const wchar_t *v20; // esi
  wchar_t v21; // cx
  FILE *v22; // eax
  char *v23; // ebx
  _DWORD *v24; // esi
  char v25; // cl
  char v26; // [esp+13h] [ebp-25h]
  int v27; // [esp+14h] [ebp-24h]
  FILE *Stream; // [esp+28h] [ebp-10h] BYREF
  FILE *(__cdecl *v30)(unsigned int); // [esp+2Ch] [ebp-Ch]
  errno_t (__cdecl *v31)(FILE **, const wchar_t *, const wchar_t *); // [esp+30h] [ebp-8h]
  int (__cdecl *v32)(FILE *); // [esp+34h] [ebp-4h]

  v27 = a2;
  v26 = 0;
  v2 = 0;
  if ( !a1 )
    return;
  v3 = wcsicmp;
  v4 = wcschr;
  v30 = _acrt_iob_func;
  v31 = wfopen_s;
  v32 = fclose;
  while ( 1 )
  {
    v5 = *(wchar_t **)(a2 + 4 * v2);
    v6 = *v5;
    if ( v6 == 64 )
    {
      sub_405994(v5 + 1);
    }
    else
    {
      if ( (_WORD)v6 != 45 && v6 != 47 )
      {
        v7 = v4(v5, 0x3Du);
        v8 = v7;
        if ( v7 )
        {
          if ( v7 == v5 )
            sub_405B2C(0, 0x427u);
          *v8 = 0;
          v9 = v8 - 1;
          v10 = v8 + 1;
          while ( 1 )
          {
            v11 = *v9;
            if ( (_WORD)v11 != 32 && v11 != 9 )
              break;
            --v9;
          }
          byte_41450D = 1;
          v9[1] = 0;
          v12 = wcsspn(v10, L" \t");
          v13 = (wchar_t *)sub_40ECDB((char *)&v10[v12]);
          v14 = wcsspn(v5, L" \t");
          v15 = (wchar_t *)sub_40ECDB((char *)&v5[v14]);
          sub_40367D(v15, v13, 2);
        }
        else
        {
          sub_40CEA2(v5);
          if ( *v5 )
          {
            v16 = sub_40EC89();
            if ( (int)wcschr(v5, 32) )
              v17 = sub_40ED1F((char *)v5);
            else
              v17 = sub_40ECDB((char *)v5);
            v16[1] = v17;
            sub_40EDE0((_DWORD **)&dword_424710, v16);
          }
        }
        a2 = v27;
        v4 = wcschr;
        *(_DWORD *)(v27 + 4 * v2) = 0;
        goto LABEL_51;
      }
      v18 = v5 + 1;
      if ( !v3(v5 + 1, L"help") )
        goto LABEL_54;
      if ( *v18 )
      {
        while ( 1 )
        {
          if ( !wcsicmp(v18, L"nologo") )
          {
            sub_40CB79(v18[2], 1);
            goto LABEL_49;
          }
          v19 = *v18;
          if ( v19 == 63 )
          {
            a2 = v27;
            v25 = 1;
            v4 = wcschr;
            v26 = 1;
            goto LABEL_52;
          }
          if ( v19 == 102 || v19 == 70 )
            break;
          if ( v19 == 120 || v19 == 88 )
          {
            v20 = v18 + 1;
            v21 = *v20;
            if ( !*v20 )
            {
              if ( ++v2 >= a1 || (v20 = *(const wchar_t **)(v27 + 4 * v2), (v21 = *v20) == 0) )
              {
                sub_405B2C(0, 0x426u);
                v21 = *v20;
              }
            }
            if ( v21 != 45 || v20[1] )
            {
              if ( v31(&Stream, v20, L"wt") )
                sub_405B2C(0, 0x418u, v20);
              sub_40D10C(Stream);
              v32(Stream);
            }
            else
            {
              v22 = v30(1u);
              sub_40D10C(v22);
            }
            goto LABEL_49;
          }
          sub_40CB79(v19, 1);
          if ( !*++v18 )
            goto LABEL_49;
        }
        v23 = (char *)(v18 + 1);
        if ( !v18[1] )
        {
          if ( ++v2 >= a1 || (v23 = *(char **)(v27 + 4 * v2), !*(_WORD *)v23) )
            sub_405B2C(0, 0x425u);
        }
        v24 = sub_40EC89();
        v24[1] = sub_40ECDB(v23);
        sub_40EDE0((_DWORD **)&dword_435470, v24);
      }
LABEL_49:
      v4 = wcschr;
    }
    a2 = v27;
LABEL_51:
    v25 = v26;
LABEL_52:
    if ( ++v2 >= a1 )
      break;
    v3 = wcsicmp;
  }
  if ( v25 )
  {
LABEL_54:
    sub_405CCE();
    exit(0);
  }
}
// 402488: using guessed type wchar_t aNologo[7];
// 402498: using guessed type wchar_t aWt[3];
// 41450D: using guessed type char byte_41450D;
// 424710: using guessed type int dword_424710;
// 435470: using guessed type int dword_435470;

//----- (0040CAA9) --------------------------------------------------------
void *sub_40CAA9()
{
  void *result; // eax
  _DWORD *v1; // esi
  wchar_t *v2; // esi
  wchar_t *v3; // eax
  int v4; // ecx
  struct _WIN32_FIND_DATAW FindFileData; // [esp+8h] [ebp-460h] BYREF
  wchar_t Destination[262]; // [esp+258h] [ebp-210h] BYREF

  result = (void *)waccess(L"makefile", 4);
  if ( result )
  {
    if ( dword_424710 )
    {
      v2 = *(wchar_t **)(dword_424710 + 4);
      result = (void *)waccess(v2, 4);
      if ( !result )
      {
        v3 = wcsrchr(v2, 0x2Eu);
        if ( !v3 || (result = sub_40E456(Destination, 0x101u, v2, (int)v3, &FindFileData)) == 0 )
        {
          v4 = dword_424710;
          result = *(void **)dword_424710;
          dword_424710 = *(_DWORD *)dword_424710;
          dword_435470 = v4;
        }
      }
    }
    else if ( (byte_41450C & 1) == 0 )
    {
      return (void *)sub_405B2C(0, 0x428u);
    }
  }
  else
  {
    v1 = sub_40EC89();
    result = sub_40ECDB((char *)L"makefile");
    v1[1] = result;
    dword_435470 = (int)v1;
  }
  return result;
}
// 41450C: using guessed type char byte_41450C;
// 424710: using guessed type int dword_424710;
// 435470: using guessed type int dword_435470;
// 40CAA9: using guessed type wchar_t Destination[262];

//----- (0040CB79) --------------------------------------------------------
int __fastcall sub_40CB79(wint_t C, char a2)
{
  char *v2; // esi
  int v3; // edi
  int result; // eax
  char v5; // bl
  int v6; // ecx
  char v7; // bl
  wchar_t *v8; // eax
  wchar_t *v9; // eax
  wchar_t v10; // dx
  const wchar_t *v11; // eax
  char v13; // [esp+10h] [ebp-8h]

  v2 = &byte_41450E;
  v13 = 0;
  v3 = towupper(C);
  result = v3;
  if ( (unsigned __int16)v3 > 0x4Cu )
  {
    if ( (unsigned __int16)v3 > 0x52u )
    {
      result = (unsigned __int16)v3 - 83;
      if ( (unsigned __int16)v3 == 83 )
      {
        v13 = 8;
        goto LABEL_44;
      }
      result = (unsigned __int16)v3 - 84;
      if ( (unsigned __int16)v3 == 84 )
      {
        v13 = 16;
        goto LABEL_11;
      }
      result = (unsigned __int16)v3 - 85;
      if ( (unsigned __int16)v3 == 85 )
      {
        v13 = 64;
        goto LABEL_44;
      }
      result = (unsigned __int16)v3 - 89;
      if ( (unsigned __int16)v3 == 89 )
      {
        v13 = 64;
        goto LABEL_11;
      }
      goto LABEL_39;
    }
    if ( v3 == 82 )
    {
      v13 = 2;
      goto LABEL_11;
    }
    result = (unsigned __int16)v3 - 78;
    if ( (unsigned __int16)v3 == 78 )
    {
      v13 = 4;
      goto LABEL_44;
    }
    result = (unsigned __int16)v3 - 79;
    if ( (unsigned __int16)v3 == 79 )
    {
      byte_424735 = 1;
      return result;
    }
    result = (unsigned __int16)v3 - 80;
    if ( (unsigned __int16)v3 == 80 )
    {
      v13 = 1;
      goto LABEL_11;
    }
    result = (unsigned __int16)v3 - 81;
    if ( (unsigned __int16)v3 == 81 )
    {
      v13 = 8;
      goto LABEL_11;
    }
    goto LABEL_39;
  }
  if ( (unsigned __int16)v3 == 76 )
  {
    v13 = 0x80;
    goto LABEL_10;
  }
  if ( (unsigned __int16)v3 > 0x44u )
  {
    result = (unsigned __int16)v3 - 69;
    if ( (unsigned __int16)v3 == 69 )
    {
      v13 = 4;
      goto LABEL_11;
    }
    result = (unsigned __int16)v3 - 71;
    if ( (unsigned __int16)v3 == 71 )
    {
      byte_424F63 = 1;
      return result;
    }
    result = (unsigned __int16)v3 - 73;
    if ( (unsigned __int16)v3 == 73 )
    {
      v13 = 2;
      goto LABEL_44;
    }
    result = (unsigned __int16)v3 - 75;
    if ( (unsigned __int16)v3 == 75 )
    {
      byte_424737 = 1;
      return result;
    }
LABEL_39:
    result = sub_405B2C(0, 0x429u, C);
    goto LABEL_44;
  }
  if ( v3 == 68 )
  {
    v13 = 1;
  }
  else
  {
    result = (unsigned __int16)v3 - 32;
    if ( (unsigned __int16)v3 == 32 )
      return result;
    result = (unsigned __int16)v3 - 65;
    if ( (unsigned __int16)v3 != 65 )
    {
      result = (unsigned __int16)v3 - 66;
      if ( (unsigned __int16)v3 == 66 )
      {
        byte_424736 = 1;
        return result;
      }
      result = (unsigned __int16)v3 - 67;
      if ( (unsigned __int16)v3 == 67 )
      {
        v13 = 32;
LABEL_10:
        byte_424F60 = 1;
LABEL_11:
        v5 = byte_41450C;
        v2 = &byte_41450C;
        goto LABEL_45;
      }
      goto LABEL_39;
    }
    v13 = 16;
  }
LABEL_44:
  v5 = byte_41450E;
LABEL_45:
  if ( dword_4353AC )
  {
    v6 = dword_4353A8;
  }
  else
  {
    result = sub_40B534(aMa);
    dword_4353AC = result;
    v6 = *(_DWORD *)(result + 8);
    dword_4353A8 = v6;
  }
  if ( a2 )
  {
    v7 = v13 | v5;
    *v2 = v7;
    if ( v3 == 81 )
      *v2 = v7 | 0x20;
    if ( !wcschr(*(const wchar_t **)(v6 + 4), v3) )
    {
      v8 = wcschr(*(const wchar_t **)(dword_4353A8 + 4), 0x20u);
      if ( v8 )
        *v8 = v3;
    }
  }
  else
  {
    if ( v2 != &byte_41450E )
      return result;
    *v2 = v5 & ~v13;
    v9 = wcschr(*(const wchar_t **)(v6 + 4), v3);
    if ( v9 )
    {
      do
      {
        v10 = v9[1];
        *v9++ = v10;
      }
      while ( v10 );
    }
  }
  v11 = (const wchar_t *)sub_40ECDB((char *)&aMakeflags[10]);
  result = wputenv_s(aMa, v11);
  if ( result )
    return sub_405B2C(dword_424724, 0x41Fu);
  return result;
}
// 41402C: using guessed type wchar_t aMakeflags[29];
// 41450C: using guessed type char byte_41450C;
// 41450E: using guessed type char byte_41450E;
// 424724: using guessed type int dword_424724;
// 424735: using guessed type char byte_424735;
// 424736: using guessed type char byte_424736;
// 424737: using guessed type char byte_424737;
// 424F60: using guessed type char byte_424F60;
// 424F63: using guessed type char byte_424F63;
// 4353A8: using guessed type int dword_4353A8;
// 4353AC: using guessed type int dword_4353AC;

//----- (0040CDB4) --------------------------------------------------------
void __cdecl Function()
{
  int v0; // esi
  const wchar_t *v1; // edi

  signal(2, (_crt_signal_t)1);
  signal(15, (_crt_signal_t)1);
  if ( byte_435478 && (byte_41450E & 4) == 0 && (byte_41450C & 0x10) == 0 && dword_424F54 && waccess(dword_424F54, 0) )
  {
    v0 = dword_42471C;
    v1 = dword_424F54;
    if ( dword_42471C )
    {
      while ( wcsicmp(*(const wchar_t **)(v0 + 4), v1) )
      {
        v0 = *(_DWORD *)v0;
        if ( !v0 )
        {
          v1 = dword_424F54;
          goto LABEL_10;
        }
      }
    }
    else
    {
LABEL_10:
      if ( !wunlink(v1) )
        sub_405B2C(dword_424724, 0xFA8u, dword_424F54);
    }
  }
  sub_405B2C(0, 0x422u);
  sub_40CE64();
}
// 41450C: using guessed type char byte_41450C;
// 41450E: using guessed type char byte_41450E;
// 42471C: using guessed type int dword_42471C;
// 424724: using guessed type int dword_424724;
// 435478: using guessed type char byte_435478;

//----- (0040CE64) --------------------------------------------------------
int sub_40CE64()
{
  int result; // eax
  int i; // esi

  result = fcloseall();
  for ( i = dword_435474; i; i = *(_DWORD *)i )
  {
    result = wunlink(*(const wchar_t **)(i + 4));
    if ( (byte_41450E & 4) != 0 )
    {
      sub_40D1B2((wchar_t *)L"\tdel %s\n", *(_DWORD *)(i + 4));
      result = sub_40D194();
    }
  }
  return result;
}
// 41450E: using guessed type char byte_41450E;
// 435474: using guessed type int dword_435474;

//----- (0040CEA2) --------------------------------------------------------
const unsigned __int16 *__fastcall sub_40CEA2(const unsigned __int16 *a1)
{
  char v1; // bl
  const unsigned __int16 *result; // eax
  int v3; // edx

  v1 = 0;
  result = &a1[wcslen(a1) - 1];
  if ( *a1 != 34 || *result != 34 )
    goto LABEL_7;
  v1 = 1;
  do
  {
    --result;
LABEL_7:
    if ( result <= a1 )
      break;
    v3 = *result;
  }
  while ( v3 == 32 || v3 == 46 );
  if ( v1 )
    *++result = 34;
  *((_WORD *)result + 1) = 0;
  return result;
}

//----- (0040CEF8) --------------------------------------------------------
int __fastcall sub_40CEF8(unsigned int a1)
{
  int v1; // esi
  wchar_t **v3; // eax
  HMODULE v4; // edi
  HRSRC Resource; // eax
  _WORD *v6; // edx
  int i; // ebx
  int v9; // [esp-18h] [ebp-640h]
  int v10; // [esp-14h] [ebp-63Ch]
  int v11; // [esp-10h] [ebp-638h]
  int v12; // [esp-Ch] [ebp-634h]
  int v13; // [esp-8h] [ebp-630h]
  int v14; // [esp-4h] [ebp-62Ch]
  wchar_t Buffer[260]; // [esp+10h] [ebp-618h] BYREF
  wchar_t Dir[256]; // [esp+218h] [ebp-410h] BYREF
  wchar_t Filename[258]; // [esp+418h] [ebp-210h] BYREF
  wchar_t Drive[4]; // [esp+61Ch] [ebp-Ch] BYREF

  v1 = 0;
  if ( byte_438EE0 )
  {
    v4 = hModule;
  }
  else
  {
    v3 = _p__wpgmptr();
    wsplitpath_s(*v3, Drive, 3u, Dir, 0x100u, Filename, 0x100u, 0, 0);
    wmakepath_s(Buffer, 0x104u, Drive, Dir, 0, 0);
    if ( wcsncat_s(Filename, 0x100u, L"UI.DLL", 0xFFFFFFFF)
      || sub_40B652(Buffer, Filename, v9, v10, v11, v12, v13, v14) < 0 )
    {
      v4 = 0;
      hModule = 0;
    }
    else
    {
      v4 = hModule;
    }
    byte_438EE0 = 1;
  }
  Resource = FindResourceExW(v4, (LPCWSTR)6, (LPCWSTR)(unsigned __int16)((a1 >> 4) + 1), word_438EE8);
  if ( Resource )
  {
    v6 = LoadResource(v4, Resource);
    if ( v6 )
    {
      for ( i = a1 & 0xF; i; --i )
        v6 += (unsigned __int16)*v6 + 1;
      return *v6 != 0 ? (unsigned int)(v6 + 1) : 0;
    }
  }
  return v1;
}
// 40CF94: variable 'v9' is possibly undefined
// 40CF94: variable 'v10' is possibly undefined
// 40CF94: variable 'v11' is possibly undefined
// 40CF94: variable 'v12' is possibly undefined
// 40CF94: variable 'v13' is possibly undefined
// 40CF94: variable 'v14' is possibly undefined
// 438EE0: using guessed type char byte_438EE0;
// 438EE8: using guessed type __int16 word_438EE8;

//----- (0040D019) --------------------------------------------------------
void *sub_40D019()
{
  return &unk_4386B8;
}

//----- (0040D01F) --------------------------------------------------------
int sub_40D01F(wchar_t *Buffer, wchar_t *Format, ...)
{
  _DWORD *v2; // eax
  unsigned __int64 v4; // [esp-1Ch] [ebp-1Ch]
  va_list va; // [esp+10h] [ebp+10h] BYREF

  va_start(va, Format);
  v2 = sub_40D019();
  HIDWORD(v4) = v2[1];
  LODWORD(v4) = *v2 | 1;
  return _stdio_common_vswscanf(v4, Buffer, 0xFFFFFFFF, Format, 0, va);
}

//----- (0040D049) --------------------------------------------------------
bool __thiscall sub_40D049(FILE *Stream)
{
  int v1; // eax
  void *osfhandle; // esi
  DWORD Mode; // [esp+4h] [ebp-4h] BYREF

  v1 = fileno(Stream);
  osfhandle = (void *)get_osfhandle(v1);
  return (GetFileType(osfhandle) & 0xFFFF7FFF) == 2 && GetConsoleMode(osfhandle, &Mode);
}

//----- (0040D088) --------------------------------------------------------
bool sub_40D088()
{
  FILE *v0; // eax
  FILE *v1; // eax
  bool result; // al

  v0 = _acrt_iob_func(1u);
  byte_43547D = sub_40D049(v0);
  v1 = _acrt_iob_func(2u);
  result = sub_40D049(v1);
  byte_43547C = result;
  return result;
}
// 43547C: using guessed type char byte_43547C;
// 43547D: using guessed type char byte_43547D;

//----- (0040D0B3) --------------------------------------------------------
int sub_40D0B3()
{
  FILE *v1; // eax

  if ( byte_43547C )
    return 0;
  v1 = _acrt_iob_func(2u);
  return fflush(v1);
}
// 43547C: using guessed type char byte_43547C;

//----- (0040D0D1) --------------------------------------------------------
int sub_40D0D1(wchar_t *Format, ...)
{
  va_list va; // [esp+Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  return sub_40D14A(Format, va);
}

//----- (0040D0E0) --------------------------------------------------------
int sub_40D0E0()
{
  int result; // eax
  FILE *v1; // eax

  if ( byte_43547C )
  {
    LOWORD(result) = putwch(0xAu);
  }
  else
  {
    v1 = _acrt_iob_func(2u);
    LOWORD(result) = fputwc(0xAu, v1);
  }
  return (unsigned __int16)result;
}
// 43547C: using guessed type char byte_43547C;

//----- (0040D10C) --------------------------------------------------------
bool __thiscall sub_40D10C(FILE *Stream)
{
  FILE *v2; // eax
  int v3; // edi
  int v4; // eax
  FILE *v5; // eax
  bool result; // al

  v2 = _acrt_iob_func(2u);
  v3 = fileno(v2);
  v4 = fileno(Stream);
  dup2(v4, v3);
  v5 = _acrt_iob_func(2u);
  result = sub_40D049(v5);
  byte_43547C = result;
  return result;
}
// 43547C: using guessed type char byte_43547C;

//----- (0040D14A) --------------------------------------------------------
int __fastcall sub_40D14A(wchar_t *Format, va_list ArgList)
{
  unsigned __int64 *v4; // eax
  unsigned __int64 *v5; // esi
  FILE *v7; // eax

  v4 = (unsigned __int64 *)sub_40D237();
  v5 = v4;
  if ( byte_43547C )
    return _conio_common_vcwprintf(*v4, Format, 0, ArgList);
  v7 = _acrt_iob_func(2u);
  return _stdio_common_vfwprintf(*v5, v7, Format, 0, ArgList);
}
// 43547C: using guessed type char byte_43547C;

//----- (0040D194) --------------------------------------------------------
int sub_40D194()
{
  FILE *v1; // eax

  if ( byte_43547D )
    return 0;
  v1 = _acrt_iob_func(1u);
  return fflush(v1);
}
// 43547D: using guessed type char byte_43547D;

//----- (0040D1B2) --------------------------------------------------------
int sub_40D1B2(wchar_t *Format, ...)
{
  va_list va; // [esp+Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  return sub_40D1ED(Format, va);
}

//----- (0040D1C1) --------------------------------------------------------
int sub_40D1C1()
{
  int result; // eax
  FILE *v1; // eax

  if ( byte_43547D )
  {
    LOWORD(result) = putwch(0xAu);
  }
  else
  {
    v1 = _acrt_iob_func(1u);
    LOWORD(result) = fputwc(0xAu, v1);
  }
  return (unsigned __int16)result;
}
// 43547D: using guessed type char byte_43547D;

//----- (0040D1ED) --------------------------------------------------------
int __fastcall sub_40D1ED(wchar_t *Format, va_list ArgList)
{
  unsigned __int64 *v4; // eax
  unsigned __int64 *v5; // esi
  FILE *v7; // eax

  v4 = (unsigned __int64 *)sub_40D237();
  v5 = v4;
  if ( byte_43547D )
    return _conio_common_vcwprintf(*v4, Format, 0, ArgList);
  v7 = _acrt_iob_func(1u);
  return _stdio_common_vfwprintf(*v5, v7, Format, 0, ArgList);
}
// 43547D: using guessed type char byte_43547D;

//----- (0040D237) --------------------------------------------------------
void *sub_40D237()
{
  return &unk_4386C8;
}

//----- (0040D23D) --------------------------------------------------------
int __thiscall sub_40D23D(void *this)
{
  int v1; // eax
  unsigned int v2; // eax
  int result; // eax
  int v4; // edx
  int v5; // ecx
  char v6; // bh
  unsigned __int8 i; // bl
  int v8; // eax
  char v9; // al
  int v10; // eax
  char v11; // al
  _BYTE *v12; // esi
  int v13; // [esp+10h] [ebp-8h]
  int v14; // [esp+10h] [ebp-8h]
  char v15; // [esp+17h] [ebp-1h]

  v1 = dword_414028;
  byte_424F62 = 1;
  byte_435391[dword_414028] = 23;
  v2 = v1 + 2;
  dword_414028 = v2;
  if ( v2 >= 0x10 )
    __report_rangecheckfailure();
  byte_435390[v2] = 0;
  dword_424730 = dword_424724;
  LOBYTE(result) = sub_40A4AD((int)this, 0);
  v4 = dword_414028;
  LOBYTE(v5) = result;
  v6 = 0;
  v15 = result;
  for ( i = byte_435390[dword_414028]; i != 23; i = byte_435390[v4] )
  {
    if ( (i & 0x40) != 0 )
    {
      v8 = byte_435390[v4] & 0xF;
      dword_414028 = v4 - 1;
      result = funcs_40D2BD[v8]();
    }
    else
    {
      if ( (i & 0x10) == 0 )
      {
        result = (unsigned __int8)byte_401540[8 * i + (v5 & 0xF)];
        v13 = result;
        if ( (result & 0x20) != 0 )
        {
          sub_405B2C(dword_424730, result + 1000, &Src);
          v4 = dword_414028;
          result = v13;
        }
        dword_414028 = --v4;
        if ( (result & 0x80u) != 0 )
        {
          v10 = result & 0xF;
          v14 = v10;
          if ( !v6 )
          {
            v11 = sub_40A4AD(v5, i);
            v4 = dword_414028;
            v6 = v11;
            v10 = v14;
          }
          result = (unsigned __int8)byte_401520[8 * i + (v6 & 0xF)] + v10;
        }
        v12 = (_BYTE *)*((_DWORD *)&off_4014D0 + result);
        v5 = (unsigned __int8)*v12;
        if ( *v12 )
        {
          do
          {
            LOBYTE(result) = v12[v5];
            byte_435390[++v4] = result;
            --v5;
          }
          while ( v5 );
          dword_414028 = v4;
        }
        goto LABEL_25;
      }
      if ( i == (_BYTE)v5 )
      {
        LOBYTE(v5) = byte_43538F[v4--];
        dword_414028 = v4;
        if ( (v5 & 0x40) != 0 )
        {
          dword_414028 = v4 - 1;
          funcs_40D2BD[v5 & 0xF]();
          v4 = dword_414028;
        }
        result = dword_424724;
        dword_424730 = dword_424724;
        if ( v6 )
        {
          if ( Src == 10 )
          {
            result = dword_424724 - 1;
            dword_424730 = dword_424724 - 1;
          }
          LOBYTE(v5) = v6;
          v6 = 0;
          v15 = v5;
        }
        else
        {
          v9 = sub_40A4AD(v5, byte_435390[v4]);
          v4 = dword_414028;
          LOBYTE(v5) = v9;
          result = dword_424724;
          v15 = v5;
          dword_424730 = dword_424724;
        }
        continue;
      }
      result = sub_405B2C(dword_424730, 0x409u, &Src);
    }
    v4 = dword_414028;
LABEL_25:
    LOBYTE(v5) = v15;
  }
  dword_414028 = v4 - 1;
  return result;
}
// 40D34D: variable 'v5' is possibly undefined
// 401580: using guessed type int (*funcs_40D2BD[6])();
// 4125FC: using guessed type void __noreturn __report_rangecheckfailure(void);
// 414028: using guessed type int dword_414028;
// 424724: using guessed type int dword_424724;
// 424730: using guessed type int dword_424730;
// 424F62: using guessed type char byte_424F62;

//----- (0040D421) --------------------------------------------------------
unsigned int __fastcall sub_40D421(int a1, _WORD *a2)
{
  _WORD *v2; // esi
  unsigned int v4; // ecx

  v2 = a2 + 1;
  while ( *a2++ )
    ;
  v4 = a2 - v2 + a1;
  if ( v4 > 0x28 )
  {
    sub_40D1B2((wchar_t *)L"\n\t\t\t");
    return 0;
  }
  return v4;
}

//----- (0040D450) --------------------------------------------------------
void __fastcall sub_40D450(int a1, int a2, FILETIME FileTime)
{
  struct _FILETIME LocalFileTime; // [esp+Ch] [ebp-5Ch] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+14h] [ebp-54h] BYREF
  WCHAR DateStr[20]; // [esp+24h] [ebp-44h] BYREF
  WCHAR TimeStr[12]; // [esp+4Ch] [ebp-1Ch] BYREF

  if ( FileTime )
  {
    if ( FileTimeToLocalFileTime(&FileTime, &LocalFileTime)
      && FileTimeToSystemTime(&LocalFileTime, &SystemTime)
      && GetDateFormatW(0x400u, 0, &SystemTime, L"ddd, MMM dd yyyy", DateStr, 20) )
    {
      if ( GetTimeFormatW(0x400u, 0, &SystemTime, L"HH:mm:ss", TimeStr, 12) )
        sub_405C06(4u, DateStr, TimeStr, a1, 32, a2);
    }
  }
  else
  {
    sub_405C06(6u, a1 + 26, 32, a2);
  }
}

//----- (0040D50A) --------------------------------------------------------
void __fastcall sub_40D50A(int a1, int a2)
{
  int v2; // edi
  int v3; // ebx
  wchar_t *v4; // eax
  __int16 *v5; // ecx
  wchar_t *v6; // eax
  wchar_t *v7; // ebx
  int v8; // edi
  WCHAR *i; // eax
  _WORD *v10; // esi
  WCHAR *v11; // eax
  _WORD *v12; // esi
  int v13; // [esp+10h] [ebp-280h] BYREF
  void *Block; // [esp+18h] [ebp-278h]
  __int16 *v15; // [esp+1Ch] [ebp-274h] BYREF
  int v16; // [esp+20h] [ebp-270h] BYREF
  int v17; // [esp+24h] [ebp-26Ch]
  wchar_t *Context; // [esp+28h] [ebp-268h] BYREF
  HANDLE hFindFile; // [esp+2Ch] [ebp-264h] BYREF
  wchar_t *String; // [esp+30h] [ebp-260h] BYREF
  int v21; // [esp+34h] [ebp-25Ch]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+38h] [ebp-258h] BYREF

  v2 = a1;
  v17 = a1;
  v16 = a2;
  sub_405C06(0xCu);
  v3 = 0;
  v21 = 0;
  while ( v2 )
  {
    v4 = wcschr(*(const wchar_t **)(v2 + 4), 0x24u);
    v5 = *(__int16 **)(v2 + 4);
    if ( v4 )
    {
      Context = 0;
      String = 0;
      v15 = v5;
      sub_40F9D0(&v13, &v15, 1, &v16, 0, (int)&String);
      v6 = String;
      String = 0;
      Block = v6;
      v7 = wcstok_s(v6, L" \t", &Context);
      if ( v7 )
      {
        v8 = v21;
        do
        {
          if ( wcspbrk(v7, L"*?") )
          {
            for ( i = sub_408256(v7, &FindFileData, &hFindFile); i; i = sub_4083E1(&FindFileData, hFindFile) )
            {
              v10 = sub_4114A5(v7, i);
              sub_40D1B2((wchar_t *)L"%s ", v10);
              v8 = sub_40D421(v8, v10);
              free(v10);
            }
          }
          else
          {
            sub_40D1B2((wchar_t *)L"%s ", v7);
            v8 = sub_40D421(v8, v7);
          }
          v7 = wcstok_s(0, L" \t", &Context);
        }
        while ( v7 );
        v21 = v8;
        v2 = v17;
      }
      free(Block);
      v3 = v21;
    }
    else
    {
      if ( wcspbrk((const wchar_t *)v5, L"*?") )
      {
        v11 = sub_408256(*(wchar_t **)(v2 + 4), &FindFileData, &hFindFile);
        if ( !v11 )
          goto LABEL_20;
        do
        {
          v12 = sub_4114A5(*(wchar_t **)(v2 + 4), v11);
          sub_40D1B2((wchar_t *)L"%s ", v12);
          v3 = sub_40D421(v3, v12);
          free(v12);
          v11 = sub_4083E1(&FindFileData, hFindFile);
        }
        while ( v11 );
      }
      else
      {
        sub_40D1B2((wchar_t *)L"%s ", *(_DWORD *)(v2 + 4));
        v3 = sub_40D421(v3, *(_WORD **)(v2 + 4));
      }
      v21 = v3;
    }
LABEL_20:
    v2 = *(_DWORD *)v2;
    v17 = v2;
  }
}

//----- (0040D740) --------------------------------------------------------
int sub_40D740()
{
  _DWORD *v0; // edi
  _DWORD *i; // esi
  int v2; // eax
  _DWORD *j; // ebx

  sub_405C06(8u);
  v0 = &unk_434F90;
  do
  {
    for ( i = (_DWORD *)*v0; i; i = (_DWORD *)*i )
    {
      v2 = i[2];
      if ( v2 && *(_DWORD *)(v2 + 4) )
      {
        sub_405C06(0xEu, i[1], *(_DWORD *)(v2 + 4));
        for ( j = *(_DWORD **)i[2]; j; j = (_DWORD *)*j )
        {
          if ( j[1] )
            sub_40D1B2((wchar_t *)L"\t\t%s\n", j[1]);
        }
      }
    }
    ++v0;
  }
  while ( (int)v0 < (int)byte_435390 );
  sub_40D1C1();
  return sub_40D194();
}

//----- (0040D7B1) --------------------------------------------------------
int sub_40D7B1()
{
  _BYTE *v0; // esi
  wchar_t *v1; // eax
  _DWORD *v2; // edi
  _DWORD *i; // esi

  sub_405C06(7u);
  v0 = dword_424714;
  if ( dword_424714 )
  {
    do
    {
      v1 = (wchar_t *)L"%s::";
      if ( !v0[20] )
        v1 = L"%s:";
      sub_40D1B2(v1, *((_DWORD *)v0 + 2));
      sub_405C06(0xAu);
      v2 = (_DWORD *)*((_DWORD *)v0 + 3);
      if ( v2 )
      {
        sub_40D1B2(L"%s\n", v2[1]);
        while ( 1 )
        {
          v2 = (_DWORD *)*v2;
          if ( !v2 )
            break;
          sub_40D1B2((wchar_t *)L"\t\t\t%s\n", v2[1]);
        }
      }
      sub_40D1C1();
      v0 = *(_BYTE **)v0;
    }
    while ( v0 );
  }
  sub_40D1B2((wchar_t *)L"%s: ", L".SUFFIXES");
  for ( i = (_DWORD *)dword_424720; i; i = (_DWORD *)*i )
    sub_40D1B2((wchar_t *)L"%s ", i[1]);
  sub_40D1C1();
  return sub_40D194();
}
// 401168: using guessed type wchar_t aSuffixes[10];
// 40253C: using guessed type wchar_t aS_3[4];
// 402544: using guessed type wchar_t aS_4[4];
// 424720: using guessed type int dword_424720;

//----- (0040D851) --------------------------------------------------------
int sub_40D851()
{
  unsigned int v0; // ebx
  _DWORD *v1; // esi
  _DWORD *v2; // ebx
  int v3; // edi
  unsigned __int16 *v4; // esi
  unsigned int v5; // eax
  _DWORD *v6; // edi
  int result; // eax
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]
  unsigned int v10; // [esp+14h] [ebp-4h]

  sub_405C06(9u);
  v0 = 0;
  v10 = 0;
  do
  {
    v1 = *(_DWORD **)((char *)dword_424510 + v0);
    v9 = v1;
    if ( v1 )
    {
      do
      {
        sub_40D1B2((wchar_t *)L"%s:%c", v1[1], (*(_BYTE *)(*(_DWORD *)(v1[6] + 4) + 16) & 0x20) != 0 ? 58 : 32);
        v2 = (_DWORD *)v1[6];
        dword_424F48 = v1[1];
        dword_424F54 = (wchar_t *)dword_424F48;
        dword_424F58 = dword_424F48;
        if ( v2 )
        {
          do
          {
            v3 = v2[1];
            sub_405C06(0xBu);
            v4 = L"dinsb";
            v5 = 1;
            v8 = 1;
            do
            {
              if ( ((unsigned __int8)v5 & *(_BYTE *)(v3 + 16)) != 0 )
              {
                sub_40D1B2((wchar_t *)L"-%c ", *v4);
                v5 = v8;
              }
              v5 *= 2;
              ++v4;
              v8 = v5;
            }
            while ( v5 < 0x10 );
            sub_40D50A(*(_DWORD *)v3, *(_DWORD *)(v3 + 4));
            sub_405C06(0xAu);
            v6 = *(_DWORD **)(v3 + 8);
            if ( v6 )
            {
              if ( v6[1] )
                sub_40D1B2(L"%s\n", v6[1]);
              while ( 1 )
              {
                v6 = (_DWORD *)*v6;
                if ( !v6 )
                  break;
                if ( v6[1] )
                  sub_40D1B2((wchar_t *)L"\t\t\t%s\n", v6[1]);
              }
            }
            else
            {
              sub_40D1C1();
            }
            v2 = (_DWORD *)*v2;
          }
          while ( v2 );
          v1 = v9;
        }
        v1 = (_DWORD *)*v1;
        v9 = v1;
        sub_40D1C1();
      }
      while ( v1 );
      v0 = v10;
    }
    v0 += 4;
    v10 = v0;
  }
  while ( v0 < 0x200 );
  sub_40D1C1();
  sub_40D194();
  result = 0;
  dword_424F48 = 0;
  dword_424F54 = 0;
  dword_424F58 = 0;
  return result;
}
// 402544: using guessed type wchar_t aS_4[4];
// 402580: using guessed type wchar_t aDinsb[6];
// 424510: using guessed type int dword_424510[128];
// 424F48: using guessed type int dword_424F48;
// 424F58: using guessed type int dword_424F58;

//----- (0040D9A6) --------------------------------------------------------
char __stdcall sub_40D9A6(char a1)
{
  int v1; // edi
  char v2; // al
  int v3; // esi
  int v4; // eax
  BOOL v5; // ecx
  int v6; // ecx
  BOOL v7; // eax
  unsigned int v8; // eax

  v1 = dword_435690;
  v2 = *(_BYTE *)dword_435690;
  v3 = dword_435690 - 8;
  dword_435690 -= 8;
  if ( v2 != 22 )
  {
    if ( v2 != 23 || *(_BYTE *)v3 != 23 )
      return 0;
    v6 = wcscmp(*(const unsigned __int16 **)(v3 + 4), *(const unsigned __int16 **)(v1 + 4));
    if ( v6 )
      v6 = v6 < 0 ? -1 : 1;
    switch ( a1 )
    {
      case 6:
        v7 = v6 != 0;
        goto LABEL_48;
      case 7:
        v7 = v6 == 0;
        goto LABEL_48;
      case 8:
        v7 = v6 > 0;
        goto LABEL_48;
      case 9:
        v8 = v6;
        break;
      case 10:
        v8 = ~v6;
        break;
      case 11:
        v7 = v6 <= 0;
LABEL_48:
        *(_DWORD *)(v3 + 4) = v7;
        *(_BYTE *)v3 = 22;
        return 1;
      default:
        return 0;
    }
    v7 = v8 >> 31;
    goto LABEL_48;
  }
  if ( *(_BYTE *)v3 == 22 )
  {
    switch ( a1 )
    {
      case 1:
        v4 = 0;
        if ( !*(_DWORD *)(v3 + 4) )
          goto LABEL_5;
        goto LABEL_6;
      case 2:
        v4 = 0;
        if ( *(_DWORD *)(v3 + 4) )
        {
LABEL_5:
          if ( *(_DWORD *)(v1 + 4) )
LABEL_6:
            v4 = 1;
        }
        goto LABEL_30;
      case 3:
        *(_DWORD *)(v3 + 4) |= *(_DWORD *)(v1 + 4);
        return 1;
      case 4:
        *(_DWORD *)(v3 + 4) ^= *(_DWORD *)(v1 + 4);
        return 1;
      case 5:
        *(_DWORD *)(v3 + 4) &= *(_DWORD *)(v1 + 4);
        return 1;
      case 6:
        v5 = *(_DWORD *)(v1 + 4) != *(_DWORD *)(v3 + 4);
        goto LABEL_13;
      case 7:
        v4 = *(_DWORD *)(v3 + 4) == *(_DWORD *)(v1 + 4);
        goto LABEL_30;
      case 8:
        v5 = *(_DWORD *)(v3 + 4) > *(_DWORD *)(v1 + 4);
        goto LABEL_13;
      case 9:
        v5 = *(_DWORD *)(v3 + 4) < *(_DWORD *)(v1 + 4);
        goto LABEL_13;
      case 10:
        v5 = *(_DWORD *)(v3 + 4) >= *(_DWORD *)(v1 + 4);
        goto LABEL_13;
      case 11:
        v5 = *(_DWORD *)(v3 + 4) <= *(_DWORD *)(v1 + 4);
LABEL_13:
        *(_DWORD *)(v3 + 4) = v5;
        return 1;
      case 12:
        *(int *)(v3 + 4) >>= *(_DWORD *)(v1 + 4);
        return 1;
      case 13:
        *(_DWORD *)(v3 + 4) <<= *(_DWORD *)(v1 + 4);
        return 1;
      case 14:
        *(_DWORD *)(v3 + 4) -= *(_DWORD *)(v1 + 4);
        return 1;
      case 15:
        *(_DWORD *)(v3 + 4) += *(_DWORD *)(v1 + 4);
        return 1;
      case 16:
        if ( !*(_DWORD *)(v1 + 4) )
          sub_405B2C(dword_424724, 0x437u);
        *(int *)(v3 + 4) %= *(_DWORD *)(v1 + 4);
        return 1;
      case 17:
        if ( !*(_DWORD *)(v1 + 4) )
          sub_405B2C(dword_424724, 0x437u);
        v4 = *(_DWORD *)(v3 + 4) / *(_DWORD *)(v1 + 4);
        goto LABEL_30;
      case 18:
        v4 = *(_DWORD *)(v1 + 4) * *(_DWORD *)(v3 + 4);
LABEL_30:
        *(_DWORD *)(v3 + 4) = v4;
        break;
      default:
        return 0;
    }
    return 1;
  }
  return 0;
}
// 424724: using guessed type int dword_424724;
// 435690: using guessed type int dword_435690;

//----- (0040DBEE) --------------------------------------------------------
char __stdcall sub_40DBEE(char a1)
{
  if ( *(_BYTE *)dword_435690 == 22 )
  {
    switch ( a1 )
    {
      case 19:
        *(_DWORD *)(dword_435690 + 4) = -*(_DWORD *)(dword_435690 + 4);
        return 1;
      case 20:
        *(_DWORD *)(dword_435690 + 4) = ~*(_DWORD *)(dword_435690 + 4);
        return 1;
      case 21:
        *(_DWORD *)(dword_435690 + 4) = *(_DWORD *)(dword_435690 + 4) == 0;
        return 1;
    }
  }
  return 0;
}
// 435690: using guessed type int dword_435690;

//----- (0040DC2C) --------------------------------------------------------
wchar_t *sub_40DC2C()
{
  wchar_t *v0; // esi
  wchar_t *v1; // ecx
  wchar_t v2; // bx
  wchar_t *v3; // edx
  wchar_t *v4; // edi
  wchar_t *result; // eax

  v0 = EndPtr + 1;
  v1 = EndPtr + 1;
  EndPtr = v1;
  if ( *v1 )
  {
    v2 = *v1;
    v3 = v0;
    v4 = v0;
    while ( 1 )
    {
      if ( v2 == 34 )
      {
        v3 = v4 + 1;
        if ( v4[1] != 34 )
          break;
      }
      v1 = v3 + 1;
      EndPtr = v1;
      ++v3;
      v4 = v1;
      v2 = *v1;
      if ( !*v1 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    sub_405B2C(dword_424724, 0x3FEu, 34);
    v1 = EndPtr;
  }
  *v1 = 0;
  result = v0;
  ++EndPtr;
  return result;
}
// 424724: using guessed type int dword_424724;

//----- (0040DCA7) --------------------------------------------------------
wchar_t *sub_40DCA7()
{
  wchar_t *v0; // edi
  wchar_t *v1; // edx
  wchar_t v2; // ax
  wchar_t v3; // si
  wchar_t *v4; // ebx
  _WORD *v5; // ebx
  wchar_t *result; // eax
  wchar_t *v7; // [esp+10h] [ebp-8h]

  v0 = EndPtr + 1;
  v1 = EndPtr + 1;
  v7 = ++EndPtr;
  v2 = *EndPtr;
  if ( *EndPtr )
  {
    v3 = *EndPtr;
    v4 = v0;
    do
    {
      if ( v3 == 94 && (v5 = v4 + 1, *v5 == 93) )
      {
        memmove(v0, v5, 2 * wcslen(v5) + 2);
        v1 = EndPtr;
      }
      else
      {
        v2 = v3;
        if ( v3 == 93 )
          break;
      }
      EndPtr = ++v1;
      v0 = v1;
      v4 = v1;
      v2 = *v1;
      v3 = *v1;
    }
    while ( *v1 );
    v0 = v7;
  }
  if ( !v2 )
  {
    sub_405B2C(dword_424724, 0x3FEu, 93);
    v1 = EndPtr;
  }
  *v1 = 0;
  result = v0;
  ++EndPtr;
  return result;
}
// 424724: using guessed type int dword_424724;

//----- (0040DD70) --------------------------------------------------------
int __fastcall sub_40DD70(char a1, int a2)
{
  unsigned __int8 v4; // bl
  int result; // eax

  if ( a1 == 25 )
  {
    v4 = 3;
  }
  else if ( a1 )
  {
    if ( (unsigned __int8)a1 <= 0x15u )
      v4 = ((unsigned __int8)a1 > 0x12u) + 1;
    else
      v4 = 0;
  }
  else
  {
    v4 = 4;
  }
  result = v4;
  if ( !byte_40159C[5 * (unsigned __int8)byte_43547E + v4] )
    result = sub_405B2C(dword_424724, 0x3FFu);
  dword_435688 = a2;
  byte_43547E = v4;
  byte_435682 = a1;
  LOBYTE(dword_435684) = a1;
  return result;
}
// 424724: using guessed type int dword_424724;
// 43547E: using guessed type char byte_43547E;
// 435682: using guessed type char byte_435682;
// 435684: using guessed type int dword_435684;
// 435688: using guessed type int dword_435688;

//----- (0040DDDE) --------------------------------------------------------
wchar_t *sub_40DDDE()
{
  wchar_t *i; // eax
  wchar_t v1; // cx
  wchar_t *j; // eax
  wchar_t *v3; // esi
  wchar_t v4; // cx
  wchar_t *v5; // eax
  wchar_t *v6; // ecx
  wchar_t v7; // dx
  wchar_t *v8; // edx
  wchar_t v9; // cx

  for ( i = EndPtr; ; EndPtr = i )
  {
    v1 = *i;
    if ( *i != 32 && v1 != 9 )
      break;
    ++i;
  }
  if ( v1 != 40 )
  {
    sub_405B2C(dword_424724, 0x3FFu);
    i = EndPtr;
  }
  for ( j = i + 1; ; ++j )
  {
    EndPtr = j;
    v3 = j;
    v4 = *j;
    if ( *j != 32 && v4 != 9 )
      break;
  }
  if ( v4 != 34 )
  {
    v8 = j;
    while ( 1 )
    {
      v9 = *j++;
      EndPtr = j;
      if ( !v9 )
        break;
      if ( v9 == 41 )
      {
        *v8 = 0;
        return v3;
      }
      if ( v9 != 32 && v9 != 9 )
LABEL_25:
        v8 = j;
    }
    sub_405B2C(dword_424724, 0x3FFu);
    j = EndPtr;
    goto LABEL_25;
  }
  v5 = sub_40DC2C();
  v6 = EndPtr;
  v3 = v5;
  while ( 1 )
  {
    v7 = *v6;
    if ( *v6 != 32 && v7 != 9 )
      break;
    EndPtr = ++v6;
  }
  if ( v7 != 41 )
  {
    sub_405B2C(dword_424724, 0x3FFu);
    v6 = EndPtr;
  }
  EndPtr = v6 + 1;
  return v3;
}
// 424724: using guessed type int dword_424724;

//----- (0040DEFF) --------------------------------------------------------
int sub_40DEFF()
{
  wchar_t *i; // ecx
  wint_t v1; // si
  wchar_t *v2; // edx
  wchar_t **v3; // edi
  wchar_t *v4; // ebx
  wchar_t v5; // cx
  char v6; // cl
  wchar_t *v7; // edx
  wchar_t *v8; // ebx
  int v9; // edi
  wchar_t *v10; // eax
  wchar_t *v11; // eax
  int v13; // [esp-Ch] [ebp-1Ch]

  for ( i = EndPtr; ; EndPtr = i )
  {
    v1 = *i;
    if ( *i != 32 && v1 != 9 )
      break;
    ++i;
  }
  if ( v1 < 0x80u && (byte_401090[v1] & 2) != 0 )
  {
    v2 = off_414070;
    v3 = &off_414070;
    if ( off_414070 )
    {
      while ( 1 )
      {
        v4 = i;
        i = EndPtr;
        if ( *v2 )
        {
          v5 = *v2;
          do
          {
            if ( *v4 != v5 )
              break;
            ++v2;
            ++v4;
            v5 = *v2;
          }
          while ( *v2 );
          i = EndPtr;
        }
        if ( !*v2 )
          break;
        v3 += 2;
        v2 = *v3;
        if ( !*v3 )
          goto LABEL_15;
      }
      i = v4;
      EndPtr = v4;
    }
  }
  else
  {
    v3 = (wchar_t **)&unk_414118;
  }
LABEL_15:
  if ( *v3 )
  {
    v6 = *((_BYTE *)v3 + 4);
    v7 = 0;
    return sub_40DD70(v6, (int)v7);
  }
  switch ( v1 )
  {
    case '-':
      EndPtr = i + 1;
      v6 = byte_435682 != 22 ? 19 : 14;
      v7 = 0;
      return sub_40DD70(v6, (int)v7);
    case '"':
      v7 = sub_40DC2C();
      v6 = 23;
      return sub_40DD70(v6, (int)v7);
    case '[':
      v7 = sub_40DCA7();
      v6 = 24;
      return sub_40DD70(v6, (int)v7);
  }
  if ( iswdigit(v1) )
  {
    v8 = EndPtr;
    *errno() = 0;
    v9 = wcstol(EndPtr, &EndPtr, 0);
    if ( *errno() == 34 )
    {
      v13 = dword_424724;
      *EndPtr = 0;
      sub_405B2C(v13, 0x436u, v8);
    }
    if ( towupper(*EndPtr) == 76 )
      ++EndPtr;
    v7 = (wchar_t *)v9;
    goto LABEL_40;
  }
  if ( !v1 )
  {
    v7 = 0;
    byte_43547F = 1;
    v6 = 0;
    return sub_40DD70(v6, (int)v7);
  }
  if ( !wcsnicmp(EndPtr, L"DEFINED", 7u) )
  {
    EndPtr += 7;
    v10 = sub_40DDDE();
    v7 = (wchar_t *)sub_40E38A(v10);
LABEL_40:
    v6 = 22;
    return sub_40DD70(v6, (int)v7);
  }
  if ( !wcsnicmp(EndPtr, L"EXISTS", 6u) )
  {
    EndPtr += 6;
LABEL_39:
    v11 = sub_40DDDE();
    v7 = (wchar_t *)(waccess(v11, 0) == 0);
    goto LABEL_40;
  }
  if ( !wcsnicmp(EndPtr, L"EXIST", 5u) )
  {
    EndPtr += 5;
    goto LABEL_39;
  }
  return sub_405B2C(dword_424724, 0x3FFu);
}
// 414070: using guessed type wchar_t *off_414070;
// 424724: using guessed type int dword_424724;
// 43547F: using guessed type char byte_43547F;
// 435682: using guessed type char byte_435682;

//----- (0040E1EF) --------------------------------------------------------
int sub_40E1EF()
{
  int *v0; // edx
  int *v1; // esi
  int result; // eax
  int v3; // ecx

  v0 = (int *)dword_435690;
  if ( dword_435690 < (unsigned int)byte_4376A0 )
  {
    sub_405B2C(dword_424724, 0x3FFu);
    v0 = (int *)dword_435690;
  }
  v1 = (int *)dword_43568C;
  if ( dword_43568C > (unsigned int)&unk_437698 )
  {
    sub_405B2C(dword_424724, 0x412u);
    v0 = (int *)dword_435690;
    v1 = (int *)dword_43568C;
  }
  result = *v0;
  v3 = v0[1];
  *v1 = *v0;
  v1[1] = v3;
  dword_43568C = (int)(v1 + 2);
  dword_435690 = (int)(v0 - 2);
  return result;
}
// 424724: using guessed type int dword_424724;
// 43568C: using guessed type int dword_43568C;
// 435690: using guessed type int dword_435690;
// 4376A0: using guessed type unsigned __int8 byte_4376A0[4088];

//----- (0040E260) --------------------------------------------------------
bool sub_40E260()
{
  int v0; // edx
  char *v1; // esi
  char v2; // al
  wchar_t *v3; // ecx
  intptr_t v4; // eax
  char (__stdcall *v5)(char); // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // ecx
  unsigned __int8 *v10; // edx
  unsigned __int8 v11; // bh
  int v12; // eax

  dword_43568C = (int)&unk_4356A0;
  dword_435690 = (int)byte_4376A0;
  byte_43547F = 0;
  byte_43547E = 3;
  byte_435682 = 25;
  sub_40DD70(25, 0);
  v7 = dword_435690;
  v8 = dword_435688;
  *(_DWORD *)dword_435690 = dword_435684;
  *(_DWORD *)(v7 + 4) = v8;
  while ( !byte_43547F )
  {
    sub_40DEFF();
    v9 = dword_435684;
    v10 = (unsigned __int8 *)dword_435690;
    if ( (_BYTE)dword_435684 != 25 )
    {
      while ( 1 )
      {
        v11 = byte_4015C0[(unsigned __int8)v9];
        if ( v11 > (unsigned __int8)byte_4015C0[*v10] )
          break;
        if ( !v11 )
        {
          if ( *v10 != 25 )
          {
            do
            {
              sub_40E1EF();
              v10 = (unsigned __int8 *)dword_435690;
            }
            while ( *(_BYTE *)dword_435690 != 25 );
          }
          if ( v10 < byte_4376A0 )
          {
            sub_405B2C(dword_424724, 0x3FFu);
            v10 = (unsigned __int8 *)dword_435690;
          }
          v7 = (int)(v10 - 8);
          goto LABEL_15;
        }
        sub_40E1EF();
        v10 = (unsigned __int8 *)dword_435690;
        v9 = dword_435684;
      }
    }
    if ( v10 == (unsigned __int8 *)&unk_438698 )
    {
      sub_405B2C(dword_424724, 0x412u);
      v7 = dword_435690;
    }
    else
    {
      v12 = dword_435688;
      v7 = (int)(v10 + 8);
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 4) = v12;
LABEL_15:
      dword_435690 = v7;
    }
  }
  if ( (unsigned __int8 *)v7 != &byte_4376A0[-8] )
    sub_405B2C(dword_424724, 0x3FFu);
  v0 = dword_435690;
  v1 = (char *)&unk_4356A0;
  if ( dword_43568C > (unsigned int)&unk_4356A0 )
  {
    do
    {
      v2 = *v1;
      if ( (unsigned __int8)*v1 <= 0x15u )
      {
        v5 = sub_40DBEE;
        if ( (unsigned __int8)v2 <= 0x12u )
          v5 = sub_40D9A6;
        if ( !v5(v2) )
          sub_405B2C(dword_424724, 0x438u);
        v0 = dword_435690;
      }
      else
      {
        v3 = (wchar_t *)*((_DWORD *)v1 + 1);
        v0 += 8;
        dword_435690 = v0;
        if ( v2 == 24 )
        {
          v4 = sub_40756C(v3, 0, 1, 0, 0);
          v0 = dword_435690;
          *(_DWORD *)(dword_435690 + 4) = v4;
          *(_BYTE *)v0 = 22;
        }
        else
        {
          *(_DWORD *)v0 = *(_DWORD *)v1;
          *(_DWORD *)(v0 + 4) = v3;
        }
      }
      v1 += 8;
    }
    while ( (unsigned int)v1 < dword_43568C );
  }
  if ( (unsigned __int8 *)v0 == byte_4376A0 && *(_BYTE *)v0 == 22 )
    return *(_DWORD *)(v0 + 4) != 0;
  sub_405B2C(dword_424724, 0x3FFu);
  return 0;
}
// 424724: using guessed type int dword_424724;
// 43547E: using guessed type char byte_43547E;
// 43547F: using guessed type char byte_43547F;
// 435682: using guessed type char byte_435682;
// 435684: using guessed type int dword_435684;
// 435688: using guessed type int dword_435688;
// 43568C: using guessed type int dword_43568C;
// 435690: using guessed type int dword_435690;
// 4376A0: using guessed type unsigned __int8 byte_4376A0[4088];

//----- (0040E38A) --------------------------------------------------------
bool __thiscall sub_40E38A(wchar_t *String)
{
  wchar_t *v1; // edi
  wchar_t *Context; // [esp+Ch] [ebp-4h] BYREF

  Context = 0;
  v1 = wcstok_s(String, L" \t", &Context);
  if ( wcstok_s(0, L" \t", &Context) )
    sub_405B2C(dword_424724, 0x409u, v1);
  if ( !v1 )
    sub_405B2C(dword_424724, 0x417u);
  return sub_40B534(v1) != 0;
}
// 424724: using guessed type int dword_424724;

//----- (0040E3F9) --------------------------------------------------------
bool __fastcall sub_40E3F9(wchar_t *String, char a2)
{
  if ( !*String )
    sub_405B2C(dword_424724, 0x3FAu);
  if ( a2 != 4 )
  {
    if ( a2 == 5 )
      return !sub_40E38A(String);
    if ( a2 != 6 )
    {
      if ( a2 != 7 )
      {
        EndPtr = String;
        return sub_40E260();
      }
      return !sub_40E38A(String);
    }
  }
  return sub_40E38A(String);
}
// 424724: using guessed type int dword_424724;

//----- (0040E456) --------------------------------------------------------
void **__fastcall sub_40E456(wchar_t *Destination, rsize_t a2, wchar_t *Str, int a4, LPWIN32_FIND_DATAW lpFindFileData)
{
  void *v5; // eax
  wchar_t *v6; // edi
  const wchar_t *v7; // ebx
  _WORD *v8; // esi
  wchar_t v9; // cx
  char *v10; // edx
  int v11; // ebx
  wchar_t *v12; // ecx
  int v13; // edx
  const wchar_t *v14; // edi
  int v15; // ecx
  __int16 v16; // ax
  const wchar_t *v17; // edi
  wchar_t *v18; // eax
  __int16 v19; // ax
  const wchar_t *v20; // esi
  wchar_t v21; // cx
  int v22; // esi
  wchar_t *v23; // edi
  wchar_t *v24; // eax
  int v25; // eax
  const wchar_t *v26; // edi
  int v27; // esi
  wchar_t *v28; // edi
  wchar_t v29; // cx
  wchar_t v30; // dx
  int v31; // eax
  int v32; // esi
  rsize_t v33; // ebx
  const wchar_t *v34; // eax
  int v35; // ebx
  wchar_t *v36; // eax
  int v37; // edi
  _DWORD *v38; // eax
  DWORD v40; // ecx
  DWORD v41; // edx
  wchar_t *v42; // [esp+14h] [ebp-28h]
  int v43; // [esp+14h] [ebp-28h]
  char *v44; // [esp+1Ch] [ebp-20h]
  void **v45; // [esp+28h] [ebp-14h]
  int v46; // [esp+2Ch] [ebp-10h]
  int v47; // [esp+2Ch] [ebp-10h]
  wchar_t *Source; // [esp+30h] [ebp-Ch]

  v5 = dword_424714;
  v45 = (void **)dword_424714;
  v6 = Destination;
  if ( !dword_424714 )
    return 0;
  while ( 1 )
  {
    Source = (wchar_t *)*((_DWORD *)v5 + 2);
    v42 = wcsrchr(Source, 0x2Eu);
    if ( sub_411AA4(v42, a4) )
      goto LABEL_88;
    v7 = Source + 1;
    *v6 = 0;
    v8 = Source + 1;
    if ( !Source[1] )
      break;
    v9 = *v7;
    while ( v9 != 123 )
    {
      if ( v9 == 94 )
      {
        ++v8;
      }
      else if ( v9 == 34 )
      {
        do
          ++v8;
        while ( *v8 != 34 );
      }
      v9 = *++v8;
      if ( !*v8 )
        goto LABEL_36;
    }
    v10 = (char *)v8;
    do
    {
      if ( v9 == 125 )
        break;
      if ( v9 == 94 )
        v10 += 2;
      v10 += 2;
      v9 = *(_WORD *)v10;
    }
    while ( *(_WORD *)v10 );
    v44 = v10;
    v11 = (v10 - (char *)v8 - 2) >> 1;
    v12 = Str;
    v13 = v11;
    v46 = v11;
    if ( *Str == 34 )
      v12 = Str + 1;
    v14 = v8 + 1;
    if ( v11 )
    {
      v15 = (char *)v12 - (char *)v14;
      v43 = v15;
      do
      {
        if ( *v14 == 92 || *v14 == 47 )
        {
          v16 = *(const wchar_t *)((char *)v14 + v15);
          if ( v16 != 92 && v16 != 47 )
            goto LABEL_87;
        }
        else
        {
          if ( wcsnicmp(v14, (const wchar_t *)((char *)v14 + v15), 1u) )
            goto LABEL_87;
          v15 = v43;
          v13 = v46;
        }
        --v13;
        ++v14;
        v46 = v13;
      }
      while ( v13 );
    }
    v42 = v8;
    v17 = &Str[v11 + 1];
    v18 = wcschr(v17, 0x5Cu);
    if ( !v18 )
    {
      v18 = wcschr(v17, 0x2Fu);
      if ( !v18 )
      {
        v6 = Destination;
LABEL_35:
        v7 = Source + 1;
        break;
      }
    }
    if ( v18 != v17 || (v19 = *((_WORD *)v44 - 1), v19 == 92) )
    {
LABEL_87:
      v6 = Destination;
      goto LABEL_88;
    }
    v6 = Destination;
    if ( v19 != 47 )
      goto LABEL_35;
LABEL_88:
    v5 = *v45;
    v45 = (void **)v5;
    if ( !v5 )
      return 0;
  }
LABEL_36:
  if ( *Source == 123 )
  {
    v20 = v7;
    if ( *v7 )
    {
      v21 = *v7;
      do
      {
        if ( v21 == 125 )
          break;
        if ( v21 == 94 )
          ++v20;
        v21 = *++v20;
      }
      while ( *v20 );
      v6 = Destination;
    }
    v22 = v20 - v7;
    if ( v22 )
    {
      wcsncpy_s(v6, a2, v7, v22);
      v7 += v22;
      if ( *(v7 - 1) != 92 )
        v6[v22++] = 92;
    }
    else if ( *Str == 34 )
    {
      v22 = 3;
      wcsncpy_s(v6, a2, L"\".\\", 3u);
    }
    else
    {
      v22 = 2;
      wcsncpy_s(v6, a2, L".\\", 2u);
    }
    Source = (wchar_t *)(v7 + 1);
    v23 = wcsrchr(Str, 0x5Cu);
    v24 = wcsrchr(Str, 0x2Fu);
    if ( v24 > v23 )
      v23 = v24;
    if ( v23 )
    {
      wcscpy_s(&Destination[v22], a2 - v22, v23 + 1);
      v25 = a4 - (_DWORD)v23 - 2;
    }
    else
    {
      v26 = Str + 1;
      if ( *Str != 34 )
        v26 = Str;
      wcscpy_s(&Destination[v22], a2 - v22, v26);
      v25 = a4 - (_DWORD)v26;
    }
    v27 = (v25 >> 1) + v22;
    goto LABEL_76;
  }
  if ( *v8 )
  {
    v28 = wcsrchr(Str, 0x2Eu);
    v29 = *v28;
    if ( *v28 == 58 )
    {
LABEL_65:
      if ( v29 == 58 )
      {
LABEL_68:
        ++v28;
        goto LABEL_70;
      }
    }
    else
    {
      v30 = *v28;
      while ( 1 )
      {
        v29 = v30;
        if ( v30 == 92 )
          break;
        v29 = v30;
        if ( v30 != 47 )
        {
          v29 = v30;
          if ( v28 > Str )
          {
            v30 = *--v28;
            v29 = *v28;
            if ( *v28 != 58 )
              continue;
          }
        }
        goto LABEL_65;
      }
    }
    if ( v29 != 92 && v29 != 47 )
      goto LABEL_70;
    goto LABEL_68;
  }
  v28 = Str;
LABEL_70:
  v31 = 0;
  v47 = 0;
  v32 = (a4 - (int)v28) >> 1;
  if ( v28 != Str && *Str == 34 )
  {
    *Destination = 34;
    v31 = 1;
    v47 = 1;
  }
  v33 = a2 - v31;
  if ( v32 >= (int)(a2 - v31) )
  {
    sub_405B2C(0, 0x434u);
    v31 = v47;
  }
  wcsncpy_s(&Destination[v31], v33, v28, v32);
  v27 = v47 + v32;
LABEL_76:
  v34 = Source;
  v35 = v42 - Source;
  if ( v35 >= (int)(a2 - v27) )
  {
    sub_405B2C(0, 0x434u);
    v34 = Source;
  }
  v6 = Destination;
  wcsncpy_s(&Destination[v27], a2 - v27, v34, v35);
  if ( *Destination == 34 )
  {
    v36 = Destination;
    v37 = v35 + v27;
    if ( Destination[v35 - 1 + v27] != 34 )
    {
      if ( (int)(a2 - v35 - v27) <= 1 )
        sub_405B2C(0, 0x434u);
      v36 = Destination;
      ++v35;
      Destination[v37] = 34;
    }
    v6 = v36;
  }
  v6[v35 + v27] = 0;
  v38 = sub_40EE2D(v6, 0, 0);
  if ( !v38 )
  {
    if ( sub_4084F3(v6, lpFindFileData) )
      return v45;
    goto LABEL_88;
  }
  v40 = v38[4];
  v41 = v38[5];
  lpFindFileData->ftCreationTime.dwLowDateTime = v40;
  lpFindFileData->ftCreationTime.dwHighDateTime = v41;
  lpFindFileData->ftLastWriteTime.dwLowDateTime = v40;
  lpFindFileData->ftLastWriteTime.dwHighDateTime = v41;
  return v45;
}
// 402614: using guessed type wchar_t asc_402614[4];

//----- (0040E8BD) --------------------------------------------------------
void sub_40E8BD()
{
  int v0; // eax
  char *v1; // esi
  wchar_t *v2; // edx
  _WORD *v3; // ecx
  char *v5; // ebx
  int v6; // edx
  const wchar_t *v7; // edi
  int v8; // ecx
  int v9; // eax
  void **v10; // ecx
  _DWORD *v11; // ebx
  _DWORD *v12; // edx
  const wchar_t *v13; // edi
  _DWORD *v14; // edi
  int *v15; // esi
  void **v16; // edx
  void **v17; // ecx
  int v18; // edi
  char *v19; // ebx
  wchar_t *String1; // [esp+Ch] [ebp-1Ch]
  int *v21; // [esp+10h] [ebp-18h]
  int v22; // [esp+14h] [ebp-14h]
  char *v23; // [esp+18h] [ebp-10h]
  int *v24; // [esp+1Ch] [ebp-Ch] BYREF
  const wchar_t **v25; // [esp+20h] [ebp-8h] BYREF
  void *Block; // [esp+24h] [ebp-4h]

  v0 = dword_424720;
  v24 = 0;
  v21 = (int *)dword_424720;
  v1 = (char *)dword_424714;
  v23 = (char *)dword_424714;
  for ( dword_424714 = 0; v0; v21 = (int *)v0 )
  {
    v2 = *(wchar_t **)(v0 + 4);
    String1 = v2;
    v3 = v2 + 1;
    while ( *v2++ )
      ;
    v5 = v1;
    v6 = v2 - v3;
    v22 = v6;
    for ( Block = v1; v5; v6 = v22 )
    {
      v7 = (const wchar_t *)*((_DWORD *)v5 + 2);
      v25 = (const wchar_t **)(v5 + 8);
      if ( *v7 == 123 )
      {
        LOWORD(v8) = 123;
        do
        {
          if ( (_WORD)v8 == 94 )
            ++v7;
          v8 = *++v7;
        }
        while ( v8 != 125 );
        ++v7;
      }
      if ( !wcsnicmp(String1, v7, v6) && ((v9 = v7[v22], v9 == 46) || (_WORD)v9 == 123) )
      {
        v10 = (void **)Block;
        v11 = Block;
        v12 = (_DWORD *)*((_DWORD *)Block + 1);
        if ( v12 )
        {
          *v12 = *(_DWORD *)Block;
        }
        else
        {
          v1 = *(char **)Block;
          v23 = *(char **)Block;
        }
        if ( *v10 )
          *((_DWORD *)*v10 + 1) = v10[1];
        Block = *v10;
        *v11 = 0;
        v13 = (const wchar_t *)dword_424714;
        if ( dword_424714 )
        {
          while ( wcsicmp(*((const wchar_t **)v13 + 2), *v25) )
          {
            v13 = *(const wchar_t **)v13;
            if ( !v13 )
              goto LABEL_22;
          }
          free((void *)*v25);
          while ( 1 )
          {
            v18 = v11[3];
            if ( !v18 )
              break;
            v11[3] = *(_DWORD *)v18;
            free(*(void **)(v18 + 4));
            *(_DWORD *)v18 = dword_435698;
            dword_435698 = v18;
          }
          free(v11);
        }
        else
        {
LABEL_22:
          v14 = (_DWORD *)v11[3];
          if ( v14 )
          {
            v15 = (int *)v25;
            do
            {
              v25 = (const wchar_t **)v14[1];
              byte_4386AC = *((_BYTE *)v11 + 20);
              if ( byte_4386AC )
                dword_4386B0 = *v15;
              sub_40F012((wint_t **)&v25, &v24, 0, 0, 0, 0, 0, 0);
              v14 = (_DWORD *)*v14;
              byte_4386AC = 0;
            }
            while ( v14 );
            v1 = v23;
          }
          v16 = &dword_424714;
          v11[4] = v24;
          v24 = 0;
          v17 = (void **)dword_424714;
          if ( dword_424714 )
          {
            do
            {
              v16 = v17;
              v17 = (void **)*v17;
            }
            while ( v17 );
          }
          *v16 = v11;
        }
        v5 = (char *)Block;
      }
      else
      {
        v5 = *(char **)v5;
        Block = v5;
      }
    }
    v0 = *v21;
  }
  if ( v1 )
  {
    v19 = v1;
    do
    {
      if ( (byte_41450C & 1) != 0 )
        sub_405B2C(0, 0xFA5u, *((_DWORD *)v1 + 2));
      free(*((void **)v1 + 2));
      sub_405322(*((_DWORD **)v1 + 3));
      sub_405322(*((_DWORD **)v1 + 4));
      v1 = *(char **)v1;
      free(v19);
      v19 = v1;
    }
    while ( v1 );
  }
}
// 41450C: using guessed type char byte_41450C;
// 424720: using guessed type int dword_424720;
// 435698: using guessed type int dword_435698;
// 4386AC: using guessed type char byte_4386AC;
// 4386B0: using guessed type int dword_4386B0;

//----- (0040EADD) --------------------------------------------------------
void **__fastcall sub_40EADD(
        int a1,
        wchar_t *a2,
        int a3,
        unsigned __int64 a4,
        _DWORD **a5,
        _DWORD *a6,
        _DWORD *a7,
        _DWORD *a8,
        wchar_t **a9)
{
  wchar_t *v11; // eax
  __int64 v12; // rax
  _DWORD *v13; // esi
  char v14; // dl
  int v15; // eax
  int v16; // eax
  unsigned int v17; // edx
  unsigned int v18; // ecx
  _DWORD *v19; // esi
  _DWORD *v20; // edx
  _DWORD *v21; // esi
  _DWORD *v22; // ebx
  unsigned int v23; // esi
  int v24; // eax
  void **result; // eax
  const wchar_t *v26; // [esp-8h] [ebp-298h]
  __int64 v27; // [esp+10h] [ebp-280h] BYREF
  _DWORD *v28; // [esp+1Ch] [ebp-274h] BYREF
  int v29; // [esp+20h] [ebp-270h]
  _DWORD *v30; // [esp+24h] [ebp-26Ch]
  _DWORD *v31; // [esp+28h] [ebp-268h]
  _DWORD **v32; // [esp+2Ch] [ebp-264h]
  _DWORD *v33; // [esp+30h] [ebp-260h]
  void **v34; // [esp+34h] [ebp-25Ch]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+38h] [ebp-258h] BYREF

  v32 = a5;
  v30 = a6;
  v26 = *(const wchar_t **)(a1 + 4);
  v31 = a7;
  v33 = a8;
  v11 = wcsrchr(v26, 0x2Eu);
  if ( !v11 )
    return 0;
  v34 = sub_40E456(a2, 0x101u, *(wchar_t **)(a1 + 4), (int)v11, &FindFileData);
  if ( !v34 )
    return 0;
  v12 = sub_40823C((char *)&FindFileData);
  *a9 = a2;
  v13 = v30;
  v27 = v12;
  while ( 1 )
  {
    v13 = (_DWORD *)*v13;
    if ( !v13 )
      break;
    if ( !wcsicmp((const wchar_t *)v13[1], a2) )
    {
      *(_BYTE *)(a1 + 8) &= ~1u;
      break;
    }
  }
  v14 = *(_BYTE *)(a1 + 8);
  v28 = 0;
  v15 = sub_403F66(a2, v14, (unsigned int *)&v27, 0, &v28);
  v29 = v15;
  if ( v28 )
  {
    v16 = sub_405594(v28);
    v29 += v16;
    sub_4055B2(&v28);
    v15 = v29;
  }
  v17 = v27;
  *v31 += v15;
  v18 = HIDWORD(v27);
  if ( (*(_BYTE *)(a1 + 8) & 0x10) != 0
    || a4 < __PAIR64__(HIDWORD(v27), v17)
    || byte_424736 && a4 == __PAIR64__(HIDWORD(v27), v17) )
  {
    if ( !v13 )
    {
      v19 = sub_40EC89();
      v19[1] = sub_40ECDB((char *)a2);
      v20 = v19;
      v21 = v32;
      sub_40EDE0(v32, v20);
      v17 = v27;
      if ( !*v30 )
        *v30 = *v21;
      v18 = HIDWORD(v27);
    }
    if ( (*(_BYTE *)(a1 + 8) & 0x11) == 1 )
    {
      sub_405C06(3u, a2, *(_DWORD *)(a1 + 4));
      v18 = HIDWORD(v27);
      v17 = v27;
    }
  }
  v22 = v33;
  v23 = v33[1];
  v24 = *v33;
  if ( *(_QWORD *)v33 <= __PAIR64__(v18, v17) )
  {
    v24 = v17;
    v23 = v18;
  }
  *v33 = v24;
  result = v34;
  v22[1] = v23;
  return result;
}
// 424736: using guessed type char byte_424736;

//----- (0040EC89) --------------------------------------------------------
_DWORD *sub_40EC89()
{
  _DWORD *v0; // edx
  int v1; // esi
  _DWORD *result; // eax

  v0 = (_DWORD *)dword_435698;
  if ( dword_435698 )
  {
    dword_435698 = *(_DWORD *)dword_435698;
  }
  else
  {
    v1 = dword_4386A4;
    if ( (unsigned int)dword_4386A4 >= 8 )
    {
      v0 = (_DWORD *)dword_4386A0;
    }
    else
    {
      v1 = 0x8000;
      v0 = sub_40B5D9(0x8000u);
    }
    dword_4386A0 = (int)(v0 + 2);
    dword_4386A4 = v1 - 8;
  }
  *v0 = 0;
  result = v0;
  v0[1] = 0;
  return result;
}
// 435698: using guessed type int dword_435698;
// 4386A0: using guessed type int dword_4386A0;
// 4386A4: using guessed type int dword_4386A4;

//----- (0040ECDB) --------------------------------------------------------
void *__thiscall sub_40ECDB(char *Src)
{
  char *v2; // edi
  char *v3; // ecx
  __int16 v4; // ax
  int v5; // edi
  void *v6; // esi

  v2 = Src;
  v3 = Src + 2;
  do
  {
    v4 = *(_WORD *)v2;
    v2 += 2;
  }
  while ( v4 );
  v5 = ((v2 - v3) >> 1) + 1;
  v6 = sub_40B5D9((unsigned __int64)(unsigned int)v5 >> 31 != 0 ? -1 : 2 * v5);
  memcpy(v6, Src, 2 * v5);
  return v6;
}

//----- (0040ED1F) --------------------------------------------------------
_WORD *__thiscall sub_40ED1F(char *this)
{
  char *v1; // ebx
  char *v2; // ecx
  __int16 v3; // ax
  int v4; // ebx
  _WORD *v5; // edi

  v1 = this;
  v2 = this + 2;
  do
  {
    v3 = *(_WORD *)v1;
    v1 += 2;
  }
  while ( v3 );
  v4 = (v1 - v2) >> 1;
  v5 = sub_40B5D9((unsigned __int64)(unsigned int)(v4 + 3) >> 31 != 0 ? -1 : 2 * (v4 + 3));
  *v5 = 34;
  memcpy(v5 + 1, this, 2 * v4);
  v5[v4 + 1] = 34;
  v5[v4 + 2] = 0;
  return v5;
}

//----- (0040ED85) --------------------------------------------------------
wchar_t *__fastcall sub_40ED85(char *Block, const wchar_t *a2)
{
  char *v3; // esi
  char *v4; // ecx
  __int16 v5; // ax
  int v6; // esi
  const wchar_t *v7; // ecx
  int v8; // esi
  const wchar_t *v9; // edx
  unsigned int v11; // edi
  wchar_t *v12; // esi

  v3 = Block;
  v4 = Block + 2;
  do
  {
    v5 = *(_WORD *)v3;
    v3 += 2;
  }
  while ( v5 );
  v6 = v3 - v4;
  v7 = a2;
  v8 = v6 >> 1;
  v9 = a2 + 1;
  while ( *v7++ )
    ;
  v11 = v8 + v7 - v9 + 1;
  v12 = (wchar_t *)sub_403D5C(Block, v11);
  wcscat_s(v12, v11, a2);
  return v12;
}

//----- (0040EDE0) --------------------------------------------------------
_DWORD *__fastcall sub_40EDE0(_DWORD **a1, _DWORD *a2)
{
  _DWORD *v2; // esi
  _DWORD *result; // eax

  v2 = *a1;
  if ( *a1 )
  {
    do
    {
      result = (_DWORD *)*v2;
      a1 = (_DWORD **)v2;
      v2 = result;
    }
    while ( result );
  }
  *a1 = a2;
  return result;
}

//----- (0040EDF5) --------------------------------------------------------
int __thiscall sub_40EDF5(wint_t *this, int a2)
{
  char v3; // si
  char v4; // al

  v3 = 0;
  while ( *this )
  {
    if ( *this == 47 )
      v4 = 92;
    else
      v4 = towupper(*this);
    v3 += v4;
    ++this;
  }
  return v3 & 0x7F;
}

//----- (0040EE2D) --------------------------------------------------------
_DWORD *__thiscall sub_40EE2D(wchar_t *Source, int a2, int a3)
{
  int v4; // eax
  _DWORD *result; // eax
  int v6; // ecx
  wchar_t *v7; // esi
  rsize_t v9; // esi
  wchar_t *v10; // ebx
  wchar_t *v11; // esi
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  _DWORD *v15; // esi
  int v16; // ecx
  wchar_t *v17; // ebx
  wchar_t *v18; // esi
  rsize_t v20; // esi
  int v21; // eax
  _DWORD *v22; // [esp+10h] [ebp-8h]
  char v23; // [esp+17h] [ebp-1h]

  v23 = 0;
  if ( !*Source )
    return 0;
  v4 = sub_40EDF5(Source, (int)Source);
  result = sub_4119EC(Source, v4);
  if ( !result )
  {
    if ( !wcsncmp(Source, L".\\", 2u) || !wcsncmp(Source, L"./", 2u) )
    {
      v11 = Source + 2;
      v10 = Source + 2;
    }
    else
    {
      v7 = Source;
      while ( *v7++ )
        ;
      v9 = v7 - (Source + 1) + 3;
      v10 = (wchar_t *)sub_40B5D9((unsigned __int64)v9 >> 31 != 0 ? -1 : 2 * v9);
      wcscpy_s(v10, v9, L".\\");
      wcscat_s(v10, v9, Source);
      v23 = 1;
      v11 = Source + 2;
    }
    v12 = sub_40EDF5(v10, v6);
    result = sub_4119EC(v10, v12);
    v22 = result;
    if ( result )
    {
      if ( v23 )
      {
        free(v10);
        return v22;
      }
    }
    else
    {
      if ( v10 != v11 )
        v10[1] = 47;
      v14 = sub_40EDF5(v10, v13);
      v15 = sub_4119EC(v10, v14);
      if ( v23 )
        free(v10);
      if ( !v15 )
      {
        if ( *Source == 34 )
        {
          v17 = sub_411BBE(Source);
        }
        else
        {
          v18 = Source;
          while ( *v18++ )
            ;
          v20 = v18 - (Source + 1) + 3;
          v17 = (wchar_t *)sub_40B5D9((unsigned __int64)v20 >> 31 != 0 ? -1 : 2 * v20);
          wcscpy_s(v17, v20, ::Source);
          wcscat_s(v17, v20, Source);
          wcscat_s(v17, v20, ::Source);
        }
        v21 = sub_40EDF5(v17, v16);
        v15 = sub_4119EC(v17, v21);
        free(v17);
      }
      return v15;
    }
  }
  return result;
}
// 40EEDE: variable 'v6' is possibly undefined
// 40EF1A: variable 'v13' is possibly undefined
// 40EFAF: variable 'v16' is possibly undefined

//----- (0040EFD4) --------------------------------------------------------
bool __fastcall sub_40EFD4(__int16 a1)
{
  int v1; // esi
  const wchar_t *v2; // eax
  const wchar_t *v3; // edx
  int v4; // eax

  v1 = 3;
  v2 = 0;
  v3 = L" \t\n";
  if ( a1 == 32 )
  {
LABEL_4:
    v2 = v3;
  }
  else
  {
    while ( v1 != 1 )
    {
      ++v3;
      --v1;
      if ( *v3 == a1 )
        goto LABEL_4;
    }
  }
  if ( v2 )
    v4 = v2 - L" \t\n";
  else
    v4 = -1;
  return v4 != -1;
}

//----- (0040F012) --------------------------------------------------------
char __fastcall sub_40F012(
        wint_t **a1,
        int **a2,
        void **a3,
        const unsigned __int16 *a4,
        int a5,
        int a6,
        int a7,
        char a8)
{
  wint_t **v8; // edi
  int *v9; // ecx
  _DWORD *i; // ecx
  wint_t *v11; // ecx
  wint_t v12; // si
  wint_t *v13; // edx
  char v14; // dl
  wint_t *v15; // eax
  bool v16; // zf
  wint_t *v17; // eax
  wint_t *v18; // ecx
  int v19; // eax
  wint_t *v20; // eax
  void *v21; // esp
  wchar_t *v22; // edi
  wchar_t **v23; // esi
  unsigned int v24; // ecx
  unsigned int v25; // edi
  int *v26; // edi
  int v27; // esi
  int v28; // eax
  int v29; // ecx
  _DWORD *v30; // eax
  void *v31; // eax
  void **v32; // esi
  char v33; // al
  _BYTE *v34; // edi
  int v35; // eax
  int v36; // eax
  wchar_t v38[6]; // [esp+0h] [ebp-240h] BYREF
  int v39[2]; // [esp+Ch] [ebp-234h] BYREF
  const unsigned __int16 *v40; // [esp+14h] [ebp-22Ch]
  int **v41; // [esp+18h] [ebp-228h]
  wint_t **v42; // [esp+1Ch] [ebp-224h]
  void *v43; // [esp+20h] [ebp-220h] BYREF
  bool v44; // [esp+27h] [ebp-219h] BYREF
  void *v45; // [esp+28h] [ebp-218h] BYREF
  char v46; // [esp+2Eh] [ebp-212h]
  bool v47; // [esp+2Fh] [ebp-211h]
  wchar_t v48[2]; // [esp+30h] [ebp-210h] BYREF
  __int16 v49[4]; // [esp+234h] [ebp-Ch] BYREF

  v8 = a1;
  v41 = a2;
  v40 = a4;
  v42 = a1;
  v47 = 0;
  if ( a2 )
  {
    if ( a3 )
    {
      v45 = *a3;
    }
    else
    {
      v9 = *a2;
      v45 = v9;
      if ( v9 )
      {
        for ( i = (_DWORD *)*v9; i; i = (_DWORD *)*i )
          v45 = i;
      }
    }
  }
  else
  {
    v45 = 0;
  }
  v11 = *v8;
  if ( !**v8 )
    return 1;
  v12 = **v8;
  v13 = *v8;
  while ( 1 )
  {
    if ( v12 == 36 )
      goto LABEL_23;
    if ( v12 == 34 )
    {
      v14 = !v47;
      v47 = !v47;
    }
    else
    {
      v14 = v47;
    }
    if ( a8 && (v12 == 44 || v12 == 41) )
      break;
    if ( !v14 && v12 == 94 )
    {
      *v8 = v11 + 1;
      if ( v11[1] == 34 )
        v47 = 1;
    }
    v11 = *v8 + 1;
    *v8 = v11;
    v13 = v11;
    v12 = *v11;
    if ( !*v11 )
    {
LABEL_23:
      if ( !*v13 )
        return 1;
      v46 = a7 & 4;
      if ( !v13[1] )
      {
        if ( (a7 & 4) != 0 )
          goto LABEL_106;
        sub_405B2C(dword_424730, 0x3EAu);
        v46 = 0;
      }
      v15 = *v8 + 1;
      v16 = !v47;
      *v8 = v15;
      if ( v16 && *v15 == 94 )
      {
        v17 = v15 + 1;
        *v8 = v17;
        if ( !sub_403B50(*v17) && v46 )
          goto LABEL_106;
        sub_405B2C(dword_424730, 0x3E9u, **v8);
      }
      v18 = *v8;
      v19 = **v8;
      if ( (_WORD)v19 == 36 )
      {
        *v8 = sub_40F8B3(v18);
      }
      else
      {
        v43 = 0;
        v44 = 0;
        if ( v19 == 40 )
        {
          v20 = sub_40F779((__int16 *)v18 + 1, v48, &v44, (int *)&v43);
          v16 = !v44;
          *v8 = v20;
          if ( !v16 )
          {
            v22 = (wchar_t *)v43;
            v23 = &off_4015E0;
            while ( v23[1] != v22 || sub_411F28((char *)*v23, (char *)v48, (int)v23[1]) )
            {
              v23 += 4;
              if ( v23 == (wchar_t **)L"DFBR" )
              {
                if ( v46 )
                  goto LABEL_106;
                sub_405B2C(dword_424730, 0x450u, v48);
                goto LABEL_46;
              }
            }
            v24 = (unsigned int)v23[2];
            if ( !v24 )
            {
LABEL_46:
              v8 = v42;
              --*v42;
              goto LABEL_100;
            }
            v25 = 1;
            while ( 1 )
            {
              v43 = (void *)v25;
              if ( !sub_40F606(v42, v41, &v45, v40, a5, a6, a7, (int)*v23, *((_BYTE *)v23 + v25 + 11), v25, v24) )
                break;
              v24 = (unsigned int)v23[2];
              ++v25;
              if ( (unsigned int)v43 >= v24 )
                goto LABEL_46;
            }
LABEL_106:
            if ( a3 )
              *a3 = v45;
            return 0;
          }
          if ( !wcschr(L"*@<?", v48[0]) )
            goto LABEL_61;
          if ( byte_4386AC && (byte_41450C & 0x40) == 0 )
          {
            v21 = alloca(2 * ((_DWORD)v43 + 4));
            sub_4121AD(v38, (size_t)v43 + 4, (wchar_t *)L"$(%s)", v48);
            sub_405B2C(0, 0x44Cu, v38, dword_4386B0);
            goto LABEL_61;
          }
        }
        else
        {
          if ( !wcschr(L"*@<?", v19) )
            goto LABEL_57;
          if ( byte_4386AC && (byte_41450C & 0x40) == 0 && **v8 != 60 )
          {
            v49[1] = **v8;
            v49[2] = 0;
            v49[0] = 36;
            sub_405B2C(0, 0x44Cu, v49, dword_4386B0);
LABEL_57:
            if ( !sub_403B50(**v8) )
            {
              if ( v46 )
                goto LABEL_106;
              sub_405B2C(dword_424730, 0x3EAu);
            }
            v48[0] = **v8;
            v48[1] = 0;
LABEL_61:
            v39[0] = 0;
            v39[1] = 0;
            if ( v41 )
              v26 = sub_40EC89();
            else
              v26 = v39;
            v27 = sub_40B534(v48);
            v43 = (void *)v27;
            if ( v27 )
            {
              if ( v40 )
              {
                v28 = wcscmp(v40, v48);
                if ( v28 )
                  v28 = v28 < 0 ? -1 : 1;
                if ( !v28 )
                {
                  v29 = a5;
                  v30 = *(_DWORD **)(v27 + 8);
                  if ( a5 == a6 )
                  {
LABEL_72:
                    if ( !v30 )
                      goto LABEL_74;
                    v31 = (void *)v30[1];
                  }
                  else
                  {
                    while ( v30 )
                    {
                      v30 = (_DWORD *)*v30;
                      if ( --v29 == a6 )
                        goto LABEL_72;
                    }
LABEL_74:
                    v31 = sub_40ECDB((char *)&dword_4017DC);
                  }
                  v32 = (void **)(v26 + 1);
LABEL_83:
                  *v32 = v31;
LABEL_84:
                  if ( !*v32 )
                    sub_405B2C(dword_424730, 0x410u);
                  if ( v41 )
                  {
                    if ( v45 )
                      *(_DWORD *)v45 = v26;
                    else
                      *v41 = v26;
                    v45 = v26;
                  }
                  v34 = v43;
                  if ( v43 && wcschr((const wchar_t *)*v32, 0x24u) )
                  {
                    v34[12] |= 1u;
                    v43 = *v32;
                    if ( !v40 )
                      goto LABEL_97;
                    v35 = wcscmp(v40, v48);
                    if ( v35 )
                      v35 = v35 < 0 ? -1 : 1;
                    v16 = v35 == 0;
                    v36 = a5;
                    if ( v16 )
LABEL_97:
                      v36 = a6;
                    sub_40F012((wint_t **)&v43, v41, &v45, v48, a5 + 1, v36, a7, 0);
                    v34[12] &= ~1u;
                  }
                  v8 = v42;
LABEL_100:
                  if ( a3 )
                    *a3 = v45;
                  goto LABEL_102;
                }
              }
              v33 = *(_BYTE *)(v27 + 12);
              if ( (v33 & 1) != 0 )
              {
                if ( v46 )
                  goto LABEL_106;
                sub_405B2C(dword_424730, 0x42Eu, v48);
                v32 = (void **)(v26 + 1);
                goto LABEL_84;
              }
              v32 = (void **)(v26 + 1);
              if ( (v33 & 0x10) == 0 )
              {
                v31 = *(void **)(*((_DWORD *)v43 + 2) + 4);
                goto LABEL_83;
              }
            }
            else
            {
              v32 = (void **)(v26 + 1);
            }
            v31 = sub_40ECDB((char *)&dword_4017DC);
            goto LABEL_83;
          }
        }
      }
LABEL_102:
      v11 = *v8 + 1;
      *v8 = v11;
      v13 = v11;
      v12 = *v11;
      if ( !*v11 )
        return 1;
    }
  }
  if ( a3 )
    *a3 = v45;
  return 1;
}
// 4015E0: using guessed type wchar_t *off_4015E0;
// 4017DC: using guessed type int dword_4017DC;
// 41450C: using guessed type char byte_41450C;
// 424730: using guessed type int dword_424730;
// 4386AC: using guessed type char byte_4386AC;
// 4386B0: using guessed type int dword_4386B0;
// 40F012: using guessed type int *var_218;
// 40F012: using guessed type wint_t *var_220;

//----- (0040F606) --------------------------------------------------------
char __fastcall sub_40F606(
        wint_t **this,
        int **edx0,
        void **a2,
        const unsigned __int16 *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        char a8,
        unsigned int a9,
        unsigned int a10)
{
  wint_t *v12; // esi
  char v13; // bl
  __int16 v14; // cx
  int v15; // ebx
  __int16 v16; // cx
  __int16 v18; // [esp+10h] [ebp-8h]

  v12 = *this;
  if ( !sub_40F012(this, edx0, a2, a3, a4, a5, a6, 1) )
    return 0;
  if ( !a8 && *this == v12 )
  {
    if ( (a6 & 4) != 0 )
      return 0;
    sub_405B2C(dword_424730, 0x44Eu, a9, a7);
  }
  v13 = a6 & 4;
  if ( !**this )
  {
    if ( v13 )
      return 0;
    sub_405B2C(dword_424730, 0x3E8u);
    v13 = 0;
  }
  v14 = *(*this)++;
  v18 = v14;
  if ( v14 != 44 && v14 != 41 )
  {
    if ( v13 )
      return 0;
    sub_405B2C(dword_424730, 0x3E8u);
    v14 = v18;
  }
  if ( a9 >= a10 )
  {
    if ( a9 != a10 || v14 == 41 )
      return 1;
    if ( !v13 )
    {
      v15 = 0;
      do
      {
        ++v15;
        sub_40F012(this, edx0, a2, a3, a4, a5, a6, 1);
        if ( !**this )
          sub_405B2C(dword_424730, 0x3E8u);
        v16 = *(*this)++;
      }
      while ( v16 == 44 );
      sub_405B2C(dword_424730, 0x44Fu, a7, a10, v15 + a10);
      return 1;
    }
  }
  else
  {
    if ( v14 == 44 )
      return 1;
    if ( !v13 )
    {
      sub_405B2C(dword_424730, 0x44Fu, a7, a10, a9);
      return 1;
    }
  }
  return 0;
}
// 424730: using guessed type int dword_424730;

//----- (0040F779) --------------------------------------------------------
wint_t *__fastcall sub_40F779(__int16 *a1, wint_t *a2, bool *a3, int *a4)
{
  wint_t *v4; // esi
  wint_t *v5; // ebx
  wint_t *v6; // edi
  __int16 v7; // cx
  __int16 v8; // cx
  wint_t v9; // ax
  int v10; // eax
  int *v11; // ebx
  wint_t v12; // di
  bool v13; // al
  wint_t v14; // cx
  wint_t v15; // dx
  wint_t v16; // ax

  v4 = (wint_t *)a1;
  v5 = a2;
  v6 = a2;
  if ( *a1 )
  {
    v7 = *a1;
    do
    {
      if ( v7 == 41 || v7 == 58 || sub_40EFD4(v7) )
        break;
      if ( v8 == 94 && !sub_403B50(*++v4) )
        sub_405B2C(dword_424730, 0x3E9u, *v4);
      v9 = *v4++;
      *v6++ = v9;
      v7 = *v4;
    }
    while ( *v4 );
    v5 = a2;
  }
  v10 = (char *)v6 - (char *)v5;
  v11 = a4;
  *a4 = v10 >> 1;
  *v6 = 0;
  v12 = *v4;
  v13 = sub_40EFD4(*v4);
  *a3 = v13;
  if ( v13 )
  {
    do
    {
      if ( !*++v4 )
        sub_405B2C(dword_424730, 0x410u);
    }
    while ( sub_40EFD4(*v4) );
  }
  else
  {
    v14 = v12;
    if ( v12 != 41 )
    {
      v15 = v12;
      do
      {
        v16 = v15;
        if ( v15 == 94 )
          v16 = *++v4;
        v14 = v16;
        if ( !v16 )
          break;
        v15 = *++v4;
        v14 = *v4;
      }
      while ( *v4 != 41 );
      v11 = a4;
    }
    if ( v14 != 41 )
      sub_405B2C(dword_424730, 0x3E8u);
    if ( (unsigned int)*v11 > 0x101 )
      sub_405B2C(dword_424730, 0x434u);
  }
  return v4;
}
// 40F7B0: variable 'v8' is possibly undefined
// 424730: using guessed type int dword_424730;

//----- (0040F8B3) --------------------------------------------------------
_WORD *__thiscall sub_40F8B3(_WORD *this)
{
  int v2; // eax
  _WORD *result; // eax
  int v4; // eax
  __int16 v5; // ax
  int v6; // eax
  __int16 v7; // ax
  bool v8; // zf

  if ( *this )
  {
    v2 = (unsigned __int16)this[1];
    if ( (_WORD)v2 == 94 )
      return this + 1;
    if ( v2 == 40 )
    {
      v4 = (unsigned __int16)this[2];
      if ( (_WORD)v4 == 94 || v4 != 64 )
        return this + 2;
      v5 = this[3];
      if ( v5 == 94 )
      {
        v6 = (unsigned __int16)this[4];
      }
      else
      {
        if ( v5 == 41 )
          return this + 3;
        if ( !wcschr(L"DFBR", this[3]) )
          return this;
        v7 = this[4];
        if ( v7 != 94 )
        {
          v8 = v7 == 41;
          result = this + 4;
          if ( v8 )
            return result;
          return this;
        }
        v6 = (unsigned __int16)this[5];
      }
      sub_405B2C(dword_424730, 0x3E9u, v6);
    }
  }
  return this;
}
// 424730: using guessed type int dword_424730;

//----- (0040F94D) --------------------------------------------------------
wint_t *__thiscall sub_40F94D(wchar_t *Str)
{
  wint_t *v1; // edi
  int *v2; // esi
  int v3; // ecx
  int *v4; // eax
  int v6; // [esp+10h] [ebp-18h] BYREF
  wint_t *v7; // [esp+18h] [ebp-10h] BYREF
  wint_t *v8; // [esp+1Ch] [ebp-Ch] BYREF
  wint_t *v9; // [esp+20h] [ebp-8h] BYREF
  int *v10; // [esp+24h] [ebp-4h] BYREF

  v1 = Str;
  if ( wcschr(Str, 0x24u) )
  {
    v8 = v1;
    v10 = 0;
    sub_40F012(&v8, &v10, 0, 0, 0, 0, 0, 0);
    v2 = v10;
    v7 = v1;
    v9 = 0;
    sub_40F9D0(&v6, (__int16 **)&v7, 255, &v10, 0, (int)&v9);
    v1 = v9;
    v10 = v2;
    if ( v2 )
    {
      v3 = dword_435698;
      v4 = v2;
      do
      {
        v2 = (int *)*v2;
        *v4 = v3;
        v3 = (int)v4;
        v10 = v2;
        v4 = v2;
      }
      while ( v2 );
      dword_435698 = v3;
    }
  }
  return v1;
}
// 435698: using guessed type int dword_435698;

//----- (0040F9D0) --------------------------------------------------------
_DWORD *__fastcall sub_40F9D0(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5, int a6)
{
  __int16 **v6; // edi
  _DWORD *v7; // esi
  __int16 *v8; // edx
  __int16 v9; // ax
  __int16 v10; // cx
  __int16 v11; // si
  bool v12; // cl
  _WORD *v13; // eax
  wchar_t *v14; // esi
  int v15; // eax
  int v16; // eax
  wchar_t *v17; // esi
  int v18; // esi
  _WORD *v19; // ecx
  char *v20; // edi
  int v21; // esi
  __int16 *v22; // esi
  _DWORD *v23; // ecx
  _DWORD *v24; // esi
  wchar_t *v25; // eax
  __int16 *v26; // ecx
  void **v27; // eax
  _WORD *v28; // esi
  __int16 v29; // ax
  __int16 *v31; // [esp-8h] [ebp-868h]
  __int16 v32; // [esp-4h] [ebp-864h]
  int v33; // [esp-4h] [ebp-864h]
  char v34; // [esp-4h] [ebp-864h]
  bool v35; // [esp+Fh] [ebp-851h]
  void *Block; // [esp+1Ch] [ebp-844h] BYREF
  char v38; // [esp+23h] [ebp-83Dh]
  int v39; // [esp+24h] [ebp-83Ch]
  __int16 *v40; // [esp+28h] [ebp-838h] BYREF
  int v41; // [esp+2Ch] [ebp-834h]
  __int16 *v42; // [esp+30h] [ebp-830h]
  int v43; // [esp+34h] [ebp-82Ch]
  _DWORD *v44; // [esp+38h] [ebp-828h]
  int v45; // [esp+3Ch] [ebp-824h]
  int v46; // [esp+40h] [ebp-820h] BYREF
  _DWORD Src[517]; // [esp+48h] [ebp-818h] BYREF
  int savedregs; // [esp+860h] [ebp+0h] BYREF

  v6 = a2;
  v7 = a1;
  v44 = a1;
  v38 = a3;
  v8 = *a2;
  v45 = a6;
  Src[514] = 0;
  Src[512] = Src;
  Src[513] = 1024;
  v9 = *v8;
  v43 = 0;
  v35 = 0;
  v10 = v9;
  if ( v9 )
  {
    while ( 1 )
    {
      v11 = v10;
      while ( v11 != 36 )
      {
        if ( v11 == 34 )
        {
          v12 = !v35;
          v35 = !v35;
        }
        else
        {
          v12 = v35;
        }
        if ( !a5 || v11 != 44 && v11 != 41 )
        {
          if ( !v12 && v11 == 94 )
          {
            sub_403B80(Src, 94);
            if ( *++*v6 == 34 )
              v35 = 1;
          }
          v32 = *(*v6)++;
          sub_403B80(Src, v32);
          v8 = *v6;
          v11 = **v6;
          if ( v11 )
            continue;
        }
        goto LABEL_79;
      }
      v13 = v8 + 1;
      v14 = (wchar_t *)(v8 + 2);
      Block = v8 + 1;
      if ( v8[1] == 40 )
      {
        if ( wcschr(L"*@<?", *v14) )
        {
          v33 = 3;
LABEL_19:
          sub_41008C(v6, Src, (int)&savedregs, v33);
          goto LABEL_78;
        }
        v8 = *v6;
        v13 = Block;
      }
      if ( *v13 == 36 )
      {
        v15 = *v14;
        if ( (_WORD)v15 != 94 && v38 == 1 )
        {
          if ( v15 == 64 )
          {
            v33 = 2;
            goto LABEL_19;
          }
          if ( (_WORD)v15 == 40 )
            ++v14;
          v16 = v14[1];
          if ( (v16 == 70 || v16 == 68 || v16 == 66 || v16 == 82) && v14[2] == 41 )
          {
            v33 = 4;
            goto LABEL_19;
          }
        }
        v33 = 5;
        goto LABEL_19;
      }
      if ( wcschr(L"*@<?", v8[1]) )
      {
        sub_41008C(v6, Src, (int)&savedregs, 1);
      }
      else
      {
        if ( (*v6)[1] != 40 || (v17 = wcspbrk((const wchar_t *)*v6 + 2, L" \t\n:)"), Block = v17, !sub_40EFD4(*v17)) )
        {
          v23 = a4;
          if ( !*a4 )
          {
            sub_405B2C(dword_424730, 0x410u);
            v23 = a4;
          }
          v24 = (_DWORD *)*v23;
          *v23 = *(_DWORD *)*v23;
          v25 = wcschr((const wchar_t *)v24[1], 0x24u);
          v26 = (__int16 *)v24[1];
          if ( v25 )
          {
            v40 = (__int16 *)v24[1];
            Block = 0;
            v27 = (void **)sub_40F9D0(&v46, &v40, a3, a4, 0, (int)&Block);
            sub_4105D7(Src, v6, *v27, (int)v27[1]);
            if ( Block )
              sub_4124CC(Block);
          }
          else
          {
            v28 = v26 + 1;
            v31 = v26;
            do
              v29 = *v26++;
            while ( v29 != (_WORD)v43 );
            sub_4105D7(Src, v6, v31, v26 - v28);
          }
          goto LABEL_78;
        }
        v18 = (char *)v17 - (char *)*v6;
        v40 = *v6;
        v19 = (char *)Block + 2;
        v20 = (char *)(v40 + 2);
        Block = v19;
        v21 = (v18 >> 1) - 2;
        v42 = v40 + 2;
        v41 = v21;
        *a2 = v19;
        if ( sub_40EFD4(*v19) )
        {
          v22 = (__int16 *)Block;
          do
            *a2 = ++v22;
          while ( sub_40EFD4(*v22) );
          v21 = v41;
          v20 = (char *)v42;
        }
        LOBYTE(v39) = v40[v21 + 1] == 105;
        if ( sub_411D11(v20, v21, (char *)L"subst", 5) || sub_411D11(v20, v21, (char *)L"substi", 6) )
        {
          v6 = a2;
          sub_410A63(Src, a2, a3, a4, v39);
        }
        else if ( sub_411D11(v20, v21, (char *)L"strip", 5) )
        {
          v6 = a2;
          sub_410B16(Src, a2, a3, a4);
        }
        else
        {
          if ( sub_411D11(v20, v21, (char *)L"filter", 6) || sub_411D11(v20, v21, (char *)L"filteri", 7) )
          {
            v34 = 1;
          }
          else
          {
            if ( !sub_411D11(v20, v21, (char *)L"filterout", 9) && !sub_411D11(v20, v21, (char *)L"filterouti", 10) )
            {
              if ( sub_411D11(v20, v21, (char *)L"findstring", 10) || sub_411D11(v20, v21, (char *)L"findstringi", 11) )
              {
                v6 = a2;
                sub_410CBC(Src, a2, a3, a4, v39);
              }
              else if ( sub_411D11(v20, v21, (char *)L"abspath", 7) )
              {
                v6 = a2;
                sub_410D61(Src, a2, a3, a4);
              }
              else if ( sub_411D11(v20, v21, (char *)L"basename", 8) )
              {
                v6 = a2;
                sub_410E89(Src, a2, a3, a4);
              }
              else if ( sub_411D11(v20, v21, (char *)L"patsubst", 8) || sub_411D11(v20, v21, (char *)L"patsubsti", 9) )
              {
                v6 = a2;
                sub_410F77(Src, a2, a3, a4, v39);
              }
              else if ( sub_411D11(v20, v21, (char *)L"lowercase", 9) )
              {
                v6 = a2;
                sub_4110E3(Src, a2, a3, a4);
              }
              else if ( sub_411D11(v20, v21, (char *)L"uppercase", 9) )
              {
                v6 = a2;
                sub_411151(Src, a2, a3, a4);
              }
              else
              {
                sub_405B2C(dword_424730, 0x410u);
                v6 = a2;
              }
              goto LABEL_78;
            }
            v34 = 0;
          }
          v6 = a2;
          sub_410BA1(Src, a2, a3, a4, v39, v34);
        }
      }
LABEL_78:
      v8 = *v6;
      v10 = **v6;
      if ( !v10 )
      {
LABEL_79:
        v7 = v44;
        break;
      }
    }
  }
  sub_403B80(Src, 0);
  sub_403C20(Src, v7, (char *)v45);
  return v7;
}
// 402690: using guessed type wchar_t aAbspath[8];
// 4026A0: using guessed type wchar_t aBasename[9];
// 4026B4: using guessed type wchar_t aFilter[7];
// 4026C4: using guessed type wchar_t aFilteri[8];
// 4026D4: using guessed type wchar_t aFilterout[10];
// 4026E8: using guessed type wchar_t aFilterouti[11];
// 402700: using guessed type wchar_t aFindstring[11];
// 402718: using guessed type wchar_t aFindstringi[12];
// 402730: using guessed type wchar_t aLowercase[10];
// 402744: using guessed type wchar_t aPatsubst[9];
// 402758: using guessed type wchar_t aPatsubsti[10];
// 40276C: using guessed type wchar_t aStrip[6];
// 402778: using guessed type wchar_t aSubst[6];
// 402784: using guessed type wchar_t aSubsti[7];
// 402794: using guessed type wchar_t aUppercase[10];
// 424730: using guessed type int dword_424730;

//----- (00410022) --------------------------------------------------------
_DWORD *__fastcall sub_410022(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5, int a6)
{
  int v8; // ecx

  sub_40F9D0(a1, a2, a3, a4, 1, a6);
  if ( !**a2 )
    sub_405B2C(dword_424730, 0x410u);
  v8 = (unsigned __int16)*(*a2)++;
  if ( a5 )
  {
    if ( v8 == 41 )
      return a1;
    goto LABEL_7;
  }
  if ( v8 != 44 )
LABEL_7:
    sub_405B2C(dword_424730, 0x410u);
  return a1;
}
// 424730: using guessed type int dword_424730;

//----- (0041008C) --------------------------------------------------------
void __userpurge sub_41008C(__int16 **a1@<edx>, _DWORD *a2@<ecx>, int a3@<ebp>, int a4)
{
  int v5; // esi
  int v6; // edx
  int v7; // edx
  wchar_t *v8; // ecx
  __int16 *v9; // edi
  int v10; // edi
  unsigned __int16 *v11; // esi
  unsigned __int16 v12; // cx
  wchar_t *v13; // esi
  wchar_t *v14; // ecx
  _WORD *v15; // edi
  wchar_t **v17; // eax
  wchar_t *v18; // edi
  wchar_t *v19; // esi
  wchar_t **v21; // eax
  wchar_t **v22; // eax
  size_t v23; // edi
  wchar_t *v24; // [esp-850h] [ebp-85Ch]
  wchar_t *v26; // [esp-838h] [ebp-844h] BYREF
  void *v27; // [esp-834h] [ebp-840h] BYREF
  wchar_t *v28; // [esp-830h] [ebp-83Ch]
  int v29; // [esp-82Ch] [ebp-838h] BYREF
  wchar_t *v30; // [esp-828h] [ebp-834h]
  __int16 **v31; // [esp-824h] [ebp-830h]
  int v32; // [esp-820h] [ebp-82Ch]
  char v33; // [esp-81Bh] [ebp-827h] BYREF
  char v34; // [esp-81Ah] [ebp-826h]
  char v35; // [esp-819h] [ebp-825h] BYREF
  _DWORD v36[521]; // [esp-818h] [ebp-824h] BYREF
  void *retaddr; // [esp+Ch] [ebp+0h]

  v36[518] = a3;
  v36[519] = retaddr;
  v31 = a1;
  v5 = 0;
  v34 = 0;
  v35 = 0;
  v32 = 1;
  if ( a4 == 1 )
  {
    v7 = v32;
  }
  else
  {
    if ( a4 == 2 )
    {
      v6 = v32;
LABEL_10:
      v8 = (wchar_t *)dword_424F48;
      goto LABEL_24;
    }
    if ( a4 != 3 )
    {
      if ( a4 != 4 )
      {
        if ( a4 == 5 )
        {
          sub_403B80(a2, 36);
          *a1 += 2;
        }
        return;
      }
      v6 = 4;
      v32 = 4;
      v34 = 1;
      goto LABEL_10;
    }
    v7 = 2;
    v34 = 1;
  }
  v9 = *a1;
  switch ( v9[v7] )
  {
    case '*':
      if ( v9[v7 + 1] != 42 )
      {
        v8 = (wchar_t *)dword_424F58;
        v35 = 1;
        goto LABEL_23;
      }
      v5 = dword_424F44;
      ++v7;
      goto LABEL_22;
    case '<':
      v8 = (wchar_t *)dword_424F4C;
      goto LABEL_23;
    case '?':
      v5 = dword_424F50;
      goto LABEL_22;
  }
  if ( v9[v7] != 64 )
  {
LABEL_22:
    v8 = 0;
    goto LABEL_23;
  }
  v8 = dword_424F54;
LABEL_23:
  v6 = v7 + 1;
  v32 = v6;
LABEL_24:
  v26 = 0;
  v10 = 0;
  v30 = 0;
  if ( v8 )
  {
    if ( !v5 )
    {
      v18 = v8;
      v28 = v8;
      v19 = v8;
      v30 = v8 + 1;
      while ( *v18++ )
        ;
      v10 = v18 - v30;
      v33 = 0;
      if ( v35 )
      {
        v21 = (wchar_t **)sub_410488(&v29, 82, v19, v10, 0, (unsigned int)&v33);
        v6 = v32;
        v19 = *v21;
        v10 = (int)v21[1];
        v28 = *v21;
      }
      v35 = 0;
      if ( v34 )
      {
        v22 = (wchar_t **)sub_410488(&v29, (*v31)[v6], v19, v10, 0, (unsigned int)&v35);
        v14 = *v22;
        v10 = (int)v22[1];
        v28 = *v22;
      }
      else
      {
        v14 = v28;
      }
      if ( v33 || v35 )
      {
        v30 = (wchar_t *)(v10 + 2);
        v13 = (wchar_t *)sub_403D2A(v10 + 2);
        v23 = v10;
        v24 = v28;
        *v13 = 34;
        memcpy(v13 + 1, v24, v23 * 2);
        v14 = v13;
        v13[v23 + 1] = 34;
        v10 = (int)v30;
      }
      else
      {
        v13 = 0;
      }
      goto LABEL_58;
    }
    goto LABEL_33;
  }
  if ( v5 )
  {
LABEL_33:
    v36[513] = 1024;
    v36[512] = v36;
    v36[514] = 0;
    while ( v5 )
    {
      if ( v34 )
      {
        v15 = *(_WORD **)(v5 + 4);
        v35 = 0;
        v30 = v15 + 1;
        while ( *v15++ )
          ;
        sub_410488(&v27, (*v31)[v6], *(_WORD **)(v5 + 4), v15 - v30, 0, (unsigned int)&v35);
        if ( v35 )
          sub_403B80(v36, 34);
        sub_403BE1(v36, v27, (int)v28);
        if ( v35 )
          sub_403B80(v36, 34);
      }
      else
      {
        sub_403BB0(v36, *(__int16 **)(v5 + 4));
      }
      if ( *(_DWORD *)v5 )
        sub_403B80(v36, 32);
      v5 = *(_DWORD *)v5;
      v6 = v32;
    }
    sub_403B80(v36, 0);
    v17 = (wchar_t **)sub_403C20(v36, &v29, (char *)&v26);
    v13 = v26;
    v14 = *v17;
    v10 = (int)v17[1];
    goto LABEL_58;
  }
  v11 = (unsigned __int16 *)*v31;
  v12 = **v31;
  v32 = v12;
  if ( v12 )
  {
    do
    {
      v32 = v12;
      if ( v12 == 32 )
        break;
      v32 = v12;
      if ( v12 == 9 )
        break;
      v12 = *++v11;
      v32 = *v11;
    }
    while ( (_WORD)v32 );
    v10 = (int)v30;
  }
  *v11 = 0;
  sub_405B2C(dword_424730, 0xFA6u, *v31);
  *v11 = v32;
  v13 = 0;
  v14 = 0;
LABEL_58:
  sub_4105D7(a2, v31, v14, v10);
  if ( v13 )
    sub_4124CC(v13);
}
// 41008C: could not find valid save-restore pair for ebp
// 424730: using guessed type int dword_424730;
// 424F44: using guessed type int dword_424F44;
// 424F48: using guessed type int dword_424F48;
// 424F50: using guessed type int dword_424F50;
// 424F58: using guessed type int dword_424F58;

//----- (00410488) --------------------------------------------------------
_DWORD *__fastcall sub_410488(_DWORD *a1, __int16 a2, _WORD *a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  unsigned int v7; // ecx
  unsigned int v8; // ebx
  _WORD *v9; // edi
  _DWORD *v10; // eax
  unsigned int v11; // edx
  int v13; // [esp+4h] [ebp-Ch] BYREF
  int v14; // [esp+8h] [ebp-8h]
  __int16 v15; // [esp+Eh] [ebp-2h]

  v15 = a2;
  v7 = a4;
  if ( !a4 )
  {
    *(_BYTE *)a6 = 0;
    *a1 = a3;
    a1[1] = 0;
    return a1;
  }
  v8 = 0;
  v9 = a3;
  if ( (_BYTE)a5 || *a3 != 34 )
  {
    *(_BYTE *)a6 = 0;
  }
  else
  {
    *(_BYTE *)a6 = 1;
    v10 = sub_411CE1(&a3, &v13, 1u, v7 - ((v9[v7 - 1] == 34) + 1));
    v9 = (_WORD *)*v10;
    v7 = v10[1];
    a3 = (_WORD *)*v10;
    a4 = v7;
  }
  v11 = -1;
  a6 = -1;
  a5 = v7 - 1;
  if ( (int)(v7 - 1) >= 0 )
  {
    while ( 1 )
    {
      v14 = (unsigned __int16)v9[a5];
      if ( v14 == 92 || (_WORD)v14 == 47 )
        break;
      if ( (_WORD)v14 == 46 && a6 == -1 )
        a6 = a5;
      if ( (--a5 & 0x80000000) != 0 )
        goto LABEL_16;
    }
    v11 = a5;
  }
LABEL_16:
  if ( v15 == 66 )
  {
LABEL_31:
    if ( v11 == -1 )
    {
      if ( v7 > 1 && v9[1] == 58 )
        v8 = 2;
    }
    else
    {
      v8 = v11 + 1;
    }
    if ( v15 == 66 && a6 != -1 )
      v7 = a6 - v8;
    sub_411CE1(&a3, a1, v8, v7);
    return a1;
  }
  if ( v15 != 68 )
  {
    if ( v15 != 70 )
    {
      if ( v15 != 82 || a6 == -1 )
      {
        *a1 = v9;
        a1[1] = v7;
      }
      else
      {
        sub_411CE1(&a3, a1, 0, a6);
      }
      return a1;
    }
    goto LABEL_31;
  }
  if ( v11 == -1 )
  {
    if ( v9[1] == 58 )
    {
      sub_411CE1(&a3, a1, 0, 2u);
    }
    else
    {
      *a1 = L".";
      a1[1] = 1;
    }
  }
  else
  {
    if ( v11 == 2 && v9[1] == 58 )
      v11 = 3;
    sub_411CE1(&a3, a1, 0, v11);
  }
  return a1;
}

//----- (004105D7) --------------------------------------------------------
__int16 *__fastcall sub_4105D7(_DWORD *a1, __int16 **a2, void *Src, int a4)
{
  _DWORD *v5; // ebx
  const wchar_t *v6; // eax
  __int16 *v7; // eax
  __int16 *v8; // ecx
  __int16 *v9; // edi
  __int16 v10; // dx
  __int16 *result; // eax
  __int16 *v12; // ecx
  __int16 *v13; // edx
  int v14; // edi
  __int16 *v16; // [esp+14h] [ebp-4h] BYREF
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v5 = a1;
  v6 = (const wchar_t *)(*a2 + 1);
  *a2 = (__int16 *)v6;
  if ( *v6 == 94 )
    *a2 = (__int16 *)++v6;
  v7 = (__int16 *)wcschr(v6, 0x3Au);
  v8 = *a2;
  v9 = v7;
  v16 = v7;
  if ( *v8 )
  {
    v10 = *v8;
    do
    {
      if ( v10 == 41 )
        break;
      if ( v10 == 94 )
        ++v8;
      v10 = *++v8;
    }
    while ( *v8 );
    v9 = v16;
    v5 = a1;
  }
  if ( **a2 == 40 && v9 && v9 < v8 )
  {
    sub_4106C2(&v16, v5, (int)&savedregs, Src, a4);
    result = v16;
  }
  else
  {
    sub_403BE1(v5, Src, a4);
    v12 = *a2;
    v13 = *a2;
    v14 = (unsigned __int16)**a2;
    if ( v14 == 36 )
    {
      v13 = ++v12;
      *a2 = v12;
      LOWORD(v14) = *v12;
    }
    if ( (_WORD)v14 == 40 )
    {
      do
        *a2 = ++v12;
      while ( *v12 != 41 );
      v13 = v12;
    }
    else if ( (_WORD)v14 == 42 && v12[1] == 42 )
    {
      v13 = v12 + 1;
    }
    result = v13 + 1;
  }
  *a2 = result;
  return result;
}

//----- (004106C2) --------------------------------------------------------
void __userpurge sub_4106C2(__int16 **a1@<edx>, _DWORD *a2@<ecx>, int a3@<ebp>, void *a4, int a5)
{
  __int16 **v5; // esi
  __int16 *v6; // edi
  __int16 v7; // ax
  __int16 v8; // dx
  __int16 v9; // cx
  __int16 v10; // dx
  __int16 v11; // cx
  char *v12; // eax
  __int16 *v13; // esi
  char *v14; // edx
  __int16 v15; // cx
  __int16 v16; // ax
  __int16 *v17; // esi
  char *v18; // edi
  char *v19; // ecx
  __int16 v20; // dx
  __int16 v21; // ax
  _DWORD **v22; // eax
  int v25; // [esp-2Ch] [ebp-38h]
  __int16 *v26; // [esp-28h] [ebp-34h]
  __int16 *v27; // [esp-20h] [ebp-2Ch]
  char *v28; // [esp-20h] [ebp-2Ch]
  _DWORD *v29[4]; // [esp-1Ch] [ebp-28h] BYREF
  int v30; // [esp-Ch] [ebp-18h]
  unsigned int v31; // [esp-8h] [ebp-14h]
  int v32; // [esp+0h] [ebp-Ch]
  int v33; // [esp+4h] [ebp-8h]
  int retaddr; // [esp+Ch] [ebp+0h]

  v32 = a3;
  v33 = retaddr;
  v5 = a1;
  v6 = ++*a1;
  v27 = *a1;
  v7 = **a1;
  v8 = v7;
  if ( v7 )
  {
    v9 = v7;
    do
    {
      v8 = v9;
      if ( v9 == 61 )
        break;
      if ( v9 == 94 )
        ++v6;
      v9 = *++v6;
      v8 = *v6;
    }
    while ( *v6 );
    v5 = a1;
    v27 = v6;
  }
  if ( v8 != 61 )
    sub_405B2C(dword_424724, 0x3EBu);
  if ( v6 == *v5 )
    sub_405B2C(dword_424724, 0x3EDu);
  v26 = v6;
  v10 = *v6;
  if ( *v6 )
  {
    v11 = *v6;
    do
    {
      v10 = v11;
      if ( v11 == 41 )
        break;
      if ( v11 == 94 )
        ++v6;
      v11 = *++v6;
      v10 = *v6;
    }
    while ( *v6 );
    v5 = a1;
    v26 = v6;
    v6 = v27;
  }
  if ( v10 != 41 )
    sub_405B2C(dword_424724, 0x3E8u);
  v12 = (char *)sub_403D2A(v6 - *v5 + 1);
  v13 = *v5;
  v14 = v12;
  v28 = v12;
  v15 = *v13;
  if ( *v13 != 61 )
  {
    do
    {
      v16 = v15;
      if ( v15 == 94 )
        v16 = *++v13;
      ++v13;
      *(_WORD *)v14 = v16;
      v14 += 2;
      v15 = *v13;
    }
    while ( *v13 != 61 );
    v12 = v28;
  }
  v25 = (v14 - v12) >> 1;
  *(_WORD *)v14 = 0;
  v17 = v13 + 1;
  v18 = (char *)sub_403D2A(v26 - v6);
  v19 = v18;
  if ( *v17 != 41 )
  {
    v20 = *v17;
    do
    {
      v21 = v20;
      if ( v20 == 94 )
        v21 = *++v17;
      ++v17;
      *(_WORD *)v19 = v21;
      v19 += 2;
      v20 = *v17;
    }
    while ( *v17 != 41 );
  }
  v29[0] = 0;
  v30 = 0;
  *(_WORD *)v19 = 0;
  *a1 = v26 + 1;
  v31 = 7;
  sub_41215D(v29, v18, (v19 - v18) >> 1);
  v22 = v29;
  if ( v31 >= 8 )
    v22 = (_DWORD **)v29[0];
  sub_4108DD(a2, a4, a5, v28, (void **)v25, v22, v30);
  if ( v31 >= 8 )
    sub_41209A(v29[0], v31 + 1);
  free(v28);
  free(v18);
}
// 4106C2: could not find valid save-restore pair for ebp
// 424724: using guessed type int dword_424724;

//----- (004108DD) --------------------------------------------------------
void **__thiscall sub_4108DD(_DWORD *this, void *Src, int a3, char *a4, void **a5, void *a6, int a7)
{
  void **result; // eax
  int v9; // esi
  void *v10; // ebx
  int v11; // eax
  void **v12; // eax
  int v13; // [esp+Ch] [ebp-14h] BYREF
  int v14; // [esp+14h] [ebp-Ch] BYREF
  int v15; // [esp+1Ch] [ebp-4h]

  result = a5;
  if ( !a5 )
    return (void **)sub_403BE1(this, Src, a3);
  v9 = a3;
  if ( a3 )
  {
    v10 = Src;
    while ( 1 )
    {
      v11 = sub_411C7A((char **)&Src, a4, (unsigned int)result, (int)this);
      v15 = v11;
      if ( v11 == -1 )
      {
        result = (void **)sub_403BE1(this, v10, v9);
        v10 = 0;
        v9 = 0;
      }
      else
      {
        v12 = (void **)sub_411CE1(&Src, &v14, 0, v11);
        sub_403BE1(this, *v12, (int)v12[1]);
        sub_403BE1(this, a6, a7);
        result = (void **)sub_411CE1(&Src, &v13, (unsigned int)a5 + v15, 0xFFFFFFFF);
        v10 = *result;
        v9 = (int)result[1];
      }
      a3 = v9;
      Src = v10;
      if ( !v9 )
        break;
      result = a5;
    }
  }
  return result;
}
// 410913: variable 'this' is possibly undefined

//----- (00410984) --------------------------------------------------------
int __thiscall sub_410984(
        _DWORD *this,
        _WORD *Src,
        unsigned int a3,
        wchar_t *String2,
        size_t MaxCount,
        void *a6,
        int a7)
{
  int result; // eax
  unsigned int v9; // esi
  const wchar_t *v10; // ecx
  wint_t v11; // ax
  void **v12; // eax
  _DWORD *v13; // eax
  _WORD *v14; // ecx
  int v15; // [esp+Ch] [ebp-14h] BYREF
  int v16; // [esp+14h] [ebp-Ch] BYREF
  int v17; // [esp+1Ch] [ebp-4h]

  if ( MaxCount )
  {
    v17 = towupper(*String2);
    for ( result = a3; ; a3 = result )
    {
      if ( !result )
        return result;
      v9 = 0;
      while ( 1 )
      {
        v10 = String2;
        if ( Src[v9] == *String2 )
          goto LABEL_8;
        v11 = towupper(Src[v9]);
        if ( v11 == (_WORD)v17 )
          break;
LABEL_9:
        if ( ++v9 >= a3 )
        {
          sub_403BE1(this, Src, a3);
          result = 0;
          Src = 0;
          goto LABEL_11;
        }
      }
      v10 = String2;
LABEL_8:
      if ( wcsnicmp(&Src[v9], v10, MaxCount) )
        goto LABEL_9;
      v12 = (void **)sub_411CE1(&Src, &v16, 0, v9);
      sub_403BE1(this, *v12, (int)v12[1]);
      sub_403BE1(this, a6, a7);
      v13 = sub_411CE1(&Src, &v15, v9 + MaxCount, 0xFFFFFFFF);
      v14 = (_WORD *)*v13;
      result = v13[1];
      Src = v14;
LABEL_11:
      ;
    }
  }
  return sub_403BE1(this, Src, a3);
}

//----- (00410A63) --------------------------------------------------------
void __fastcall sub_410A63(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5)
{
  int v6; // esi
  void **v7; // edi
  void *Src; // [esp+Ch] [ebp-30h] BYREF
  int v9; // [esp+10h] [ebp-2Ch]
  wchar_t *String2; // [esp+14h] [ebp-28h] BYREF
  size_t MaxCount; // [esp+18h] [ebp-24h]
  void *v12; // [esp+1Ch] [ebp-20h] BYREF
  int v13; // [esp+20h] [ebp-1Ch]
  _DWORD *v14; // [esp+24h] [ebp-18h]
  int v15; // [esp+28h] [ebp-14h] BYREF
  int v16; // [esp+2Ch] [ebp-10h] BYREF
  int v17; // [esp+30h] [ebp-Ch] BYREF
  int v18; // [esp+34h] [ebp-8h] BYREF

  v14 = a1;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  sub_410022(&String2, a2, a3, a4, 0, (int)&v15);
  sub_410022(&v12, a2, a3, a4, 0, (int)&v16);
  sub_410022(&Src, a2, a3, a4, 1, (int)&v17);
  if ( a5 )
    sub_410984(v14, Src, v9, String2, MaxCount, v12, v13);
  else
    sub_4108DD(v14, Src, v9, (char *)String2, (void **)MaxCount, v12, v13);
  v6 = 3;
  v7 = (void **)&v18;
  do
  {
    --v7;
    --v6;
    if ( *v7 )
      sub_4124CC(*v7);
  }
  while ( v6 );
}

//----- (00410B16) --------------------------------------------------------
void __fastcall sub_410B16(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4)
{
  int v5; // esi
  _WORD *v6; // eax
  _WORD *v7; // [esp+Ch] [ebp-1Ch] BYREF
  int v8; // [esp+10h] [ebp-18h]
  _WORD *v9; // [esp+14h] [ebp-14h] BYREF
  int v10; // [esp+18h] [ebp-10h]
  void *Src; // [esp+1Ch] [ebp-Ch] BYREF
  int v12; // [esp+20h] [ebp-8h]
  void *Block; // [esp+24h] [ebp-4h] BYREF

  Block = 0;
  sub_410022(&v7, a2, a3, a4, 1, (int)&Block);
  v5 = v8;
  v6 = v7;
  v9 = v7;
  v10 = v8;
  if ( v8 )
  {
    while ( 1 )
    {
      Src = 0;
      v12 = 0;
      sub_41122D(&Src, (int *)&v9, v6, v5);
      v5 = v10;
      if ( v12 )
      {
        sub_403BE1(a1, Src, v12);
        if ( !v5 )
          break;
        sub_403B80(a1, 32);
      }
      if ( !v5 )
        break;
      v6 = v9;
    }
  }
  if ( Block )
    sub_4124CC(Block);
}

//----- (00410BA1) --------------------------------------------------------
void __fastcall sub_410BA1(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5, char a6)
{
  char v6; // bl
  int v9; // eax
  _WORD *v10; // ecx
  int v11; // esi
  int v12; // eax
  _WORD *v13; // ecx
  char v14; // al
  int v15; // esi
  void **v16; // edi
  int v17[2]; // [esp+10h] [ebp-40h] BYREF
  _WORD *v18; // [esp+18h] [ebp-38h] BYREF
  int v19; // [esp+1Ch] [ebp-34h]
  _WORD *v20; // [esp+20h] [ebp-30h] BYREF
  int v21; // [esp+24h] [ebp-2Ch]
  int v22; // [esp+28h] [ebp-28h] BYREF
  int v23; // [esp+2Ch] [ebp-24h] BYREF
  _WORD *v24; // [esp+30h] [ebp-20h] BYREF
  int v25; // [esp+34h] [ebp-1Ch]
  _WORD *v26; // [esp+38h] [ebp-18h] BYREF
  int v27; // [esp+3Ch] [ebp-14h]
  int v28; // [esp+40h] [ebp-10h] BYREF
  unsigned int v29; // [esp+44h] [ebp-Ch]
  void *Src; // [esp+48h] [ebp-8h] BYREF
  int v31; // [esp+4Ch] [ebp-4h]

  v6 = 0;
  v22 = 0;
  v23 = 0;
  sub_410022(&v18, a2, a3, a4, 0, (int)&v22);
  sub_410022(&v20, a2, a3, a4, 1, (int)&v23);
  v9 = v21;
  v10 = v20;
  v24 = v20;
  v25 = v21;
  if ( v21 )
  {
    while ( 1 )
    {
      Src = 0;
      v31 = 0;
      sub_41122D(&Src, (int *)&v24, v10, v9);
      v11 = v31;
      if ( v31 )
      {
        v12 = v19;
        v13 = v18;
        v26 = v18;
        v27 = v19;
        if ( v19 )
        {
          while ( 1 )
          {
            v28 = 0;
            v29 = 0;
            sub_41122D(&v28, (int *)&v26, v13, v12);
            v17[0] = 0;
            v17[1] = 0;
            if ( sub_4112D1(a5, v17, (int)Src, v11, v28, v29) )
              break;
            v12 = v27;
            if ( !v27 )
              goto LABEL_8;
            v13 = v26;
          }
          v14 = 1;
        }
        else
        {
LABEL_8:
          v14 = 0;
        }
        if ( v14 == a6 )
        {
          if ( v6 )
            sub_403B80(a1, 32);
          sub_403BE1(a1, Src, v11);
          v6 = 1;
        }
      }
      v9 = v25;
      if ( !v25 )
        break;
      v10 = v24;
    }
  }
  v15 = 2;
  v16 = (void **)&v24;
  do
  {
    --v16;
    --v15;
    if ( *v16 )
      sub_4124CC(*v16);
  }
  while ( v15 );
}

//----- (00410CBC) --------------------------------------------------------
void __fastcall sub_410CBC(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5)
{
  int v7; // ecx
  int v8; // esi
  wchar_t *v9; // edi
  int v10; // esi
  void **p_String1; // edi
  int v12[2]; // [esp+10h] [ebp-1Ch] BYREF
  int v13; // [esp+18h] [ebp-14h] BYREF
  int v14; // [esp+1Ch] [ebp-10h] BYREF
  wchar_t *String1; // [esp+20h] [ebp-Ch] BYREF
  size_t MaxCount; // [esp+24h] [ebp-8h]

  v13 = 0;
  v14 = 0;
  sub_410022(&String1, a2, a3, a4, 0, (int)&v13);
  sub_410022(v12, a2, a3, a4, 1, (int)&v14);
  if ( a5 )
  {
    if ( sub_4111BF(String1, MaxCount, v12[0], v12[1]) )
    {
      v8 = MaxCount;
      v9 = String1;
LABEL_5:
      sub_403BE1(a1, v9, v8);
    }
  }
  else
  {
    v8 = MaxCount;
    v9 = String1;
    if ( sub_411C7A((char **)v12, (char *)String1, MaxCount, v7) != -1 )
      goto LABEL_5;
  }
  v10 = 2;
  p_String1 = (void **)&String1;
  do
  {
    --p_String1;
    --v10;
    if ( *p_String1 )
      sub_4124CC(*p_String1);
  }
  while ( v10 );
}
// 410D29: variable 'v7' is possibly undefined

//----- (00410D61) --------------------------------------------------------
void __fastcall sub_410D61(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4)
{
  WCHAR *v4; // eax
  int v5; // edi
  WCHAR *v6; // esi
  _WORD *v7; // eax
  WCHAR *v8; // eax
  bool v9; // bl
  _DWORD *v10; // ebx
  _WORD *v11; // [esp+Ch] [ebp-3Ch] BYREF
  int v12; // [esp+10h] [ebp-38h]
  _DWORD *v13; // [esp+14h] [ebp-34h]
  _WORD *v14; // [esp+18h] [ebp-30h] BYREF
  int v15; // [esp+1Ch] [ebp-2Ch]
  void *Src; // [esp+20h] [ebp-28h] BYREF
  int v17; // [esp+24h] [ebp-24h]
  void *Block; // [esp+28h] [ebp-20h] BYREF
  WCHAR FileName[2]; // [esp+2Ch] [ebp-1Ch] BYREF
  int v20; // [esp+3Ch] [ebp-Ch]
  unsigned int v21; // [esp+40h] [ebp-8h]

  v13 = a1;
  Block = 0;
  sub_410022(&v11, a2, a3, a4, 1, (int)&Block);
  v4 = (WCHAR *)sub_403D2A(0x8000u);
  v5 = v12;
  v6 = v4;
  v7 = v11;
  v14 = v11;
  v15 = v12;
  if ( v12 )
  {
    while ( 1 )
    {
      Src = 0;
      v17 = 0;
      sub_41122D(&Src, (int *)&v14, v7, v5);
      v5 = v15;
      if ( v17 )
      {
        *(_DWORD *)FileName = 0;
        v20 = 0;
        v21 = 7;
        sub_41215D((_DWORD **)FileName, Src, v17);
        v8 = FileName;
        if ( v21 >= 8 )
          v8 = *(WCHAR **)FileName;
        v9 = GetFullPathNameW(v8, 0x8000u, v6, 0) == 0;
        if ( v21 >= 8 )
          sub_41209A(*(_DWORD **)FileName, v21 + 1);
        if ( v9 )
          sub_405B2C(dword_424730, 0x410u);
        v10 = v13;
        sub_403BB0(v13, (__int16 *)v6);
        if ( !v5 )
          break;
        sub_403B80(v10, 32);
      }
      if ( !v5 )
        break;
      v7 = v14;
    }
  }
  if ( v6 )
    sub_4124CC(v6);
  if ( Block )
    sub_4124CC(Block);
}
// 424730: using guessed type int dword_424730;

//----- (00410E89) --------------------------------------------------------
void __fastcall sub_410E89(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4)
{
  _DWORD *v4; // ebx
  int v5; // edi
  _WORD *v6; // eax
  int v7; // eax
  void *v8; // edx
  int v9; // ecx
  unsigned int v10; // esi
  int v11; // ebx
  int v12[2]; // [esp+10h] [ebp-30h] BYREF
  _WORD *v13; // [esp+18h] [ebp-28h] BYREF
  int v14; // [esp+1Ch] [ebp-24h]
  _WORD *v15; // [esp+20h] [ebp-20h] BYREF
  int v16; // [esp+24h] [ebp-1Ch]
  void *Src; // [esp+28h] [ebp-18h] BYREF
  int v18; // [esp+2Ch] [ebp-14h]
  unsigned __int16 *v19; // [esp+30h] [ebp-10h] BYREF
  int v20; // [esp+34h] [ebp-Ch]
  _DWORD *v21; // [esp+38h] [ebp-8h]
  void *Block; // [esp+3Ch] [ebp-4h] BYREF

  Block = 0;
  v4 = a1;
  v21 = a1;
  sub_410022(&v13, a2, a3, a4, 1, (int)&Block);
  v5 = v14;
  v6 = v13;
  v15 = v13;
  v16 = v14;
  if ( v14 )
  {
    while ( 1 )
    {
      v19 = 0;
      v20 = 0;
      sub_41122D(&v19, (int *)&v15, v6, v5);
      v7 = v20;
      v5 = v16;
      if ( !v20 )
        goto LABEL_16;
      v8 = v19;
      v9 = v20 - 1;
      v10 = -1;
      v12[0] = (int)v19;
      v12[1] = v20;
      if ( v20 - 1 < 0 )
        goto LABEL_13;
      do
      {
        v11 = v19[v9];
        if ( v11 == 92 || v11 == 47 )
          break;
        if ( v11 == 46 && v10 == -1 )
          v10 = v9;
        --v9;
      }
      while ( v9 >= 0 );
      if ( v10 == -1 )
        break;
      sub_411CE1(v12, &Src, 0, v10);
      v7 = v18;
      v8 = Src;
      v4 = v21;
LABEL_14:
      sub_403BE1(v4, v8, v7);
      if ( !v5 )
        goto LABEL_18;
      sub_403B80(v4, 32);
LABEL_16:
      if ( !v5 )
        goto LABEL_18;
      v6 = v15;
    }
    v4 = v21;
LABEL_13:
    Src = v19;
    v18 = v20;
    goto LABEL_14;
  }
LABEL_18:
  if ( Block )
    sub_4124CC(Block);
}

//----- (00410F77) --------------------------------------------------------
void __fastcall sub_410F77(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5)
{
  int v6; // edi
  _WORD *v7; // eax
  int v8; // esi
  unsigned int v9; // eax
  _DWORD *v10; // ebx
  int v11; // esi
  void **v12; // eax
  int v13; // esi
  void **v14; // edi
  int v15; // [esp+10h] [ebp-54h] BYREF
  int v16[2]; // [esp+18h] [ebp-4Ch] BYREF
  _WORD *v17; // [esp+20h] [ebp-44h] BYREF
  int v18; // [esp+24h] [ebp-40h]
  _WORD *v19; // [esp+28h] [ebp-3Ch] BYREF
  int v20; // [esp+2Ch] [ebp-38h]
  void *Src; // [esp+30h] [ebp-34h] BYREF
  int v22; // [esp+34h] [ebp-30h]
  void *v23; // [esp+38h] [ebp-2Ch] BYREF
  int v24; // [esp+3Ch] [ebp-28h]
  int v25; // [esp+40h] [ebp-24h] BYREF
  unsigned int v26; // [esp+44h] [ebp-20h]
  _DWORD *v27; // [esp+48h] [ebp-1Ch]
  int v28; // [esp+4Ch] [ebp-18h] BYREF
  int v29; // [esp+50h] [ebp-14h] BYREF
  int v30; // [esp+54h] [ebp-10h] BYREF
  int v31; // [esp+58h] [ebp-Ch] BYREF
  int v32; // [esp+5Ch] [ebp-8h] BYREF

  v27 = a1;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  sub_410022(v16, a2, a3, a4, 0, (int)&v29);
  sub_410022(&v25, a2, a3, a4, 0, (int)&v30);
  sub_410022(&v17, a2, a3, a4, 1, (int)&v31);
  v6 = v18;
  v7 = v17;
  v19 = v17;
  v20 = v18;
  if ( v18 )
  {
    while ( 1 )
    {
      v23 = 0;
      v24 = 0;
      sub_41122D(&v23, (int *)&v19, v7, v6);
      v8 = v24;
      v6 = v20;
      if ( v24 )
      {
        Src = 0;
        v22 = 0;
        if ( sub_4112D1(a5, &Src, (int)v23, v24, v16[0], v16[1]) )
        {
          v9 = v26;
          v28 = 0;
          v10 = v27;
          if ( v26 )
          {
            while ( !sub_41144B(&v28, v25, v9) )
            {
              v11 = v28;
              sub_403B80(v10, *(_WORD *)(v25 + 2 * v28));
              v9 = v26;
              v28 = v11 + 1;
              if ( v11 + 1 >= v26 )
                goto LABEL_10;
            }
            sub_403BE1(v10, Src, v22);
            v12 = (void **)sub_411CE1(&v25, &v15, v28 + 1, 0xFFFFFFFF);
            sub_403BE1(v10, *v12, (int)v12[1]);
          }
        }
        else
        {
          v10 = v27;
          sub_403BE1(v27, v23, v8);
        }
LABEL_10:
        if ( !v6 )
          break;
        sub_403B80(v10, 32);
      }
      if ( !v6 )
        break;
      v7 = v19;
    }
  }
  v13 = 3;
  v14 = (void **)&v32;
  do
  {
    --v14;
    --v13;
    if ( *v14 )
      sub_4124CC(*v14);
  }
  while ( v13 );
}

//----- (004110E3) --------------------------------------------------------
void __fastcall sub_4110E3(_DWORD *Src, __int16 **a2, char a3, _DWORD *a4)
{
  wint_t *v5; // esi
  wint_t *v6; // ebx
  __int16 v7; // ax
  wint_t *v8; // [esp+Ch] [ebp-Ch] BYREF
  int v9; // [esp+10h] [ebp-8h]
  void *Block; // [esp+14h] [ebp-4h] BYREF

  Block = 0;
  sub_410022(&v8, a2, a3, a4, 1, (int)&Block);
  sub_403CAC(Src, v9);
  v5 = v8;
  v6 = &v8[v9];
  while ( v5 != v6 )
  {
    v7 = towlower(*v5);
    sub_403B80(Src, v7);
    ++v5;
  }
  if ( Block )
    sub_4124CC(Block);
}

//----- (00411151) --------------------------------------------------------
void __fastcall sub_411151(_DWORD *Src, __int16 **a2, char a3, _DWORD *a4)
{
  wint_t *v5; // esi
  wint_t *v6; // ebx
  __int16 v7; // ax
  wint_t *v8; // [esp+Ch] [ebp-Ch] BYREF
  int v9; // [esp+10h] [ebp-8h]
  void *Block; // [esp+14h] [ebp-4h] BYREF

  Block = 0;
  sub_410022(&v8, a2, a3, a4, 1, (int)&Block);
  sub_403CAC(Src, v9);
  v5 = v8;
  v6 = &v8[v9];
  while ( v5 != v6 )
  {
    v7 = towupper(*v5);
    sub_403B80(Src, v7);
    ++v5;
  }
  if ( Block )
    sub_4124CC(Block);
}

//----- (004111BF) --------------------------------------------------------
char __stdcall sub_4111BF(wchar_t *String1, size_t MaxCount, int a3, unsigned int a4)
{
  wint_t v4; // bx
  int v5; // esi
  int v6; // eax
  const wchar_t *v7; // ecx

  if ( MaxCount > a4 )
    return 0;
  v4 = towupper(*String1);
  v5 = 0;
  while ( 1 )
  {
    v6 = a3;
    v7 = String1;
    if ( *String1 == *(_WORD *)(a3 + 2 * v5) )
      break;
    if ( v4 == towupper(*(_WORD *)(a3 + 2 * v5)) )
    {
      v6 = a3;
      v7 = String1;
      break;
    }
LABEL_7:
    if ( ++v5 > a4 - MaxCount )
      return 0;
  }
  if ( wcsnicmp(v7, (const wchar_t *)(v6 + 2 * v5), MaxCount) )
    goto LABEL_7;
  return 1;
}

//----- (0041122D) --------------------------------------------------------
_WORD *__fastcall sub_41122D(_DWORD *a1, int *a2, _WORD *a3, int a4)
{
  int v6; // eax
  _WORD *result; // eax
  int v8; // ecx
  int *v9; // eax
  unsigned int v10; // edx
  int v11; // ecx
  int v12; // eax
  int v13; // eax
  int *v14; // eax
  int v15; // ecx
  int v16; // [esp-4h] [ebp-1Ch]
  _DWORD v17[2]; // [esp+8h] [ebp-10h] BYREF
  int v18; // [esp+10h] [ebp-8h] BYREF
  int v19; // [esp+14h] [ebp-4h]

  v6 = sub_411DF8(a3, a4, (int)a1, L" \t\n", 3, a4);
  v19 = v6;
  if ( v6 == -1 )
  {
    result = a3;
    v8 = a4;
    *a2 = 0;
    a2[1] = 0;
    *a1 = result;
    a1[1] = v8;
  }
  else
  {
    v9 = sub_411CE1(&a3, v17, 0, v6);
    v16 = a4;
    v10 = a4;
    v11 = *v9;
    a1[1] = v9[1];
    v12 = v19;
    *a1 = v11;
    v13 = sub_411D36((int)a3, v10, v12 + 1, L" \t\n", 3, v16);
    if ( v13 == -1 )
    {
      v18 = 0;
      v14 = &v18;
      v19 = 0;
    }
    else
    {
      v14 = sub_411CE1(&a3, v17, v13, 0xFFFFFFFF);
    }
    v15 = *v14;
    result = (_WORD *)v14[1];
    *a2 = v15;
    a2[1] = (int)result;
  }
  return result;
}
// 41122D: using guessed type _DWORD var_10[2];

//----- (004112D1) --------------------------------------------------------
char __fastcall sub_4112D1(char a1, _DWORD *a2, int a3, unsigned int a4, int a5, unsigned int a6)
{
  char v6; // bl
  unsigned int v7; // esi
  size_t v8; // ecx
  unsigned int v9; // eax
  size_t v11; // edx
  wint_t v12; // ax
  wint_t v13; // si
  size_t v14; // esi
  char result; // al
  int *v16; // eax
  int v17; // ecx
  int v18; // eax
  bool v19; // zf
  unsigned int v20; // [esp-8h] [ebp-38h]
  wchar_t *String1; // [esp+10h] [ebp-20h] BYREF
  wint_t C[2]; // [esp+14h] [ebp-1Ch]
  int v23; // [esp+18h] [ebp-18h] BYREF
  size_t v24; // [esp+1Ch] [ebp-14h]
  wchar_t *String2; // [esp+20h] [ebp-10h] BYREF
  size_t MaxCount; // [esp+24h] [ebp-Ch] BYREF
  unsigned int v27; // [esp+28h] [ebp-8h]
  char v28; // [esp+2Fh] [ebp-1h]

  v6 = 0;
  v28 = a1;
  v7 = a6;
  v8 = 0;
  MaxCount = 0;
  v9 = 0;
  v27 = 0;
  v24 = 0;
  v11 = 0;
  if ( a6 )
  {
    *(_DWORD *)C = 0;
    v24 = 0;
    while ( 1 )
    {
      if ( v9 >= a4 )
      {
        v9 = *(_DWORD *)C;
        goto LABEL_19;
      }
      if ( sub_41144B((int *)&MaxCount, a5, v7) )
        break;
      *(_DWORD *)C = *(unsigned __int16 *)(a5 + 2 * MaxCount);
      v12 = *(_WORD *)(a3 + 2 * v27);
      if ( C[0] != v12 )
      {
        if ( !v28 )
          goto LABEL_12;
        v13 = towupper(v12);
        if ( towupper(C[0]) != v13 )
          goto LABEL_12;
        v7 = a6;
      }
      v11 = MaxCount + 1;
      v8 = v11;
      ++MaxCount;
      v9 = v27 + 1;
      *(_DWORD *)C = v11;
      ++v27;
      v24 = v11;
      if ( v11 >= v7 )
      {
        v9 = v11;
        v24 = v11;
        goto LABEL_19;
      }
    }
    sub_411CE1(&a5, &String2, MaxCount + 1, 0xFFFFFFFF);
    sub_411CE1(&a3, &v23, v27, 0xFFFFFFFF);
    v14 = MaxCount;
    if ( v24 < MaxCount )
    {
LABEL_12:
      *a2 = 0;
      result = 0;
      a2[1] = 0;
      return result;
    }
    v16 = sub_411CE1(&v23, &String1, 0, v24 - MaxCount);
    v17 = *v16;
    v20 = v16[1];
    a2[1] = v20;
    *a2 = v17;
    sub_411CE1(&v23, &String1, v20, 0xFFFFFFFF);
    if ( v28 )
    {
      v18 = wcsnicmp(String1, String2, v14);
    }
    else
    {
      if ( *(_DWORD *)C != v14 )
        return v6;
      v18 = sub_411F28((char *)String1, (char *)String2, *(int *)C);
    }
    v19 = v18 == 0;
    goto LABEL_24;
  }
LABEL_19:
  if ( v9 + 1 == v7 )
  {
    v24 = v11;
    if ( *(_WORD *)(a5 + 2 * v8) == 37 )
    {
      *a2 = 0;
      result = 1;
      a2[1] = 0;
      return result;
    }
  }
  *a2 = 0;
  a2[1] = 0;
  if ( v24 == v7 )
  {
    v19 = v27 == a4;
LABEL_24:
    if ( v19 )
      return 1;
  }
  return v6;
}

//----- (0041144B) --------------------------------------------------------
char __thiscall sub_41144B(int *this, int a2, unsigned int a3)
{
  int v4; // eax
  __int16 v5; // si
  int v6; // ecx
  __int16 v7; // si
  unsigned int v8; // eax

  v4 = *this;
  v5 = *(_WORD *)(a2 + 2 * *this);
  if ( v5 == 37 )
    return 1;
  if ( v5 == 92 )
  {
    v6 = v4 + 1;
    if ( v4 + 1 < a3 )
    {
      v7 = *(_WORD *)(a2 + 2 * v4 + 2);
      if ( v7 == 37 || v7 == 92 && (v8 = v4 + 2, v8 < a3) && *(_WORD *)(a2 + 2 * v8) == 37 )
        *this = v6;
    }
  }
  return 0;
}

//----- (004114A5) --------------------------------------------------------
void *__fastcall sub_4114A5(wchar_t *FullPath, wchar_t *Filename)
{
  wchar_t Buffer[260]; // [esp+8h] [ebp-418h] BYREF
  wchar_t Dir[258]; // [esp+210h] [ebp-210h] BYREF
  wchar_t Drive[4]; // [esp+414h] [ebp-Ch] BYREF

  wsplitpath_s(FullPath, Drive, 3u, Dir, 0x100u, 0, 0, 0, 0);
  wmakepath_s(Buffer, 0x104u, Drive, Dir, Filename, 0);
  return sub_40ECDB((char *)Buffer);
}

//----- (00411519) --------------------------------------------------------
char __thiscall sub_411519(_WORD *this)
{
  _WORD *v1; // edx
  char v2; // bl
  __int16 v3; // cx
  __int16 v4; // si
  __int16 v5; // cx
  _WORD *v6; // ecx
  __int16 v7; // si
  _WORD *v8; // edx
  _WORD *v9; // ecx
  __int16 v10; // dx
  const wchar_t *v11; // esi
  wchar_t *v12; // eax
  _WORD *v14; // [esp+14h] [ebp-4h]

  v1 = this;
  v2 = 0;
  v14 = this;
  v3 = *this;
  if ( v3 == 123 )
  {
    v14 = ++v1;
    v4 = *v1;
    if ( *v1 )
    {
      v5 = *v1;
      do
      {
        v4 = v5;
        if ( v5 == 125 )
          break;
        if ( v5 == 94 )
          ++v1;
        v5 = *++v1;
        v4 = *v1;
      }
      while ( *v1 );
      v14 = v1;
      v2 = 0;
    }
    v3 = v4;
    if ( v4 )
    {
      v14 = ++v1;
      v3 = *v1;
    }
  }
  if ( v3 == 46 )
  {
    v6 = v1;
    v7 = 46;
    do
    {
      if ( v7 == 123 )
        break;
      if ( v7 == 94 )
        ++v6;
      v7 = *++v6;
    }
    while ( *v6 );
    v8 = v14;
    v2 = 0;
    while ( v8 < v6 && *v8 != 92 && *v8 != 47 )
      ++v8;
    if ( !*v6 || v8 != v6 )
    {
      v12 = wcspbrk(v14 + 1, L"./\\");
      if ( !v12 || *v12 != 46 )
        return v2;
      v11 = v12 + 1;
      goto LABEL_36;
    }
    v9 = v6 + 1;
    if ( *v9 )
    {
      v10 = *v9;
      while ( v10 != 125 )
      {
        if ( v10 == 94 )
          ++v9;
        v10 = *++v9;
        if ( !*v9 )
          return v2;
      }
      if ( v9[1] == 46 )
      {
        v11 = v9 + 2;
LABEL_36:
        if ( !wcschr(v11, 0x2Fu) && !wcschr(v11, 0x5Cu) )
        {
          if ( wcschr(v11, 0x2Eu) )
            sub_405B2C(dword_424730, 0x444u);
          else
            return 1;
        }
      }
    }
  }
  return v2;
}
// 424730: using guessed type int dword_424730;

//----- (0041168E) --------------------------------------------------------
char __fastcall sub_41168E(char *a1, int a2, unsigned __int16 *a3, const wchar_t *a4)
{
  unsigned __int16 *v4; // edi
  char *v5; // esi
  unsigned __int16 v6; // ax
  char *v7; // ebx
  unsigned __int16 *v8; // ecx
  int v9; // eax
  unsigned __int16 *v10; // edx
  char v11; // bh
  char v12; // bl
  const wchar_t *v13; // eax
  unsigned int v14; // kr00_4
  const wchar_t *v15; // ebx
  unsigned int v16; // kr04_4
  unsigned int v17; // kr08_4
  int v18; // ecx
  __int16 v19; // ax
  const wchar_t *i; // eax
  char result; // al
  unsigned int v22; // [esp+1Ch] [ebp-21Ch]
  char v23; // [esp+24h] [ebp-214h]
  char v24; // [esp+25h] [ebp-213h]
  char v25; // [esp+26h] [ebp-212h]
  char v26; // [esp+27h] [ebp-211h]
  wchar_t Drive[262]; // [esp+28h] [ebp-210h] BYREF

  v4 = a3;
  v5 = a1;
  v6 = *a3;
  v7 = &a1[2 * a2];
  v22 = (unsigned int)v7;
  if ( *a3 )
  {
    while ( 1 )
    {
      v8 = v4;
      if ( v5 >= v7 )
        return 1;
      if ( v6 != 37 )
        goto LABEL_10;
      v9 = *++v4;
      if ( !(_WORD)v9 )
      {
        v4 = v8;
        goto LABEL_57;
      }
      if ( (_WORD)v9 == 37 )
      {
        *(_WORD *)v5 = 37;
        goto LABEL_11;
      }
      if ( v9 != 115 )
        break;
      for ( i = a4; i; ++i )
      {
        if ( !*i )
          break;
        if ( v5 >= v7 )
          break;
        *(_WORD *)v5 = *i;
        v5 += 2;
      }
LABEL_57:
      v6 = *++v4;
      if ( !*v4 )
        goto LABEL_58;
    }
    if ( *v4 != 124 )
    {
      *(_WORD *)v5 = 37;
      v5 += 2;
      if ( v5 != v7 )
      {
        v6 = *v4;
LABEL_10:
        *(_WORD *)v5 = v6;
LABEL_11:
        v5 += 2;
        goto LABEL_57;
      }
      return 1;
    }
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    Drive[0] = 0;
    while ( 1 )
    {
      v10 = v4++;
      switch ( *v4 )
      {
        case 0u:
          v4 = v10;
LABEL_45:
          v7 = (char *)v22;
          while ( v8 <= v4 && (unsigned int)v5 < v22 )
          {
            v19 = *v8++;
            *(_WORD *)v5 = v19;
            v5 += 2;
          }
          goto LABEL_57;
        case 0x46u:
          if ( *v10 == 124 )
          {
            v12 = 1;
            v11 = 1;
            v26 = 1;
            v25 = 1;
            v24 = 1;
            v23 = 1;
            goto LABEL_23;
          }
          break;
        case 0x64u:
          v11 = v25;
          v12 = 1;
          v26 = 1;
          goto LABEL_23;
        case 0x65u:
          v23 = 1;
          break;
        case 0x66u:
          v24 = 1;
          break;
        case 0x70u:
          v11 = 1;
          v25 = 1;
          goto LABEL_22;
        default:
          goto LABEL_45;
      }
      v11 = v25;
LABEL_22:
      v12 = v26;
LABEL_23:
      if ( *v4 == 70 )
      {
        v13 = a4;
        if ( !a4 )
        {
          sub_405B2C(0, 0x449u);
          v13 = 0;
        }
        if ( v12 )
          wsplitpath_s(v13, Drive, 0x104u, 0, 0, 0, 0, 0, 0);
        if ( v11 )
        {
          v14 = wcslen(Drive);
          v15 = a4;
          wsplitpath_s(a4, 0, 0, &Drive[v14], 260 - v14, 0, 0, 0, 0);
        }
        else
        {
          v15 = a4;
        }
        if ( v24 )
        {
          v16 = wcslen(Drive);
          wsplitpath_s(v15, 0, 0, 0, 0, &Drive[v16], 260 - v16, 0, 0);
        }
        if ( v23 )
        {
          v17 = wcslen(Drive);
          wsplitpath_s(v15, 0, 0, 0, 0, 0, 0, &Drive[v17], 260 - v17);
        }
        v7 = (char *)v22;
        if ( Drive[0] )
        {
          v18 = (char *)Drive - v5;
          do
          {
            if ( (unsigned int)v5 >= v22 )
              break;
            *(_WORD *)v5 = *(_WORD *)&v5[v18];
            v5 += 2;
          }
          while ( *(_WORD *)&v5[v18] );
        }
        goto LABEL_57;
      }
    }
  }
LABEL_58:
  if ( v5 < v7 )
  {
    result = 0;
    *(_WORD *)v5 = 0;
    return result;
  }
  return 1;
}
// 41168E: using guessed type wchar_t Drive[262];

//----- (004119EC) --------------------------------------------------------
_DWORD *__thiscall sub_4119EC(wint_t *this, int a2)
{
  _DWORD *v2; // edi
  wint_t *v3; // ebx
  wint_t *v4; // eax
  wint_t v5; // cx
  wint_t v6; // si
  bool v7; // zf
  wint_t *v9; // [esp+Ch] [ebp-8h]
  _DWORD *v10; // [esp+10h] [ebp-4h]
  wint_t *v11; // [esp+1Ch] [ebp+8h]

  v2 = (_DWORD *)dword_424510[a2];
  v9 = this;
  v10 = v2;
  if ( !v2 )
    return 0;
  while ( 1 )
  {
    v3 = this;
    v4 = (wint_t *)v2[1];
    v11 = v4;
    if ( *this )
    {
      do
      {
        v5 = *v4;
        if ( !*v4 )
          break;
        if ( *v3 == 92 || *v3 == 47 )
        {
          if ( v5 != 92 && v5 != 47 )
            break;
        }
        else
        {
          v6 = towupper(*v4);
          v7 = towupper(*v3) == v6;
          v4 = v11;
          if ( !v7 )
            break;
        }
        ++v3;
        v11 = ++v4;
      }
      while ( *v3 );
      v2 = v10;
      this = v9;
    }
    if ( !*v3 && !*v4 )
      return v2;
    v2 = (_DWORD *)*v2;
    v10 = v2;
    if ( !v2 )
      return 0;
  }
}
// 424510: using guessed type int dword_424510[128];

//----- (00411AA4) --------------------------------------------------------
int __fastcall sub_411AA4(_WORD *a1, int a2)
{
  __int16 *v2; // edi
  _WORD *v3; // edx
  char *v4; // esi
  void *v6; // esp
  __int16 *v7; // ecx
  __int16 v8; // ax
  void *v9; // esp
  wchar_t v10; // ax
  wchar_t v11; // cx
  wchar_t *v12; // eax
  int v13; // esi
  wchar_t v14; // cx
  wchar_t *v15; // eax
  int v16; // edi
  wchar_t *v17; // esi
  wchar_t v19[6]; // [esp+0h] [ebp-20h] BYREF
  int v20; // [esp+Ch] [ebp-14h]
  __int16 *v21; // [esp+10h] [ebp-10h]
  wchar_t *v22; // [esp+14h] [ebp-Ch]
  int v23; // [esp+18h] [ebp-8h]

  v2 = (__int16 *)a2;
  v21 = (__int16 *)a2;
  v3 = a1 + 1;
  v4 = (char *)a1;
  v23 = 0;
  while ( *a1++ )
    ;
  v6 = alloca(2 * (a1 - v3) + 2);
  v7 = v2;
  do
    v8 = *v7++;
  while ( v8 != (_WORD)v23 );
  v9 = alloca(2 * (v7 - (v2 + 1)) + 2);
  v10 = *(_WORD *)v4;
  v23 = 34;
  v11 = v10;
  if ( v10 == 34 )
  {
    v4 += 2;
    v11 = *(_WORD *)v4;
  }
  v12 = v19;
  if ( v11 )
  {
    v13 = v4 - (char *)v19;
    do
    {
      *v12 = v11;
      v22 = v12++;
      v20 = v11;
      v11 = *(wchar_t *)((char *)v12 + v13);
    }
    while ( v11 );
    v2 = v21;
    if ( v12 != v19 && (_WORD)v20 == (_WORD)v23 )
      v12 = v22;
  }
  *v12 = 0;
  v14 = *v2;
  if ( *v2 == (_WORD)v23 )
    v14 = *++v2;
  v15 = v19;
  if ( v14 )
  {
    v16 = (char *)v2 - (char *)v19;
    do
    {
      v22 = (wchar_t *)v14;
      v17 = v15;
      *v15++ = v14;
      v14 = *(wchar_t *)((char *)v15 + v16);
    }
    while ( v14 );
    if ( v15 != v19 && (_WORD)v22 == (_WORD)v23 )
      v15 = v17;
  }
  *v15 = 0;
  return wcsicmp(v19, v19);
}

//----- (00411BBE) --------------------------------------------------------
_WORD *__fastcall sub_411BBE(_WORD *a1)
{
  char *v1; // esi
  _WORD *v2; // edx
  __int64 v4; // rax
  _WORD *v5; // edx
  __int16 v6; // ax
  _WORD *v7; // ecx
  int v8; // esi
  __int16 v9; // di

  v1 = (char *)a1;
  v2 = a1 + 1;
  while ( *a1++ )
    ;
  v4 = 2i64 * (unsigned int)(a1 - v2 + 1);
  v5 = sub_40B5D9(HIDWORD(v4) != 0 ? -1 : v4);
  v6 = *(_WORD *)v1;
  if ( *(_WORD *)v1 == 34 )
  {
    v1 += 2;
    v6 = *(_WORD *)v1;
  }
  v7 = v5;
  if ( v6 )
  {
    v8 = v1 - (char *)v5;
    v9 = v6;
    do
    {
      *v7++ = v9;
      v9 = *(_WORD *)((char *)v7 + v8);
    }
    while ( v9 );
  }
  if ( *(v7 - 1) == 34 )
    --v7;
  *v7 = 0;
  return v5;
}

//----- (00411C33) --------------------------------------------------------
FILE *__fastcall sub_411C33(wchar_t *FileName, wchar_t *Mode)
{
  wchar_t *v4; // ecx
  wchar_t v5; // ax

  if ( *FileName == 34 )
  {
    *wcsrchr(FileName, 0x22u) = 0;
    v4 = FileName;
    v5 = FileName[1];
    *FileName = v5;
    while ( v5 )
    {
      ++v4;
      v5 = v4[1];
      *v4 = v5;
    }
  }
  return wfsopen(FileName, Mode, 32);
}

//----- (00411C7A) --------------------------------------------------------
int __thiscall sub_411C7A(char **this, char *a2, unsigned int a3, int a4)
{
  unsigned int v4; // eax
  char *v5; // ebx
  unsigned int v6; // eax
  char *v8; // ecx
  int v9; // edx
  char *v10; // esi
  char *v11; // eax
  char *v12; // esi
  char *v14; // [esp+Ch] [ebp-4h]

  v4 = (unsigned int)this[1];
  v5 = *this;
  if ( a3 > v4 )
    return -1;
  v6 = v4 - a3;
  if ( a3 )
  {
    v8 = *this;
    v14 = &v5[2 * v6 + 2];
    v9 = 2 * (v6 + 1);
    while ( 1 )
    {
      v11 = (char *)sub_411EFF(v8, v9 >> 1, a2);
      v12 = v11;
      if ( !v11 )
        break;
      if ( !sub_411F28(v11, a2, a3) )
        return (v12 - v5) >> 1;
      v10 = v12 + 2;
      v9 = v14 - v10;
      v8 = v10;
    }
    return -1;
  }
  return 0;
}

//----- (00411CE1) --------------------------------------------------------
_DWORD *__thiscall sub_411CE1(_DWORD *this, _DWORD *a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // edx
  unsigned int v5; // edx
  _DWORD *result; // eax

  v4 = this[1];
  if ( v4 < a3 )
    sub_403D1E();
  v5 = v4 - a3;
  if ( v5 >= a4 )
    v5 = a4;
  result = a2;
  *a2 = *this + 2 * a3;
  a2[1] = v5;
  return result;
}

//----- (00411D11) --------------------------------------------------------
bool __stdcall sub_411D11(char *a1, int a2, char *a3, int a4)
{
  return a2 == a4 && !sub_411F28(a1, a3, a2);
}

//----- (00411D36) --------------------------------------------------------
int __fastcall sub_411D36(int a1, unsigned int a2, unsigned int a3, __int16 *a4, int a5, int a6)
{
  unsigned int v8; // edi
  _WORD *v9; // esi
  int v10; // eax
  char v13[260]; // [esp+10h] [ebp-108h] BYREF

  if ( a3 >= a2 )
    return -1;
  memset(v13, 0, 0x100u);
  v8 = a1 + 2 * a2;
  v9 = (_WORD *)(a1 + 2 * a3);
  if ( !sub_411ECF(v13, a4, &a4[a5]) )
  {
    while ( (unsigned int)v9 < v8 )
    {
      if ( !sub_411EFF(a4, a5, v9) )
        return ((int)v9 - a1) >> 1;
      ++v9;
    }
    return -1;
  }
  if ( (unsigned int)v9 >= v8 )
    return -1;
  while ( 1 )
  {
    v10 = (unsigned __int16)*v9;
    if ( (unsigned __int16)v10 >= 0x100u || !v13[v10] )
      break;
    if ( (unsigned int)++v9 >= v8 )
      return -1;
  }
  return ((int)v9 - a1) >> 1;
}
// 411D36: using guessed type char var_108[260];

//----- (00411DF8) --------------------------------------------------------
int __fastcall sub_411DF8(_WORD *a1, int a2, int a3, __int16 *a4, int a5, int a6)
{
  unsigned int v8; // ebx
  _WORD *v9; // esi
  unsigned __int16 *v12; // ecx
  int v13; // eax
  char v14[260]; // [esp+10h] [ebp-108h] BYREF

  if ( !a5 || !a2 )
    return -1;
  memset(v14, 0, 0x100u);
  v8 = (unsigned int)&a1[a2];
  if ( !sub_411ECF(v14, a4, &a4[a5]) )
  {
    v9 = a1;
    if ( (unsigned int)a1 >= v8 )
      return -1;
    while ( !sub_411EFF(a4, a5, v9) )
    {
      if ( (unsigned int)++v9 >= v8 )
        return -1;
    }
    return v9 - a1;
  }
  v12 = a1;
  if ( (unsigned int)a1 >= v8 )
    return -1;
  while ( 1 )
  {
    v13 = *v12;
    if ( (unsigned __int16)v13 < 0x100u )
    {
      if ( v14[v13] )
        break;
    }
    if ( (unsigned int)++v12 >= v8 )
      return -1;
  }
  return v12 - a1;
}
// 411DF8: using guessed type char var_108[260];

//----- (00411ECF) --------------------------------------------------------
char __thiscall sub_411ECF(_BYTE *this, __int16 *a2, __int16 *a3)
{
  __int16 v4; // ax

  while ( 1 )
  {
    if ( a2 == a3 )
      return 1;
    v4 = *a2;
    if ( (unsigned __int16)*a2 >= 0x100u )
      break;
    ++a2;
    this[(unsigned __int8)v4] = 1;
  }
  return 0;
}

//----- (00411EFF) --------------------------------------------------------
_WORD *__fastcall sub_411EFF(_WORD *a1, int a2, _WORD *a3)
{
  int v3; // esi

  v3 = 0;
  if ( a2 )
  {
    while ( *a1 != *a3 )
    {
      if ( a2 == 1 )
        return (_WORD *)v3;
      --a2;
      ++a1;
    }
    return a1;
  }
  return (_WORD *)v3;
}

//----- (00411F28) --------------------------------------------------------
int __fastcall sub_411F28(char *a1, char *a2, int a3)
{
  int v3; // edi
  int result; // eax
  int v5; // ebx
  bool v6; // cc
  unsigned __int16 v7; // si

  v3 = a3;
  result = 0;
  if ( a3 )
  {
    if ( *(_WORD *)a1 < *(_WORD *)a2 )
    {
      return -1;
    }
    else
    {
      v5 = a1 - a2;
      v6 = *(_WORD *)a1 <= *(_WORD *)a2;
      while ( v6 )
      {
        if ( v3 == 1 )
          return result;
        a2 += 2;
        --v3;
        v7 = *(_WORD *)&a2[v5];
        v6 = v7 <= *(_WORD *)a2;
        if ( v7 < *(_WORD *)a2 )
          return -1;
      }
      return 1;
    }
  }
  return result;
}

//----- (00411F6F) --------------------------------------------------------
void __noreturn sub_411F6F()
{
  std::_Xlength_error("string too long");
}
// 4390CC: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (00411F7B) --------------------------------------------------------
_DWORD *__thiscall sub_411F7B(_DWORD *this)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 0;
  this[1] = "bad array new length";
  *this = &off_402674;
  return result;
}
// 402674: using guessed type int (__thiscall *off_402674)(void *Block, char);

//----- (00411F93) --------------------------------------------------------
int __thiscall sub_411F93(_DWORD *this)
{
  *this = &off_402674;
  return _std_exception_destroy(this + 1);
}
// 402674: using guessed type int (__thiscall *off_402674)(void *Block, char);
// 4390F8: using guessed type int __cdecl _std_exception_destroy(_DWORD);

//----- (00411FA5) --------------------------------------------------------
char *__thiscall sub_411FA5(char *Block, char a2)
{
  *(_DWORD *)Block = &off_402674;
  _std_exception_destroy(Block + 4);
  if ( (a2 & 1) != 0 )
    sub_4124CC(Block);
  return Block;
}
// 402674: using guessed type int (__thiscall *off_402674)(void *Block, char);
// 4390F8: using guessed type int __cdecl _std_exception_destroy(_DWORD);

//----- (00411FD3) --------------------------------------------------------
_DWORD *__thiscall sub_411FD3(_DWORD *this, int a2)
{
  sub_411FFB(this, a2);
  *this = &off_402674;
  return this;
}
// 402674: using guessed type int (__thiscall *off_402674)(void *Block, char);

//----- (00411FFB) --------------------------------------------------------
_DWORD *__thiscall sub_411FFB(_DWORD *this, int a2)
{
  *this = &off_402674;
  this[1] = 0;
  this[2] = 0;
  _std_exception_copy(a2 + 4, this + 1);
  return this;
}
// 402674: using guessed type int (__thiscall *off_402674)(void *Block, char);
// 4390E0: using guessed type int __cdecl _std_exception_copy(_DWORD, _DWORD);

//----- (00412028) --------------------------------------------------------
void __noreturn sub_412028()
{
  void *v0; // ecx
  int v1[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_411F7B(v1);
  CxxThrowException(v0, (_ThrowInfo *)&_TI3_AVbad_array_new_length_std__);
}
// 41203E: variable 'v0' is possibly undefined
// 412028: using guessed type int var_C[3];

//----- (00412044) --------------------------------------------------------
_DWORD *__thiscall sub_412044(void *this, unsigned int a2)
{
  size_t v2; // ecx
  void *v3; // eax
  void *v4; // ecx
  _DWORD *result; // eax

  if ( a2 > 0x7FFFFFFF )
    goto LABEL_10;
  v2 = 2 * a2;
  if ( 2 * a2 < 0x1000 )
  {
    if ( v2 )
      return sub_40B5D9(v2);
    else
      return 0;
  }
  if ( v2 + 35 <= v2 )
LABEL_10:
    sub_412028();
  v3 = sub_40B5D9(v2 + 35);
  v4 = v3;
  if ( !v3 )
    invalid_parameter_noinfo_noreturn();
  result = (_DWORD *)(((unsigned int)v3 + 35) & 0xFFFFFFE0);
  *(result - 1) = v4;
  return result;
}

//----- (0041209A) --------------------------------------------------------
void __stdcall sub_41209A(_DWORD *Block, int a2)
{
  void *v2; // eax

  v2 = Block;
  if ( (unsigned int)(2 * a2) >= 0x1000 )
  {
    if ( (unsigned int)Block - *(Block - 1) - 4 > 0x1F )
      invalid_parameter_noinfo_noreturn();
    v2 = (void *)*(Block - 1);
  }
  sub_4124CC(v2);
}

//----- (004120D4) --------------------------------------------------------
_DWORD **__thiscall sub_4120D4(_DWORD **this, unsigned int a2, int a3, void *Src)
{
  unsigned int v5; // esi
  unsigned int v6; // ebx
  void *v7; // ecx
  unsigned int v8; // edx
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v12; // [esp+10h] [ebp-4h]

  v5 = 2147483646;
  if ( a2 > 0x7FFFFFFE )
    sub_411F6F();
  v6 = (unsigned int)this[5];
  v7 = (void *)(a2 | 7);
  if ( (a2 | 7) <= 0x7FFFFFFE )
  {
    v8 = v6 >> 1;
    if ( v6 <= 2147483646 - (v6 >> 1) )
    {
      v5 = v8 + v6;
      if ( (unsigned int)v7 >= v8 + v6 )
        v5 = a2 | 7;
    }
  }
  v9 = sub_412044(v7, v5 + 1);
  this[5] = (_DWORD *)v5;
  v12 = v9;
  this[4] = (_DWORD *)a2;
  memcpy(v9, Src, 2 * a2);
  v10 = v12;
  *((_WORD *)v12 + a2) = 0;
  if ( v6 >= 8 )
  {
    sub_41209A(*this, v6 + 1);
    v10 = v12;
  }
  *this = v10;
  return this;
}

//----- (0041215D) --------------------------------------------------------
_DWORD **__thiscall sub_41215D(_DWORD **this, void *Src, unsigned int a3)
{
  unsigned int v3; // eax
  _DWORD *v5; // ebx

  v3 = a3;
  if ( a3 > (unsigned int)this[5] )
  {
    LOBYTE(a3) = 0;
    return sub_4120D4(this, v3, a3, Src);
  }
  else
  {
    v5 = this;
    if ( (unsigned int)this[5] >= 8 )
      v5 = *this;
    this[4] = (_DWORD *)a3;
    memmove(v5, Src, 2 * a3);
    *((_WORD *)v5 + a3) = 0;
    return this;
  }
}

//----- (004121AD) --------------------------------------------------------
int sub_4121AD(wchar_t *Buffer, size_t BufferCount, wchar_t *Format, ...)
{
  unsigned __int64 *v3; // eax
  int result; // eax
  va_list va; // [esp+14h] [ebp+14h] BYREF

  va_start(va, Format);
  v3 = (unsigned __int64 *)sub_40D237();
  result = _stdio_common_vswprintf_s(*v3, Buffer, BufferCount, Format, 0, va);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (004121DB) --------------------------------------------------------
WCHAR *__thiscall sub_4121DB(wchar_t *FullPath)
{
  WCHAR *result; // eax
  wchar_t *v3; // esi
  _DWORD *v4; // edi
  _DWORD *v5; // esi
  void *v6; // eax
  WCHAR *Filename; // [esp+10h] [ebp-260h]
  HANDLE hFindFile; // [esp+14h] [ebp-25Ch] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+18h] [ebp-258h] BYREF

  result = sub_408256(FullPath, &FindFileData, &hFindFile);
  v3 = result;
  if ( result )
  {
    v4 = sub_40EC89();
    v4[1] = sub_4114A5(FullPath, v3);
    while ( 1 )
    {
      Filename = sub_4083E1(&FindFileData, hFindFile);
      if ( !Filename )
        break;
      v5 = sub_40EC89();
      v6 = sub_4114A5(FullPath, Filename);
      *v5 = v4;
      v4 = v5;
      v5[1] = v6;
    }
    return (WCHAR *)v4;
  }
  return result;
}

//----- (00412318) --------------------------------------------------------
int sub_412318()
{
  __scrt_initialize_default_local_stdio_options();
  return 0;
}
// 412A4F: using guessed type int __scrt_initialize_default_local_stdio_options(void);

//----- (004124CC) --------------------------------------------------------
void __cdecl sub_4124CC(void *Block)
{
  free(Block);
}

//----- (00412706) --------------------------------------------------------
_DWORD *__thiscall sub_412706(_DWORD *Block, char a2)
{
  *Block = &type_info::`vftable';
  if ( (a2 & 1) != 0 )
    sub_4124CC(Block);
  return Block;
}
// 40103C: using guessed type void *type_info::`vftable';

//----- (00412A12) --------------------------------------------------------
int __cdecl UserMathErrorFunction()
{
  return 0;
}

//----- (00412A15) --------------------------------------------------------
int sub_412A15()
{
  return 1;
}

//----- (00412A1F) --------------------------------------------------------
void sub_412A1F()
{
  InitializeSListHead(&ListHead);
}

//----- (00412A2B) --------------------------------------------------------
char sub_412A2B()
{
  return 1;
}

//----- (00412A6C) --------------------------------------------------------
BOOL sub_412A6C()
{
  return dword_414004 == 0;
}
// 414004: using guessed type int dword_414004;

//----- (00412A78) --------------------------------------------------------
void *sub_412A78()
{
  return &unk_438EF0;
}

//----- (00412A7E) --------------------------------------------------------
void *sub_412A7E()
{
  return &unk_438EEC;
}

//----- (00412BE6) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_412BE6()
{
  return SetUnhandledExceptionFilter(__scrt_unhandled_exception_filter);
}

//----- (00412C48) --------------------------------------------------------
void sub_412C48()
{
  dword_4144E8 = 0;
}
// 4144E8: using guessed type int dword_4144E8;

//----- (00412C50) --------------------------------------------------------
void sub_412C50()
{
  ;
}
// 412C50: could not find valid save-restore pair for edi

//----- (00412C7C) --------------------------------------------------------
void __cdecl sub_412C7C()
{
  ;
}
// 412C7C: could not find valid save-restore pair for edi

//----- (00412F7D) --------------------------------------------------------
int sub_412F7D()
{
  _DWORD *v0; // eax
  int v1; // ecx
  _DWORD *v2; // eax
  int v3; // ecx

  v0 = sub_40D237();
  v1 = v0[1];
  *v0 |= 4u;
  v0[1] = v1;
  v2 = sub_40D019();
  v3 = v2[1];
  *v2 |= 2u;
  v2[1] = v3;
  return 0;
}

// nfuncs=298 queued=229 decompiled=229 lumina nreq=0 worse=0 better=0
// ALL OK, 229 function(s) have been successfully decompiled
