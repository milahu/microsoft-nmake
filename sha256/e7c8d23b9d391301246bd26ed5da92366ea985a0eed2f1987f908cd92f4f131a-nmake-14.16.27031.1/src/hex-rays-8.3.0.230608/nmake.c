/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

wchar_t *sub_402AE0();
_DWORD *sub_402B07();
char sub_402C29();
void sub_402CE6();
char __thiscall sub_402DC5(wchar_t *String1);
void __fastcall sub_402EA0(wchar_t *Control, int *a2, _DWORD *a3);
_WORD *__thiscall sub_40300C(_DWORD *this);
char sub_4030D2();
void sub_4031EC();
void sub_403323();
char __fastcall sub_403430(wchar_t *Name, wchar_t *Str, int a3);
char __fastcall sub_403552(wchar_t *Name, wchar_t *Str, int a3);
void __fastcall sub_4036AA(wchar_t *Block, char a2, int a3);
void __thiscall sub_40376B(_DWORD **this);
_DWORD *__thiscall sub_403885(_DWORD *this);
bool __fastcall sub_4038CF(wint_t C);
int sub_4038F4();
int __fastcall sub_403A44(wchar_t *a1, char a2, _DWORD *a3, int a4);
int __fastcall sub_403A81(wchar_t *a1, char a2, _DWORD *a3, wchar_t *a4, _DWORD *a5);
unsigned int __fastcall sub_403AD7(int a1, char a2, _DWORD *a3, char a4, wchar_t *a5, _DWORD *a6);
_DWORD *__fastcall sub_40468C(int a1, int a2);
char __fastcall sub_404A65(__int16 **a1, _DWORD *a2);
int __thiscall sub_404BAE(_DWORD *this);
_DWORD *__fastcall sub_404BD8(char *Src, char a2);
int __fastcall sub_404C1F(_DWORD *a1, int a2, int a3, int a4);
wchar_t **__thiscall sub_404CCB(_DWORD *this);
int __thiscall sub_404E20(_DWORD *this);
void __thiscall sub_404E3E(_DWORD *this);
wchar_t *__fastcall sub_404E6D(wchar_t **a1, int *a2);
void *__fastcall sub_404F75(char *Src, int a2, void **a3);
char *__fastcall sub_404FB4(wchar_t *Str, int *a2, void **a3);
void __fastcall sub_405040(wchar_t *a1, int *a2, void **a3);
void __thiscall sub_4051F1(wchar_t *FileName);
void *__fastcall sub_405389(void *Block, unsigned int a2);
int sub_4053D9(int a1, unsigned int a2, ...);
void sub_4054B3(unsigned int a1, ...);
int sub_405542();
void sub_40556E();
size_t __fastcall sub_4055A8(_DWORD *a1, const wchar_t **a2, wchar_t *String);
wchar_t **__fastcall sub_40571A(char *Src, _DWORD *a2, int a3, char a4, const wchar_t *a5);
wchar_t **__fastcall sub_40575C(_DWORD *a1, _DWORD *a2, int a3, char a4, const wchar_t *a5);
wchar_t **__fastcall sub_405BDE(wchar_t *a1, int a2, wchar_t **ArgList);
wchar_t *__fastcall sub_405CEF(int a1, wchar_t **a2);
char *__thiscall sub_406309(wchar_t *Str);
char __fastcall sub_406429(int a1, wint_t **a2, int *a3);
char __fastcall sub_4065E0(wchar_t *FileName, int a2);
char __fastcall sub_4066FF(wchar_t *String, rsize_t a2, int *a3, int *a4);
int __stdcall sub_406903(int a1);
bool __fastcall sub_406909(_WORD *a1, _DWORD *a2);
char __fastcall sub_4069D2(wchar_t *FullPath, wchar_t *a2, int a3);
wchar_t **__fastcall sub_406E74(wchar_t *Source, char a2, char a3, char a4, void **a5);
void *sub_4075F7();
char __fastcall sub_407693(__int16 *a1, int a2, char a3, unsigned __int8 a4, const wchar_t *a5, wchar_t ***a6);
void __fastcall sub_4078F8(int a1, __int16 **a2);
void __fastcall sub_40798C(int ArgList, char a2);
__int64 __thiscall sub_407A1B(char *this);
WCHAR *__fastcall sub_407A35(wchar_t *Str, LPWIN32_FIND_DATAW lpFindFileData, HANDLE *a3);
WCHAR *__fastcall sub_407BC1(LPWIN32_FIND_DATAW lpFindFileData, HANDLE hFindFile);
void *__fastcall sub_407BE4(wchar_t *a1, wchar_t *a2, struct _WIN32_FIND_DATAW *lpFindFileData, HANDLE *a4);
char __fastcall sub_407CDE(_WORD *Block, LPWIN32_FIND_DATAW lpFindFileData);
char __fastcall sub_407D6D(wchar_t *Str, _DWORD *a2);
int sub_407F02();
wchar_t *sub_4080AB();
wchar_t *__fastcall sub_4081E7(wchar_t *String1, char *a2);
int __thiscall sub_408338(wint_t *this);
char __fastcall sub_4084BB(wchar_t *String1, int a2, wchar_t **a3);
void __fastcall sub_408697(wchar_t *String, char a2);
wchar_t *sub_4087C0();
char sub_4088D8();
wint_t *__fastcall sub_4089C1(wint_t *a1, int a2);
wchar_t *__fastcall sub_408A2F(const wchar_t *a1);
void *__thiscall sub_408AC3(__int16 **this);
wchar_t *__fastcall sub_408C25(wchar_t *a1, _DWORD *a2, wchar_t **a3);
errno_t __fastcall sub_408F3C(void **a1, wchar_t *a2);
int __fastcall sub_409019(wchar_t *Source, const unsigned __int16 *a2, char a3);
wchar_t *__fastcall sub_40918A(FILE *a1, int a2, const wchar_t **a3, char a4, _BYTE *a5);
char __fastcall sub_4093AE(wchar_t *Str, const wchar_t **a2, wchar_t *a3, char a4);
int sub_4097A7();
wint_t __fastcall sub_40980F(char a1);
unsigned __int8 __fastcall sub_409894(wchar_t a1);
unsigned __int8 __fastcall sub_409978(wint_t Character, _WORD *a2, int a3);
char __fastcall sub_409B95(int a1, char a2);
int __fastcall sub_409C3A(char a1);
wint_t __fastcall sub_409D17(wint_t a1, char a2);
wchar_t *__fastcall sub_409DC8(char a1, int a2, int a3);
const unsigned __int16 *__fastcall sub_40A326(const unsigned __int16 *a1, unsigned int a2);
unsigned __int8 __thiscall sub_40A5D2(wchar_t *String);
wchar_t *__thiscall sub_40AA77(wchar_t *FullPath);
int __thiscall sub_40AB4F(const unsigned __int16 *this);
void *__thiscall sub_40ABE3(size_t Size);
void *__thiscall sub_40AC08(size_t Size);
void *__fastcall sub_40AC26(void *Block, size_t Size);
int __fastcall sub_40AC5C(wchar_t *Source, wchar_t *a2, int a3, int a4, int a5, int a6, int a7, int a8);
wchar_t **__thiscall sub_40B245(int this, wchar_t **String, int Radix, wchar_t ***a4);
void __cdecl _guard_check_icall_nop(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); // idb
bool sub_40B3AE();
bool sub_40B3D3();
char __thiscall sub_40B452(BYTE *lpDst);
char sub_40B4DF();
int __thiscall sub_40B533(void *this);
LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
LONG __fastcall sub_40B94D(struct _EXCEPTION_POINTERS *ExceptionInfo, void *a2, void *a3);
int __cdecl main(int argc, const char **argv, const char **envp);
char *sub_40BE06();
int __fastcall sub_40BF68(int a1, int a2, int a3);
int sub_40C20D();
char *sub_40C357();
void __fastcall sub_40C423(unsigned int a1, int a2);
void *sub_40C731();
int __fastcall sub_40C801(wint_t C, char a2);
void __cdecl Function();
int sub_40CAAD();
const unsigned __int16 *__fastcall sub_40CAEB(const unsigned __int16 *a1);
int __fastcall sub_40CB41(unsigned int a1);
void *sub_40CC62();
int sub_40CC68(wchar_t *Buffer, size_t BufferCount, wchar_t *Format, ...);
int __fastcall sub_40CC96(void *a1, void *Src, size_t Size);
void *sub_40CD10();
int sub_40CD16(wchar_t *Buffer, wchar_t *Format, ...);
bool __thiscall sub_40CD40(FILE *Stream);
int sub_40CD80();
int sub_40CD9E(wchar_t *Format, ...);
int sub_40CDAD();
bool __thiscall sub_40CDD9(FILE *Stream);
int __fastcall sub_40CE16(wchar_t *Format, va_list ArgList); // idb
int sub_40CE60();
int sub_40CE7E(wchar_t *Format, ...);
int sub_40CE8D();
int __fastcall sub_40CEB9(wchar_t *Format, va_list ArgList); // idb
int __thiscall sub_40CF03(void *this);
int __fastcall sub_40D0E7(int a1, _WORD *a2);
void __fastcall sub_40D11B(int a1, int a2, FILETIME FileTime);
void __fastcall sub_40D1D5(int a1, int a2);
int sub_40D3DE();
int sub_40D44F();
int sub_40D4EF();
char __stdcall sub_40D644(char a1);
char __stdcall sub_40D894(char a1);
wchar_t *sub_40D8D2();
wchar_t *sub_40D949();
int __fastcall sub_40DA09(char a1, int a2);
wchar_t *sub_40DA77();
int sub_40DB84();
int sub_40DE62();
bool sub_40DED3();
bool __thiscall sub_40DFF3(wchar_t *String);
bool __fastcall sub_40E062(wchar_t *String, char a2);
void **__fastcall sub_40E0BF(wchar_t *Destination, rsize_t a2, wchar_t *Str, __int16 *a4, LPWIN32_FIND_DATAW lpFindFileData);
void sub_40E52E();
void **__fastcall sub_40E715(int a1, wchar_t *a2, int a3, unsigned __int64 a4, int ***a5, int ***a6, _DWORD *a7, _DWORD *a8, wchar_t **a9);
_DWORD *sub_40E8C7();
void *__thiscall sub_40E919(char *Src);
_WORD *__thiscall sub_40E95D(char *this);
wchar_t *__fastcall sub_40E9C3(char *Block, const wchar_t *a2);
_DWORD *__fastcall sub_40EA1E(_DWORD **a1, _DWORD *a2);
int __thiscall sub_40EA33(wint_t *this, int a2);
_DWORD *__thiscall sub_40EA6B(wchar_t *Source, int a2, int a3);
char __fastcall sub_40EBFB(_WORD *a1, int **a2, int **a3, const unsigned __int16 *a4, int a5, int a6, int a7);
wint_t *__fastcall sub_40F10D(wint_t *a1, wint_t *a2);
_WORD *__thiscall sub_40F20F(_WORD *this);
wchar_t *__thiscall sub_40F2A9(wchar_t *Str);
void *__fastcall sub_40F311(__int16 *a1, char a2, _DWORD *a3);
char **__fastcall sub_40F673(const void **a1, _DWORD *a2, char **a3, unsigned int *a4, const void *a5);
void __fastcall sub_40F6E7(const void **a1, __int16 **a2, char **a3, char **a4, unsigned int *a5, char *a6, const void *a7);
wchar_t *__fastcall sub_40FA53(__int16 a1, wchar_t *a2, rsize_t SizeInWords, wchar_t *Source);
__int16 *__fastcall sub_40FBAB(const void **a1, __int16 **a2, char **a3, char **a4, wchar_t *String1, unsigned int *a6, const void *a7);
void __fastcall sub_40FCDB(const void **a1, __int16 **a2, char **a3, char **a4, wchar_t *String1, unsigned int *a6, const void *a7);
void *__fastcall sub_40FF33(wchar_t *FullPath, wchar_t *Filename);
char __thiscall sub_40FFA7(_WORD *this);
char __fastcall sub_410126(char *a1, int a2, unsigned __int16 *a3, const wchar_t *a4);
_DWORD *__thiscall sub_410424(wint_t *this, int a2);
int __fastcall sub_4104DC(_WORD *a1, __int16 *a2);
_WORD *__fastcall sub_4105E0(_WORD *a1);
FILE *__fastcall sub_410655(wchar_t *FileName, wchar_t *Mode);
void *__fastcall sub_41069D(void *Block, unsigned int a2);
WCHAR *__thiscall sub_4106E9(wchar_t *FullPath);
int sub_410820();
// void __noreturn __report_rangecheckfailure(void); weak
int __cdecl UserMathErrorFunction();
int sub_410F0D();
void sub_410F17();
char sub_410F23();
// int __scrt_initialize_default_local_stdio_options(void); weak
BOOL sub_410F64();
void *sub_410F70();
void *sub_410F76();
LPTOP_LEVEL_EXCEPTION_FILTER sub_4110DE();
// LONG __stdcall __scrt_unhandled_exception_filter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
void sub_41112B();
void sub_411133();
void __cdecl sub_41115F(); // idb
// void *__cdecl memset(void *, int Val, size_t Size);
int sub_41142A();
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl memmove(void *, const void *Src, size_t Size);

//-------------------------------------------------------------------------
// Data declarations

char byte_401060[] = { '\0' }; // weak
wchar_t **off_401170[12] =
{
  &off_401210,
  &off_401204,
  &off_4011F8,
  &off_4011EC,
  &off_4011E0,
  &off_4011EC,
  &off_4011E0,
  &off_4011D4,
  &off_4011C8,
  &off_4011BC,
  &off_4011B0,
  &off_4011A4
}; // weak
void *const off_401240 = &aSuffixes_0; // idb
char byte_401280[] = { '\x01' }; // weak
char byte_4013A0[] = { '\x01' }; // weak
char byte_4013A1[] = { '\x02' }; // weak
int (*funcs_40CF81[6])() = { &sub_402AE0, &sub_402B07, &sub_403323, &sub_4030D2, &sub_402CE6, &sub_4031EC }; // weak
char byte_401480[] = { '\x01' }; // weak
char byte_4014A0[] = { '\"' }; // weak
_UNKNOWN off_4014E0; // weak
char byte_401570[] = { '\0' }; // weak
char byte_401590[] = { '\0' }; // weak
int dword_401690 = 0; // weak
const wchar_t aPa[] = L"PA"; // idb
const wchar_t aPa_0[] = L"PA"; // idb
int dword_401938 = 65279; // weak
void *off_402480 = (void *)0x41004D; // weak
void *off_40248C = (void *)0x41004D; // weak
const wchar_t aMa[] = L"MA"; // idb
int dword_412004 = 1; // weak
char byte_412020 = '\x01'; // weak
char byte_412021 = '\x01'; // weak
int dword_412024 = -1; // weak
int dword_412028 = -1; // weak
wchar_t aMakeflags[29] = L"MAKEFLAGS=                  "; // weak
char byte_412066 = '\x01'; // weak
wchar_t *off_412068 = &dword_401690; // idb
wchar_t *off_41206C = &dword_401690; // idb
wchar_t *off_412070 = L"("; // weak
_UNKNOWN unk_412118; // weak
union _SLIST_HEADER ListHead; // idb
int dword_412468; // weak
int dword_412480; // weak
int dword_412484; // weak
wchar_t *dword_412488; // idb
char byte_41248C; // weak
char byte_41248D; // weak
char byte_41248E; // weak
char byte_41248F; // weak
wchar_t Destination; // idb
wchar_t Str; // idb
int dword_422490[128]; // weak
int dword_422690; // weak
void *dword_422694; // idb
int dword_422698; // idb
int dword_42269C; // weak
int dword_4226A0; // weak
int dword_4226A4; // weak
int dword_4226A8; // weak
wchar_t *dword_4226AC; // idb
int dword_4226B0; // weak
char byte_4226B4; // weak
char byte_4226B5; // weak
char byte_4226B6; // weak
char byte_4226B7; // weak
wchar_t *Block; // idb
int dword_4226BC; // weak
wchar_t Src; // idb
wchar_t word_4226C2; // idb
__int16 word_422EBC; // weak
int dword_422EC0; // weak
int dword_422EC4; // weak
int dword_422EC8; // weak
void *dword_422ECC; // idb
int dword_422ED0; // weak
wchar_t *dword_422ED4; // idb
int dword_422ED8; // weak
FILE *Stream; // idb
char byte_422EE0; // weak
char byte_422EE1; // weak
char byte_422EE2; // weak
char byte_422EE3; // weak
void *dword_422EE4; // idb
wchar_t *dword_422EE8; // idb
int dword_422EEC; // weak
wchar_t word_422EF0[32768]; // weak
int dword_432EF0; // weak
int dword_432EF4; // weak
void *dword_432EF8; // idb
wchar_t *dword_432EFC; // idb
char byte_432F00[]; // weak
int dword_432F10[255]; // weak
char byte_43330F[]; // weak
char byte_433310[]; // weak
char byte_433311[]; // weak
int dword_433320; // weak
int dword_433324; // weak
int dword_433328; // weak
int dword_43332C; // weak
int dword_433330[]; // weak
int dword_433334[]; // weak
int dword_433338[]; // weak
int dword_4333F0; // weak
int dword_4333F4; // weak
char byte_4333F8; // weak
char byte_4333F9; // weak
char byte_4333FA; // weak
char byte_4333FB; // weak
char byte_4333FC; // weak
char byte_4333FD; // weak
char byte_4333FE; // weak
char byte_4333FF; // weak
_UNKNOWN unk_433400; // weak
char byte_433602; // weak
char byte_433603; // weak
int dword_433604; // weak
int dword_433608; // weak
int dword_43360C; // weak
int dword_433610; // weak
wchar_t *EndPtr; // idb
int dword_433618; // weak
int dword_43361C; // weak
_UNKNOWN unk_433620; // weak
_UNKNOWN unk_435618; // weak
unsigned __int8 byte_435620[4088]; // weak
_UNKNOWN unk_436618; // weak
int dword_436620; // weak
int dword_436624; // weak
int dword_436628; // weak
LPCVOID lpBaseAddress; // idb
struct _SECURITY_ATTRIBUTES MutexAttributes; // idb
HANDLE ArgList; // idb
char byte_436640; // weak
int dword_436644; // weak
_UNKNOWN unk_436648; // weak
HANDLE hHandle; // idb
_UNKNOWN unk_436658; // weak
PVOID dword_436660; // idb
PVOID Ptr; // idb
int dword_43666C; // weak
wchar_t word_436670[1024]; // weak
WCHAR Dst[260]; // weak
wchar_t Buffer[260]; // weak
struct _STARTUPINFOW StartupInfo; // idb
HANDLE ProcessInformation; // idb
char byte_4372D4; // weak
HMODULE hModule; // idb
__int16 word_4372DC; // weak
_UNKNOWN unk_4372E0; // weak
_UNKNOWN unk_4372E4; // weak
// extern LSTATUS (__stdcall *RegQueryValueExW)(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern LSTATUS (__stdcall *RegOpenKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// extern HRSRC (__stdcall *FindResourceExW)(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage);
// extern HGLOBAL (__stdcall *LoadResource)(HMODULE hModule, HRSRC hResInfo);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern BOOL (__stdcall *GetExitCodeProcess)(HANDLE hProcess, LPDWORD lpExitCode);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern UINT (__stdcall *GetTempFileNameW)(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *SetFileTime)(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *GetFileTime)(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern HMODULE (__stdcall *LoadLibraryExW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// extern DWORD (__stdcall *GetLastError)();
// extern DWORD (__stdcall *GetEnvironmentVariableW)(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// extern PVOID (__stdcall *EncodePointer)(PVOID Ptr);
// extern PVOID (__stdcall *DecodePointer)(PVOID Ptr);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern LANGID (__stdcall *GetUserDefaultUILanguage)();
// extern DWORD (__stdcall *GetVersion)();
// extern DWORD (__stdcall *ExpandEnvironmentStringsW)(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
// extern HANDLE (__stdcall *CreateFileMappingW)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
// extern LPVOID (__stdcall *MapViewOfFileEx)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress);
// extern HANDLE (__stdcall *CreateEventW)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// extern HANDLE (__stdcall *CreateMutexW)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern BOOL (__stdcall *DuplicateHandle)(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern BOOL (__stdcall *CreateProcessW)(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern BOOL (__stdcall *ReleaseMutex)(HANDLE hMutex);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern BOOL (__stdcall *UnmapViewOfFile)(LPCVOID lpBaseAddress);
// extern UINT (__stdcall *SetErrorMode)(UINT uMode);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern BOOL (__stdcall *GetFileSizeEx)(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// extern DWORD (__stdcall *GetFileType)(HANDLE hFile);
// extern BOOL (__stdcall *GetConsoleMode)(HANDLE hConsoleHandle, LPDWORD lpMode);
// extern BOOL (__stdcall *FileTimeToLocalFileTime)(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
// extern BOOL (__stdcall *FileTimeToSystemTime)(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
// extern int (__stdcall *GetDateFormatW)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate);
// extern int (__stdcall *GetTimeFormatW)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern wchar_t *(__cdecl *wcsstr)(const wchar_t *Str, const wchar_t *SubStr);
// extern wchar_t *(__cdecl *wcsrchr)(const wchar_t *Str, wchar_t Ch);
// extern wchar_t *(__cdecl *wcschr)(const wchar_t *Str, wchar_t Ch);
// extern int (__cdecl *_conio_common_vcwprintf)(unsigned __int64 Options, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern wint_t (__cdecl *putwch)(wchar_t Character);
// extern unsigned int (__cdecl *wcstoul)(const wchar_t *String, wchar_t **EndPtr, int Radix);
// extern errno_t (__cdecl *itow_s)(int Value, wchar_t *Buffer, size_t BufferCount, int Radix);
// extern int (__cdecl *wcstol)(const wchar_t *String, wchar_t **EndPtr, int Radix);
// extern wchar_t ***(__cdecl *_p__wenviron)();
// extern errno_t (__cdecl *wputenv_s)(const wchar_t *Name, const wchar_t *Value);
// extern void (__cdecl *wsearchenv)(const wchar_t *Filename, const wchar_t *VarName, wchar_t *ResultPath);
// extern wchar_t *(__cdecl *wgetcwd)(wchar_t *DstBuf, int SizeInWords);
// extern errno_t (__cdecl *wdupenv_s)(wchar_t **Buffer, size_t *BufferCount, const wchar_t *VarName);
// extern errno_t (__cdecl *wgetenv_s)(size_t *RequiredCount, wchar_t *Buffer, size_t BufferCount, const wchar_t *VarName);
// extern int (__cdecl *wputenv)(const wchar_t *EnvString);
// extern int (__cdecl *chdrive)(int Drive);
// extern errno_t (__cdecl *wmakepath_s)(wchar_t *Buffer, size_t BufferCount, const wchar_t *Drive, const wchar_t *Dir, const wchar_t *Filename, const wchar_t *Ext);
// extern int (__cdecl *wchdir)(const wchar_t *Path);
// extern int (__cdecl *wremove)(const wchar_t *FileName);
// extern errno_t (__cdecl *wsplitpath_s)(const wchar_t *FullPath, wchar_t *Drive, size_t DriveCount, wchar_t *Dir, size_t DirCount, wchar_t *Filename, size_t FilenameCount, wchar_t *Ext, size_t ExtCount);
// extern int (__cdecl *wunlink)(const wchar_t *FileName);
// extern int (__cdecl *waccess)(const wchar_t *FileName, int AccessMode);
// extern errno_t (__cdecl *waccess_s)(const wchar_t *FileName, int AccessMode);
// extern void (__cdecl *free)(void *Block);
// extern void *(__cdecl *realloc)(void *Block, size_t Size);
// extern void *(__cdecl *malloc)(size_t Size);
// extern char *(__cdecl *setlocale)(int Category, const char *Locale);
// extern intptr_t (__cdecl *wspawnvp)(int Mode, const wchar_t *FileName, const wchar_t *const *ArgList);
// extern int *(__cdecl *errno)();
// extern errno_t (__cdecl *wcserror_s)(wchar_t *Buffer, size_t SizeInWords, int ErrorNumber);
// extern void (__cdecl *invalid_parameter_noinfo)();
// extern unsigned int *(__cdecl *_doserrno)();
// extern wchar_t **(__cdecl *_p__wpgmptr)();
// extern _invalid_parameter_handler (__cdecl *set_invalid_parameter_handler)(_invalid_parameter_handler Handler);
// extern _crt_signal_t (__cdecl *signal)(int Signal, _crt_signal_t Function);
// extern void (__cdecl __noreturn *exit)(int Code);
// extern wchar_t *(__cdecl *fgetws)(wchar_t *Buffer, int BufferCount, FILE *Stream);
// extern int (__cdecl *_stdio_common_vfwprintf)(unsigned __int64 Options, FILE *Stream, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern FILE *(__cdecl *wfsopen)(const wchar_t *FileName, const wchar_t *Mode, int ShFlag);
// extern int (__cdecl *fclose)(FILE *Stream);
// extern wint_t (__cdecl *fputwc)(wchar_t Character, FILE *Stream);
// extern int (__cdecl *fflush)(FILE *Stream);
// extern errno_t (__cdecl *wfopen_s)(FILE **Stream, const wchar_t *FileName, const wchar_t *Mode);
// extern int (__cdecl *setvbuf)(FILE *Stream, char *Buffer, int Mode, size_t Size);
// extern intptr_t (__cdecl *get_osfhandle)(int FileHandle);
// extern int (__cdecl *_stdio_common_vswprintf_s)(unsigned __int64 Options, wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern int (__cdecl *_stdio_common_vswscanf)(unsigned __int64 Options, const wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern size_t (__cdecl *fwrite)(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// extern int (__cdecl *feof)(FILE *Stream);
// extern wint_t (__cdecl *ungetwc)(wint_t Character, FILE *Stream);
// extern wint_t (__cdecl *getwc)(FILE *Stream);
// extern int (__cdecl *dup)(int FileHandle);
// extern int (__cdecl *lseek)(int FileHandle, int Offset, int Origin);
// extern int (__cdecl *close)(int FileHandle);
// extern int (__cdecl *fileno)(FILE *Stream);
// extern int (__cdecl *dup2)(int FileHandleSrc, int FileHandleDst);
// extern errno_t (__cdecl *wsopen_s)(int *FileHandle, const wchar_t *FileName, int OpenFlag, int ShareFlag, int PermissionFlag);
// extern FILE *(__cdecl *_acrt_iob_func)(unsigned int Ix);
// extern int (__cdecl *fcloseall)();
// extern size_t (__cdecl *wcsspn)(const wchar_t *String, const wchar_t *Control);
// extern errno_t (__cdecl *wcsupr_s)(wchar_t *String, size_t Size);
// extern errno_t (__cdecl *wcsncat_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source, rsize_t MaxCount);
// extern int (__cdecl *wcsncmp)(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// extern errno_t (__cdecl *wcsncpy_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source, rsize_t MaxCount);
// extern errno_t (__cdecl *wcscpy_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// extern int (__cdecl *wcsnicmp)(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// extern wint_t (__cdecl *towupper)(wint_t C);
// extern wchar_t *(__cdecl *wcstok_s)(wchar_t *String, const wchar_t *Delimiter, wchar_t **Context);
// extern int (__cdecl *iswalpha)(wint_t C);
// extern int (__cdecl *iswspace)(wint_t C);
// extern wchar_t *(__cdecl *wcspbrk)(const wchar_t *String, const wchar_t *Control);
// extern int (__cdecl *wcsicmp)(const wchar_t *String1, const wchar_t *String2);
// extern int (__cdecl *iswdigit)(wint_t C);
// extern errno_t (__cdecl *wcscat_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);


//----- (00402AE0) --------------------------------------------------------
wchar_t *sub_402AE0()
{
  wchar_t *result; // eax

  sub_40EBFB(&Src, (int **)&dword_4226BC, 0, 0, 0, 0, 0);
  result = (wchar_t *)sub_40E919((char *)&Src);
  Block = result;
  return result;
}
// 4226BC: using guessed type int dword_4226BC;

//----- (00402B07) --------------------------------------------------------
_DWORD *sub_402B07()
{
  _DWORD *v0; // eax
  char v1; // dl
  _DWORD *v2; // esi
  void *v3; // eax
  int *v4; // esi
  int *v5; // eax
  int v6; // ecx
  _DWORD *v8; // [esp+Ch] [ebp-4h] BYREF

  if ( Block )
  {
    byte_4226B4 |= 0x20u;
    sub_402C29();
    Block = 0;
  }
  if ( (byte_4226B4 & 0x20) != 0 && sub_40FFA7(&Src) )
  {
    if ( (byte_4226B4 & 0x10) != 0 )
      sub_4053D9(dword_4226B0, 0x444u);
    sub_4053D9(dword_4226B0, 0x43Du);
  }
  v0 = sub_40E8C7();
  v1 = byte_4226B4;
  v2 = v0;
  if ( (byte_4226B4 & 0x40) != 0 )
  {
    v0[1] = dword_4226AC;
    dword_4226AC = 0;
  }
  else
  {
    v3 = sub_40E919((char *)&Src);
    v1 = byte_4226B4;
    v2[1] = v3;
  }
  v8 = v2;
  if ( (v1 & 0x30) != 16 )
  {
    sub_40EBFB((_WORD *)v2[1], (int **)&dword_4226BC, 0, 0, 0, 0, 0);
    v1 = byte_4226B4;
  }
  if ( (v1 & 0x20) != 0 )
  {
    v4 = (int *)dword_4226BC;
    sub_402EA0((wchar_t *)L"$", (int *)&v8, &dword_4226BC);
    sub_402EA0((wchar_t *)L"*?", (int *)&v8, 0);
    v5 = v4;
    dword_4226BC = (int)v4;
    if ( v4 )
    {
      v6 = dword_433618;
      do
      {
        v4 = (int *)*v4;
        *v5 = v6;
        v6 = (int)v5;
        v5 = v4;
        dword_4226BC = (int)v4;
      }
      while ( v4 );
      dword_433618 = v6;
    }
  }
  return sub_40EA1E((_DWORD **)&dword_4226A8, v8);
}
// 4226A8: using guessed type int dword_4226A8;
// 4226B0: using guessed type int dword_4226B0;
// 4226B4: using guessed type char byte_4226B4;
// 4226BC: using guessed type int dword_4226BC;
// 433618: using guessed type int dword_433618;

//----- (00402C29) --------------------------------------------------------
char sub_402C29()
{
  _DWORD *v0; // eax
  int *v1; // esi
  int *v2; // eax
  int v3; // ecx
  int v4; // ecx

  byte_41248F = byte_41248E;
  v0 = sub_40E8C7();
  v0[1] = Block;
  v1 = (int *)dword_4226BC;
  dword_4226A8 = (int)v0;
  sub_402EA0((wchar_t *)L"$", &dword_4226A8, &dword_4226BC);
  sub_402EA0((wchar_t *)L"*?", &dword_4226A8, 0);
  v2 = v1;
  dword_4226BC = (int)v1;
  if ( v1 )
  {
    v3 = dword_433618;
    do
    {
      v1 = (int *)*v1;
      *v2 = v3;
      v3 = (int)v2;
      v2 = v1;
      dword_4226BC = (int)v1;
    }
    while ( v1 );
    dword_433618 = v3;
  }
  v4 = dword_4226A8;
  if ( dword_4226A8
    || (byte_4226B4 & 0x20) == 0 && (LOBYTE(v2) = sub_4053D9(dword_4226A4, 0x43Bu, Block), (v4 = dword_4226A8) != 0) )
  {
    LOBYTE(v2) = sub_40FFA7(*(_WORD **)(v4 + 4));
    if ( (_BYTE)v2 )
      byte_4226B4 |= 0x10u;
  }
  return (char)v2;
}
// 41248E: using guessed type char byte_41248E;
// 41248F: using guessed type char byte_41248F;
// 4226A4: using guessed type int dword_4226A4;
// 4226A8: using guessed type int dword_4226A8;
// 4226B4: using guessed type char byte_4226B4;
// 4226BC: using guessed type int dword_4226BC;
// 433618: using guessed type int dword_433618;

//----- (00402CE6) --------------------------------------------------------
void sub_402CE6()
{
  char v0; // bl
  int v1; // esi
  _DWORD *v2; // eax
  int v3; // eax

  if ( Block )
  {
    sub_402C29();
    Block = 0;
  }
  else
  {
    byte_4226B4 &= ~0x20u;
  }
  v0 = byte_41248F;
  if ( word_4226C2 )
  {
    v0 = byte_41248F | 0x20;
    byte_41248F |= 0x20u;
  }
  v1 = dword_4226A8;
  if ( !dword_4226A8 )
    sub_4053D9(dword_4226B0, 0x40Du);
  if ( (byte_4226B4 & 0x10) != 0 )
  {
    v2 = sub_40AC08(0x18u);
    v2[2] = *(_DWORD *)(v1 + 4);
    *((_BYTE *)v2 + 20) = (v0 & 0x20) != 0;
    *v2 = dword_422694;
    dword_422694 = v2;
    if ( *v2 )
      *(_DWORD *)(*v2 + 4) = v2;
    goto LABEL_14;
  }
  if ( *(_DWORD *)v1 )
  {
LABEL_16:
    dword_412480 = v1;
    goto LABEL_17;
  }
  if ( !sub_402DC5(*(wchar_t **)(v1 + 4)) )
  {
    v1 = dword_4226A8;
    goto LABEL_16;
  }
  free(*(void **)(dword_4226A8 + 4));
LABEL_14:
  v3 = dword_433618;
  dword_433618 = dword_4226A8;
  *(_DWORD *)dword_4226A8 = v3;
LABEL_17:
  dword_4226A8 = 0;
  byte_4226B4 |= 0x80u;
}
// 412480: using guessed type int dword_412480;
// 41248F: using guessed type char byte_41248F;
// 4226A8: using guessed type int dword_4226A8;
// 4226B0: using guessed type int dword_4226B0;
// 4226B4: using guessed type char byte_4226B4;
// 433618: using guessed type int dword_433618;

//----- (00402DC5) --------------------------------------------------------
char __thiscall sub_402DC5(wchar_t *String1)
{
  wchar_t *v1; // esi
  int v2; // ebx
  int v3; // eax
  const wchar_t *v5; // eax
  bool v6; // cf
  wchar_t v7; // cx
  char v8; // [esp+Fh] [ebp-1h]

  v1 = String1;
  v2 = 0;
  v8 = 0;
  if ( !wcsicmp(String1, L".SILENT") )
  {
    byte_4226B4 |= 2u;
    sub_40C801(0x73u, 1);
    v8 = 1;
  }
  if ( !wcsicmp(v1, L".IGNORE") )
  {
    byte_4226B4 |= 4u;
    sub_40C801(0x69u, 1);
    return 1;
  }
  v3 = wcscmp(v1, L".SUFFIXES");
  if ( v3 )
    v3 = v3 < 0 ? -1 : 1;
  if ( !v3 )
  {
    byte_4226B4 |= 1u;
    return 1;
  }
  v5 = L".PRECIOUS";
  while ( 1 )
  {
    v6 = *v1 < *v5;
    if ( *v1 != *v5 )
      break;
    if ( !*v1 )
      goto LABEL_17;
    v7 = v1[1];
    v6 = v7 < v5[1];
    if ( v7 != v5[1] )
      break;
    v1 += 2;
    v5 += 2;
    if ( !v7 )
      goto LABEL_17;
  }
  v2 = v6 ? -1 : 1;
LABEL_17:
  if ( !v2 )
  {
    byte_4226B4 |= 8u;
    return 1;
  }
  return v8;
}
// 401124: using guessed type wchar_t aPrecious[10];
// 401138: using guessed type wchar_t aSuffixes[10];
// 4226B4: using guessed type char byte_4226B4;

//----- (00402EA0) --------------------------------------------------------
void __fastcall sub_402EA0(wchar_t *Control, int *a2, _DWORD *a3)
{
  int v3; // esi
  int *v4; // ebx
  _DWORD *v5; // edi
  __int16 *v6; // ecx
  void *v7; // eax
  int v8; // eax
  int *v9; // edx
  int *v10; // eax
  void *v11; // eax
  int *v12; // ecx
  char *v13; // esi
  int *v14; // ecx
  void *v15; // [esp-4h] [ebp-2Ch]
  _DWORD *v16; // [esp+Ch] [ebp-1Ch] BYREF
  int *v17; // [esp+10h] [ebp-18h]
  void *Block; // [esp+14h] [ebp-14h]
  wchar_t *v19; // [esp+18h] [ebp-10h]
  void *v20; // [esp+1Ch] [ebp-Ch] BYREF
  void *v21; // [esp+20h] [ebp-8h]
  int v22; // [esp+24h] [ebp-4h]

  v17 = a2;
  v3 = *a2;
  v4 = 0;
  v5 = 0;
  v19 = Control;
  Block = 0;
  v16 = 0;
  v21 = 0;
  while ( v3 )
  {
    if ( !wcspbrk(*(const wchar_t **)(v3 + 4), Control) )
      goto LABEL_24;
    v6 = *(__int16 **)(v3 + 4);
    if ( *v19 == 36 )
    {
      v7 = sub_40F311(v6, 255, a3);
      v15 = *(void **)(v3 + 4);
      Block = v7;
      free(v15);
    }
    else
    {
      if ( sub_40FFA7(v6) || (v5 = sub_4106E9(*(wchar_t **)(v3 + 4)), (v16 = v5) == 0) )
      {
LABEL_24:
        v4 = (int *)v3;
        v3 = *(_DWORD *)v3;
        goto LABEL_25;
      }
      v21 = *(void **)(v3 + 4);
    }
    v8 = *(_DWORD *)v3;
    v9 = v17;
    if ( v4 )
    {
      *v4 = v8;
      *(_DWORD *)v3 = dword_433618;
      v10 = v4;
    }
    else
    {
      *v17 = v8;
      *(_DWORD *)v3 = dword_433618;
      v10 = v9;
    }
    v22 = *v10;
    dword_433618 = v3;
    if ( *v19 == 36 )
    {
      v20 = Block;
      while ( 1 )
      {
        v13 = (char *)sub_40300C(&v20);
        if ( !v13 )
          break;
        v5 = sub_40E8C7();
        v16 = v5;
        v11 = sub_40E919(v13);
        v12 = v17;
        v5[1] = v11;
        *v5 = *v12;
        *v12 = (int)v5;
        if ( !v4 )
          v4 = v5;
      }
      free(Block);
    }
    else
    {
      if ( v5 )
      {
        if ( !v4 )
        {
          v14 = (int *)*v5;
          v4 = v5;
          if ( *v5 )
          {
            do
            {
              v4 = v14;
              v14 = (int *)*v14;
            }
            while ( v14 );
          }
        }
        sub_40EA1E(&v16, (_DWORD *)*v9);
        v5 = v16;
        *v17 = (int)v16;
      }
      free(v21);
    }
    v3 = v22;
LABEL_25:
    Control = v19;
  }
}
// 433618: using guessed type int dword_433618;

//----- (0040300C) --------------------------------------------------------
_WORD *__thiscall sub_40300C(_DWORD *this)
{
  _DWORD *v1; // edi
  _WORD *i; // ecx
  __int16 v3; // ax
  _WORD *v4; // ebx
  _WORD *result; // eax
  __int16 v6; // dx
  __int16 v7; // si
  _WORD *v8; // eax
  _WORD *v9; // [esp+10h] [ebp-8h]

  v1 = this;
  for ( i = (_WORD *)*this; ; ++i )
  {
    v3 = *i;
    if ( *i != 32 && v3 != 9 )
      break;
  }
  v4 = i;
  v9 = i;
  if ( !v3 )
    return 0;
  if ( v3 == 34 )
  {
    do
      ++i;
    while ( *i && *i != 34 );
    v6 = *i;
  }
  else
  {
    v7 = *i;
    do
    {
      v6 = v7;
      if ( v7 == 32 )
        break;
      v6 = v7;
      if ( v7 == 9 )
        break;
      v7 = *++i;
      v6 = *i;
    }
    while ( *i );
    v1 = this;
    v4 = v9;
  }
  v8 = i;
  if ( v6 == 32 || v6 == 9 )
    goto LABEL_23;
  if ( v6 != 34 )
  {
    if ( !v6 )
      --i;
    goto LABEL_24;
  }
  if ( *++i )
LABEL_23:
    *i = 0;
  else
    i = v8;
LABEL_24:
  result = v4;
  *v1 = i + 1;
  return result;
}

//----- (004030D2) --------------------------------------------------------
char sub_4030D2()
{
  char v0; // al
  const wchar_t *v1; // ecx
  int *v2; // ecx
  int v3; // esi
  int *v4; // ecx
  char result; // al

  v0 = byte_4226B4;
  v1 = 0;
  if ( byte_4226B4 < 0 )
  {
    v0 = byte_4226B4 & 0x7F;
    byte_4226B4 &= ~0x80u;
  }
  if ( (v0 & 0x10) == 0 )
  {
    if ( (v0 & 6) != 0 )
    {
      if ( dword_4226A8 )
      {
        if ( (v0 & 2) != 0 )
        {
          v1 = L".SILENT";
        }
        else if ( (v0 & 4) != 0 )
        {
          v1 = L".IGNORE";
        }
        sub_4053D9(dword_4226B0, 0x442u, v1);
        goto LABEL_24;
      }
      goto LABEL_25;
    }
    if ( (v0 & 1) != 0 )
    {
      if ( !dword_4226A8 )
      {
        v2 = (int *)dword_4226A0;
        v3 = dword_4226A0;
        if ( dword_4226A0 )
        {
          do
          {
            dword_4226A0 = *v2;
            free(*(void **)(v3 + 4));
            *(_DWORD *)v3 = dword_433618;
            v2 = (int *)dword_4226A0;
            dword_433618 = v3;
            v3 = dword_4226A0;
          }
          while ( dword_4226A0 );
          goto LABEL_24;
        }
        goto LABEL_25;
      }
      v4 = &dword_4226A0;
    }
    else
    {
      if ( (v0 & 8) == 0 )
      {
        dword_422698 = (int)sub_40AC08(0x20u);
        *(_DWORD *)dword_422698 = dword_4226A8;
        *(_DWORD *)(dword_422698 + 4) = dword_4226BC;
        goto LABEL_24;
      }
      if ( !dword_4226A8 )
        goto LABEL_25;
      v4 = &dword_42269C;
    }
    sub_40376B((_DWORD **)v4);
    goto LABEL_24;
  }
  if ( dword_4226A8 )
  {
    sub_4053D9(dword_4226B0, 0x43Eu);
LABEL_24:
    v0 = byte_4226B4;
  }
LABEL_25:
  dword_4226A8 = 0;
  result = v0 | 0x40;
  dword_4226BC = 0;
  byte_4226B4 = result;
  return result;
}
// 42269C: using guessed type int dword_42269C;
// 4226A0: using guessed type int dword_4226A0;
// 4226A8: using guessed type int dword_4226A8;
// 4226B0: using guessed type int dword_4226B0;
// 4226B4: using guessed type char byte_4226B4;
// 4226BC: using guessed type int dword_4226BC;
// 433618: using guessed type int dword_433618;

//----- (004031EC) --------------------------------------------------------
void sub_4031EC()
{
  const wchar_t *v0; // ecx
  char v1; // bl
  int v2; // esi
  int v3; // ecx
  int v4; // ecx
  int v5; // [esp-4h] [ebp-10h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = 0;
  v1 = 1;
  v6 = 1;
  if ( (byte_4226B4 & 0x10) != 0 )
  {
    *((_DWORD *)dword_422694 + 3) = dword_4226A8;
  }
  else if ( (byte_4226B4 & 0xF) != 0 )
  {
    if ( dword_4226A8 )
    {
      if ( (byte_4226B4 & 2) != 0 )
      {
        v0 = L".SILENT";
      }
      else if ( (byte_4226B4 & 4) != 0 )
      {
        v0 = L".IGNORE";
      }
      else if ( (byte_4226B4 & 8) != 0 )
      {
        v0 = L".PRECIOUS";
      }
      else if ( (byte_4226B4 & 1) != 0 )
      {
        v0 = L".SUFFIXES";
      }
      sub_4053D9(dword_4226B0, 0x441u, v0);
    }
  }
  else
  {
    v2 = dword_412480;
    *(_DWORD *)(dword_422698 + 8) = dword_4226A8;
    *(_DWORD *)(dword_422698 + 12) = dword_4226BC;
    *(_BYTE *)(dword_422698 + 16) = byte_41248F;
    if ( v2 )
    {
      do
      {
        if ( sub_402DC5(*(wchar_t **)(v2 + 4)) )
        {
          sub_4053D9(dword_4226B0, 0x445u);
          v3 = v5;
        }
        sub_4036AA(*(wchar_t **)(v2 + 4), v6, v3);
        if ( !dword_422690 )
        {
          dword_422690 = v2;
          v1 = 0;
        }
        v4 = *(_DWORD *)v2;
        dword_412480 = *(_DWORD *)v2;
        if ( v1 )
        {
          *(_DWORD *)v2 = dword_433618;
          dword_433618 = v2;
        }
        v6 = 0;
        v2 = v4;
      }
      while ( v4 );
    }
  }
  dword_412480 = 0;
  dword_4226A8 = 0;
  dword_4226BC = 0;
  dword_422698 = 0;
  byte_4226B4 = 0;
}
// 403273: variable 'v5' is possibly undefined
// 40327B: variable 'v3' is possibly undefined
// 401124: using guessed type wchar_t aPrecious[10];
// 401138: using guessed type wchar_t aSuffixes[10];
// 412480: using guessed type int dword_412480;
// 41248F: using guessed type char byte_41248F;
// 422690: using guessed type int dword_422690;
// 4226A8: using guessed type int dword_4226A8;
// 4226B0: using guessed type int dword_4226B0;
// 4226B4: using guessed type char byte_4226B4;
// 4226BC: using guessed type int dword_4226BC;
// 433618: using guessed type int dword_433618;

//----- (00403323) --------------------------------------------------------
void sub_403323()
{
  int *v0; // esi
  wchar_t *v1; // ebx
  int *v2; // eax
  int v3; // ecx
  wchar_t *v4; // esi
  wint_t v5; // cx

  if ( wcschr(Block, 0x24u) )
  {
    v0 = (int *)dword_4226BC;
    v1 = (wchar_t *)sub_40F311((__int16 *)Block, 255, &dword_4226BC);
    if ( !*v1 )
      sub_4053D9(dword_4226B0, 0x3ECu);
    v2 = v0;
    dword_4226BC = (int)v0;
    if ( v0 )
    {
      v3 = dword_433618;
      do
      {
        v0 = (int *)*v0;
        *v2 = v3;
        v3 = (int)v2;
        v2 = v0;
        dword_4226BC = (int)v0;
      }
      while ( v0 );
      dword_433618 = v3;
    }
    free(Block);
    Block = v1;
  }
  v4 = Block;
  if ( *Block )
  {
    v5 = *Block;
    do
    {
      if ( !sub_4038CF(v5) )
        break;
      v5 = *++v4;
    }
    while ( *v4 );
    if ( *v4 )
      sub_4053D9(dword_4226B0, 0x3E9u, *v4);
  }
  byte_41248D = 1;
  if ( !sub_403552(Block, dword_4226AC, 0) )
  {
    free(Block);
    free(dword_4226AC);
  }
  dword_4226AC = 0;
  Block = 0;
}
// 41248D: using guessed type char byte_41248D;
// 4226B0: using guessed type int dword_4226B0;
// 4226BC: using guessed type int dword_4226BC;
// 433618: using guessed type int dword_433618;

//----- (00403430) --------------------------------------------------------
char __fastcall sub_403430(wchar_t *Name, wchar_t *Str, int a3)
{
  wchar_t *v4; // edi
  wchar_t *v5; // esi
  wint_t v6; // cx
  int v8; // esi
  wchar_t *v9; // eax
  wchar_t *v10; // ecx
  __int64 v12; // rax
  wchar_t *v13; // eax
  wchar_t v14; // dx
  wchar_t *v15; // esi
  wchar_t *v16; // ecx
  wchar_t *v17; // [esp+Ch] [ebp-8h]

  v4 = Str;
  v5 = Name;
  v6 = *Name;
  if ( v6 )
  {
    do
    {
      if ( !sub_4038CF(v6) )
        break;
      v6 = *++v5;
    }
    while ( *v5 );
    v4 = Str;
  }
  if ( *v5 )
  {
    if ( (a3 & 4) != 0 )
      return 0;
    sub_4053D9(dword_4226B0, 0x3E9u, *v5);
  }
  if ( (a3 & 0x40) != 0 )
  {
    v8 = 0;
    v9 = wcschr(v4, 0x24u);
    if ( v9 )
    {
      do
      {
        ++v8;
        v9 = wcschr(v9 + 1, 0x24u);
      }
      while ( v9 );
      v4 = Str;
      if ( v8 )
      {
        v10 = Str;
        while ( *v10++ )
          ;
        v12 = 2i64 * (unsigned int)(v10 - (Str + 1) + v8 + 1);
        v13 = (wchar_t *)sub_40ABE3(HIDWORD(v12) != 0 ? -1 : v12);
        v14 = *Str;
        v15 = Str;
        v17 = v13;
        v16 = v13;
        if ( *Str )
        {
          do
          {
            *v16 = v14;
            ++v15;
            ++v16;
            if ( v14 == 36 )
              *v16++ = 36;
            v14 = *v15;
          }
          while ( *v15 );
          v4 = Str;
        }
        *v16 = 0;
        free(v4);
        v4 = v17;
      }
    }
  }
  return sub_403552(Name, v4, a3);
}
// 4226B0: using guessed type int dword_4226B0;

//----- (00403552) --------------------------------------------------------
char __fastcall sub_403552(wchar_t *Name, wchar_t *Str, int a3)
{
  int v5; // eax
  unsigned __int8 v6; // al
  wchar_t *v7; // eax
  int v8; // eax
  _DWORD *v9; // esi
  unsigned __int8 v10; // al
  _DWORD *v12; // ecx
  _DWORD *v13; // eax
  bool v14; // zf
  _DWORD *v15; // ecx
  char v16; // al
  char v17; // cl
  _DWORD *v18; // [esp+10h] [ebp-Ch]
  size_t RequiredCount; // [esp+14h] [ebp-8h] BYREF
  char v20; // [esp+1Bh] [ebp-1h]

  v20 = 0;
  RequiredCount = 0;
  if ( (a3 & 2) != 0 )
  {
    if ( !*Str )
      goto LABEL_13;
  }
  else
  {
    if ( !byte_41248D || (byte_41248C & 4) != 0 || wgetenv_s(&RequiredCount, 0, 0, Name) || !RequiredCount )
      goto LABEL_13;
    v5 = sub_40AB4F(Name);
    if ( v5 )
    {
      v6 = *(_BYTE *)(v5 + 12);
      if ( (v6 & 2) != 0 || ((unsigned __int8)byte_41248C & v6 & 4) != 0 )
        return 0;
    }
  }
  v7 = sub_40F2A9(Str);
  if ( wputenv_s(Name, v7) )
    sub_4053D9(dword_4226B0, 0x41Fu);
LABEL_13:
  byte_41248D = 0;
  v8 = sub_40AB4F(Name);
  v9 = (_DWORD *)v8;
  if ( v8 )
  {
    v10 = *(_BYTE *)(v8 + 12);
    if ( (v10 & 2) != 0 || ((unsigned __int8)byte_41248C & v10 & 4) != 0 )
      return 0;
  }
  v12 = sub_40E8C7();
  v18 = v12;
  v12[1] = Str;
  if ( v9 )
  {
    v20 = 1;
  }
  else
  {
    v13 = sub_40AC08(0x10u);
    v12 = v18;
    v9 = v13;
    v13[1] = Name;
  }
  v14 = v20 == 0;
  *((_BYTE *)v9 + 12) = a3 | v9[3] & 0xEF;
  *v12 = v9[2];
  v9[2] = v12;
  if ( v14 )
  {
    v15 = (_DWORD *)dword_436624;
    dword_436624 = 0;
    *v9 = *v15;
    *v15 = v9;
  }
  if ( (a3 & 0x40) == 0 && wcschr(Str, 0x24u) )
  {
    *((_BYTE *)v9 + 12) |= 1u;
    v16 = sub_40EBFB(Str, 0, 0, Name, 1, 0, a3);
    *((_BYTE *)v9 + 12) &= ~1u;
    v17 = *((_BYTE *)v9 + 12);
    if ( !v16 )
    {
      v9[2] = 0;
      *((_BYTE *)v9 + 12) = v17 | 0x10;
    }
  }
  return 1;
}
// 41248C: using guessed type char byte_41248C;
// 41248D: using guessed type char byte_41248D;
// 4226B0: using guessed type int dword_4226B0;
// 436624: using guessed type int dword_436624;

//----- (004036AA) --------------------------------------------------------
void __fastcall sub_4036AA(wchar_t *Block, char a2, int a3)
{
  _DWORD *v3; // eax
  _DWORD *v5; // eax
  int v6; // ecx
  _DWORD *v7; // edi
  _DWORD *v8; // eax
  _DWORD *v9; // esi
  int *v10; // eax
  int v11; // ecx
  int *v12; // esi
  int *v13; // ecx

  v3 = (_DWORD *)dword_422698;
  if ( !dword_422698 )
  {
    v3 = sub_40AC08(0x20u);
    dword_422698 = (int)v3;
  }
  if ( a2 )
  {
    v5 = sub_40AC08(8u);
    v6 = dword_422698;
    v7 = v5;
    v5[1] = dword_422698;
  }
  else
  {
    v7 = sub_403885(v3);
  }
  v8 = sub_40EA6B(Block, v6, v6);
  v9 = v8;
  if ( v8 )
  {
    if ( (((unsigned __int8)byte_41248F ^ *((_BYTE *)v8 + 8)) & 0x20) != 0 )
      sub_4053D9(dword_4226B0, 0x43Fu);
    sub_40EA1E((_DWORD **)v9 + 6, v7);
    free(Block);
  }
  else
  {
    *v7 = 0;
    v10 = (int *)sub_40AC08(0x20u);
    LOBYTE(v11) = byte_41248F;
    v12 = v10;
    *((_BYTE *)v10 + 8) = byte_41248F;
    v10[1] = (int)Block;
    v10[6] = (int)v7;
    v13 = &dword_422490[sub_40EA33(Block, v11)];
    *v12 = *v13;
    *v13 = (int)v12;
  }
}
// 4036F4: variable 'v6' is possibly undefined
// 403752: variable 'v11' is possibly undefined
// 41248F: using guessed type char byte_41248F;
// 422490: using guessed type int dword_422490[128];
// 4226B0: using guessed type int dword_4226B0;

//----- (0040376B) --------------------------------------------------------
void __thiscall sub_40376B(_DWORD **this)
{
  int v1; // edi
  _DWORD **v2; // esi
  _DWORD *v3; // ebx
  int *v4; // esi
  wchar_t *v5; // eax
  int v6; // edx
  int *v7; // ecx
  wchar_t *v8; // eax
  char *v9; // ebx
  _DWORD *v10; // esi
  wchar_t *Block; // [esp+Ch] [ebp-18h]
  int v12; // [esp+14h] [ebp-10h]
  wchar_t *Context; // [esp+1Ch] [ebp-8h] BYREF
  int v15; // [esp+20h] [ebp-4h]

  v1 = dword_4226A8;
  v2 = this;
  v3 = (_DWORD *)dword_4226A8;
  v15 = dword_4226A8;
  v12 = dword_4226A8;
  while ( v1 )
  {
    if ( wcschr(*(const wchar_t **)(v1 + 4), 0x24u) )
    {
      v4 = (int *)dword_4226BC;
      v5 = (wchar_t *)sub_40F311(*(__int16 **)(v1 + 4), 255, &dword_4226BC);
      Block = v5;
      if ( v4 != (int *)dword_4226BC )
      {
        v6 = dword_433618;
        do
        {
          v7 = (int *)*v4;
          *v4 = v6;
          v6 = (int)v4;
          v4 = v7;
        }
        while ( v7 != (int *)dword_4226BC );
        dword_433618 = v6;
      }
      Context = 0;
      v8 = wcstok_s(v5, L" \t", &Context);
      if ( v8 )
      {
        v9 = (char *)v8;
        do
        {
          v10 = sub_40E8C7();
          v10[1] = sub_40E919(v9);
          sub_40EA1E(this, v10);
          v9 = (char *)wcstok_s(0, L" \t", &Context);
        }
        while ( v9 );
        v1 = v15;
        v3 = (_DWORD *)v12;
      }
      free(Block);
      free(*(void **)(v1 + 4));
      v1 = *(_DWORD *)v1;
      v2 = this;
      v15 = v1;
      *v3 = dword_433618;
      dword_433618 = (int)v3;
    }
    else
    {
      v1 = *(_DWORD *)v1;
      *v3 = 0;
      v15 = v1;
      sub_40EA1E(v2, v3);
    }
    v3 = (_DWORD *)v1;
    v12 = v1;
  }
}
// 4226A8: using guessed type int dword_4226A8;
// 4226BC: using guessed type int dword_4226BC;
// 433618: using guessed type int dword_433618;

//----- (00403885) --------------------------------------------------------
_DWORD *__thiscall sub_403885(_DWORD *this)
{
  _DWORD *v2; // edi
  _DWORD *v3; // eax
  int v4; // edx

  v2 = sub_40AC08(8u);
  v3 = sub_40AC08(0x20u);
  v4 = *this;
  v2[1] = v3;
  *v3 = v4;
  v3[1] = this[1];
  v3[2] = this[2];
  v3[3] = this[3];
  *((_BYTE *)v3 + 16) = *((_BYTE *)this + 16);
  v3[6] = this[6];
  v3[7] = this[7];
  return v2;
}

//----- (004038CF) --------------------------------------------------------
bool __fastcall sub_4038CF(wint_t C)
{
  if ( C >= 0x80u )
    return iswspace(C) == 0;
  else
    return byte_401060[C] & 1;
}

//----- (004038F4) --------------------------------------------------------
int sub_4038F4()
{
  WCHAR *v0; // eax
  wchar_t *v1; // edi
  int v2; // ecx
  int v3; // esi
  int result; // eax
  int *v5; // ebx
  int v6; // esi
  int v7; // [esp-4h] [ebp-27Ch]
  __int64 v8; // [esp+10h] [ebp-268h] BYREF
  HANDLE hFindFile; // [esp+1Ch] [ebp-25Ch] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+20h] [ebp-258h] BYREF

  while ( 1 )
  {
    result = dword_422690;
    v5 = (int *)dword_422690;
    if ( !dword_422690 )
      return result;
    if ( wcspbrk(*(const wchar_t **)(dword_422690 + 4), L"*?") )
    {
      v0 = sub_407A35(*(wchar_t **)(dword_422690 + 4), &FindFileData, &hFindFile);
      if ( v0 )
      {
        while ( 1 )
        {
          v1 = (wchar_t *)sub_40FF33(*(wchar_t **)(dword_422690 + 4), v0);
          v8 = sub_407A1B((char *)&FindFileData);
          v3 = sub_403A44(v1, byte_41248E, &v8, v2);
          free(v1);
          if ( v3 < 0 && (byte_41248C & 8) != 0 )
            break;
          v0 = sub_407BC1(&FindFileData, hFindFile);
          if ( !v0 )
            goto LABEL_11;
        }
        v6 = -1;
        goto LABEL_16;
      }
      sub_4053D9(0, 0x42Du, *(_DWORD *)(dword_422690 + 4));
    }
    else
    {
      v8 = 0i64;
      if ( sub_403A44(*(wchar_t **)(dword_422690 + 4), byte_41248E, &v8, v7) < 0 && (byte_41248C & 8) != 0 )
      {
        v6 = 255;
LABEL_16:
        sub_404BAE(v5);
        return v6;
      }
    }
LABEL_11:
    dword_422690 = *v5;
    *v5 = dword_433618;
    dword_433618 = (int)v5;
  }
}
// 40397A: variable 'v2' is possibly undefined
// 4039E5: variable 'v7' is possibly undefined
// 41248C: using guessed type char byte_41248C;
// 41248E: using guessed type char byte_41248E;
// 422690: using guessed type int dword_422690;
// 433618: using guessed type int dword_433618;
// 4038F4: using guessed type __int64 var_268;

//----- (00403A44) --------------------------------------------------------
int __fastcall sub_403A44(wchar_t *a1, char a2, _DWORD *a3, int a4)
{
  int v4; // eax
  int v5; // esi
  _DWORD *v7; // [esp+4h] [ebp-4h] BYREF

  v7 = 0;
  v4 = sub_403A81(a1, a2, a3, 0, &v7);
  v5 = v4;
  if ( v7 )
  {
    v5 = sub_404E20(v7) + v4;
    sub_404E3E(&v7);
  }
  return v5;
}

//----- (00403A81) --------------------------------------------------------
int __fastcall sub_403A81(wchar_t *a1, char a2, _DWORD *a3, wchar_t *a4, _DWORD *a5)
{
  _DWORD *v7; // eax
  int result; // eax
  char v9; // [esp+Ch] [ebp-4h]

  ++dword_412484;
  v9 = 1;
  v7 = sub_40EA6B(a1, (int)a1, (int)a1);
  if ( !v7 )
  {
    v7 = sub_404BD8((char *)a1, a2);
    v9 = 0;
  }
  result = sub_403AD7((int)v7, a2, a3, v9, a4, a5);
  --dword_412484;
  return result;
}
// 412484: using guessed type int dword_412484;

//----- (00403AD7) --------------------------------------------------------
unsigned int __fastcall sub_403AD7(int a1, char a2, _DWORD *a3, char a4, wchar_t *a5, _DWORD *a6)
{
  unsigned int result; // eax
  _DWORD *v8; // ebx
  int v9; // esi
  _DWORD *v10; // edx
  int v11; // eax
  char v12; // al
  _DWORD *v13; // ebx
  unsigned int v14; // esi
  __int64 v15; // rax
  wchar_t *v16; // ecx
  int v17; // ecx
  unsigned int *v18; // ebx
  bool v19; // zf
  int v20; // edx
  _DWORD *v21; // eax
  _DWORD *v22; // ebx
  int v23; // eax
  int v24; // ecx
  unsigned int v25; // edx
  unsigned int v26; // ecx
  __int64 v27; // rax
  unsigned int v28; // eax
  _DWORD *v29; // esi
  _DWORD *v30; // esi
  int v31; // eax
  void **v32; // ebx
  void **v33; // esi
  _DWORD *v34; // edx
  wchar_t *v35; // esi
  char v36; // cl
  unsigned int v37; // ebx
  wchar_t *v38; // ecx
  char v39; // bl
  wchar_t **v40; // eax
  __int64 v41; // rax
  unsigned int dwHighDateTime; // ecx
  unsigned __int64 v43; // kr00_8
  unsigned __int64 v44; // kr08_8
  _DWORD *v45; // esi
  _DWORD *v47; // ecx
  int v48; // ebx
  unsigned int v49; // esi
  unsigned int v50; // ebx
  char v51; // al
  char v52; // al
  unsigned int v53; // ecx
  unsigned int v54; // esi
  unsigned int v55; // eax
  unsigned int *v56; // edx
  __int64 v57; // kr10_8
  void **v58; // eax
  _DWORD *v59; // eax
  wchar_t *v60; // eax
  unsigned int v61; // edx
  char v62; // al
  const wchar_t *v63; // eax
  wchar_t **v64; // eax
  wchar_t **v65; // eax
  wchar_t **v66; // eax
  unsigned int v67; // edx
  DWORD v68; // eax
  unsigned int v69; // ecx
  DWORD *v70; // edx
  DWORD *v71; // eax
  _DWORD *v72; // ecx
  _DWORD *v73; // ebx
  char v74; // al
  char v75; // al
  char v76; // al
  unsigned int *v77; // eax
  _DWORD *v78; // ebx
  _DWORD *v79; // ecx
  int v80; // [esp-4h] [ebp-4F4h]
  int v81; // [esp-4h] [ebp-4F4h]
  struct _FILETIME SystemTimeAsFileTime; // [esp+14h] [ebp-4DCh] BYREF
  void **v83; // [esp+1Ch] [ebp-4D4h]
  _DWORD *v84; // [esp+20h] [ebp-4D0h]
  _DWORD *v85; // [esp+24h] [ebp-4CCh]
  wchar_t *v86; // [esp+28h] [ebp-4C8h]
  _DWORD *v87; // [esp+2Ch] [ebp-4C4h] BYREF
  void *Block; // [esp+30h] [ebp-4C0h]
  _DWORD *v89; // [esp+34h] [ebp-4BCh]
  DWORD *v90; // [esp+38h] [ebp-4B8h]
  int v91; // [esp+3Ch] [ebp-4B4h] BYREF
  unsigned __int64 v92; // [esp+40h] [ebp-4B0h] BYREF
  wchar_t *v93; // [esp+4Ch] [ebp-4A4h] BYREF
  unsigned int v94; // [esp+50h] [ebp-4A0h]
  unsigned int v95; // [esp+54h] [ebp-49Ch]
  int v96; // [esp+58h] [ebp-498h]
  unsigned int v97; // [esp+5Ch] [ebp-494h]
  unsigned __int64 v98; // [esp+60h] [ebp-490h] BYREF
  _DWORD *v99; // [esp+6Ch] [ebp-484h] BYREF
  int v100; // [esp+70h] [ebp-480h]
  _DWORD *v101; // [esp+74h] [ebp-47Ch] BYREF
  unsigned int v102; // [esp+78h] [ebp-478h]
  unsigned int v103; // [esp+7Ch] [ebp-474h] BYREF
  unsigned int v104; // [esp+80h] [ebp-470h]
  unsigned int v105; // [esp+84h] [ebp-46Ch]
  unsigned int v106; // [esp+88h] [ebp-468h]
  char v107; // [esp+8Fh] [ebp-461h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+90h] [ebp-460h] BYREF
  __int16 v109[262]; // [esp+2E0h] [ebp-210h] BYREF

  v86 = a5;
  v93 = a5;
  result = 0;
  v107 = a2;
  v89 = a3;
  v105 = 0;
  v103 = 0;
  if ( !a1 )
  {
    *a3 = 0;
    a3[1] = 0;
    return result;
  }
  if ( (*(_BYTE *)(a1 + 9) & 1) != 0 )
  {
    sub_4053D9(0, 0x42Fu, *(_DWORD *)(a1 + 4));
    a2 = v107;
  }
  v8 = *(_DWORD **)(a1 + 28);
  if ( v8 )
  {
    v9 = sub_404E20((_DWORD *)*v8);
    sub_404E3E(v8);
    v10 = v89;
    v11 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 28) = 0;
    *v10 = v11;
    v10[1] = *(_DWORD *)(a1 + 20);
    return v9;
  }
  v12 = *(_BYTE *)(a1 + 9);
  if ( (v12 & 2) != 0 )
  {
    if ( (a2 & 1) != 0 )
      sub_40D11B(2 * dword_412484, *(_DWORD *)(a1 + 4), *(FILETIME *)(a1 + 16));
    *a3 = *(_DWORD *)(a1 + 16);
    a3[1] = *(_DWORD *)(a1 + 20);
    if ( (byte_41248C & 8) == 0 && dword_412484 == 1 && (*(_BYTE *)(a1 + 9) & 4) == 0 )
    {
      if ( sub_407A35(*(wchar_t **)(a1 + 4), &FindFileData, (HANDLE *)&v91) )
        sub_4054B3(2u, *(_DWORD *)(a1 + 4));
    }
    return (*(unsigned __int8 *)(a1 + 9) >> 2) & 1;
  }
  v13 = *(_DWORD **)(a1 + 24);
  v14 = 0;
  HIDWORD(v15) = 0;
  v99 = 0;
  v101 = 0;
  v84 = 0;
  v96 = 0;
  v100 = 0;
  v102 = 0;
  v95 = 0;
  v92 = 0i64;
  v98 = 0i64;
  v90 = 0;
  v87 = 0;
  v16 = *(wchar_t **)(a1 + 4);
  v106 = 0;
  v104 = 0;
  *(_BYTE *)(a1 + 9) = v12 | 1;
  dword_422ED4 = v16;
  dword_422ED8 = (int)v16;
  v85 = v13;
  if ( !v13 )
  {
LABEL_104:
    dword_422EC8 = 0;
    dword_422ECC = 0;
    v49 = *v89;
    v50 = v89[1];
    if ( !*(_QWORD *)v89 )
    {
      if ( *(_QWORD *)(a1 + 16) )
      {
        v49 = *(_DWORD *)(a1 + 16);
        v50 = *(_DWORD *)(a1 + 20);
      }
      else if ( sub_407A35(v16, &FindFileData, (HANDLE *)&v91) )
      {
        v57 = sub_407A1B((char *)&FindFileData);
        v50 = HIDWORD(v57);
        v49 = v57;
      }
    }
    if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
      sub_40D11B(2 * dword_412484, *(_DWORD *)(a1 + 4), (FILETIME)__PAIR64__(v50, v49));
    v58 = sub_40E715(
            a1,
            (wchar_t *)v109,
            (int)v16,
            __PAIR64__(v50, v49),
            (int ***)&v99,
            (int ***)&v101,
            &v103,
            &v98,
            &v93);
    v83 = v58;
    if ( v58 && !v96 )
    {
      v59 = v58[3];
      dword_422ECC = v109;
      v84 = v59;
    }
    v60 = *(wchar_t **)(a1 + 4);
    v61 = v103;
    dword_422ED0 = (int)v99;
    dword_422ED4 = v60;
    dword_422ED8 = (int)v60;
    dword_422EC4 = (int)v101;
    v106 = v103;
    if ( byte_4226B7 && (*(_BYTE *)(a1 + 9) & 8) == 0 || !v103 )
    {
      if ( __PAIR64__(v50, v49) < v98
        || byte_4226B6 && __PAIR64__(v50, v49) == v98
        || !(v50 | v49) && !v98
        || (*(_BYTE *)(a1 + 8) & 0x10) != 0 )
      {
        v62 = byte_4333F8;
        v107 = byte_4333F8;
        byte_4333F8 = 1;
        if ( v96 )
        {
          v63 = v93;
          if ( !v93 )
          {
            if ( v101 )
              v63 = (const wchar_t *)v101[1];
            else
              v63 = 0;
          }
          v64 = sub_40571A(*(char **)(a1 + 4), *(_DWORD **)(v96 + 8), *(_DWORD *)(v96 + 12), *(_BYTE *)(v96 + 16), v63);
          v106 = (unsigned int)v64 + v103;
LABEL_154:
          byte_4333F8 = v107;
          if ( v96 )
            goto LABEL_158;
          goto LABEL_155;
        }
        if ( v84 )
        {
          if ( !*((_BYTE *)v83 + 20) || (byte_41248C & 0x40) != 0 )
          {
            v65 = sub_40571A(*(char **)(a1 + 4), v84, (int)v83[4], *(_BYTE *)(a1 + 8), v93);
            v106 = (unsigned int)v65 + v103;
          }
          else
          {
            sub_404C1F(a6, (int)v83, a1, (int)v84);
          }
          byte_4333F8 = v107;
LABEL_155:
          if ( v84 )
            goto LABEL_158;
          goto LABEL_156;
        }
        if ( (byte_41248C & 0x10) != 0 )
        {
          if ( !v100 )
          {
LABEL_148:
            byte_4333F8 = v62;
LABEL_156:
            if ( dword_422EC4 )
            {
              v69 = HIDWORD(v98);
              v68 = v98;
LABEL_159:
              v61 = v106;
              v95 = v69;
              v102 = v68;
              if ( v90 && v96 )
              {
                v70 = v90;
                *v90 = v68;
                v71 = v70;
                v61 = v106;
                v71[1] = v69;
              }
LABEL_167:
              if ( byte_4226B7 && v61 )
              {
                v19 = (*(_BYTE *)(a1 + 9) & 8) == 0;
                byte_412020 = 0;
                if ( v19 )
                {
                  if ( dword_412484 == 1 )
                    sub_4053D9(0, 0xFAAu, *(_DWORD *)(a1 + 4));
                }
                else
                {
                  sub_4053D9(0, 0xFABu, *(_DWORD *)(a1 + 4));
                }
              }
              if ( (byte_41248C & 8) != 0 && dword_412484 == 1 )
              {
                v72 = v101;
                v73 = v99;
                if ( v101 != v99 )
                {
                  sub_404BAE(v101);
                  v72 = v73;
                }
                sub_404BAE(v72);
                return -(dword_422EC0 != 0);
              }
              else
              {
                v74 = *(_BYTE *)(a1 + 9) & 0xFE;
                v19 = *(_DWORD *)(a1 + 28) == 0;
                *(_BYTE *)(a1 + 9) = v74;
                if ( v19 )
                {
                  v75 = v74 | 2;
                  if ( (int)v106 <= 0 )
                    v76 = v75 & 0xFB;
                  else
                    v76 = v75 | 4;
                  *(_BYTE *)(a1 + 9) = v76;
                }
                if ( v95 >= v50 && (v95 > v50 || v102 > v49) )
                {
                  v49 = v102;
                  v50 = v95;
                }
                v77 = v89;
                *(_DWORD *)(a1 + 20) = v50;
                *(_DWORD *)(a1 + 16) = v49;
                v77[1] = v50;
                v78 = v99;
                *v77 = v49;
                v79 = v101;
                if ( v101 != v78 )
                {
                  sub_404BAE(v101);
                  v79 = v78;
                }
                sub_404BAE(v79);
                return v106;
              }
            }
LABEL_158:
            GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
            v69 = (unsigned __int64)(*(_QWORD *)&SystemTimeAsFileTime + 2i64) >> 32;
            v68 = SystemTimeAsFileTime.dwLowDateTime + 2;
            goto LABEL_159;
          }
          v66 = sub_40571A(
                  *(char **)(a1 + 4),
                  *(_DWORD **)(v100 + 8),
                  *(_DWORD *)(v100 + 12),
                  *(_BYTE *)(v100 + 16),
                  v93);
          v67 = (unsigned int)v66 + v103;
        }
        else
        {
          if ( a4 || v50 | v49 )
            goto LABEL_154;
          if ( !byte_4226B7 )
          {
            sub_4053D9(0, 0x431u, *(_DWORD *)(a1 + 4));
            goto LABEL_154;
          }
          v67 = 1;
        }
        v62 = v107;
        v106 = v67;
        goto LABEL_148;
      }
      v60 = *(wchar_t **)(a1 + 4);
    }
    if ( (byte_41248C & 8) == 0 && dword_412484 == 1 && (*(_BYTE *)(a1 + 9) & 8) == 0 )
    {
      sub_4054B3(2u, v60);
      v61 = v103;
    }
    goto LABEL_167;
  }
  if ( (*(_BYTE *)(v13[1] + 16) & 0x20) != 0 )
  {
    if ( sub_407A35(v16, &FindFileData, (HANDLE *)&v91) )
    {
      v15 = sub_407A1B((char *)&FindFileData);
      v104 = HIDWORD(v15);
      v14 = v15;
      v106 = v15;
    }
    else
    {
      HIDWORD(v15) = v104;
    }
  }
  while ( 1 )
  {
    v17 = v13[1];
    v97 = 0;
    v94 = 0;
    v100 = v17;
    v18 = (unsigned int *)(v17 + 24);
    v19 = *(_QWORD *)(v17 + 24) == 0i64;
    v83 = (void **)(v17 + 24);
    if ( v19 )
      break;
    if ( HIDWORD(v15) <= *(_DWORD *)(v17 + 28) && (HIDWORD(v15) < *(_DWORD *)(v17 + 28) || v14 <= *v18) )
    {
      v14 = *v18;
      HIDWORD(v15) = *(_DWORD *)(v17 + 28);
      v106 = *v18;
      v104 = HIDWORD(v15);
    }
LABEL_102:
    v13 = (_DWORD *)*v85;
    v85 = v13;
    if ( !v13 )
    {
      v16 = *(wchar_t **)(a1 + 4);
      goto LABEL_104;
    }
  }
  v20 = *(_DWORD *)(a1 + 4);
  v90 = (DWORD *)(v17 + 24);
  v21 = sub_40468C(v17, v20);
  v22 = v21;
  Block = v21;
  while ( v22 )
  {
    v92 = *((_QWORD *)v22 + 1);
    v23 = sub_403A81((wchar_t *)v22[1], *(_BYTE *)(v100 + 16), &v92, 0, &v87);
    v24 = v23 + v105;
    v105 = v24;
    v103 = v24;
    if ( byte_4226B7 && v23 )
    {
      if ( (*((_BYTE *)sub_40EA6B((wchar_t *)v22[1], v24, v24) + 9) & 8) == 0 )
      {
        v80 = v22[1];
        byte_412020 = 0;
        sub_4053D9(0, 0xFAAu, v80);
      }
      *(_BYTE *)(a1 + 9) |= 8u;
    }
    v25 = HIDWORD(v92);
    v26 = v92;
    if ( __PAIR64__(v94, v97) <= v92 )
    {
      v94 = HIDWORD(v92);
      v97 = v92;
    }
    if ( !(v104 | v14) && (*(_BYTE *)(v100 + 16) & 0x20) == 0 )
    {
      if ( sub_407A35(*(wchar_t **)(a1 + 4), &FindFileData, (HANDLE *)&v91) )
      {
        v27 = sub_407A1B((char *)&FindFileData);
        v26 = v92;
        v14 = v27;
        v28 = HIDWORD(v27);
        v106 = v14;
        v25 = HIDWORD(v92);
        v104 = v28;
        *(_DWORD *)(a1 + 16) = v14;
        *(_DWORD *)(a1 + 20) = v28;
        goto LABEL_40;
      }
      v25 = HIDWORD(v92);
      v26 = v92;
    }
    v28 = v104;
LABEL_40:
    if ( (*(_BYTE *)(a1 + 8) & 0x10) != 0
      || v28 < v25
      || v28 <= v25 && v14 < v26
      || byte_4226B6 && v14 == v26 && v28 == v25 )
    {
      v29 = sub_40E8C7();
      v29[1] = sub_40E919((char *)v22[1]);
      sub_40EA1E(&v99, v29);
    }
    v30 = sub_40E8C7();
    v30[1] = sub_40E919((char *)v22[1]);
    v21 = sub_40EA1E(&v101, v30);
    v22 = (_DWORD *)*v22;
    v14 = v106;
  }
  if ( v87 )
  {
    v31 = sub_404E20(v87);
    v105 += v31;
    v103 = v105;
    sub_404E3E(&v87);
  }
  v32 = (void **)Block;
  while ( 1 )
  {
    v33 = v32;
    if ( !v32 )
      break;
    free(v32[1]);
    v32 = (void **)*v32;
    free(v33);
  }
  LOBYTE(v21) = *(_BYTE *)(v100 + 16);
  v34 = *(_DWORD **)(v100 + 8);
  Block = v21;
  if ( ((unsigned __int8)v21 & 0x20) == 0 )
  {
    if ( v34 )
    {
      if ( v96 )
        sub_4053D9(0, 0xFA4u, *(_DWORD *)(a1 + 4));
      else
        v96 = v100;
    }
    if ( v98 <= __PAIR64__(v94, v97) )
      v98 = __PAIR64__(v94, v97);
    goto LABEL_98;
  }
  if ( !v34 )
  {
LABEL_98:
    v48 = v105;
    goto LABEL_99;
  }
  v35 = *(wchar_t **)(a1 + 4);
  dword_422EC8 = 0;
  dword_422ECC = 0;
  dword_422ED0 = (int)v99;
  dword_422EC4 = (int)v101;
  v36 = byte_4226B7;
  dword_422ED4 = v35;
  dword_422ED8 = (int)v35;
  if ( (!byte_4226B7 || (*(_BYTE *)(a1 + 9) & 8) != 0) && v105 )
  {
    v37 = v106;
    goto LABEL_65;
  }
  if ( v104 < v94 || (v37 = v106, v104 <= v94) && v106 < v97 )
  {
LABEL_72:
    v38 = v86;
    v39 = byte_4333F8;
    byte_4333F8 = 1;
    if ( !v86 )
    {
      if ( v101 )
        v38 = (wchar_t *)v101[1];
      else
        v38 = 0;
      v93 = v38;
      v86 = v38;
    }
    v40 = sub_40571A((char *)v35, v34, *(_DWORD *)(v100 + 12), (char)v21, v38);
    v19 = (*(_BYTE *)(a1 + 8) & 4) == 0;
    v105 += (unsigned int)v40;
    v103 = v105;
    if ( v19 && sub_407A35(*(wchar_t **)(a1 + 4), &FindFileData, (HANDLE *)&v91) )
    {
      v41 = sub_407A1B((char *)&FindFileData);
      dwHighDateTime = HIDWORD(v41);
    }
    else
    {
      if ( v98 )
      {
        v43 = v98;
        dwHighDateTime = HIDWORD(v43);
        LODWORD(v41) = v43;
        v44 = v98;
        v95 = HIDWORD(v44);
        v102 = v44;
LABEL_84:
        HIDWORD(v41) = v83;
        v45 = v99;
        *v83 = (void *)v41;
        LODWORD(v41) = v101;
        *(_DWORD *)(HIDWORD(v41) + 4) = dwHighDateTime;
        v47 = (_DWORD *)v41;
        if ( (_DWORD *)v41 != v45 )
        {
          sub_404BAE((_DWORD *)v41);
          v47 = v45;
        }
        sub_404BAE(v47);
        v99 = 0;
        v101 = 0;
        v36 = byte_4226B7;
        byte_4333F8 = v39;
        goto LABEL_87;
      }
      GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
      LODWORD(v41) = SystemTimeAsFileTime.dwLowDateTime;
      dwHighDateTime = SystemTimeAsFileTime.dwHighDateTime;
    }
    v95 = dwHighDateTime;
    v102 = v41;
    goto LABEL_84;
  }
LABEL_65:
  if ( byte_4226B6 )
  {
    if ( v37 == v97 )
    {
      v35 = *(wchar_t **)(a1 + 4);
      if ( v104 == v94 )
        goto LABEL_72;
    }
  }
  if ( !(v104 | v37) && !(v94 | v97) || !*(_DWORD *)v100 )
  {
    LOBYTE(v21) = (_BYTE)Block;
    goto LABEL_72;
  }
LABEL_87:
  if ( !v36 )
    goto LABEL_98;
  if ( (*(_BYTE *)(a1 + 9) & 8) != 0 )
  {
    sub_4053D9(0, 0xFABu, *(_DWORD *)(a1 + 4));
    *(_BYTE *)(a1 + 9) &= ~8u;
  }
  v48 = v105;
  if ( v105 )
  {
    v81 = *(_DWORD *)(a1 + 4);
    v48 = 0;
    byte_412020 = 0;
    v105 = 0;
    v103 = 0;
    sub_4053D9(0, 0xFAAu, v81);
  }
LABEL_99:
  if ( (*(_BYTE *)(v100 + 16) & 0x20) == 0 || *v85 )
  {
    HIDWORD(v15) = v104;
    v14 = v106;
    goto LABEL_102;
  }
  v51 = *(_BYTE *)(a1 + 9) & 0xFC | 2;
  *(_BYTE *)(a1 + 9) = v51;
  if ( v48 <= 0 )
    v52 = v51 & 0xFB;
  else
    v52 = v51 | 4;
  v53 = v104;
  v54 = v95;
  *(_BYTE *)(a1 + 9) = v52;
  if ( v54 < v53 )
  {
    v55 = v106;
  }
  else if ( v54 > v53 || (v55 = v106, v102 > v106) )
  {
    v55 = v102;
    v53 = v54;
  }
  v56 = v89;
  *(_DWORD *)(a1 + 16) = v55;
  *(_DWORD *)(a1 + 20) = v53;
  *v56 = v55;
  result = v48;
  v56[1] = v53;
  return result;
}
// 403F13: variable 'v21' is possibly undefined
// 4042E7: variable 'v16' is possibly undefined
// 412020: using guessed type char byte_412020;
// 412484: using guessed type int dword_412484;
// 41248C: using guessed type char byte_41248C;
// 4226B6: using guessed type char byte_4226B6;
// 4226B7: using guessed type char byte_4226B7;
// 422EC0: using guessed type int dword_422EC0;
// 422EC4: using guessed type int dword_422EC4;
// 422EC8: using guessed type int dword_422EC8;
// 422ED0: using guessed type int dword_422ED0;
// 422ED8: using guessed type int dword_422ED8;
// 4333F8: using guessed type char byte_4333F8;
// 403AD7: using guessed type wchar_t var_210[262];

//----- (0040468C) --------------------------------------------------------
_DWORD *__fastcall sub_40468C(int a1, int a2)
{
  _DWORD *v2; // ebx
  int v3; // edi
  int v4; // eax
  __int16 *v5; // edi
  __int16 *v6; // ecx
  __int16 v7; // si
  __int16 v8; // dx
  __int16 *v9; // esi
  char *v10; // edi
  __int16 v11; // cx
  __int16 v12; // dx
  wchar_t *v13; // esi
  wchar_t *v14; // ebx
  wchar_t *v15; // esi
  wchar_t *v16; // esi
  _DWORD *v17; // ebx
  wchar_t *v18; // ecx
  rsize_t v20; // esi
  wchar_t *v21; // eax
  __int64 v22; // rax
  bool v23; // zf
  _DWORD *v24; // ecx
  __int16 *v26; // [esp+Ch] [ebp-28Ch]
  int v27; // [esp+14h] [ebp-284h] BYREF
  int v28; // [esp+18h] [ebp-280h]
  __int16 *v29; // [esp+1Ch] [ebp-27Ch] BYREF
  unsigned int v30; // [esp+20h] [ebp-278h]
  _DWORD *v31; // [esp+24h] [ebp-274h]
  __int16 *v32; // [esp+28h] [ebp-270h]
  HANDLE hFindFile; // [esp+2Ch] [ebp-26Ch] BYREF
  _DWORD *v34; // [esp+30h] [ebp-268h] BYREF
  wchar_t *String; // [esp+34h] [ebp-264h] BYREF
  wchar_t *Source; // [esp+38h] [ebp-260h]
  char v37; // [esp+3Fh] [ebp-259h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+40h] [ebp-258h] BYREF

  v2 = *(_DWORD **)a1;
  hFindFile = 0;
  v28 = a2;
  v31 = v2;
  v3 = 0;
  v4 = *(_DWORD *)(a1 + 4);
  v34 = 0;
  v27 = v4;
  if ( v2 )
  {
    do
    {
      v5 = (__int16 *)v2[1];
      v6 = v5;
      v32 = v5;
      v7 = *v5;
      if ( *v5 )
      {
        v8 = *v5;
        do
        {
          v7 = v8;
          if ( v8 == 36 )
            break;
          if ( v8 == 94 )
            ++v6;
          v8 = *++v6;
          v7 = *v6;
        }
        while ( *v6 );
        v2 = v31;
        v5 = v32;
        a2 = v28;
      }
      if ( v7 )
      {
        dword_422EC8 = a2;
        v5 = (__int16 *)sub_40F311(v5, 1, &v27);
        v32 = v5;
      }
      v9 = (__int16 *)sub_40E919((char *)v5);
      v26 = v9;
      v29 = v9;
      if ( sub_404A65(&v29, &String) )
      {
        do
        {
          v10 = (char *)String;
          if ( *String == 123 )
          {
            v11 = 123;
            do
            {
              v12 = v11;
              if ( v11 == 125 )
                break;
              if ( v11 == 94 )
                v10 += 2;
              v10 += 2;
              v11 = *(_WORD *)v10;
              v12 = *(_WORD *)v10;
            }
            while ( *(_WORD *)v10 );
            v13 = String;
            if ( v12 )
            {
              *(_WORD *)v10 = 0;
              v10 += 2;
              String = ++v13;
            }
          }
          else
          {
            v13 = 0;
            String = 0;
          }
          v37 = 0;
          FindFileData.ftCreationTime.dwLowDateTime = 0;
          FindFileData.ftCreationTime.dwHighDateTime = 0;
          FindFileData.ftLastWriteTime.dwLowDateTime = 0;
          FindFileData.ftLastWriteTime.dwHighDateTime = 0;
          v14 = (wchar_t *)sub_40E919(v10);
          Source = v14;
          if ( (wcspbrk((const wchar_t *)v10, L"*?") || v13)
            && (v15 = (wchar_t *)sub_407BE4(v13, (wchar_t *)v10, &FindFileData, &hFindFile)) != 0 )
          {
            v37 = 1;
            free(v14);
            v10 = (char *)v15;
            v16 = (wchar_t *)sub_40FF33(v15, FindFileData.cFileName);
            Source = v16;
          }
          else
          {
            v16 = Source;
          }
          do
          {
            v17 = sub_40AC08(0x10u);
            if ( !wcschr(v16, 0x20u) || wcschr(v16, 0x22u) )
            {
              v17[1] = sub_40E919((char *)v16);
            }
            else
            {
              v18 = v16 + 1;
              while ( *v16++ )
                ;
              v20 = v16 - v18 + 3;
              v21 = (wchar_t *)sub_40ABE3((unsigned __int64)v20 >> 31 != 0 ? -1 : 2 * v20);
              v17[1] = v21;
              wcscpy_s(v21, v20, L"\"");
              wcscat_s((wchar_t *)v17[1], v20, Source);
              wcscat_s((wchar_t *)v17[1], v20, L"\"");
              v16 = Source;
            }
            if ( !byte_4226B5 || sub_407A35(v16, &FindFileData, &hFindFile) )
            {
              v22 = sub_407A1B((char *)&FindFileData);
              v30 = HIDWORD(v22);
              HIDWORD(v22) = v22;
              v17[3] = v30;
            }
            else
            {
              v22 = 0i64;
              v17[3] = 0;
              v30 = 0;
            }
            v23 = byte_4226B5 == 0;
            v17[2] = v22;
            if ( v23 )
            {
              sub_40EA1E(&v34, v17);
            }
            else
            {
              v24 = v34;
              if ( !v34 )
                goto LABEL_43;
              LODWORD(v22) = v34;
              do
              {
                if ( __PAIR64__(v30, HIDWORD(v22)) > *(_QWORD *)(v22 + 8) )
                  break;
                v24 = (_DWORD *)v22;
                LODWORD(v22) = *(_DWORD *)v22;
              }
              while ( (_DWORD)v22 );
              v16 = Source;
              if ( v24 == (_DWORD *)v22 )
              {
LABEL_43:
                v34 = v17;
              }
              else
              {
                *v24 = v17;
                *v17 = v22;
              }
            }
            free(v16);
            if ( !v37 )
              break;
            if ( !wcspbrk((const wchar_t *)v10, L"*?") )
              break;
            if ( !sub_407BC1(&FindFileData, hFindFile) )
              break;
            v16 = (wchar_t *)sub_40FF33((wchar_t *)v10, FindFileData.cFileName);
            Source = v16;
          }
          while ( v16 );
        }
        while ( sub_404A65(&v29, &String) );
        v2 = v31;
        v5 = v32;
        v9 = v26;
      }
      if ( v5 != (__int16 *)v2[1] )
        free(v5);
      free(v9);
      v2 = (_DWORD *)*v2;
      a2 = v28;
      v31 = v2;
    }
    while ( v2 );
    return v34;
  }
  return (_DWORD *)v3;
}
// 4226B5: using guessed type char byte_4226B5;
// 422EC8: using guessed type int dword_422EC8;

//----- (00404A65) --------------------------------------------------------
char __fastcall sub_404A65(__int16 **a1, _DWORD *a2)
{
  __int16 **v2; // ebx
  unsigned __int16 *v3; // esi
  __int16 v4; // di
  __int16 v5; // cx
  __int16 v7; // cx
  bool v8; // zf
  __int16 v9; // cx
  __int16 v10; // ax
  int v11; // eax
  __int16 v12; // cx
  __int16 v13; // dx

  v2 = a1;
  v3 = (unsigned __int16 *)*a1;
  v4 = **a1;
  if ( v4 )
  {
    v5 = **a1;
    do
    {
      if ( v5 != 32 )
      {
        v4 = v5;
        if ( v5 != 9 )
          break;
      }
      v5 = *++v3;
      v4 = *v3;
    }
    while ( *v3 );
    v2 = a1;
  }
  *a2 = v3;
  if ( !v4 )
    return 0;
  if ( v4 == 34 )
  {
    v7 = 34;
    while ( v7 )
    {
      v7 = *++v3;
      if ( *v3 == 34 )
        goto LABEL_15;
    }
LABEL_14:
    sub_4053D9(0, 0x40Eu);
LABEL_15:
    v8 = *++v3 == 0;
    goto LABEL_35;
  }
  v9 = v4;
  if ( v4 == 123 )
  {
    do
    {
      if ( *++v3 == 34 )
      {
        ++v3;
        do
        {
          v10 = *v3;
          if ( !*v3 )
            break;
          ++v3;
        }
        while ( v10 != 34 );
      }
      v11 = *v3;
    }
    while ( v11 != 125 && (_WORD)v11 );
    if ( !(_WORD)v11 )
      sub_4053D9(0, 0x423u);
    v9 = *++v3;
    if ( *v3 == 34 )
    {
      v12 = 34;
      while ( v12 )
      {
        v12 = *++v3;
        if ( *v3 == 34 )
          goto LABEL_15;
      }
      goto LABEL_14;
    }
  }
  if ( v9 )
  {
    do
    {
      v13 = v9;
      if ( v9 == 32 )
        break;
      v13 = v9;
      if ( v9 == 9 )
        break;
      v9 = *++v3;
      v13 = *v3;
    }
    while ( *v3 );
    v2 = a1;
    v8 = v13 == 0;
LABEL_35:
    if ( !v8 )
      *v3++ = 0;
  }
  *v2 = (__int16 *)v3;
  return 1;
}
// 404ADF: conditional instruction was optimized away because ax.2==22

//----- (00404BAE) --------------------------------------------------------
int __thiscall sub_404BAE(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // edi
  int result; // eax

  v1 = this;
  v2 = (int)this;
  while ( v1 )
  {
    v1 = (_DWORD *)*v1;
    free(*(void **)(v2 + 4));
    result = dword_433618;
    *(_DWORD *)v2 = dword_433618;
    dword_433618 = v2;
    v2 = (int)v1;
  }
  return result;
}
// 433618: using guessed type int dword_433618;

//----- (00404BD8) --------------------------------------------------------
_DWORD *__fastcall sub_404BD8(char *Src, char a2)
{
  _DWORD *v4; // edi
  int v5; // ecx
  int *v6; // ecx
  _DWORD *result; // eax

  v4 = sub_40AC08(0x20u);
  v4[1] = sub_40E919(Src);
  *((_BYTE *)v4 + 8) = a2;
  *((_BYTE *)v4 + 9) = 0;
  v4[4] = 0;
  v4[5] = 0;
  v4[6] = 0;
  v6 = &dword_422490[sub_40EA33((wint_t *)Src, v5)];
  *v4 = *v6;
  result = v4;
  *v6 = (int)v4;
  return result;
}
// 404C07: variable 'v5' is possibly undefined
// 422490: using guessed type int dword_422490[128];

//----- (00404C1F) --------------------------------------------------------
int __fastcall sub_404C1F(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // eax
  _DWORD *v6; // esi
  _DWORD *v7; // edi
  _DWORD *v8; // esi
  _DWORD *v9; // esi
  int result; // eax

  v5 = a2;
  v6 = 0;
  v7 = (_DWORD *)*a1;
  if ( !*a1 )
    goto LABEL_7;
  do
  {
    if ( v7[1] == v5 )
    {
      if ( *((_BYTE *)v7 + 8) == *(_BYTE *)(a3 + 8) )
        break;
      v5 = a2;
    }
    v6 = v7;
    v7 = (_DWORD *)*v7;
  }
  while ( v7 );
  if ( !v7 )
  {
LABEL_7:
    v7 = sub_40AC08(0x14u);
    v7[1] = a2;
    *((_BYTE *)v7 + 8) = *(_BYTE *)(a3 + 8);
    if ( v6 )
    {
      *v6 = v7;
    }
    else if ( *a1 )
    {
      *(_DWORD *)*a1 = v7;
    }
    else
    {
      *a1 = v7;
    }
  }
  v8 = sub_40E8C7();
  v8[1] = sub_40E919(*(char **)(a3 + 4));
  sub_40EA1E((_DWORD **)v7 + 3, v8);
  v9 = sub_40E8C7();
  v9[1] = sub_40E919((char *)dword_422ECC);
  sub_40EA1E((_DWORD **)v7 + 4, v9);
  result = a3;
  *(_DWORD *)(a3 + 28) = a1;
  return result;
}

//----- (00404CCB) --------------------------------------------------------
wchar_t **__thiscall sub_404CCB(_DWORD *this)
{
  _DWORD *v1; // ebx
  int v2; // edi
  _DWORD *v3; // esi
  const unsigned __int16 *v4; // edx
  wchar_t *v5; // edi
  int **v6; // esi
  const wchar_t *v7; // eax
  const wchar_t *v8; // eax
  int v9; // edx
  _DWORD *v10; // ecx
  _DWORD *v11; // edx
  int v12; // ecx
  int **i; // esi
  _DWORD *v14; // eax
  int v16; // [esp-Ch] [ebp-2Ch]
  char v17; // [esp-8h] [ebp-28h]
  rsize_t SizeInWords; // [esp+10h] [ebp-10h]
  wchar_t **SizeInWordsa; // [esp+10h] [ebp-10h]
  char v21; // [esp+1Fh] [ebp-1h]

  v1 = this;
  v2 = 0;
  v3 = (_DWORD *)this[4];
  if ( v3 )
  {
    do
    {
      v4 = (const unsigned __int16 *)v3[1];
      v2 += wcslen(v4) + 1;
      if ( *v4 != 34 && wcschr(v4, 0x20u) )
        v2 += 2;
      v3 = (_DWORD *)*v3;
    }
    while ( v3 );
    v1 = this;
  }
  SizeInWords = v2 + 1;
  v5 = (wchar_t *)sub_40ABE3((unsigned __int64)(unsigned int)(v2 + 1) >> 31 != 0 ? -1 : 2 * (v2 + 1));
  *v5 = 0;
  v6 = (int **)v1[4];
  if ( v6 )
  {
    do
    {
      v7 = (const wchar_t *)v6[1];
      if ( *v7 == 34 || !wcschr(v7, 0x20u) )
      {
        v21 = 0;
      }
      else
      {
        v21 = 1;
        wcscat_s(v5, SizeInWords, L"\"");
      }
      wcscat_s(v5, SizeInWords, (const wchar_t *)v6[1]);
      v8 = L"\" ";
      if ( !v21 )
        v8 = L" ";
      wcscat_s(v5, SizeInWords, v8);
      v6 = (int **)*v6;
    }
    while ( v6 );
    v1 = this;
  }
  v9 = v1[1];
  v10 = (_DWORD *)v1[3];
  v17 = *((_BYTE *)v1 + 8);
  v16 = *(_DWORD *)(v9 + 16);
  v11 = *(_DWORD **)(v9 + 12);
  dword_422ECC = v5;
  SizeInWordsa = sub_40575C(v10, v11, v16, v17, 0);
  if ( !SizeInWordsa )
  {
    for ( i = (int **)v1[3]; i; i = (int **)*i )
    {
      v14 = sub_40EA6B((wchar_t *)i[1], v12, v12);
      LOBYTE(v12) = *((_BYTE *)v14 + 9) & 0xFB;
      v14[7] = 0;
      LOBYTE(v12) = v12 | 2;
      *((_BYTE *)v14 + 9) = v12;
    }
  }
  free(v5);
  return SizeInWordsa;
}
// 404DF3: variable 'v12' is possibly undefined

//----- (00404E20) --------------------------------------------------------
int __thiscall sub_404E20(_DWORD *this)
{
  int v2; // edi
  wchar_t **v3; // eax

  v2 = 0;
  while ( this )
  {
    v3 = sub_404CCB(this);
    this = (_DWORD *)*this;
    v2 += (int)v3;
  }
  return v2;
}

//----- (00404E3E) --------------------------------------------------------
void __thiscall sub_404E3E(_DWORD *this)
{
  _DWORD *v2; // esi
  _DWORD *v3; // ecx
  void *v4; // [esp-4h] [ebp-Ch]

  v2 = (_DWORD *)*this;
  while ( v2 )
  {
    v3 = (_DWORD *)v2[3];
    v4 = v2;
    *v3 = dword_433618;
    dword_433618 = v2[4];
    *(_DWORD *)dword_433618 = v3;
    v2 = (_DWORD *)*v2;
    free(v4);
  }
  *this = 0;
}
// 433618: using guessed type int dword_433618;

//----- (00404E6D) --------------------------------------------------------
wchar_t *__fastcall sub_404E6D(wchar_t **a1, int *a2)
{
  wchar_t *result; // eax
  unsigned int v5; // ecx
  int v6; // esi
  unsigned int v7; // kr00_4
  wchar_t *v8; // ecx
  wchar_t *v9; // ecx
  int v10; // eax

  for ( result = *a1; (*a1)[*a2 - 1] != 10; result = *a1 )
  {
    result = fgetws(&Src, 1024, Stream);
    if ( !result )
      break;
    v5 = wcslen(&Src);
    if ( *((_WORD *)&dword_4226BC + v5) == 92 && *((_WORD *)&dword_4226BC + v5 + 1) == 10 )
    {
      *((_WORD *)&dword_4226BC + v5 + 1) = 0;
      *((_WORD *)&dword_4226BC + v5) = 32;
    }
    v6 = *a2;
    v7 = wcslen(&Src);
    v8 = *a1;
    *a2 += v7;
    v9 = (wchar_t *)sub_40AC26(v8, 2 * (v7 + v6) + 2);
    if ( !v9 )
    {
      sub_4053D9(dword_4226A4, 0x419u);
      v9 = 0;
    }
    v10 = *a2 - v6;
    *a1 = v9;
    wcscpy_s(&v9[v6], v10 + 1, &Src);
  }
  return result;
}
// 4226A4: using guessed type int dword_4226A4;
// 4226BC: using guessed type int dword_4226BC;

//----- (00404F75) --------------------------------------------------------
void *__fastcall sub_404F75(char *Src, int a2, void **a3)
{
  void *v5; // eax
  void *result; // eax

  if ( !*a3 )
  {
    v5 = sub_40ABE3(0x20u);
LABEL_5:
    *a3 = v5;
    goto LABEL_6;
  }
  if ( (a2 & 7) == 0 )
  {
    v5 = sub_405389(*a3, a2 + 8);
    goto LABEL_5;
  }
LABEL_6:
  result = sub_40E919(Src);
  *((_DWORD *)*a3 + a2) = result;
  return result;
}

//----- (00404FB4) --------------------------------------------------------
char *__fastcall sub_404FB4(wchar_t *Str, int *a2, void **a3)
{
  wchar_t *v5; // eax
  int v6; // ecx
  char *result; // eax
  wchar_t *Context; // [esp+8h] [ebp-4h] BYREF

  v5 = wcschr(Str, 0x5Cu);
  if ( v5 )
  {
    v6 = *(v5 - 1);
    if ( (v6 == 32 || v6 == 9) && v5[1] == 10 )
      *v5 = 0;
  }
  Context = 0;
  for ( result = (char *)wcstok_s(Str, L" \t\n", &Context); result; result = (char *)wcstok_s(0, L" \t\n", &Context) )
  {
    if ( *(_WORD *)result == 64 )
      return (char *)sub_4053D9(0, 0xFA1u, result + 2);
    sub_404F75(result, *a2, a3);
    ++*a2;
  }
  return result;
}

//----- (00405040) --------------------------------------------------------
void __fastcall sub_405040(wchar_t *a1, int *a2, void **a3)
{
  int *v4; // esi
  wchar_t *v5; // eax
  wchar_t *v6; // ebx
  wchar_t *v7; // esi
  bool v8; // zf
  wchar_t v9; // ax
  int *v10; // edx
  unsigned int v11; // ebx
  wchar_t *v12; // edi
  wchar_t v13; // cx
  wchar_t *v14; // ecx
  wchar_t v15; // ax
  __int16 v16; // ax
  int v17; // ebx
  int *v18; // eax
  int v19; // [esp+Ch] [ebp-10h] BYREF
  wchar_t *v20; // [esp+10h] [ebp-Ch] BYREF
  int *v21; // [esp+14h] [ebp-8h]
  char v22; // [esp+1Bh] [ebp-1h]

  v22 = 0;
  v4 = a2;
  v21 = a2;
  v5 = wcschr(a1, 0x22u);
  v6 = v5;
  if ( !v5 )
  {
    sub_404FB4(a1, v4, a3);
    return;
  }
  if ( v5 != a1 )
  {
    v7 = v5 - 1;
    if ( *(v5 - 1) == 61 )
    {
      *v5 = 32;
      v8 = v7 == a1;
      if ( v7 > a1 )
      {
        do
        {
          v9 = *v7;
          if ( *v7 == 32 )
            break;
          if ( v9 == 9 )
            break;
          if ( v9 == 10 )
            break;
          --v7;
        }
        while ( v7 > a1 );
        v8 = v7 == a1;
      }
      if ( !v8 )
      {
        v10 = v21;
        *v7++ = 0;
        sub_404FB4(a1, v10, a3);
      }
      goto LABEL_15;
    }
    v4 = v21;
  }
  *v5 = 0;
  sub_404FB4(a1, v4, a3);
  v7 = v6 + 1;
LABEL_15:
  v20 = v7;
  v11 = wcslen(v7);
  v12 = v7;
  if ( !*v7 )
    goto LABEL_32;
  v13 = *v7;
  while ( 1 )
  {
    if ( v13 != 34 )
    {
      if ( v13 == 92 )
      {
        v16 = *(v12 - 1);
        if ( (v16 == 32 || v16 == 9) && v12[1] == 10 )
        {
          v17 = v11 - 2;
          *v12 = 0;
          v19 = v17;
          if ( !v22 )
          {
            v22 = 1;
            v20 = (wchar_t *)sub_40E919((char *)v7);
          }
          sub_404E6D(&v20, &v19);
          v7 = v20;
          v12 = &v20[v17];
          v11 = v19;
        }
      }
      goto LABEL_29;
    }
    if ( v12[1] != 34 )
      break;
    v14 = v12;
    *v12 = 34;
    do
    {
      ++v14;
      v15 = v14[1];
      *v14 = v15;
    }
    while ( v15 );
LABEL_29:
    v13 = *++v12;
    if ( !*v12 )
      goto LABEL_32;
  }
  v18 = v21;
  *v12++ = 0;
  sub_404F75((char *)v7, *v18, a3);
  ++*v21;
  sub_405040(a3);
LABEL_32:
  if ( v12 == &v7[v11] )
    sub_4053D9(0, 0x3EEu);
  if ( v22 )
    free(v7);
}

//----- (004051F1) --------------------------------------------------------
void __thiscall sub_4051F1(wchar_t *FileName)
{
  void **v2; // edi
  unsigned int v3; // esi
  FILE *v4; // eax
  wchar_t *v5; // esi
  unsigned int v6; // ecx
  unsigned int v7; // edx
  void **v8; // [esp+10h] [ebp-10h] BYREF
  unsigned int v9; // [esp+14h] [ebp-Ch] BYREF
  wchar_t *v10; // [esp+18h] [ebp-8h] BYREF
  unsigned int v11; // [esp+1Ch] [ebp-4h] BYREF

  v2 = 0;
  v3 = 0;
  v9 = 0;
  v4 = wfsopen(FileName, L"rt,ccs=unicode", 32);
  Stream = v4;
  if ( !v4 )
    v4 = (FILE *)sub_4053D9(0, 0x41Cu, FileName);
  v8 = 0;
  if ( fgetws(&Src, 1024, v4) )
  {
    v5 = &Src;
    do
    {
      v6 = wcslen(&Src);
      v11 = v6;
      if ( v6 == 1023 && word_422EBC != 10
        || *((_WORD *)&dword_4226BC + v6 + 1) == 10 && *((_WORD *)&dword_4226BC + v6) == 92 )
      {
        if ( *((_WORD *)&dword_4226BC + v6 + 1) == 10 && *((_WORD *)&dword_4226BC + v6) == 92 )
        {
          v7 = 2 * (v6 - 1);
          if ( v7 >= 0x800 )
            __report_rangecheckfailure();
          v11 = v6 - 1;
          *(wchar_t *)((char *)&Src + v7) = 0;
          *((_WORD *)&dword_4226BC + v6) = 32;
        }
        v10 = (wchar_t *)sub_40E919((char *)&Src);
        sub_404E6D(&v10, (int *)&v11);
        v5 = v10;
      }
      sub_405040(v5, (int *)&v9, (void **)&v8);
      if ( v5 != &Src )
        free(v5);
      v5 = &Src;
    }
    while ( fgetws(&Src, 1024, Stream) );
    v3 = v9;
    v2 = v8;
  }
  if ( fclose(Stream) == -1 )
    sub_4053D9(0, 0x424u, FileName);
  sub_40C423(v3, (int)v2);
  while ( v3 )
  {
    if ( v2[--v3] )
      free(v2[v3]);
  }
}
// 410AF8: using guessed type void __noreturn __report_rangecheckfailure(void);
// 4226BC: using guessed type int dword_4226BC;
// 422EBC: using guessed type __int16 word_422EBC;

//----- (00405389) --------------------------------------------------------
void *__fastcall sub_405389(void *Block, unsigned int a2)
{
  void *v2; // esi
  void *v3; // eax

  v2 = 0;
  if ( Block )
  {
    if ( a2 <= 0x3FFFFFFE )
    {
      v3 = realloc(Block, 4 * a2);
      goto LABEL_6;
    }
LABEL_7:
    sub_4053D9(dword_4226B0, 0x41Bu);
    return v2;
  }
  if ( a2 > 0x3FFFFFFE )
    goto LABEL_7;
  v3 = malloc(4 * a2);
LABEL_6:
  v2 = v3;
  if ( !v3 )
    goto LABEL_7;
  return v2;
}
// 4226B0: using guessed type int dword_4226B0;

//----- (004053D9) --------------------------------------------------------
int sub_4053D9(int a1, unsigned int a2, ...)
{
  int v2; // esi
  int result; // eax
  unsigned int v4; // edi
  wchar_t *v5; // eax
  va_list ArgList; // [esp+18h] [ebp+10h] BYREF

  va_start(ArgList, a2);
  v2 = 2;
  if ( (byte_41248C & 0x20) == 0 || (result = a2 - 4000, a2 - 4000 >= 0x3E8) )
  {
    sub_405542();
    if ( a1 )
      sub_40CD9E((wchar_t *)L"%s(%u) : ", dword_422EE4, a1);
    else
      sub_40CD9E((wchar_t *)L"NMAKE : ");
    v4 = a2 / 0x3E8;
    if ( a2 / 0x3E8 == 1 )
    {
      sub_4054B3(0x14u);
      if ( a2 == 1051 )
        v2 = 4;
    }
    else if ( v4 == 2 )
    {
      sub_4054B3(0x15u);
    }
    else if ( v4 == 4 )
    {
      sub_4054B3(0x16u);
    }
    sub_40CD9E((wchar_t *)L" U%04d: ", a2);
    v5 = (wchar_t *)sub_40CB41(a2);
    sub_40CE16(v5, ArgList);
    sub_40CDAD();
    result = sub_40CD80();
    if ( v4 == 1 )
    {
      sub_40CD9E((wchar_t *)L"Stop.\n");
      sub_40CAAD();
      exit(v2);
    }
  }
  return result;
}
// 41248C: using guessed type char byte_41248C;
// 4053D9: using guessed type unsigned int arg_4;

//----- (004054B3) --------------------------------------------------------
void sub_4054B3(unsigned int a1, ...)
{
  unsigned int v1; // ecx
  unsigned int v2; // esi
  wchar_t *v3; // eax
  va_list va; // [esp+14h] [ebp+Ch] BYREF

  va_start(va, a1);
  if ( a1 == 13 || (byte_41248C & 0x20) == 0 )
  {
    sub_405542();
    v1 = a1;
    v2 = a1 - 20;
    if ( a1 == 24 )
    {
      if ( v2 <= 5 )
        sub_40CDAD();
      else
        sub_40CE8D();
      v1 = 24;
    }
    v3 = (wchar_t *)sub_40CB41(v1);
    if ( v2 <= 5 )
      sub_40CE16(v3, va);
    else
      sub_40CEB9(v3, va);
    if ( (a1 < 0xA || a1 > 0x17) && a1 != 124 )
    {
      if ( v2 <= 5 )
        sub_40CDAD();
      else
        sub_40CE8D();
    }
    if ( v2 <= 5 )
      sub_40CD80();
    else
      sub_40CE60();
  }
}
// 41248C: using guessed type char byte_41248C;

//----- (00405542) --------------------------------------------------------
int sub_405542()
{
  int result; // eax

  if ( !byte_422EE0 )
  {
    byte_422EE0 = 1;
    sub_4054B3(0x18u, L"14.16.27031.1");
    sub_4054B3(0x19u);
    return sub_40CD80();
  }
  return result;
}
// 401638: using guessed type wchar_t a1416270311[14];
// 422EE0: using guessed type char byte_422EE0;

//----- (0040556E) --------------------------------------------------------
void sub_40556E()
{
  unsigned int v0; // edi
  unsigned int v1; // esi

  v0 = 100;
  v1 = 103;
  do
    sub_4054B3(v0++, L"NMAKE");
  while ( v0 < 0x67 );
  do
  {
    if ( v1 == 113 )
      v1 = 114;
    if ( v1 == 121 )
      v1 = 122;
    sub_4054B3(v1++);
  }
  while ( v1 <= 0x7C );
}
// 401654: using guessed type wchar_t aNmake_1[6];

//----- (004055A8) --------------------------------------------------------
size_t __fastcall sub_4055A8(_DWORD *a1, const wchar_t **a2, wchar_t *String)
{
  wchar_t *v3; // esi
  size_t result; // eax
  const wchar_t **v5; // ebx
  wchar_t *v6; // edi
  const wchar_t *v7; // esi
  int v8; // eax
  const wchar_t **i; // [esp+14h] [ebp-8h]
  char v11; // [esp+1Bh] [ebp-1h]

  v3 = String;
  result = (size_t)a1;
  v5 = a2;
  v11 = 1;
  v6 = String;
  for ( i = a2; *v6; ++v6 )
    ;
  *a1 = 0;
  if ( String < v6 )
  {
    while ( 1 )
    {
      result = wcsspn(v3, L" \t");
      v7 = &v3[result];
      if ( v7 >= v6 )
        goto LABEL_36;
      if ( v5 )
      {
        *v5++ = v7;
        i = v5;
      }
      if ( *v7 == 34 )
        break;
      v3 = wcspbrk(v7, L" \t\"/");
      if ( v3 )
      {
        do
        {
          if ( v3 >= v6 )
            break;
          if ( *v3 != 47 )
            break;
          if ( v11 )
            break;
          v3 = wcspbrk(v3 + 1, L" \t\"/");
        }
        while ( v3 );
        v5 = i;
        if ( v3 )
        {
          if ( *v3 == 34 )
          {
            do
              ++v3;
            while ( v3 < v6 && *v3 != 34 );
            v3 = wcspbrk(v3, L" \t");
          }
        }
      }
      if ( !v11 )
        goto LABEL_31;
      v11 = 0;
      if ( v3 )
      {
        if ( *v3 == 47 && v5 )
        {
          *v3 = 0;
          *(v5 - 1) = (const wchar_t *)sub_40E919((char *)*(v5 - 1));
          *v3-- = 47;
        }
        goto LABEL_31;
      }
LABEL_32:
      v3 = v6;
LABEL_33:
      if ( v5 )
        *v3++ = 0;
LABEL_35:
      result = (size_t)a1;
      ++*a1;
      if ( v3 >= v6 )
        goto LABEL_36;
    }
    v3 = (wchar_t *)(v7 + 1);
    if ( v3 >= v6 )
      goto LABEL_35;
    do
    {
      v8 = *v3;
      if ( v8 == 92 )
      {
        ++v3;
      }
      else if ( (_WORD)v8 == 34 )
      {
        break;
      }
      ++v3;
    }
    while ( v3 < v6 );
    if ( v3 >= v6 )
      goto LABEL_35;
    v3 = wcspbrk(v3 + 1, L" \t");
LABEL_31:
    if ( v3 )
      goto LABEL_33;
    goto LABEL_32;
  }
LABEL_36:
  if ( v5 )
    *v5 = 0;
  return result;
}

//----- (0040571A) --------------------------------------------------------
wchar_t **__fastcall sub_40571A(char *Src, _DWORD *a2, int a3, char a4, const wchar_t *a5)
{
  _DWORD *v7; // ebx
  wchar_t **result; // eax

  v7 = sub_40E8C7();
  v7[1] = sub_40E919(Src);
  result = sub_40575C(v7, a2, a3, a4, a5);
  *v7 = dword_433618;
  dword_433618 = (int)v7;
  return result;
}
// 433618: using guessed type int dword_433618;

//----- (0040575C) --------------------------------------------------------
wchar_t **__fastcall sub_40575C(_DWORD *a1, _DWORD *a2, int a3, char a4, const wchar_t *a5)
{
  wchar_t **v5; // esi
  _DWORD *v6; // ebx
  _DWORD *v7; // edi
  bool v8; // bl
  bool v10; // al
  char v11; // bl
  char v12; // bh
  wchar_t *v13; // ecx
  wchar_t *v14; // edx
  wchar_t v15; // si
  __int16 i; // si
  wchar_t *v17; // esi
  wchar_t *v18; // eax
  BOOL v19; // eax
  wchar_t *v20; // edi
  wchar_t *j; // eax
  bool v22; // zf
  wchar_t *v23; // eax
  wchar_t *v24; // edx
  unsigned int v26; // esi
  wchar_t *v27; // edi
  char v28; // bl
  bool v29; // cl
  char v30; // bh
  bool v31; // al
  bool v32; // dl
  wchar_t **v33; // eax
  int v34; // [esp-Ch] [ebp-58h]
  bool v35; // [esp+10h] [ebp-3Ch]
  bool v36; // [esp+28h] [ebp-24h]
  wchar_t *v37; // [esp+2Ch] [ebp-20h]
  _DWORD *v38; // [esp+30h] [ebp-1Ch]
  wchar_t *v39; // [esp+34h] [ebp-18h] BYREF
  int v40; // [esp+38h] [ebp-14h] BYREF
  unsigned int v41; // [esp+3Ch] [ebp-10h]
  wchar_t **v42; // [esp+40h] [ebp-Ch] BYREF
  int v43; // [esp+44h] [ebp-8h]
  wchar_t *Str; // [esp+48h] [ebp-4h] BYREF

  ++dword_422EC0;
  v5 = 0;
  v41 = 0;
  v6 = a2;
  v38 = a2;
  v42 = 0;
  v7 = a1;
  if ( (byte_41248C & 8) != 0 )
    return 0;
  if ( (byte_41248C & 0x10) != 0 )
  {
    if ( a1 )
    {
      v8 = (a4 & 4) != 0;
      do
      {
        sub_40798C(v7[1], v8);
        v7 = (_DWORD *)*v7;
      }
      while ( v7 );
    }
    return 0;
  }
  if ( !a2 )
    goto LABEL_59;
  v10 = (a4 & 0x40) != 0;
  v35 = v10;
  do
  {
    v11 = sub_4093AE((wchar_t *)v6[1], (const wchar_t **)&v39, (wchar_t *)&a3, v10);
    v12 = 0;
    dword_432EF0 = 0;
    v13 = v39;
    Str = v39;
    v14 = v39;
    LOBYTE(v43) = 0;
    if ( *v39 )
    {
      v15 = *v39;
      do
      {
        if ( v15 == 94 || v15 == 36 )
          ++v14;
        v15 = *++v14;
      }
      while ( *v14 );
      v13 = v39;
    }
    for ( i = *v39; i == 33 || i == 45 || i == 64 || i == 94 || i == 32 || i == 9; i = *v13 )
    {
      switch ( i )
      {
        case '!':
          v12 |= 4u;
LABEL_47:
          LOBYTE(v43) = v12;
          break;
        case '-':
          v12 |= 2u;
          Str = v13 + 1;
          LOBYTE(v43) = v12;
          if ( iswdigit(v13[1]) )
          {
            v20 = Str;
            dword_432EF0 = wcstoul(Str, &Str, 10);
            if ( *errno() == 34 )
            {
              v34 = dword_4226A4;
              *Str = 0;
              sub_4053D9(v34, 0x436u, v20);
            }
            for ( j = Str; iswspace(*j); j = ++Str )
              ;
          }
          else
          {
            dword_432EF0 = -1;
          }
          v13 = --Str;
          break;
        case '@':
          if ( (byte_41248E & 4) != 0 )
            break;
          v12 |= 1u;
          goto LABEL_47;
        case '^':
          Str = ++v13;
          v19 = *v13 == 32 || *v13 == 9;
          i = v19 ? 32 : 94;
          break;
        default:
          goto LABEL_49;
      }
      if ( i == 94 )
        break;
LABEL_49:
      Str = ++v13;
    }
    if ( (v12 & 4) != 0 )
    {
      if ( sub_407693((__int16 *)v13, a3, a4, v43, a5, &v42) )
      {
        v17 = Str;
        if ( wcschr(Str, 0x24u) )
        {
          v18 = (wchar_t *)sub_40F311((__int16 *)Str, 255, &a3);
          Str = v18;
        }
        else
        {
          v18 = Str;
        }
        if ( v17 != v18 )
          free(v18);
        v5 = v42;
        v22 = (a4 & 2) == 0;
        goto LABEL_54;
      }
      v13 = Str;
    }
    v37 = v13;
    if ( !v11 )
    {
      v23 = wcschr(v13, 0x24u);
      v13 = Str;
      if ( v23 )
      {
        v13 = (wchar_t *)sub_40F311((__int16 *)Str, 255, &a3);
        Str = v13;
      }
    }
    v24 = v13 + 1;
    while ( *v13++ )
      ;
    v26 = v13 - v24 + 1;
    if ( v26 <= 0x8000 )
      v26 = 0x8000;
    v27 = (wchar_t *)sub_40ABE3((unsigned __int64)v26 >> 31 != 0 ? -1 : 2 * v26);
    wcscpy_s(v27, v26, Str);
    if ( sub_410126((char *)v27, v26, Str, a5) )
      sub_4053D9(0, 0x447u, Str);
    v28 = a4 & 4;
    v29 = (v12 & 2) != 0;
    v30 = a4 & 2;
    v36 = v29;
    while ( 1 )
    {
      v31 = !v28 || (v43 & 8) != 0;
      v32 = v28 || (a4 & 8) == 0 && (v43 & 1) == 0;
      v33 = sub_406E74(v27, v32, v31, v29, (void **)&v40);
      v5 = v33;
      v42 = v33;
      if ( v30 )
        break;
      if ( v33 != (wchar_t **)259 )
        goto LABEL_89;
      if ( !byte_4333F9 )
      {
        sub_4053D9(0, 0xFACu, v40);
        v5 = 0;
        v42 = 0;
LABEL_89:
        if ( !v5 )
          break;
LABEL_90:
        if ( (unsigned int)v5 > dword_432EF0 && !byte_4226B7 )
          sub_4053D9(0, 0x435u, v40, v5);
        break;
      }
      if ( v41 >= 0xA )
        goto LABEL_90;
      sub_4053D9(0, 0xFADu, v40);
      v29 = v36;
      ++v41;
    }
    if ( v37 != Str )
      free(Str);
    free(v39);
    free(v27);
    v22 = v30 == 0;
LABEL_54:
    if ( v22 && byte_4226B7 && v5 && (unsigned int)v5 > dword_432EF0 )
      break;
    v10 = v35;
    v6 = (_DWORD *)*v38;
    v38 = v6;
  }
  while ( v6 );
LABEL_59:
  if ( (a4 & 2) != 0 || !byte_4226B7 || (unsigned int)v5 <= dword_432EF0 )
    return 0;
  return v5;
}
// 41248C: using guessed type char byte_41248C;
// 41248E: using guessed type char byte_41248E;
// 4226A4: using guessed type int dword_4226A4;
// 4226B7: using guessed type char byte_4226B7;
// 422EC0: using guessed type int dword_422EC0;
// 432EF0: using guessed type int dword_432EF0;
// 4333F9: using guessed type char byte_4333F9;

//----- (00405BDE) --------------------------------------------------------
wchar_t **__fastcall sub_405BDE(wchar_t *a1, int a2, wchar_t **ArgList)
{
  unsigned int v3; // ebx
  int v4; // esi
  wchar_t **v5; // edi
  char v6; // cl
  wchar_t *v7; // edx
  wchar_t *v8; // ecx
  int i; // eax
  const wchar_t *v11; // eax
  wchar_t **result; // eax
  wchar_t **v13; // esi
  int v14; // [esp+Ch] [ebp-8h]

  v3 = 0;
  v4 = a2;
  v5 = ArgList;
  if ( a1 )
  {
    ArgList[a2] = L">";
    v5[a2 + 1] = a1;
    v4 = a2 + 2;
    v5[a2 + 2] = 0;
LABEL_3:
    v5[v4] = (wchar_t *)L"\"";
    v6 = 1;
    v5[++v4] = 0;
  }
  else
  {
    v7 = *ArgList;
    if ( **ArgList == 34 )
    {
      v8 = *ArgList;
      ArgList = (wchar_t **)(v7 + 1);
      while ( *v8++ )
        ;
      if ( v7[(((char *)v8 - (char *)ArgList) >> 1) - 1] == 34 )
      {
        for ( i = v4 - 1; ; i = v14 - 1 )
        {
          v14 = i;
          if ( i < 1 )
            break;
          if ( wcspbrk(v5[i], L"\"") )
            goto LABEL_3;
        }
      }
    }
    v6 = 0;
  }
  for ( ; v4 >= 0; --v4 )
    v5[v4 + 2] = v5[v4];
  *v5 = (wchar_t *)dword_422EEC;
  v11 = L"/c \"";
  if ( !v6 )
    v11 = L"/c";
  v5[1] = (wchar_t *)v11;
  *errno() = 0;
  result = (wchar_t **)wspawnvp(1, *v5, (const wchar_t *const *)v5);
  v13 = result;
  if ( result != (wchar_t **)-1 )
  {
    WaitForSingleObject(result, 0xFFFFFFFF);
    ArgList = 0;
    do
    {
      GetExitCodeProcess(v13, (LPDWORD)&ArgList);
      if ( ArgList != (wchar_t **)259 )
        break;
      Sleep(0x3E8u);
      ++v3;
    }
    while ( v3 < 0xA );
    CloseHandle(v13);
    return ArgList;
  }
  return result;
}
// 40166C: using guessed type wchar_t asc_40166C[2];
// 401670: using guessed type wchar_t aC[5];
// 40167C: using guessed type wchar_t aC_0[3];
// 422EEC: using guessed type int dword_422EEC;

//----- (00405CEF) --------------------------------------------------------
wchar_t *__fastcall sub_405CEF(int a1, wchar_t **a2)
{
  char v2; // bl
  wchar_t *v3; // edi
  wchar_t *i; // esi
  wchar_t v5; // ax
  wchar_t v6; // ax
  wchar_t v8; // cx
  int v9; // eax
  wchar_t *v10; // ecx
  wchar_t *v11; // edi
  unsigned int v12; // kr00_4
  FILE *v13; // esi
  wchar_t v14; // cx
  char *v15; // ecx
  wchar_t v16; // bx
  wchar_t v17; // dx
  wchar_t *v18; // ecx
  __int16 v19; // ax
  wchar_t *v20; // ebx
  unsigned int v21; // kr08_4
  wchar_t *v22; // ebx
  unsigned int v23; // kr10_4
  wchar_t *v25; // [esp+10h] [ebp-106B8h]
  size_t RequiredCount; // [esp+18h] [ebp-106B0h] BYREF
  wchar_t *v28; // [esp+1Ch] [ebp-106ACh] BYREF
  wchar_t Destination[4]; // [esp+20h] [ebp-106A8h] BYREF
  wchar_t v30; // [esp+28h] [ebp-106A0h] BYREF
  char v31; // [esp+2Ah] [ebp-1069Eh] BYREF
  WCHAR TempFileName[260]; // [esp+10020h] [ebp-6A8h] BYREF
  wchar_t VarName[257]; // [esp+10228h] [ebp-4A0h] BYREF
  char v34; // [esp+1042Ah] [ebp-29Eh] BYREF
  wchar_t Source[64]; // [esp+10430h] [ebp-298h] BYREF
  wchar_t Buffer; // [esp+104B0h] [ebp-218h] BYREF
  __int16 v37[265]; // [esp+104B2h] [ebp-216h] BYREF

  v2 = 0;
  RequiredCount = 0;
  v28 = 0;
  wcscpy_s(Destination, 0x8000u, L"set ");
  v3 = &v30;
  for ( i = &Str; ; ++i )
  {
    v5 = *i;
    if ( *i != 32 && v5 != 9 )
      break;
  }
  if ( v5 == 47 && i[1] == 65 )
  {
    v6 = i[2];
    if ( v6 == 32 || v6 == 9 )
    {
      v2 = 1;
      i += 3;
    }
  }
  if ( !wcschr(i, 0x3Du) )
    return (wchar_t *)&dword_401690;
  v25 = &v30;
  if ( *i != 61 )
  {
    v8 = *i;
    do
    {
      *v3++ = v8;
      if ( v3 >= TempFileName )
        return 0;
      v8 = *++i;
    }
    while ( *i != 61 );
  }
  if ( v2 )
  {
    v9 = *(v3 - 1);
    if ( v9 == 42 || (_WORD)v9 == 47 || v9 == 37 || v9 == 43 || v9 == 45 || v9 == 38 || v9 == 94 || v9 == 124 )
    {
      --v3;
    }
    else
    {
      v10 = v3 - 2;
      if ( (_WORD)v9 == 62 && *v10 == 62 || (_WORD)v9 == 60 && *v10 == 60 )
        v3 -= 2;
    }
    if ( v30 == 34 )
      v25 = (wchar_t *)&v31;
    *v3 = 61;
    v11 = v3 + 1;
    if ( v11 < TempFileName )
    {
      RequiredCount = 0;
      if ( wgetenv_s(&RequiredCount, &Buffer, 0x106u, L"TMP") || !RequiredCount )
        wcscpy_s(&Buffer, 0x106u, L".");
      if ( !GetTempFileNameW(&Buffer, L"nm", 0, TempFileName) )
        sub_4053D9(dword_4226A4, 0x43Cu, &Buffer);
      wcscpy_s(&Buffer, 0x106u, TempFileName);
      if ( wcschr(&Buffer, 0x20u) && !wcschr(&Buffer, 0x22u) )
      {
        v12 = wcslen(&Buffer);
        memmove(v37, &Buffer, 2 * v12);
        Buffer = 34;
        v37[v12] = 34;
        if ( 2 * v12 + 4 >= 0x20C )
          __report_rangecheckfailure();
        v37[v12 + 1] = 0;
      }
      if ( !sub_405BDE(&Buffer, a1, a2) )
      {
        v13 = wfsopen(&Buffer, L"rt", 32);
        if ( !v13 )
          sub_4053D9(0, 0x41Cu, &Buffer);
        if ( !fgetws(Source, 64, v13) )
          sub_4053D9(0, 0x41Du, &Buffer);
        if ( fclose(v13) == -1 )
          sub_4053D9(0, 0x424u, &Buffer);
        if ( wremove(&Buffer) == -1 )
          sub_4053D9(0, 0x421u, &Buffer);
        if ( &v11[wcslen(Source) + 1] <= TempFileName )
        {
          wcscpy_s(v11, TempFileName - v11, Source);
          goto LABEL_77;
        }
      }
    }
    return 0;
  }
  if ( !*i )
    goto LABEL_76;
  v14 = *i;
  while ( 1 )
  {
    ++i;
    if ( v14 != 94 )
      break;
    if ( *i )
    {
      *v3 = *i++;
      goto LABEL_74;
    }
LABEL_75:
    v14 = *i;
    if ( !*i )
      goto LABEL_76;
  }
  if ( v14 != 37 )
  {
    *v3 = v14;
LABEL_74:
    if ( ++v3 >= TempFileName )
      return 0;
    goto LABEL_75;
  }
  v15 = (char *)VarName;
  v16 = *i;
  if ( *i != 37 )
  {
    v17 = *i;
    do
    {
      v16 = v17;
      if ( !v17 )
        break;
      *(_WORD *)v15 = v17;
      v15 += 2;
      if ( v15 == &v34 )
        return 0;
      v17 = *++i;
      v16 = *i;
    }
    while ( *i != 37 );
  }
  ++i;
  *(_WORD *)v15 = 0;
  if ( v16 )
  {
    wdupenv_s(&v28, 0, VarName);
    if ( v28 )
    {
      v18 = v28;
      do
        v19 = *v18++;
      while ( v19 != (_WORD)RequiredCount );
      v20 = &v3[v18 - (v28 + 1)];
      if ( v20 >= TempFileName )
        return 0;
      wcscpy_s(v3, TempFileName - v3, v28);
      v3 = v20;
      free(v28);
      v28 = 0;
    }
    else
    {
      v21 = wcslen(VarName);
      v22 = &v3[v21 + 2];
      if ( v22 >= TempFileName )
        return 0;
      *v3 = 37;
      wcscpy_s(v3 + 1, TempFileName - (v3 + 1), VarName);
      v3 += v21 + 2;
      *(v22 - 1) = 37;
    }
    goto LABEL_75;
  }
  v23 = wcslen(VarName);
  if ( &v3[v23 + 1] >= TempFileName )
    return 0;
  *v3 = 37;
  wcscpy_s(v3 + 1, TempFileName - (v3 + 1), VarName);
  v3 += v23 + 1;
LABEL_76:
  *v3 = 0;
LABEL_77:
  wcscpy_s(&::Destination, 0x8000u, Destination);
  *v25 = 0;
  return &::Destination + wcslen(Destination);
}
// 401690: using guessed type int dword_401690;
// 410AF8: using guessed type void __noreturn __report_rangecheckfailure(void);
// 4226A4: using guessed type int dword_4226A4;
// 405CEF: using guessed type __int16 var_216[265];

//----- (00406309) --------------------------------------------------------
char *__thiscall sub_406309(wchar_t *Str)
{
  wchar_t *v2; // ebx
  char *v3; // edx
  wchar_t *v4; // edi
  char *v5; // ecx
  char *v6; // esi
  char *v7; // eax
  wchar_t *VarName; // [esp+14h] [ebp-Ch]
  wchar_t *Buffer; // [esp+18h] [ebp-8h] BYREF
  char *v11; // [esp+1Ch] [ebp-4h]

  v2 = 0;
  v3 = (char *)sub_40E919((char *)&dword_401690);
  v11 = v3;
  while ( *Str )
  {
    v4 = wcschr(Str, 0x25u);
    if ( v4 )
    {
      VarName = v4 + 1;
      v2 = wcschr(v4 + 1, 0x25u);
    }
    else
    {
      VarName = (wchar_t *)2;
    }
    if ( v4 && v2 )
    {
      v5 = v11;
      *v4 = 0;
      Buffer = 0;
      *v2 = 0;
      v6 = (char *)sub_40E9C3(v5, Str);
      wdupenv_s(&Buffer, 0, VarName);
      if ( Buffer )
      {
        v11 = (char *)sub_40E9C3(v6, Buffer);
        free(Buffer);
        v3 = v11;
        Buffer = 0;
      }
      else
      {
        *v4 = 37;
        v7 = (char *)sub_40E9C3(v6, v4);
        v3 = (char *)sub_40E9C3(v7, L"%");
        v11 = v3;
      }
      *v4 = 37;
      Str = v2 + 1;
      *v2 = 37;
      v2 = 0;
    }
    else
    {
      v3 = (char *)sub_40E9C3(v11, Str);
      v11 = v3;
      Str += wcslen(Str);
    }
  }
  return v3;
}
// 401690: using guessed type int dword_401690;
// 4016B0: using guessed type wchar_t asc_4016B0[2];

//----- (00406429) --------------------------------------------------------
char __fastcall sub_406429(int a1, wint_t **a2, int *a3)
{
  wint_t *v3; // esi
  wint_t *v5; // edi
  wint_t v6; // ax
  char *v8; // eax
  const wchar_t *v9; // eax
  int v10; // eax
  int *v11; // edi
  wchar_t *v12; // esi
  int v13; // eax
  char *v14; // esi
  char *v15; // esi
  int v16; // [esp-4h] [ebp-18h]

  v3 = *a2;
  v5 = a2[1];
  if ( iswalpha(**a2) && v3[1] == 58 && !v3[2] )
  {
    v6 = towupper(*v3);
    chdrive(v6 - 64);
    *a3 = 0;
    return 1;
  }
  if ( wcsicmp(v3, L"set") )
  {
    if ( wcsnicmp(v3, L"cd", 2u) )
    {
      if ( wcsnicmp(v3, L"chdir", 5u) )
        return 0;
      v16 = 5;
    }
    else
    {
      v16 = 2;
    }
    v12 = &v3[v16];
    if ( a1 <= 2 )
    {
      sub_4078F8(a1, (__int16 **)a2);
      v13 = *v12;
      if ( (_WORD)v13 )
      {
        if ( v13 != 46 && v13 != 92 && v13 != 47 )
          return 0;
        v15 = sub_406309(v12);
        v11 = a3;
        *a3 = wchdir((const wchar_t *)v15);
        free(v15);
      }
      else
      {
        if ( !v5 || iswalpha(*v5) && v5[1] == 58 && !v5[2] )
          return 0;
        v14 = sub_406309(v5);
        v11 = a3;
        *a3 = wchdir((const wchar_t *)v14);
        free(v14);
      }
LABEL_28:
      if ( *v11 )
        *v11 = 1;
      return 1;
    }
  }
  else if ( a1 != 1 )
  {
    if ( Destination )
    {
      v8 = (char *)sub_405CEF(a1, a2);
      if ( v8 )
      {
        if ( *(_WORD *)v8 )
        {
          v9 = (const wchar_t *)sub_40E919(v8);
          v10 = wputenv(v9);
          v11 = a3;
          *a3 = v10;
          if ( v10 == -1 )
            sub_4053D9(dword_4226B0, 0x41Fu);
          goto LABEL_28;
        }
      }
    }
  }
  return 0;
}
// 4226B0: using guessed type int dword_4226B0;

//----- (004065E0) --------------------------------------------------------
char __fastcall sub_4065E0(wchar_t *FileName, int a2)
{
  int v4; // eax
  wchar_t *v5; // eax
  wchar_t *v6; // edi
  FILE *v7; // eax
  int v8; // ecx
  errno_t v9; // eax
  char v10; // dl
  int v11; // eax
  int v12; // eax
  wchar_t v14; // [esp+10h] [ebp-10h]
  FILE *Stream; // [esp+14h] [ebp-Ch]
  int FileHandle; // [esp+18h] [ebp-8h] BYREF
  bool v17; // [esp+1Fh] [ebp-1h]

  while ( 1 )
  {
    v4 = *FileName;
    if ( (_WORD)v4 != 32 && v4 != 9 )
      break;
    ++FileName;
  }
  v14 = 0;
  v5 = wcspbrk(FileName, L" \t<>\r");
  v6 = v5;
  if ( v5 )
  {
    v14 = *v5;
    *v5 = 0;
  }
  if ( a2 == 4 )
  {
    v7 = _acrt_iob_func(0);
    v8 = 0;
  }
  else
  {
    v7 = _acrt_iob_func(1u);
    v8 = a2 != 2 ? 265 : 769;
  }
  FileHandle = 0;
  Stream = v7;
  v9 = wsopen_s(&FileHandle, FileName, v8, 64, 384);
  v10 = v9 == 0;
  v17 = v9 == 0;
  if ( !v9 )
  {
    v11 = fileno(Stream);
    if ( dup2(FileHandle, v11) == -1 )
      sub_4053D9(0, 0x411u);
    close(FileHandle);
    v10 = v17;
  }
  if ( v10 && a2 == 3 )
  {
    v12 = fileno(Stream);
    lseek(v12, 0, 2);
    v10 = v17;
  }
  for ( ; *FileName; ++FileName )
    *FileName = 32;
  if ( v6 )
    *v6 = v14;
  return v10;
}

//----- (004066FF) --------------------------------------------------------
char __fastcall sub_4066FF(wchar_t *String, rsize_t a2, int *a3, int *a4)
{
  char v4; // bh
  char v5; // bl
  wchar_t *v6; // edi
  wchar_t *v7; // esi
  wchar_t *v8; // esi
  FILE *v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // edx
  FILE *v13; // eax
  int v14; // eax
  int v15; // eax
  FILE *v16; // eax
  int v17; // eax
  FILE *v18; // eax
  int v19; // eax
  int v23; // [esp+14h] [ebp-Ch]
  wchar_t *Stringa; // [esp+18h] [ebp-8h]
  char v25; // [esp+1Fh] [ebp-1h]

  v4 = 0;
  v25 = 0;
  v5 = 0;
  Stringa = String;
  v6 = 0;
  v7 = wcspbrk(String, L"<>|");
  if ( !v7 )
    return v5;
  while ( *v7 != 60 )
  {
    if ( *v7 != 62 )
    {
      if ( *v7 == 124 )
        goto LABEL_22;
      sub_4053D9(0, 0x411u);
      goto LABEL_20;
    }
    if ( v25 )
      goto LABEL_22;
    if ( !v6 )
      v6 = (wchar_t *)sub_40E919((char *)Stringa);
    *v7 = 32;
    v8 = v7 + 1;
    Stringa = v8;
    v25 = 1;
    if ( *v8 == 62 )
    {
      *v8++ = 32;
      v23 = 3;
    }
    else
    {
      v23 = 2;
    }
    v9 = _acrt_iob_func(1u);
    v10 = fileno(v9);
    v11 = dup(v10);
    *a4 = v11;
    if ( v11 == -1 )
      goto LABEL_22;
    v12 = v23;
LABEL_19:
    if ( !sub_4065E0(v8, v12) )
      goto LABEL_22;
LABEL_20:
    v7 = wcspbrk(Stringa, L"<>|");
    if ( !v7 )
      return v5;
  }
  if ( !v4 )
  {
    if ( !v6 )
      v6 = (wchar_t *)sub_40E919((char *)Stringa);
    *v7 = 32;
    v4 = 1;
    v8 = v7 + 1;
    Stringa = v8;
    v13 = _acrt_iob_func(0);
    v14 = fileno(v13);
    v15 = dup(v14);
    *a3 = v15;
    if ( v15 != -1 )
    {
      v12 = 4;
      goto LABEL_19;
    }
  }
LABEL_22:
  if ( v6 )
  {
    wcscpy_s(String, a2, v6);
    free(v6);
  }
  if ( v4 && *a3 != -1 )
  {
    v16 = _acrt_iob_func(0);
    v17 = fileno(v16);
    if ( dup2(*a3, v17) == -1 )
      sub_4053D9(0, 0x411u);
    close(*a3);
    *a3 = -1;
  }
  v5 = 1;
  if ( v25 && *a4 != -1 )
  {
    v18 = _acrt_iob_func(1u);
    v19 = fileno(v18);
    if ( dup2(*a4, v19) == -1 )
      sub_4053D9(0, 0x411u);
    close(*a4);
    *a4 = -1;
    return 1;
  }
  return v5;
}

//----- (00406903) --------------------------------------------------------
int __stdcall sub_406903(int a1)
{
  return 1;
}

//----- (00406909) --------------------------------------------------------
bool __fastcall sub_406909(_WORD *a1, _DWORD *a2)
{
  _WORD *v2; // edi
  _WORD *v4; // esi
  __int16 v5; // dx
  __int16 v6; // bx
  __int16 v7; // bx
  __int16 v8; // dx
  _WORD *v10; // [esp+8h] [ebp-4h]

  v2 = a1;
  v10 = a1;
  if ( !a1 )
    return 0;
  v4 = a1;
  v5 = *a1;
  if ( *a1 == 59 )
  {
    do
      ++a1;
    while ( *a1 == 59 );
    v5 = *a1;
  }
  v6 = v5;
  if ( v5 )
  {
    do
    {
      v6 = v5;
      if ( v5 == 59 )
        break;
      ++a1;
      if ( v5 == 34 )
      {
        v7 = *a1;
        if ( *a1 )
        {
          v8 = *a1;
          do
          {
            v7 = v8;
            if ( v8 == 34 )
              break;
            ++a1;
            *v4++ = v8;
            v8 = *a1;
            v7 = *a1;
          }
          while ( *a1 );
        }
        if ( v7 )
          ++a1;
      }
      else
      {
        *v4++ = v5;
      }
      v5 = *a1;
      v6 = *a1;
    }
    while ( *a1 );
    v2 = v10;
  }
  *a2 = v6 != 0 ? a1 + 1 : 0;
  *v4 = 0;
  return v4 != v2;
}

//----- (004069D2) --------------------------------------------------------
char __fastcall sub_4069D2(wchar_t *FullPath, wchar_t *a2, int a3)
{
  wchar_t *v3; // ebx
  unsigned int v4; // eax
  wchar_t *v5; // edi
  BOOL (__stdcall *NeedCurrentDirectoryForExePathW)(LPCWSTR); // eax
  HMODULE ModuleHandleW; // eax
  size_t v8; // eax
  wchar_t *v9; // eax
  wchar_t *v10; // ebx
  wchar_t *v11; // esi
  size_t v12; // eax
  size_t v13; // esi
  wchar_t *v14; // esi
  wchar_t *v15; // ecx
  wchar_t *v16; // ecx
  unsigned int v18; // ebx
  wchar_t *v19; // eax
  wchar_t *v20; // [esp+10h] [ebp-63Ch]
  wchar_t *v21; // [esp+14h] [ebp-638h] BYREF
  wchar_t *v22; // [esp+18h] [ebp-634h]
  wchar_t *v23; // [esp+1Ch] [ebp-630h]
  wchar_t *v24; // [esp+20h] [ebp-62Ch]
  BOOL v25; // [esp+24h] [ebp-628h] BYREF
  wchar_t *Buffer; // [esp+28h] [ebp-624h]
  size_t RequiredCount; // [esp+2Ch] [ebp-620h] BYREF
  size_t SizeInWords; // [esp+30h] [ebp-61Ch] BYREF
  char v29; // [esp+37h] [ebp-615h]
  wchar_t Filename[256]; // [esp+38h] [ebp-614h] BYREF
  wchar_t Dir[256]; // [esp+238h] [ebp-414h] BYREF
  wchar_t Ext[258]; // [esp+438h] [ebp-214h] BYREF
  wchar_t Drive[4]; // [esp+63Ch] [ebp-10h] BYREF

  Buffer = a2;
  v24 = 0;
  v29 = 0;
  if ( *FullPath == 34 )
  {
    v3 = &FullPath[wcslen(FullPath) - 1];
    v24 = v3;
    if ( *v3 == 34 )
    {
      v29 = 1;
      do
        ++FullPath;
      while ( *FullPath == 34 );
      if ( v3 > FullPath )
      {
        do
        {
          v4 = (unsigned int)(v3 - 1);
          if ( *(v3 - 1) != 34 )
            break;
          --v3;
        }
        while ( v4 > (unsigned int)FullPath );
        v24 = v3;
      }
      *v3 = 0;
    }
  }
  wsplitpath_s(FullPath, Drive, 3u, Dir, 0x100u, Filename, 0x100u, Ext, 0x100u);
  if ( Ext[0] )
  {
    v5 = Ext;
    RequiredCount = wcslen(Ext) + 1;
  }
  else
  {
    if ( wgetenv_s(&RequiredCount, 0, 0, aPa) || !RequiredCount )
      goto LABEL_17;
    v5 = (wchar_t *)sub_40ABE3((unsigned __int64)RequiredCount >> 31 != 0 ? -1 : 2 * RequiredCount);
    if ( wgetenv_s(&RequiredCount, v5, RequiredCount, aPa) )
    {
      free(v5);
      v5 = 0;
    }
    if ( !v5 )
    {
LABEL_17:
      RequiredCount = 33;
      v5 = (wchar_t *)sub_40ABE3(0x42u);
      wcscpy_s(v5, RequiredCount, L".COM;.EXE;.BAT;.CMD;.VBS;.JS;.WS");
    }
  }
  if ( Drive[0] || Dir[0] )
  {
    v13 = wcslen(Dir) + wcslen(Drive) + 1;
    v10 = (wchar_t *)sub_40ABE3((unsigned __int64)v13 >> 31 != 0 ? -1 : 2 * v13);
    v23 = v10;
    if ( wmakepath_s(v10, v13, Drive, Dir, 0, 0) )
    {
      free(v10);
      v10 = 0;
      v23 = 0;
    }
  }
  else
  {
    if ( wgetenv_s(&SizeInWords, 0, 0, aPa_0) || !SizeInWords )
      SizeInWords = 1;
    NeedCurrentDirectoryForExePathW = (BOOL (__stdcall *)(LPCWSTR))dword_43666C;
    if ( !dword_43666C )
    {
      ModuleHandleW = GetModuleHandleW(L"KERNEL32.DLL");
      NeedCurrentDirectoryForExePathW = (BOOL (__stdcall *)(LPCWSTR))GetProcAddress(
                                                                       ModuleHandleW,
                                                                       "NeedCurrentDirectoryForExePathW");
      dword_43666C = (int)NeedCurrentDirectoryForExePathW;
      if ( !NeedCurrentDirectoryForExePathW )
      {
        NeedCurrentDirectoryForExePathW = (BOOL (__stdcall *)(LPCWSTR))sub_406903;
        dword_43666C = (int)sub_406903;
      }
    }
    v25 = NeedCurrentDirectoryForExePathW(Filename);
    v8 = SizeInWords;
    if ( v25 )
    {
      v8 = SizeInWords + 2;
      SizeInWords += 2;
    }
    v9 = (wchar_t *)sub_40ABE3((unsigned __int64)v8 >> 31 != 0 ? -1 : 2 * v8);
    v10 = v9;
    v23 = v9;
    v11 = v9;
    if ( v25 )
    {
      wcscpy_s(v9, SizeInWords, L".;");
      v11 = v10 + 2;
      v12 = SizeInWords - 2;
      SizeInWords -= 2;
    }
    else
    {
      v12 = SizeInWords;
    }
    if ( wgetenv_s(&SizeInWords, v11, v12, aPa_0) || !SizeInWords )
      *v11 = 0;
  }
  v20 = v10;
  v14 = 0;
  v15 = v10;
LABEL_43:
  if ( sub_406909(v15, &v25) )
  {
    v14 = (wchar_t *)sub_40ABE3((unsigned __int64)RequiredCount >> 31 != 0 ? -1 : 2 * RequiredCount);
    wcscpy_s(v14, RequiredCount, v5);
    v22 = v14;
    v16 = v14;
    while ( 1 )
    {
      if ( !sub_406909(v16, &v21) )
      {
        v15 = (wchar_t *)v25;
        v20 = (wchar_t *)v25;
        goto LABEL_43;
      }
      if ( !wmakepath_s(Buffer, 0x104u, 0, v20, Filename, v22) && !waccess_s(Buffer, 0) )
        break;
      v16 = v21;
      v22 = v21;
    }
    if ( v29 )
    {
      v18 = wcslen(Buffer);
      memmove(Buffer + 1, Buffer, 2 * v18);
      v19 = Buffer;
      *Buffer = 34;
      v19[v18 + 1] = 34;
      v19[v18 + 2] = 0;
      v10 = v23;
      *v24 = 34;
    }
    free(v14);
    free(v10);
    if ( v5 != Ext )
      free(v5);
    return 1;
  }
  else
  {
    free(v14);
    free(v10);
    if ( v5 != Ext )
      free(v5);
    return 0;
  }
}
// 43666C: using guessed type int dword_43666C;

//----- (00406E74) --------------------------------------------------------
wchar_t **__fastcall sub_406E74(wchar_t *Source, char a2, char a3, char a4, void **a5)
{
  char v5; // bl
  void *v7; // eax
  int v8; // eax
  wchar_t *v9; // esi
  wchar_t *i; // eax
  wchar_t **result; // eax
  const wchar_t **v12; // edi
  wchar_t *v13; // eax
  wchar_t *v14; // esi
  wchar_t **v15; // esi
  int v16; // esi
  const wchar_t *v17; // ebx
  unsigned int v18; // kr00_4
  bool v19; // bl
  char v20; // bl
  wchar_t *v21; // esi
  unsigned int v22; // ecx
  FILE *v23; // eax
  int v24; // eax
  FILE *v25; // eax
  int v26; // eax
  unsigned int v27; // kr08_4
  unsigned int v28; // esi
  int v29; // eax
  int v30; // eax
  int *v31; // eax
  const wchar_t **v32; // eax
  char **v33; // ecx
  int v34; // ecx
  char v35; // [esp+10h] [ebp-444h]
  wchar_t *Block; // [esp+1Ch] [ebp-438h]
  int FileHandleSrc; // [esp+20h] [ebp-434h] BYREF
  wchar_t **v38; // [esp+24h] [ebp-430h] BYREF
  int v39; // [esp+28h] [ebp-42Ch] BYREF
  int FileHandle; // [esp+2Ch] [ebp-428h] BYREF
  char v41; // [esp+32h] [ebp-422h]
  char v42; // [esp+33h] [ebp-421h]
  wchar_t *String; // [esp+34h] [ebp-420h] BYREF
  wchar_t v44; // [esp+38h] [ebp-41Ch] BYREF
  wchar_t Destination[59]; // [esp+3Ah] [ebp-41Ah] BYREF
  wchar_t Buffer[200]; // [esp+B0h] [ebp-3A4h] BYREF
  wchar_t Str; // [esp+240h] [ebp-214h] BYREF
  char Src[522]; // [esp+242h] [ebp-212h] BYREF

  v5 = a2;
  String = Source;
  if ( !dword_422EEC )
  {
    v7 = sub_4075F7();
    Source = String;
    dword_422EEC = (int)v7;
  }
  v8 = *Source;
  v35 = 1;
  if ( v8 == 45 )
  {
    v41 = 1;
    String = Source + 1;
    if ( iswdigit(Source[1]) )
    {
      v9 = String;
      dword_432EF0 = wcstoul(String, &String, 10);
      if ( *errno() == 34 )
      {
        *String = 0;
        sub_4053D9(0, 0x436u, v9);
      }
      for ( i = String; iswspace(*i); i = ++String )
        ;
    }
    else
    {
      dword_432EF0 = -1;
    }
    Source = String;
  }
  else
  {
    if ( v8 == 64 )
    {
      String = ++Source;
      v5 = a3 != 0 ? 0 : a2;
    }
    v41 = a4;
  }
  result = 0;
  if ( !*Source )
    return result;
  v12 = 0;
  if ( wcslen(Source) >= 0x8000 )
  {
    ::Destination = 0;
  }
  else
  {
    wcscpy_s(&::Destination, 0x8000u, Source);
    Source = String;
  }
  v13 = (wchar_t *)sub_40E919((char *)Source);
  v14 = v13;
  Block = v13;
  if ( v5 )
  {
    sub_40CE7E((wchar_t *)L"\t%s\n", v13);
    sub_40CE60();
  }
  sub_4055A8(&v39, 0, v14);
  if ( !v39 )
    goto LABEL_23;
  v16 = v39;
  FileHandle = v39;
  v12 = (const wchar_t **)sub_40ABE3((unsigned __int64)(unsigned int)(v39 + 8) >> 30 != 0 ? -1 : 4 * (v39 + 8));
  sub_4055A8(&v39, v12, Block);
  if ( *v12 && dword_422EE8 && !wcsicmp(*v12, dword_422EE8) )
  {
    if ( !dword_412488 )
    {
      dword_412488 = *_p__wpgmptr();
      v17 = dword_412488;
      if ( wcspbrk(dword_412488, L" ") )
      {
        v18 = wcslen(dword_412488);
        dword_412488 = (wchar_t *)sub_40ABE3((unsigned __int64)(v18 + 3) >> 31 != 0 ? -1 : 2 * (v18 + 3));
        wcscpy_s(dword_412488, v18 + 3, L"\"");
        wcscat_s(dword_412488, v18 + 3, v17);
        wcscat_s(dword_412488, v18 + 3, L"\"");
        v16 = FileHandle;
      }
    }
    *v12 = dword_412488;
  }
  if ( !a3 )
  {
    if ( sub_406429(v16, (wint_t **)v12, (int *)&v38) )
    {
      v15 = v38;
      if ( v38 && a5 )
        *a5 = sub_40E919((char *)*v12);
      goto LABEL_89;
    }
    goto LABEL_23;
  }
  v19 = wcspbrk(String, L"<>|&%") == 0;
  if ( sub_406429(v16, (wint_t **)v12, (int *)&v38) )
  {
    v15 = v38;
    v20 = 0;
    goto LABEL_74;
  }
  v21 = String;
  if ( wcslen(String) < 0x1000 && !v19 )
  {
    v20 = 1;
LABEL_60:
    if ( wcslen(v21) >= 0x1000 )
      sub_4053D9(0, 0x447u, v21);
    else
      wcscpy_s(&::Destination, 0x8000u, v21);
    v15 = sub_405BDE(0, v39, (wchar_t **)v12);
    goto LABEL_74;
  }
  FileHandleSrc = -1;
  FileHandle = -1;
  v42 = sub_4066FF(String, wcslen(String) + 1, &FileHandleSrc, &FileHandle);
  if ( v42 )
    goto LABEL_49;
  v22 = wcslen(String);
  if ( v22 >= 0x8000 )
    sub_4053D9(0, 0x447u, String);
  if ( FileHandleSrc != -1 || FileHandle != -1 )
  {
    free(Block);
    Block = (wchar_t *)sub_40E919((char *)String);
    sub_4055A8(&v39, v12, Block);
  }
  if ( !sub_4069D2((wchar_t *)*v12, &Str, v22) )
  {
    v42 = 1;
LABEL_49:
    v15 = v38;
    goto LABEL_50;
  }
  if ( Str == 34 )
  {
    v27 = wcslen(&Str);
    if ( Buffer[v27 + 199] == 34 )
    {
      memmove(&Str, Src, 2 * v27);
      v28 = 2 * v27 - 4;
      if ( v28 >= 0x208 )
        __report_rangecheckfailure();
      *(_WORD *)&Src[v28 - 2] = 0;
    }
  }
  *v12 = &Str;
  if ( wcschr(&Str, 0x20u) )
  {
    v44 = 34;
    wcscpy_s(Destination, 0x103u, &Str);
    wcscat_s(&v44, 0x104u, L"\"");
    *v12 = &v44;
  }
  *errno() = 0;
  v15 = (wchar_t **)wspawnvp(0, &Str, v12);
  if ( v15 == (wchar_t **)-1 && *errno() != 12 && *_doserrno() == 193 )
    v42 = 1;
LABEL_50:
  if ( FileHandleSrc != -1 )
  {
    v23 = _acrt_iob_func(0);
    v24 = fileno(v23);
    if ( dup2(FileHandleSrc, v24) == -1 )
      sub_4053D9(0, 0x411u);
    close(FileHandleSrc);
  }
  if ( FileHandle != -1 )
  {
    v25 = _acrt_iob_func(1u);
    v26 = fileno(v25);
    if ( dup2(FileHandle, v26) == -1 )
      sub_4053D9(0, 0x411u);
    close(FileHandle);
  }
  v20 = v42;
  if ( v42 )
  {
    v21 = String;
    goto LABEL_60;
  }
LABEL_74:
  if ( v15 != (wchar_t **)-1 )
    goto LABEL_84;
  if ( !v41 )
  {
    v29 = *errno();
    if ( !v29 )
      goto LABEL_85;
    v30 = v29 - 2;
    if ( v30 )
    {
      if ( v30 == 10 )
      {
        v32 = v12 + 2;
        if ( !v20 )
          v32 = v12;
        sub_4053D9(0, 0x43Au, *v32);
      }
      else
      {
        v31 = errno();
        wcserror_s(Buffer, 0xC8u, *v31);
        sub_4053D9(0, 0x415u, Buffer);
      }
      goto LABEL_85;
    }
    sub_4053D9(0, 0x439u, *v12);
LABEL_84:
    if ( !v15 )
      goto LABEL_89;
LABEL_85:
    if ( a5 )
    {
      v33 = (char **)(v12 + 2);
      if ( !v20 )
        v33 = (char **)v12;
      *a5 = sub_40E919(*v33);
    }
    goto LABEL_89;
  }
LABEL_23:
  v15 = 0;
LABEL_89:
  v34 = 0;
  if ( v39 == -8 )
  {
LABEL_96:
    if ( v12 )
      free(v12);
  }
  else
  {
    while ( v12 )
    {
      if ( !v12[v34] )
        goto LABEL_96;
      if ( v12[v34] == Block )
      {
        v35 = 0;
        goto LABEL_96;
      }
      if ( ++v34 >= (unsigned int)(v39 + 8) )
        goto LABEL_96;
    }
  }
  if ( Block )
  {
    if ( v35 )
      free(Block);
  }
  return v15;
}
// 40729D: variable 'v22' is possibly undefined
// 410AF8: using guessed type void __noreturn __report_rangecheckfailure(void);
// 422EEC: using guessed type int dword_422EEC;
// 432EF0: using guessed type int dword_432EF0;
// 406E74: using guessed type char Src[522];
// 406E74: using guessed type wchar_t Destination[59];

//----- (004075F7) --------------------------------------------------------
void *sub_4075F7()
{
  void *v0; // esi
  wchar_t *Buffer; // [esp+4h] [ebp-214h] BYREF
  wchar_t ResultPath[262]; // [esp+8h] [ebp-210h] BYREF

  Buffer = 0;
  wdupenv_s(&Buffer, 0, L"COMSPEC");
  if ( Buffer )
  {
    v0 = sub_40E919((char *)Buffer);
    free(Buffer);
    return v0;
  }
  else
  {
    wsearchenv(L"CMD.EXE", aPa_0, ResultPath);
    if ( !ResultPath[0] )
      sub_4053D9(0, 0x420u);
    return sub_40E919((char *)ResultPath);
  }
}

//----- (00407693) --------------------------------------------------------
char __fastcall sub_407693(__int16 *a1, int a2, char a3, unsigned __int8 a4, const wchar_t *a5, wchar_t ***a6)
{
  int v6; // edi
  int v7; // ebx
  unsigned __int16 *v8; // esi
  int v9; // eax
  __int16 v10; // cx
  unsigned __int16 v11; // dx
  unsigned __int16 *v12; // edi
  unsigned __int16 v13; // cx
  __int16 v14; // si
  char v16; // bl
  char v17; // bh
  int *v18; // eax
  int v19; // edi
  __int16 *v20; // ecx
  bool v21; // al
  bool v22; // dl
  wchar_t **v23; // eax
  int *v24; // eax
  void *v25; // [esp-4h] [ebp-2Ch]
  int v26; // [esp+Ch] [ebp-1Ch] BYREF
  char v27[4]; // [esp+10h] [ebp-18h]
  __int16 *v28; // [esp+14h] [ebp-14h]
  int v29; // [esp+18h] [ebp-10h]
  int v30; // [esp+1Ch] [ebp-Ch]
  void *Block; // [esp+20h] [ebp-8h]
  char v32; // [esp+27h] [ebp-1h]

  v30 = a2;
  v6 = (unsigned __int16)*a1;
  v7 = 0;
  v28 = a1;
  v8 = (unsigned __int16 *)a1;
  Block = 0;
  v9 = v6;
  v29 = 0;
  if ( !(_WORD)v6 )
  {
LABEL_12:
    v14 = (__int16)Block;
    goto LABEL_13;
  }
  v10 = v6;
  Block = (void *)63;
  while ( 1 )
  {
    if ( v10 != 36 )
      goto LABEL_21;
    v11 = v8[1];
    if ( v11 == 40 )
      ++v8;
    v12 = v8 + 1;
    v13 = v8[1];
    if ( v13 != 63 )
      break;
    if ( v11 != 40 || wcschr(L"DFBR", v8[2]) && v8[3] == 41 || v8[2] == 41 )
    {
      v7 = dword_422ED0;
      v9 = *v8;
      a2 = v30;
      v29 = dword_422ED0;
      goto LABEL_12;
    }
LABEL_21:
    v10 = *++v8;
    if ( !*v8 )
      return 0;
  }
  ++v8;
  if ( v13 != 42 || v12[1] != 42 || v11 == 40 && (!wcschr(L"DFBR", v12[2]) || v12[3] != 41) && v12[2] != 41 )
    goto LABEL_21;
  v7 = dword_422EC4;
  v9 = *v12;
  a2 = v30;
  v29 = dword_422EC4;
  v14 = 42;
LABEL_13:
  if ( !(_WORD)v9 )
    return 0;
  if ( v7 )
  {
    v32 = a3 & 4;
    v16 = a3 & 4;
    LOBYTE(v9) = a4 >> 1;
    v17 = a3 & 2;
    *(_DWORD *)v27 = v9 & 0xFFFFFF01;
    do
    {
      dword_4226BC = a2;
      v18 = (int *)dword_422EC4;
      if ( v14 != 42 )
        v18 = (int *)dword_422ED0;
      v19 = *v18;
      v20 = v28;
      *v18 = 0;
      Block = sub_40F311(v20, 255, &dword_4226BC);
      if ( sub_410126((char *)word_422EF0, 0x8000, (unsigned __int16 *)Block, a5) )
        sub_4053D9(0, 0x447u, Block);
      v21 = !v16 || (a4 & 8) != 0;
      v22 = v16 || (a3 & 8) == 0 && (a4 & 1) == 0;
      v23 = sub_406E74(word_422EF0, v22, v21, v27[0], (void **)&v26);
      *a6 = v23;
      if ( !v17 && v23 && (unsigned int)v23 > dword_432EF0 && !byte_4226B7 )
        sub_4053D9(0, 0x435u, v26, v23);
      if ( v14 == 42 )
      {
        v24 = (int *)dword_422EC4;
        dword_422EC4 = v19;
      }
      else
      {
        v24 = (int *)dword_422ED0;
        dword_422ED0 = v19;
      }
      v25 = Block;
      *v24 = v19;
      free(v25);
      if ( !v17 && byte_4226B7 && *a6 && (unsigned int)*a6 > dword_432EF0 )
        break;
      a2 = v30;
    }
    while ( v19 );
    v7 = v29;
  }
  if ( v14 == 42 )
    dword_422EC4 = v7;
  else
    dword_422ED0 = v7;
  return 1;
}
// 4226B7: using guessed type char byte_4226B7;
// 4226BC: using guessed type int dword_4226BC;
// 422EC4: using guessed type int dword_422EC4;
// 422ED0: using guessed type int dword_422ED0;
// 422EF0: using guessed type wchar_t word_422EF0[32768];
// 432EF0: using guessed type int dword_432EF0;

//----- (004078F8) --------------------------------------------------------
void __fastcall sub_4078F8(int a1, __int16 **a2)
{
  int v2; // esi
  __int16 **v3; // ebx
  __int16 *v4; // ecx
  __int16 *v5; // edi
  __int16 v6; // dx
  __int16 v7; // ax
  __int16 *v8; // edx
  __int16 **v9; // [esp+10h] [ebp-4h]

  v2 = a1;
  v3 = a2;
  v9 = a2;
  if ( !a1 )
    return;
  do
  {
    v4 = *v3;
    --v2;
    v5 = *v3;
    if ( !**v3 )
      goto LABEL_15;
    v6 = *v4;
    do
    {
      if ( v6 == 92 )
      {
        v7 = 92;
LABEL_9:
        v8 = v5 + 1;
        if ( v5[1] == 34 )
        {
          *v4 = v7;
          ++v5;
          v7 = *v8;
          ++v4;
        }
        *v4 = v7;
        goto LABEL_12;
      }
      v7 = v6;
      if ( v6 == 94 )
        goto LABEL_9;
      if ( v6 == 34 )
        goto LABEL_13;
      *v4 = v6;
LABEL_12:
      ++v4;
LABEL_13:
      v6 = *++v5;
    }
    while ( *v5 );
    v3 = v9;
LABEL_15:
    ++v3;
    *v4 = 0;
    v9 = v3;
  }
  while ( v2 );
}

//----- (0040798C) --------------------------------------------------------
void __fastcall sub_40798C(int ArgList, char a2)
{
  wchar_t *v4; // eax
  __int16 *v5; // edx
  __int16 v6; // ax
  __int16 *v7; // ecx
  HANDLE FileW; // esi
  struct _FILETIME SystemTimeAsFileTime; // [esp+10h] [ebp-8h] BYREF

  if ( *(_WORD *)ArgList == 34 )
  {
    v4 = wcsrchr((const wchar_t *)ArgList, 0x22u);
    v5 = (__int16 *)(ArgList + 2);
    *v4 = 0;
    v6 = *(_WORD *)(ArgList + 2);
    *(_WORD *)ArgList = v6;
    while ( v6 )
    {
      v7 = v5++;
      v6 = *v5;
      *v7 = *v5;
    }
  }
  sub_4054B3(5u, ArgList);
  if ( !a2 )
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    FileW = CreateFileW((LPCWSTR)ArgList, 0x100u, 0, 0, 3u, 0x80u, 0);
    if ( FileW != (HANDLE)-1 )
    {
      SetFileTime(FileW, 0, 0, &SystemTimeAsFileTime);
      CloseHandle(FileW);
    }
  }
}

//----- (00407A1B) --------------------------------------------------------
__int64 __thiscall sub_407A1B(char *this)
{
  __int64 result; // rax

  if ( (*this & 0x10) == 0 )
    return *(_QWORD *)(this + 20);
  result = *(_QWORD *)(this + 4);
  if ( !result )
    return *(_QWORD *)(this + 20);
  return result;
}

//----- (00407A35) --------------------------------------------------------
WCHAR *__fastcall sub_407A35(wchar_t *Str, LPWIN32_FIND_DATAW lpFindFileData, HANDLE *a3)
{
  unsigned __int16 *v3; // ebx
  LPWIN32_FIND_DATAW v4; // edi
  char *v5; // esi
  wchar_t *v6; // eax
  unsigned int v7; // ecx
  unsigned __int16 *v8; // ecx
  unsigned __int16 v9; // dx
  HANDLE FirstFileW; // eax
  bool v13; // [esp+1Fh] [ebp-215h]
  char Block[524]; // [esp+20h] [ebp-214h] BYREF

  v3 = Str;
  v4 = lpFindFileData;
  v5 = Block;
  v6 = wcspbrk(Str, L"\"^*?");
  v13 = v6 != 0;
  if ( v6 )
  {
    v7 = wcslen(v3);
    if ( v7 + 1 > 0x104 )
    {
      v5 = (char *)sub_40ABE3((unsigned __int64)(v7 + 1) >> 31 != 0 ? -1 : 2 * (v7 + 1));
      if ( !v5 )
        sub_4053D9(dword_4226B0, 0x41Bu);
    }
    v8 = (unsigned __int16 *)v5;
    v9 = *v3;
    if ( *v3 )
    {
      do
      {
        if ( v9 != 94 && v9 != 34 )
          *v8++ = v9;
        v9 = *++v3;
      }
      while ( *v3 );
      v4 = lpFindFileData;
    }
    v3 = (unsigned __int16 *)v5;
    *v8 = 0;
  }
  FirstFileW = FindFirstFileW(v3, v4);
  *a3 = FirstFileW;
  if ( FirstFileW != (HANDLE)-1 && sub_407D6D(v3, v4) )
  {
    if ( !v13 || !wcschr(v3, 0x2Au) && !wcschr(v3, 0x3Fu) )
    {
      FindClose(*a3);
      *a3 = (HANDLE)-1;
    }
    if ( v5 != Block )
      free(v5);
    if ( (v4->dwFileAttributes & 0x10) == 0 && !v4->ftLastWriteTime.dwLowDateTime && !v4->ftLastWriteTime.dwHighDateTime )
    {
      v4->ftLastWriteTime.dwLowDateTime = -1;
      v4->ftLastWriteTime.dwHighDateTime = -1;
    }
    return v4->cFileName;
  }
  else
  {
    if ( v5 != Block )
      free(v5);
    return 0;
  }
}
// 4226B0: using guessed type int dword_4226B0;

//----- (00407BC1) --------------------------------------------------------
WCHAR *__fastcall sub_407BC1(LPWIN32_FIND_DATAW lpFindFileData, HANDLE hFindFile)
{
  if ( FindNextFileW(hFindFile, lpFindFileData) )
    return lpFindFileData->cFileName;
  FindClose(hFindFile);
  return 0;
}

//----- (00407BE4) --------------------------------------------------------
void *__fastcall sub_407BE4(wchar_t *a1, wchar_t *a2, struct _WIN32_FIND_DATAW *lpFindFileData, HANDLE *a4)
{
  char *v6; // ecx
  wchar_t *v8; // esi
  wchar_t v9; // ax
  wchar_t v10; // dx
  wchar_t v11; // cx
  int v12; // eax

  if ( sub_407A35(a2, lpFindFileData, a4) )
  {
    v6 = (char *)a2;
    return sub_40E919(v6);
  }
  if ( a1 )
  {
LABEL_5:
    v8 = &Src;
    do
    {
LABEL_6:
      v9 = *a1;
      while ( 1 )
      {
        if ( v9 )
        {
          v10 = v9;
          do
          {
            v11 = v10;
            if ( v10 != 34 )
              break;
            v10 = *++a1;
            v11 = *a1;
          }
          while ( *a1 );
          if ( v11 )
          {
            ++a1;
            *v8 = v11;
            if ( v11 != 59 )
            {
              ++v8;
              goto LABEL_6;
            }
          }
        }
        if ( v8 != &Src )
          break;
        v9 = *a1;
        if ( !*a1 )
          return 0;
      }
      v12 = *(v8 - 1);
      if ( (_WORD)v12 != 92 && v12 != 47 )
        *v8++ = 92;
      *v8 = 0;
      if ( wcspbrk(&Src, L"*?") )
        goto LABEL_5;
      wcscpy_s(v8, 1024 - (v8 - &Src), a2);
      v8 = &Src;
    }
    while ( !sub_407A35(&Src, lpFindFileData, a4) );
    v6 = (char *)&Src;
    return sub_40E919(v6);
  }
  return 0;
}

//----- (00407CDE) --------------------------------------------------------
char __fastcall sub_407CDE(_WORD *Block, LPWIN32_FIND_DATAW lpFindFileData)
{
  WCHAR *v3; // esi
  char *v4; // edx
  char v5; // bl
  int v7; // ecx
  HANDLE hFindFile; // [esp+Ch] [ebp-4h]

  v3 = Block;
  v4 = (char *)(Block + 1);
  v5 = 0;
  while ( *Block++ )
    ;
  v7 = ((char *)Block - v4) >> 1;
  if ( *v3 == 34 && v3[v7 - 1] == 34 )
  {
    v3 = sub_4105E0(v3);
    v5 = 1;
  }
  hFindFile = FindFirstFileW(v3, lpFindFileData);
  if ( hFindFile != (HANDLE)-1 && sub_407D6D(v3, lpFindFileData) )
  {
    FindClose(hFindFile);
    if ( (lpFindFileData->dwFileAttributes & 0x10) == 0
      && !lpFindFileData->ftLastWriteTime.dwLowDateTime
      && !lpFindFileData->ftLastWriteTime.dwHighDateTime )
    {
      lpFindFileData->ftLastWriteTime.dwLowDateTime = -1;
      lpFindFileData->ftLastWriteTime.dwHighDateTime = -1;
    }
    return 1;
  }
  else
  {
    if ( v5 )
      free(v3);
    return 0;
  }
}

//----- (00407D6D) --------------------------------------------------------
char __fastcall sub_407D6D(wchar_t *Str, _DWORD *a2)
{
  _DWORD *v2; // ebx
  WCHAR *v4; // esi
  wchar_t *v5; // edx
  unsigned int v6; // ecx
  _WORD *v8; // ebx
  int v9; // edx
  __int64 v11; // rax
  WCHAR *v12; // eax
  WCHAR *v13; // ecx
  unsigned int v14; // edx
  char *v15; // edi
  int i; // ebx
  WCHAR *v17; // ecx
  WCHAR v18; // dx
  HANDLE FileW; // edi
  WCHAR *v21; // [esp+10h] [ebp-18h]
  wchar_t *v22; // [esp+18h] [ebp-10h]
  unsigned int v23; // [esp+1Ch] [ebp-Ch]
  WCHAR *v25; // [esp+24h] [ebp-4h]

  v2 = a2;
  if ( (*a2 & 0x400) != 0 && a2[9] == -1610612724 )
  {
    v4 = (WCHAR *)(a2 + 11);
    v21 = (WCHAR *)(a2 + 11);
    v5 = wcsrchr(Str, 0x5Cu);
    v23 = (unsigned int)v5;
    if ( v5 )
    {
      v6 = wcslen(Str);
      v22 = v5 + 1;
      while ( *v5++ )
        ;
      v8 = v2 + 11;
      v9 = v5 - v22;
      while ( *v8++ )
        ;
      v11 = 2i64 * (v6 + 2 + v8 - (v4 + 1) - v9);
      v12 = (WCHAR *)sub_40ABE3(HIDWORD(v11) != 0 ? -1 : v11);
      v2 = a2;
      v25 = v12;
      if ( !v12 )
      {
        sub_4053D9(dword_4226B0, 0x41Bu);
        v12 = 0;
      }
      v13 = v12;
      v14 = v23 >= (unsigned int)Str ? (v23 - (unsigned int)Str + 1) >> 1 : 0;
      if ( v14 )
      {
        v15 = (char *)((char *)Str - (char *)v25);
        for ( i = 0; i != v14; ++i )
        {
          *v13 = *(WCHAR *)((char *)v13 + (_DWORD)v15);
          ++v13;
        }
        v4 = v21;
        v2 = a2;
      }
      *v13 = 92;
      v17 = v13 + 1;
      if ( *v4 )
      {
        v18 = *v4;
        do
        {
          ++v4;
          *v17++ = v18;
          v18 = *v4;
        }
        while ( *v4 );
      }
      v4 = v25;
      *v17 = 0;
    }
    FileW = CreateFileW(v4, 0x80000000, 1u, 0, 3u, 0, 0);
    if ( v23 )
      free(v4);
    if ( FileW == (HANDLE)-1 )
      return 0;
    if ( !GetFileTime(FileW, (LPFILETIME)(v2 + 1), (LPFILETIME)(v2 + 3), (LPFILETIME)(v2 + 5)) )
    {
      CloseHandle(FileW);
      return 0;
    }
    CloseHandle(FileW);
  }
  return 1;
}
// 4226B0: using guessed type int dword_4226B0;

//----- (00407F02) --------------------------------------------------------
int sub_407F02()
{
  int result; // eax
  wchar_t *v1; // edi
  wchar_t *v2; // eax
  wchar_t *v3; // esi
  wchar_t *v4; // esi
  int v5; // eax
  char v6; // [esp+Ah] [ebp-6h] BYREF
  bool v7; // [esp+Bh] [ebp-5h]
  wchar_t *Context; // [esp+Ch] [ebp-4h] BYREF

  while ( 1 )
  {
    result = getwc(Stream);
    if ( !dword_432EF8 && (!byte_412021 || (_WORD)result != 33) )
      break;
    byte_412021 = 0;
    if ( dword_432EF8 )
    {
      ungetwc(result, Stream);
      v1 = (wchar_t *)dword_432EF8;
      dword_432EF8 = 0;
    }
    else
    {
      v1 = sub_4080AB();
    }
    v7 = v1 != dword_432EFC;
    v2 = sub_4081E7(v1, &v6);
    v3 = v2;
    switch ( v6 )
    {
      case 9:
        if ( byte_422EE1 )
          sub_4053D9(dword_4226A4, 0x409u, v1);
        if ( sub_40A5D2(v3) == 18 )
          return 32;
        break;
      case 10:
        sub_408338(v2);
        break;
      case 11:
        sub_4053D9(dword_4226A4, 0x41Au, v2);
        break;
      case 12:
        if ( !wcsnicmp(v2, L"\\t", 2u) )
        {
          sub_40CE7E((wchar_t *)L"\t");
          v3 += 2;
        }
        sub_4054B3(0xDu, v3);
        break;
      case 13:
        Context = 0;
        v4 = wcstok_s(v2, L" \t", &Context);
        if ( wcstok_s(0, L" \t", &Context) )
          sub_4053D9(dword_4226A4, 0x409u, v4);
        v5 = sub_40AB4F(v4);
        if ( v5 )
          *(_BYTE *)(v5 + 12) |= 0x10u;
        break;
      default:
        sub_408697(v2, v6);
        break;
    }
    byte_412021 = 1;
    if ( v7 )
      free(v1);
    ++dword_4226A4;
  }
  return result;
}
// 412021: using guessed type char byte_412021;
// 4226A4: using guessed type int dword_4226A4;
// 422EE1: using guessed type char byte_422EE1;

//----- (004080AB) --------------------------------------------------------
wchar_t *sub_4080AB()
{
  wint_t v0; // si
  unsigned int v1; // edi
  wint_t i; // ax
  wchar_t *v3; // eax
  int v4; // edx
  wint_t v5; // ax
  wint_t v6; // si
  wint_t v7; // ax
  FILE *v9; // [esp-4h] [ebp-10h]

  v0 = sub_409C3A(1);
  if ( v0 == 10 || v0 == 0xFFFF )
    sub_4053D9(dword_4226A4, 0x3FAu);
  v1 = 0;
  for ( i = sub_409D17(v0, 1); ; i = sub_409D17(v5, 1) )
  {
    v6 = i;
    if ( i == 35 || i == 10 || i == 0xFFFF )
      break;
    if ( (unsigned int)dword_432EF4 < 2 || v1 > dword_432EF4 - 2 )
    {
      v4 = dword_432EF4 + 1024;
      dword_432EF4 += 1024;
      if ( dword_432EFC )
        v3 = (wchar_t *)sub_40AC26(dword_432EFC, 2 * v4 + 2);
      else
        v3 = (wchar_t *)sub_40ABE3((unsigned __int64)(unsigned int)(v4 + 1) >> 31 != 0 ? -1 : 2 * (v4 + 1));
      dword_432EFC = v3;
    }
    else
    {
      v3 = dword_432EFC;
    }
    v9 = Stream;
    v3[v1++] = v6;
    v5 = getwc(v9);
  }
  dword_432EFC[v1] = 0;
  if ( i == 35 )
  {
    while ( 1 )
    {
      v7 = getwc(Stream);
      v6 = v7;
      if ( v7 == 10 )
        break;
      if ( v7 == 0xFFFF )
        goto LABEL_21;
    }
  }
  if ( v6 == 0xFFFF )
LABEL_21:
    ungetwc(v6, Stream);
  return sub_40F2A9(dword_432EFC);
}
// 4226A4: using guessed type int dword_4226A4;
// 432EF4: using guessed type int dword_432EF4;

//----- (004081E7) --------------------------------------------------------
wchar_t *__fastcall sub_4081E7(wchar_t *String1, char *a2)
{
  wchar_t *v2; // edi
  wchar_t *v3; // edx
  wchar_t v4; // ax
  char v5; // bl
  wchar_t *v6; // esi
  wchar_t v7; // di
  wchar_t v8; // ax
  int v9; // esi
  wchar_t v10; // cx
  wchar_t v11; // ax
  wchar_t *v12; // esi
  char v13; // al
  wchar_t *v16; // [esp+14h] [ebp-Ch]
  int v17; // [esp+18h] [ebp-8h] BYREF
  wchar_t *v18; // [esp+1Ch] [ebp-4h]

  v18 = String1;
  v2 = String1;
  *a2 = 0;
  v3 = String1;
  v16 = String1;
  v4 = *String1;
  v17 = (int)String1;
  v5 = 9;
  if ( v4 )
  {
    v6 = String1;
    v7 = v4;
    do
    {
      v3 = v6;
      if ( v7 == 32 )
        break;
      if ( v7 == 9 )
        break;
      String1 = v6 + 1;
      v8 = v6[1];
      v6 = String1;
      v17 = (int)String1;
      v3 = String1;
      v7 = v8;
    }
    while ( v8 );
    v2 = v16;
    v18 = String1;
  }
  v9 = v3 - v2;
  if ( *String1 )
  {
    v10 = *String1;
    do
    {
      if ( v10 != 32 && v10 != 9 )
        break;
      v11 = v3[1];
      v18 = ++v3;
      v17 = (int)v3;
      v10 = v11;
    }
    while ( v11 );
    v2 = v16;
  }
  if ( !wcsnicmp(v2, L"INCLUDE", 7u) && v9 == 7 )
    goto LABEL_27;
  if ( !wcsnicmp(v2, L"CMDSWITCHES", 0xBu) && v9 == 11 )
  {
    v5 = 10;
LABEL_27:
    v12 = v18;
    goto LABEL_29;
  }
  if ( !wcsnicmp(v2, L"ERROR", 5u) && v9 == 5 )
  {
    v5 = 11;
    goto LABEL_27;
  }
  if ( !wcsnicmp(v2, L"MESSAGE", 7u) && v9 == 7 )
  {
    v5 = 12;
    goto LABEL_27;
  }
  if ( !wcsnicmp(v2, L"UNDEF", 5u) && v9 == 5 )
  {
    v5 = 13;
    goto LABEL_27;
  }
  v13 = sub_4084BB(v2, v9, (wchar_t **)&v17);
  v12 = (wchar_t *)v17;
  v5 = v13;
LABEL_29:
  *a2 = v5;
  if ( !v5 )
    sub_4053D9(dword_4226A4, 0x3F9u, dword_432EFC);
  return v12;
}
// 4226A4: using guessed type int dword_4226A4;

//----- (00408338) --------------------------------------------------------
int __thiscall sub_408338(wint_t *this)
{
  wint_t *v1; // esi
  int result; // eax
  wint_t v3; // dx
  wint_t v4; // cx
  wint_t v5; // dx
  wint_t v6; // cx
  wchar_t v7; // ax
  wchar_t v8; // ax
  wint_t v9; // dx
  wchar_t v10; // ax
  wchar_t v11; // ax

  v1 = this;
  result = *this;
  if ( (_WORD)result )
  {
    v3 = *this;
    while ( v3 != 43 )
    {
      result = v3 - 45;
      if ( v3 == 45 )
        goto LABEL_18;
      v4 = v3;
      if ( v3 != 32 )
      {
        v4 = v3;
        if ( v3 != 9 )
        {
          result = sub_4053D9(dword_4226A4, 0x400u);
          v4 = *v1;
        }
      }
LABEL_27:
      if ( v4 )
      {
        result = *++v1;
        v3 = result;
        if ( (_WORD)result )
          continue;
      }
      return result;
    }
    result = *++v1;
    v5 = result;
    if ( (_WORD)result )
    {
      v6 = *v1;
      do
      {
        v5 = v6;
        if ( v6 == 45 )
          break;
        v7 = towupper(v6);
        if ( wcschr(L"DINSU", v7) || byte_422EE1 && (v8 = towupper(*v1), wcschr(L"ABCEKLPQRTY", v8)) )
          sub_40C801(*v1, 1);
        else
          sub_4053D9(dword_4226A4, 0x400u);
        result = *++v1;
        v6 = result;
        v5 = *v1;
      }
      while ( (_WORD)result );
    }
    if ( !v5 )
      return result;
LABEL_18:
    result = *++v1;
    v4 = result;
    if ( (_WORD)result )
    {
      v9 = *v1;
      do
      {
        result = 43;
        v4 = v9;
        if ( v9 == 43 )
          break;
        v10 = towupper(v9);
        if ( wcschr(L"DINSU", v10) || byte_422EE1 && (v11 = towupper(*v1), wcschr(L"ABCEKLMPQRTV", v11)) )
          sub_40C801(*v1, 0);
        else
          sub_4053D9(dword_4226A4, 0x400u);
        result = *++v1;
        v9 = result;
        v4 = *v1;
      }
      while ( (_WORD)result );
    }
    goto LABEL_27;
  }
  return result;
}
// 4226A4: using guessed type int dword_4226A4;
// 422EE1: using guessed type char byte_422EE1;

//----- (004084BB) --------------------------------------------------------
char __fastcall sub_4084BB(wchar_t *String1, int a2, wchar_t **a3)
{
  char v4; // bl
  wchar_t *v5; // ecx
  wchar_t v6; // dx
  wchar_t v7; // ax
  int (__cdecl *v8)(const wchar_t *, const wchar_t *, size_t); // edi
  int v9; // esi
  wchar_t v10; // di
  wchar_t *String1b; // [esp+10h] [ebp-4h]

  v4 = 0;
  if ( !wcsnicmp(String1, L"IF", 2u) && a2 == 2 )
    return 1;
  if ( !wcsnicmp(String1, L"IFDEF", 5u) && a2 == 5 )
    return 6;
  if ( !wcsnicmp(String1, L"IFNDEF", 6u) && a2 == 6 )
    return 7;
  if ( wcsnicmp(String1, L"ELSE", 4u) || a2 != 4 )
  {
    if ( wcsnicmp(String1, L"ELSEIF", 6u) || a2 != 6 )
    {
      if ( wcsnicmp(String1, L"ELSEIFDEF", 9u) || a2 != 9 )
      {
        if ( !wcsnicmp(String1, L"ELSEIFNDEF", 0xAu) && a2 == 10 )
          return 5;
        if ( !wcsnicmp(String1, L"ENDIF", 5u) && a2 == 5 )
          return 8;
        return v4;
      }
      return 4;
    }
    return 3;
  }
  v5 = *a3;
  if ( !**a3 )
    return 2;
  String1b = *a3;
  v6 = **a3;
  do
  {
    v7 = v6;
    if ( v6 == 32 )
      break;
    v7 = v6;
    if ( v6 == 9 )
      break;
    v7 = *++v5;
    v6 = *v5;
  }
  while ( *v5 );
  v8 = wcsnicmp;
  v9 = v5 - String1b;
  if ( v7 )
  {
    v10 = v7;
    do
    {
      if ( v10 != 32 && v10 != 9 )
        break;
      v10 = *++v5;
    }
    while ( *v5 );
    v8 = wcsnicmp;
  }
  *a3 = v5;
  if ( !v8(String1b, L"IF", 2u) && v9 == 2 )
    return 3;
  if ( !v8(String1b, L"IFDEF", 5u) && v9 == 5 )
    return 4;
  if ( !v8(String1b, L"IFNDEF", 6u) && v9 == 6 )
    return 5;
  return v4;
}

//----- (00408697) --------------------------------------------------------
void __fastcall sub_408697(wchar_t *String, char a2)
{
  wchar_t *v2; // esi
  int v3; // eax
  int v4; // eax
  bool v5; // zf
  int v6; // ecx
  char v7; // al
  char v8; // al
  int v9; // ecx
  char v10; // al
  char v11; // al
  char v12; // al
  int v13; // eax

  v2 = String;
  if ( a2 == 1 )
    goto LABEL_30;
  if ( a2 == 2 )
  {
    v9 = dword_412024;
    if ( dword_412024 >= 0 )
    {
      v10 = byte_432F00[dword_412024];
      if ( (v10 & 9) != 0 )
      {
        v11 = v10 & 0xF6;
        byte_432F00[dword_412024] = v11;
        if ( (v11 & 4) == 0 )
        {
          if ( (v11 & 2) != 0 )
            v12 = v11 & 0xFD;
          else
            v12 = v11 | 2;
          byte_432F00[v9] = v12;
          v5 = (v12 & 2) == 0;
          goto LABEL_11;
        }
        goto LABEL_12;
      }
    }
LABEL_22:
    v3 = sub_4053D9(dword_4226A4, 0x3FDu);
LABEL_9:
    v4 = v3 - 1;
    dword_412024 = v4;
    if ( v4 < 0 )
      return;
    v5 = (byte_432F00[v4] & 2) == 0;
LABEL_11:
    if ( !v5 )
      return;
    goto LABEL_12;
  }
  if ( (unsigned __int8)a2 <= 2u )
    return;
  if ( (unsigned __int8)a2 > 5u )
  {
    if ( (unsigned __int8)a2 > 7u )
    {
      if ( a2 != 8 )
        return;
      v3 = dword_412024;
      if ( dword_412024 < 0 )
        v3 = sub_4053D9(dword_4226A4, 0x401u);
      goto LABEL_9;
    }
LABEL_30:
    if ( dword_412024 == 15 )
    {
      v3 = sub_4053D9(dword_4226A4, 0x3FBu);
      goto LABEL_9;
    }
    v5 = dword_412024 == -1;
    v13 = dword_412024 + 1;
    dword_412024 = v13;
    byte_432F00[v13] = 1;
    if ( !v5 && (*((_BYTE *)&dword_432EFC + v13 + 3) & 2) == 0 )
    {
      byte_432F00[v13] = 5;
      goto LABEL_12;
    }
LABEL_20:
    if ( sub_40E062(String, a2) )
    {
      byte_432F00[dword_412024] |= 2u;
      return;
    }
    goto LABEL_12;
  }
  v6 = dword_412024;
  if ( dword_412024 < 0 )
    goto LABEL_22;
  v7 = byte_432F00[dword_412024];
  if ( (v7 & 9) == 0 )
    goto LABEL_22;
  v8 = v7 & 0xF6 | 8;
  byte_432F00[dword_412024] = v8;
  if ( (v8 & 4) == 0 )
  {
    if ( (v8 & 2) == 0 )
    {
      String = v2;
      goto LABEL_20;
    }
    byte_432F00[v6] = v8 & 0xF9 | 4;
  }
LABEL_12:
  sub_4087C0();
}
// 412024: using guessed type int dword_412024;
// 4226A4: using guessed type int dword_4226A4;

//----- (004087C0) --------------------------------------------------------
wchar_t *sub_4087C0()
{
  wint_t v0; // ax
  wchar_t *result; // eax
  unsigned __int8 v2; // [esp+Fh] [ebp-1h] BYREF

  while ( 1 )
  {
    v0 = getwc(Stream);
    if ( v0 != 33 )
    {
      do
      {
        if ( v0 == 0xFFFF )
          break;
        ++dword_4226A4;
        while ( 1 )
        {
          if ( v0 == 92 )
          {
            v0 = sub_409D17(0x5Cu, 1);
            if ( v0 == 33 && byte_412021 )
              goto LABEL_16;
            byte_412021 = 0;
          }
          if ( v0 == 35 )
            break;
          if ( v0 == 10 )
            goto LABEL_14;
          if ( v0 == 0xFFFF )
            goto LABEL_15;
          v0 = getwc(Stream);
        }
        while ( 1 )
        {
          v0 = getwc(Stream);
          if ( v0 == 10 )
            break;
          if ( v0 == 0xFFFF )
            goto LABEL_15;
        }
LABEL_14:
        v0 = getwc(Stream);
      }
      while ( v0 != 33 );
LABEL_15:
      if ( v0 != 33 )
        return (wchar_t *)sub_4053D9(dword_4226A4, 0x3FCu);
    }
LABEL_16:
    if ( dword_432EF8 )
    {
      if ( dword_432EF8 != dword_432EFC )
        free(dword_432EF8);
    }
    dword_432EF8 = sub_4080AB();
    result = sub_4081E7((wchar_t *)dword_432EF8, (char *)&v2);
    if ( v2 <= 8u )
      return result;
    ++dword_4226A4;
  }
}
// 40885D: conditional instruction was optimized away because ax.2==A
// 408862: conditional instruction was optimized away because ax.2==A
// 4088BF: conditional instruction was optimized away because ax.2==FFFF
// 412021: using guessed type char byte_412021;
// 4226A4: using guessed type int dword_4226A4;

//----- (004088D8) --------------------------------------------------------
char sub_4088D8()
{
  char v0; // bl
  wchar_t *i; // eax
  const wchar_t *v2; // ecx
  wchar_t *v3; // edx
  int v5; // edx
  wchar_t *v7; // [esp+4h] [ebp-Ch]
  wchar_t *Context; // [esp+Ch] [ebp-4h] BYREF

  v0 = 0;
  for ( dword_4226A4 = 0; ; ++dword_4226A4 )
  {
    if ( !fgetws(&Src, 1024, Stream) )
    {
      if ( !feof(Stream) )
      {
        dword_4226B0 = dword_4226A4;
        sub_4053D9(0, 0x41Du);
      }
      return 0;
    }
    if ( Src == 91 )
      break;
LABEL_13:
    ;
  }
  Context = 0;
  for ( i = wcstok_s(&word_4226C2, L" \t\n", &Context); ; i = wcstok_s(0, L" \t\n", &Context) )
  {
    v2 = i;
    if ( !i || v0 )
    {
      v0 = 0;
      goto LABEL_13;
    }
    v3 = i;
    v7 = i + 1;
    while ( *v3++ )
      ;
    v5 = v3 - v7;
    if ( v2[v5 - 1] == 93 )
    {
      v0 = 1;
      v2[v5 - 1] = 0;
    }
    if ( !wcsicmp(v2, L"nmake") )
      break;
  }
  return 1;
}
// 4226A4: using guessed type int dword_4226A4;
// 4226B0: using guessed type int dword_4226B0;

//----- (004089C1) --------------------------------------------------------
wint_t *__fastcall sub_4089C1(wint_t *a1, int a2)
{
  wint_t *v2; // esi
  wint_t *v3; // edi
  wint_t v4; // ax
  wint_t *result; // eax
  FILE *v6; // [esp-4h] [ebp-Ch]

  v2 = a1;
  v3 = &a1[a2];
  while ( 1 )
  {
    v4 = sub_407F02();
    if ( !v4 )
      return v2;
    if ( v4 == 0xFFFF )
      break;
    *v2++ = v4;
    if ( v2 == v3 )
    {
      v6 = Stream;
      *(v2 - 1) = 0;
      ungetwc(v4, v6);
      return v2;
    }
    if ( v4 == 10 )
    {
      ++dword_4226A4;
      byte_412021 = 1;
      *v2 = 0;
      return v2;
    }
    byte_412021 = 0;
  }
  result = 0;
  *v2 = 0;
  return result;
}
// 412021: using guessed type char byte_412021;
// 4226A4: using guessed type int dword_4226A4;

//----- (00408A2F) --------------------------------------------------------
wchar_t *__fastcall sub_408A2F(const wchar_t *a1)
{
  wchar_t *result; // eax
  const wchar_t *v3; // esi

  for ( result = wcschr(a1, 0xAu); result && (result <= a1 || *(result - 1) == 94); result = wcschr(v3, 0xAu) )
  {
    v3 = result + 1;
    if ( !fgetws(result + 1, 1024 - (result + 1 - a1), Stream) )
    {
      if ( feof(Stream) )
        sub_4053D9(dword_4226A4, 0x409u, L"EOF");
      sub_4053D9(dword_4226A4, 0x41Du);
    }
    ++dword_4226A4;
  }
  return result;
}
// 4018A8: using guessed type wchar_t aEof[4];
// 4226A4: using guessed type int dword_4226A4;

//----- (00408AC3) --------------------------------------------------------
void *__thiscall sub_408AC3(__int16 **this)
{
  __int16 **v1; // edi
  char v2; // bl
  __int16 *v3; // esi
  const wchar_t *v4; // edx
  wchar_t *v5; // eax
  __int16 *v6; // edx
  __int16 v7; // ax
  __int16 v8; // cx
  bool v9; // bl
  __int16 v10; // ax
  __int16 v11; // cx
  __int16 v12; // cx
  __int16 v13; // di
  void *result; // eax
  bool v16; // [esp+17h] [ebp-1h]

  v1 = this;
  v2 = 0;
  v3 = (__int16 *)&unk_433400;
  v16 = 0;
  v4 = (const wchar_t *)*this;
  do
  {
    v5 = wcschr(v4, 0x3Cu);
    if ( !v5 )
      return 0;
    v4 = v5 + 1;
    if ( v5[1] == 60 )
      v2 = 1;
  }
  while ( !v2 );
  v6 = (__int16 *)(v5 + 2);
  v7 = *v6;
  if ( *v6 )
  {
    do
    {
      if ( v7 == 62 || v7 == 60 || v7 == 94 || v7 == 44 || v7 == 9 || v7 == 10 )
        break;
      v8 = v7;
      if ( v7 == 34 )
      {
        v9 = !v16;
        v16 = !v16;
        v8 = 34;
      }
      else
      {
        v9 = v16;
      }
      v10 = v8;
      if ( v8 == 32 )
      {
        v10 = 32;
        if ( !v9 )
          break;
      }
      v11 = v10;
      if ( v10 == 36 && (v11 = *v6, v6[1] == 40) )
      {
        *v3 = 36;
        ++v6;
        *++v3 = 40;
        v12 = *v6;
        if ( *v6 != 10 )
        {
          v13 = *v6;
          do
          {
            v12 = v13;
            if ( v13 == 41 )
              break;
            ++v6;
            *v3++ = v13;
            v13 = *v6;
            v12 = *v6;
          }
          while ( *v6 != 10 );
        }
        if ( v12 == 10 )
          break;
      }
      else
      {
        *v3++ = v11;
        v12 = *++v6;
      }
      v7 = v12;
    }
    while ( v12 );
    v1 = this;
  }
  result = &unk_433400;
  *v3 = 0;
  *v1 = v6;
  return result;
}

//----- (00408C25) --------------------------------------------------------
wchar_t *__fastcall sub_408C25(wchar_t *a1, _DWORD *a2, wchar_t **a3)
{
  _DWORD *v4; // ebx
  int *v5; // edx
  int *v6; // ecx
  char *v7; // esi
  wchar_t v8; // cx
  wchar_t *v9; // ebx
  _WORD *v10; // esi
  char *v11; // eax
  char *v12; // eax
  char *v15; // [esp+1Ch] [ebp-820h]
  unsigned int v16; // [esp+20h] [ebp-81Ch]
  wchar_t *v17; // [esp+24h] [ebp-818h] BYREF
  void *Block; // [esp+28h] [ebp-814h]
  char v19; // [esp+2Fh] [ebp-80Dh]
  wchar_t Destination[2]; // [esp+30h] [ebp-80Ch] BYREF
  wint_t v21[1024]; // [esp+34h] [ebp-808h] BYREF

  v15 = 0;
  v16 = 0;
  v19 = 0;
  Block = 0;
  wcscpy_s(Destination, 0x400u, L"<<");
  if ( !sub_4089C1(v21, 1022) )
  {
    if ( feof(Stream) )
      sub_4053D9(dword_4226A4, 0x409u, L"EOF");
    sub_4053D9(dword_4226A4, 0x41Du);
  }
  v17 = Destination;
  sub_408A2F(Destination);
  while ( 1 )
  {
    v7 = (char *)sub_408AC3((__int16 **)&v17);
    if ( !v7 )
      break;
    v4 = sub_40AC08(0xCu);
    v4[1] = sub_40E919(v7);
    v5 = &dword_433320;
    v6 = (int *)dword_433320;
    if ( dword_433320 )
    {
      do
      {
        v5 = v6;
        v6 = (int *)*v6;
      }
      while ( v6 );
    }
    *v5 = (int)v4;
  }
  if ( dword_433320 )
  {
    v17 = (wchar_t *)wcsncpy_s;
    do
    {
      while ( 1 )
      {
        v8 = Destination[0];
        v9 = Destination;
        do
        {
          ++v9;
          *a1++ = v8;
          if ( a1 == *a3 )
          {
            if ( Block )
            {
              if ( v16 + 1024 < v16 || (v12 = (char *)sub_40AC26(Block, 2 * v16 + 2048), (v15 = v12) == 0) )
              {
                sub_4053D9(dword_4226A4, 0x419u);
                v12 = v15;
              }
              Block = v12;
              v10 = v12;
              a1 = (wchar_t *)&v12[2 * v16];
              v16 += 1024;
              v11 = &v12[2 * v16];
            }
            else
            {
              v10 = sub_40ABE3(0x1000u);
              Block = v10;
              ((void (__cdecl *)(_WORD *, int, _DWORD, int))v17)(v10, 2048, *a2, 1024);
              a1 = v10 + 1024;
              v16 = 2048;
              v11 = (char *)(v10 + 2048);
            }
            *a3 = (wchar_t *)v11;
            *a2 = v10;
          }
          v8 = *v9;
        }
        while ( *v9 );
        if ( v19 && Destination[0] == 60 && Destination[1] == 60 )
          break;
        v19 = 1;
        if ( !sub_4089C1(Destination, 1024) )
        {
          if ( feof(Stream) )
            sub_4053D9(dword_4226A4, 0x409u, L"EOF");
          sub_4053D9(dword_4226A4, 0x41Du);
        }
      }
      if ( *(_DWORD *)dword_433320 && !sub_4089C1(Destination, 1024) )
      {
        if ( feof(Stream) )
          sub_4053D9(dword_4226A4, 0x409u, L"EOF");
        sub_4053D9(dword_4226A4, 0x41Du);
      }
      dword_433320 = *(_DWORD *)dword_433320;
    }
    while ( dword_433320 );
  }
  *a1 = 0;
  return a1;
}
// 4018A8: using guessed type wchar_t aEof[4];
// 4226A4: using guessed type int dword_4226A4;
// 433320: using guessed type int dword_433320;
// 408C25: using guessed type wint_t var_808[1024];

//----- (00408F3C) --------------------------------------------------------
errno_t __fastcall sub_408F3C(void **a1, wchar_t *a2)
{
  char *v2; // edi
  _WORD *v3; // esi
  int v4; // ecx
  int v6; // esi
  wchar_t *v7; // ecx
  int v8; // esi
  wchar_t *v9; // edx
  rsize_t v11; // esi
  void *v12; // esp
  wchar_t *i; // eax
  __int16 v14; // cx
  unsigned int v15; // kr00_4
  void **v16; // edi
  wchar_t *v17; // eax
  wchar_t *v19; // [esp-4h] [ebp-24h]
  wchar_t v20[8]; // [esp+0h] [ebp-20h] BYREF
  void **v21; // [esp+10h] [ebp-10h]
  rsize_t SizeInWords; // [esp+14h] [ebp-Ch]
  wchar_t *Source; // [esp+18h] [ebp-8h]

  Source = a2;
  v21 = a1;
  v2 = (char *)*a1;
  v3 = *a1;
  v4 = (int)*a1 + 2;
  while ( *v3++ )
    ;
  v6 = (int)v3 - v4;
  v7 = a2;
  v8 = v6 >> 1;
  v9 = a2 + 1;
  while ( *v7++ )
    ;
  v11 = v7 - v9 - 1 + v8;
  SizeInWords = v11;
  v12 = alloca(2 * v11);
  for ( i = v20; ; ++i )
  {
    v14 = *(_WORD *)v2;
    if ( *(_WORD *)v2 != 60 )
      goto LABEL_9;
    if ( *((_WORD *)v2 + 1) == 60 )
      break;
    v14 = 60;
LABEL_9:
    *i = v14;
    v2 += 2;
  }
  v19 = Source;
  *i = 0;
  wcscat_s(v20, v11, v19);
  wcscat_s(v20, SizeInWords, (const wchar_t *)v2 + 2);
  v15 = wcslen(v20);
  v16 = v21;
  v17 = (wchar_t *)sub_40AC26(*v21, 2 * (v15 + 1));
  *v16 = v17;
  return wcscpy_s(v17, v15 + 1, v20);
}

//----- (00409019) --------------------------------------------------------
int __fastcall sub_409019(wchar_t *Source, const unsigned __int16 *a2, char a3)
{
  const wchar_t *v3; // edi
  wint_t *v4; // esi
  wint_t v5; // cx
  const wchar_t *v6; // eax
  int result; // eax
  int v8; // esi
  int v9; // edi
  wint_t v10; // cx
  unsigned int v11; // esi
  const wchar_t *v12; // eax
  unsigned int v13; // [esp+Ch] [ebp-10h]
  wchar_t *v14; // [esp+10h] [ebp-Ch]
  wint_t *v15; // [esp+14h] [ebp-8h]
  const unsigned __int16 *v16; // [esp+18h] [ebp-4h]
  char v17; // [esp+27h] [ebp+Bh]

  v3 = Source;
  v14 = Source;
  v16 = a2;
  v4 = Source;
  v5 = *Source;
  if ( v5 )
  {
    while ( iswspace(v5) )
    {
      v5 = *++v4;
      if ( !*v4 )
      {
        a2 = v16;
        goto LABEL_5;
      }
    }
    result = 1012 - wcslen(v16);
    v13 = result;
    if ( *v3 )
    {
      v17 = a3;
      do
      {
        wcsncpy_s(word_436670, 0x400u, v3, result);
        v8 = wcslen(word_436670);
        if ( v13 < wcslen(v3) )
        {
          v15 = word_436670;
          if ( word_436670[0] )
          {
            v9 = 0;
            v10 = word_436670[0];
            do
            {
              if ( iswspace(v10) )
                v8 = (v9 >> 1) + 1;
              v9 += 2;
              v10 = *++v15;
            }
            while ( *v15 );
            v3 = v14;
          }
        }
        v11 = v8;
        if ( v11 >= 1024 )
          __report_rangecheckfailure();
        word_436670[v11] = 0;
        v12 = L">>";
        if ( !v17 )
          v12 = L">";
        sub_40CE7E((wchar_t *)L"\techo %s %s %s\n", word_436670, v12, v16);
        v3 = (const wchar_t *)((char *)v3 + v11 * 2);
        v17 = 1;
        v14 = (wchar_t *)v3;
        result = v13;
      }
      while ( *v3 );
    }
  }
  else
  {
LABEL_5:
    v6 = L">>";
    if ( !a3 )
      v6 = L">";
    return sub_40CE7E((wchar_t *)L"\techo. %s %s\n", v6, a2);
  }
  return result;
}
// 40166C: using guessed type wchar_t asc_40166C[2];
// 4018C0: using guessed type wchar_t asc_4018C0[3];
// 410AF8: using guessed type void __noreturn __report_rangecheckfailure(void);
// 436670: using guessed type wchar_t word_436670[1024];

//----- (0040918A) --------------------------------------------------------
wchar_t *__fastcall sub_40918A(FILE *a1, int a2, const wchar_t **a3, char a4, _BYTE *a5)
{
  const wchar_t **v5; // edi
  const unsigned __int16 *v6; // esi
  wchar_t *v7; // eax
  char *v8; // ebx
  wchar_t *v9; // esi
  void *v10; // eax
  wchar_t *v11; // esi
  wchar_t *result; // eax
  wchar_t *v13; // ebx
  wchar_t *v14; // ecx
  const wchar_t *v15; // esi
  FILE *v16; // edi
  int v17; // eax
  void *Block; // [esp+10h] [ebp-14h] BYREF
  wchar_t *Context; // [esp+14h] [ebp-10h] BYREF
  const unsigned __int16 *v20; // [esp+18h] [ebp-Ch]
  FILE *Stream; // [esp+1Ch] [ebp-8h]
  char v22; // [esp+23h] [ebp-1h]
  char v23; // [esp+34h] [ebp+10h]

  v5 = a3;
  v6 = (const unsigned __int16 *)a2;
  v20 = (const unsigned __int16 *)a2;
  Stream = a1;
  v7 = wcsstr(*a3, L"<<");
  v22 = 0;
  if ( v7 && (v7 == *a3 || *(v7 - 1) == 10) )
  {
    v8 = (char *)(v7 + 2);
    v9 = wcschr(v7 + 2, 0xAu);
    if ( v9 )
      *v9 = 0;
    v10 = sub_40E919(v8);
    Block = v10;
    if ( v9 )
      *v9 = 10;
    Context = 0;
    v11 = wcstok_s((wchar_t *)v10, L", \t", &Context);
    if ( v11 )
    {
      do
      {
        if ( wcsicmp(v11, L"keep") )
        {
          if ( wcsicmp(v11, L"nokeep") )
          {
            if ( wcsicmp(v11, L"unicode") )
              sub_4053D9(dword_4226A4, 0x446u);
            else
              v22 = 1;
          }
          else
          {
            *a5 = 0;
          }
        }
        else
        {
          *a5 = 1;
        }
        v11 = wcstok_s(0, L", \t", &Context);
      }
      while ( v11 );
      v5 = a3;
    }
    free(Block);
    if ( v22 )
      fwrite(&dword_401938, 2u, 1u, Stream);
    v6 = v20;
  }
  result = (wchar_t *)wcsncmp(*v5, L"<<", 2u);
  if ( result )
  {
    v23 = 0;
    while ( 1 )
    {
      result = wcschr(*v5, 0xAu);
      v13 = result;
      if ( !result )
        break;
      if ( a4 )
      {
        v14 = (wchar_t *)*v5;
        *result = 0;
        sub_409019(v14, v6, v23);
        *v13 = 10;
      }
      v15 = *v5;
      if ( v22 )
      {
        fwrite(v15, v13 - v15, 2u, Stream);
        fwrite("\r", 4u, 1u, Stream);
      }
      else
      {
        if ( v15 < v13 )
        {
          v16 = Stream;
          do
          {
            v17 = WideCharToMultiByte(0, 0, v15, 1, (LPSTR)&Block, 4, 0, 0);
            if ( v17 )
              fwrite(&Block, v17, 1u, v16);
            ++v15;
          }
          while ( v15 < v13 );
          v5 = a3;
        }
        fwrite("\r\n", 2u, 1u, Stream);
      }
      v23 = 1;
      *v5 = v13 + 1;
      result = (wchar_t *)wcsncmp(v13 + 1, L"<<", 2u);
      v6 = v20;
      if ( !result )
        goto LABEL_36;
    }
  }
  else
  {
LABEL_36:
    *v5 += 2;
  }
  return result;
}
// 401938: using guessed type int dword_401938;
// 4226A4: using guessed type int dword_4226A4;

//----- (004093AE) --------------------------------------------------------
char __fastcall sub_4093AE(wchar_t *Str, const wchar_t **a2, wchar_t *a3, char a4)
{
  const wchar_t **v5; // edi
  wchar_t *v6; // ebx
  __int16 *v8; // ebx
  __int16 *v9; // eax
  wchar_t *v10; // esi
  char *v11; // eax
  _WORD *v12; // esi
  FILE *v13; // eax
  unsigned int v14; // kr00_4
  wchar_t *v15; // edx
  const wchar_t *v16; // eax
  _WORD *v17; // ecx
  wchar_t *v19; // esi
  wchar_t *v20; // eax
  wchar_t *v21; // eax
  _DWORD *v22; // esi
  wchar_t *v23; // [esp-4h] [ebp-44Ch]
  wchar_t *v24; // [esp+Ch] [ebp-43Ch]
  size_t RequiredCount; // [esp+18h] [ebp-430h] BYREF
  const wchar_t *v27; // [esp+1Ch] [ebp-42Ch] BYREF
  void *Block; // [esp+20h] [ebp-428h]
  FILE *Stream; // [esp+24h] [ebp-424h]
  wchar_t *Stra; // [esp+28h] [ebp-420h] BYREF
  char v31; // [esp+2Fh] [ebp-419h] BYREF
  WCHAR TempFileName[260]; // [esp+30h] [ebp-418h] BYREF
  wchar_t Buffer; // [esp+238h] [ebp-210h] BYREF
  __int16 v34[261]; // [esp+23Ah] [ebp-20Eh] BYREF

  Stra = a3;
  v5 = a2;
  v6 = wcschr(Str, 0xAu);
  if ( v6 )
  {
    v23 = Stra;
    *v6 = 0;
    *v5 = (const wchar_t *)sub_40F311((__int16 *)Str, 255, v23);
    *v6 = 10;
    v8 = (__int16 *)(v6 + 1);
    v9 = (__int16 *)*v5;
    if ( *v5 == Str )
    {
      v9 = (__int16 *)sub_40E919((char *)Str);
      *v5 = (const wchar_t *)v9;
    }
    v27 = (const wchar_t *)v9;
    v10 = (wchar_t *)sub_40F311(v8, 255, Stra);
    v24 = v10;
    Stra = v10;
    v11 = (char *)sub_408AC3((__int16 **)&v27);
    if ( v11 )
    {
      do
      {
        v31 = 0;
        v12 = sub_40E919(v11);
        Block = v12;
        if ( *v12 )
        {
          Stream = sub_410655(v12, (wchar_t *)L"wb");
          if ( Stream )
          {
            v15 = wcschr(*v5, 0x3Cu);
            v16 = v15 + 1;
            if ( v15[1] != 60 )
            {
              do
              {
                v15 = wcschr(v16, 0x3Cu);
                v16 = v15 + 1;
              }
              while ( v15[1] != 60 );
              v5 = a2;
            }
            v17 = v15 + 2;
            v27 = v15 + 3;
            while ( *v17++ )
              ;
            memmove(v15, v15 + 2, 2 * (v17 - v27) + 2);
            v12 = Block;
          }
          else
          {
            sub_4053D9(dword_4226A4, 0x41Eu, v12);
          }
        }
        else
        {
          RequiredCount = 0;
          if ( wgetenv_s(&RequiredCount, &Buffer, 0x103u, L"TMP") || !RequiredCount )
            wcscpy_s(&Buffer, 0x103u, L".");
          Stream = 0;
          if ( GetTempFileNameW(&Buffer, L"nm", 0, TempFileName) )
          {
            wcscpy_s(&Buffer, 0x103u, TempFileName);
            v13 = wfsopen(&Buffer, L"wb", 32);
            Stream = v13;
          }
          else
          {
            v13 = Stream;
          }
          if ( !v13 )
            sub_4053D9(dword_4226A4, 0x41Eu, &Buffer);
          if ( wcschr(&Buffer, 0x20u) && !wcschr(&Buffer, 0x22u) )
          {
            v14 = wcslen(&Buffer);
            memmove(v34, &Buffer, 2 * v14);
            Buffer = 34;
            v34[v14] = 34;
            if ( 2 * v14 + 4 >= 0x206 )
              __report_rangecheckfailure();
            v12 = Block;
            v34[v14 + 1] = 0;
            v5 = a2;
          }
          sub_408F3C((void **)v5, &Buffer);
          free(v12);
          v12 = sub_40E919((char *)&Buffer);
          Block = v12;
        }
        v27 = *v5;
        sub_40918A(Stream, (int)v12, (const wchar_t **)&Stra, a4, &v31);
        v19 = Stra;
        v20 = wcschr(Stra, 0xAu);
        if ( v20 )
          v21 = v20 + 1;
        else
          v21 = &v19[wcslen(v19)];
        Stra = v21;
        fclose(Stream);
        if ( !v31 )
        {
          v22 = sub_40E8C7();
          v22[1] = sub_40E919((char *)Block);
          sub_40EA1E((_DWORD **)&dword_4333F4, v22);
        }
        free(Block);
        v11 = (char *)sub_408AC3((__int16 **)&v27);
      }
      while ( v11 );
      v10 = v24;
    }
    if ( v10 != (wchar_t *)v8 )
      free(v10);
    return 1;
  }
  else
  {
    *v5 = (const wchar_t *)sub_40E919((char *)Str);
    return 0;
  }
}
// 410AF8: using guessed type void __noreturn __report_rangecheckfailure(void);
// 4226A4: using guessed type int dword_4226A4;
// 4333F4: using guessed type int dword_4333F4;
// 4093AE: using guessed type __int16 var_20E[261];

//----- (004097A7) --------------------------------------------------------
int sub_4097A7()
{
  int v0; // ecx
  int result; // eax

  if ( fclose(Stream) == 0xFFFF )
    sub_4053D9(0, 0x424u, dword_422EE4);
  free(dword_422EE4);
  v0 = 3 * --dword_433324;
  Stream = (FILE *)dword_433338[v0];
  dword_422EE4 = (void *)dword_433334[v0];
  result = dword_433330[v0];
  dword_4226A4 = result;
  return result;
}
// 4226A4: using guessed type int dword_4226A4;
// 433324: using guessed type int dword_433324;
// 433330: using guessed type int dword_433330[];
// 433334: using guessed type int dword_433334[];
// 433338: using guessed type int dword_433338[];

//----- (0040980F) --------------------------------------------------------
wint_t __fastcall sub_40980F(char a1)
{
  wint_t result; // ax
  wint_t v3; // ax

LABEL_1:
  byte_412021 = 0;
  while ( 1 )
  {
    result = a1 ? getwc(Stream) : sub_407F02();
    if ( result == 0xFFFF )
      return result;
    if ( result == 10 )
    {
      byte_412021 = 1;
      if ( a1 )
        v3 = getwc(Stream);
      else
        v3 = sub_407F02();
      if ( v3 == 59 && byte_422EE1 || v3 == 35 )
      {
        ++dword_4226A4;
        goto LABEL_1;
      }
      return ungetwc(v3, Stream);
    }
  }
}
// 412021: using guessed type char byte_412021;
// 4226A4: using guessed type int dword_4226A4;
// 422EE1: using guessed type char byte_422EE1;

//----- (00409894) --------------------------------------------------------
unsigned __int8 __fastcall sub_409894(wchar_t a1)
{
  wchar_t *v2; // ecx
  unsigned int v3; // edx
  int v4; // eax

  if ( a1 == 10 || a1 == 0xFFFF )
    sub_4053D9(dword_4226A4, 0x407u);
  Src = a1;
  if ( !fgetws(&word_4226C2, 1023, Stream) )
  {
    if ( feof(Stream) )
      sub_4053D9(dword_4226A4, 0x409u, L"EOF");
    sub_4053D9(dword_4226A4, 0x41Du);
  }
  v2 = &Src;
  v3 = 2 * wcslen(&Src) - 2;
  if ( *(wchar_t *)((char *)&Src + v3) == 10 )
  {
    if ( v3 >= 0x800 )
      __report_rangecheckfailure();
    *(wchar_t *)((char *)&Src + v3) = 0;
  }
  while ( 1 )
  {
    v4 = *v2;
    if ( v4 != 32 && v4 != 9 )
      break;
    ++v2;
  }
  return sub_40A5D2(v2);
}
// 4018A8: using guessed type wchar_t aEof[4];
// 410AF8: using guessed type void __noreturn __report_rangecheckfailure(void);
// 4226A4: using guessed type int dword_4226A4;

//----- (00409978) --------------------------------------------------------
unsigned __int8 __fastcall sub_409978(wint_t Character, _WORD *a2, int a3)
{
  char v4; // dl
  wint_t v5; // ax
  char v6; // bl
  unsigned __int8 result; // al
  wint_t v8; // ax
  wchar_t v9; // si

  v4 = byte_412021;
  while ( 1 )
  {
    switch ( Character )
    {
      case 0xAu:
        goto LABEL_15;
      case 0x3Au:
        byte_412021 = 0;
        Character = sub_407F02();
        if ( Character == 58 )
        {
          *a2 = 58;
          result = 21;
          a2[1] = 0;
          return result;
        }
        v6 = 20;
LABEL_23:
        ungetwc(Character, Stream);
        return v6;
      case 0x3Bu:
        result = 19;
LABEL_44:
        byte_412021 = 0;
        return result;
      case 0x3Du:
        result = 22;
        goto LABEL_44;
    }
    if ( Character == 91 )
      break;
    if ( Character == 94 )
      goto LABEL_27;
    if ( Character != 0xFFFF )
      goto LABEL_28;
    if ( !feof(Stream) )
      sub_4053D9(dword_4226A4, 0x40Eu);
    if ( dword_433324 )
    {
      sub_4097A7();
    }
    else
    {
      if ( dword_412024 < 0 )
        return 23;
      sub_4053D9(dword_4226A4, 0x3FCu);
    }
LABEL_15:
    ++dword_4226A4;
    byte_412021 = 1;
    v5 = sub_407F02();
    Character = v5;
    if ( v5 == 59 && byte_422EE1 || v5 == 35 )
    {
      sub_40980F(0);
      ++dword_4226A4;
      byte_412021 = 1;
      Character = sub_407F02();
    }
    if ( Character == 32 || Character == 9 )
    {
      result = 18;
      goto LABEL_44;
    }
    v4 = 1;
    byte_412021 = 1;
    if ( Character != 0xFFFF )
    {
      v6 = 17;
      goto LABEL_23;
    }
  }
  if ( byte_422EE1 && v4 )
    return 23;
LABEL_27:
  ungetwc(Character, Stream);
  --a2;
LABEL_28:
  sub_40A326(a2 - 1, a3);
  if ( !byte_412021 || wcsicmp(&Src, L"include") )
  {
    byte_412021 = 0;
    return 16;
  }
  byte_412021 = 0;
  v8 = sub_409C3A(0);
  v9 = v8;
  if ( v8 == 58 || v8 == 61 )
  {
    ungetwc(v8, Stream);
    return 16;
  }
  if ( byte_422EE1 )
    sub_4053D9(dword_4226A4, 0x409u, a2);
  return sub_409894(v9);
}
// 412021: using guessed type char byte_412021;
// 412024: using guessed type int dword_412024;
// 4226A4: using guessed type int dword_4226A4;
// 422EE1: using guessed type char byte_422EE1;
// 433324: using guessed type int dword_433324;

//----- (00409B95) --------------------------------------------------------
char __fastcall sub_409B95(int a1, char a2)
{
  wint_t v3; // ax
  wint_t v4; // cx
  wchar_t *v5; // edx

  if ( byte_422EE2 )
  {
    ++dword_4226A4;
    byte_422EE2 = 0;
    v3 = sub_407F02();
    if ( v3 == 32 || v3 == 9 )
    {
      byte_412021 = 0;
      return 18;
    }
    else
    {
      v4 = -1;
      byte_412021 = 1;
      if ( v3 == 0xFFFF )
      {
        v5 = &Src;
        return sub_409978(v4, v5, (int)&dword_422EC0);
      }
      ungetwc(v3, Stream);
      return 17;
    }
  }
  else
  {
    if ( a2 != 24 && a2 != 25 )
    {
      v4 = sub_409C3A(0);
      v5 = &word_4226C2;
      Src = v4;
      word_4226C2 = 0;
      return sub_409978(v4, v5, (int)&dword_422EC0);
    }
    sub_409DC8(a2, a2, (int)&dword_422EC0);
    return a2;
  }
}
// 412021: using guessed type char byte_412021;
// 4226A4: using guessed type int dword_4226A4;
// 422EC0: using guessed type int dword_422EC0;
// 422EE2: using guessed type char byte_422EE2;

//----- (00409C3A) --------------------------------------------------------
int __fastcall sub_409C3A(char a1)
{
  int result; // eax

  while ( 1 )
  {
    LOWORD(result) = a1 ? getwc(Stream) : sub_407F02();
    result = (unsigned __int16)result;
    if ( (_WORD)result == 32 || (_WORD)result == 9 || (_WORD)result == 94 )
      break;
LABEL_14:
    if ( (_WORD)result == 92 )
      result = sub_409D17(0x5Cu, a1);
    if ( (_WORD)result != 32 && (_WORD)result != 9 )
      goto LABEL_20;
  }
  if ( (_WORD)result != 94
    || (!a1 ? (LOWORD(result) = sub_407F02()) : (LOWORD(result) = getwc(Stream)),
        (result = (unsigned __int16)result, (_WORD)result == 32) || (_WORD)result == 9) )
  {
    byte_412021 = 0;
    goto LABEL_14;
  }
  ungetwc(result, Stream);
  result = 94;
LABEL_20:
  if ( (_WORD)result == 59 )
  {
    if ( byte_412021 )
    {
      if ( !byte_422EE1 )
        goto LABEL_23;
LABEL_24:
      sub_40980F(a1);
      result = 10;
      byte_412021 = 1;
    }
  }
  else
  {
LABEL_23:
    if ( (_WORD)result == 35 )
      goto LABEL_24;
  }
  return result;
}
// 412021: using guessed type char byte_412021;
// 422EE1: using guessed type char byte_422EE1;

//----- (00409D17) --------------------------------------------------------
wint_t __fastcall sub_409D17(wint_t a1, char a2)
{
  wint_t v3; // ax
  wint_t v4; // ax
  wint_t v5; // ax

  if ( a1 != 92 )
    return a1;
  while ( 1 )
  {
    v3 = a2 ? getwc(Stream) : sub_407F02();
    if ( v3 != 10 )
      break;
    ++dword_4226A4;
    byte_412021 = 1;
    if ( a2 )
      v4 = getwc(Stream);
    else
      v4 = sub_407F02();
    a1 = v4;
    if ( v4 == 59 && byte_422EE1 || v4 == 35 )
    {
      sub_40980F(a2);
      ++dword_4226A4;
      if ( a2 )
        v5 = getwc(Stream);
      else
        v5 = sub_407F02();
      a1 = v5;
    }
    if ( a1 != 92 )
      return a1;
  }
  ungetwc(v3, Stream);
  return 92;
}
// 412021: using guessed type char byte_412021;
// 4226A4: using guessed type int dword_4226A4;
// 422EE1: using guessed type char byte_422EE1;

//----- (00409DC8) --------------------------------------------------------
wchar_t *__fastcall sub_409DC8(char a1, int a2, int a3)
{
  char v3; // bl
  wchar_t *v4; // esi
  unsigned int v5; // edi
  unsigned __int8 v6; // bh
  wint_t v7; // ax
  char v8; // al
  wchar_t *v9; // eax
  unsigned int v10; // esi
  wchar_t *v11; // eax
  unsigned int v12; // ecx
  unsigned __int8 v13; // dl
  wint_t v14; // ax
  int v15; // ecx
  int v16; // eax
  wint_t v17; // ax
  unsigned __int8 v18; // bl
  wint_t v19; // ax
  wchar_t *v20; // eax
  wchar_t *v21; // eax
  char *v22; // ebx
  wchar_t *v23; // ecx
  wchar_t *result; // eax
  __int16 v25; // [esp+Ch] [ebp-18h]
  wchar_t *v26; // [esp+10h] [ebp-14h]
  wchar_t *Source; // [esp+14h] [ebp-10h] BYREF
  unsigned int v28; // [esp+18h] [ebp-Ch]
  wchar_t *v29; // [esp+1Ch] [ebp-8h]
  bool v30; // [esp+22h] [ebp-2h]
  char v31; // [esp+23h] [ebp-1h]

  v26 = 0;
  v3 = a1;
  v28 = 0;
  v4 = &Src;
  v31 = a1;
  v30 = 0;
  Source = &Src;
  LOWORD(v5) = sub_407F02();
  if ( v3 != 24 )
  {
    if ( (_WORD)v5 != 32 && (_WORD)v5 != 9 )
    {
      if ( (_WORD)v5 != 94 )
      {
LABEL_9:
        v6 = 1;
        goto LABEL_11;
      }
      v7 = sub_407F02();
      if ( v7 != 32 && v7 != 9 )
      {
        ungetwc(v7, Stream);
        LOWORD(v5) = 94;
        goto LABEL_9;
      }
    }
    v6 = 2;
    LOWORD(v5) = sub_409C3A(0);
    goto LABEL_11;
  }
  v6 = 2;
LABEL_11:
  v29 = (wchar_t *)a3;
  while ( 1 )
  {
    if ( (_WORD)v5 == 34 )
    {
      v8 = !v30;
      v30 = !v30;
    }
    else
    {
      v8 = v30;
    }
    if ( (_WORD)v5 == 94 )
    {
      if ( v8 || v3 != 25 )
      {
        v14 = sub_407F02();
        ungetwc(v14, Stream);
        LOWORD(v5) = 94;
      }
      else
      {
        v5 = (unsigned __int16)sub_407F02();
        v25 = v5;
        if ( (unsigned __int16)v5 > 0x2Du )
        {
          switch ( (unsigned __int16)v5 )
          {
            case '@':
              goto LABEL_33;
            case '\\':
              goto LABEL_41;
            case '^':
            case '{':
            case '}':
              goto LABEL_33;
          }
        }
        else
        {
          switch ( (unsigned __int16)v5 )
          {
            case 0x2Du:
              goto LABEL_33;
            case 0xAu:
              goto LABEL_41;
            case 0x21u:
              goto LABEL_33;
          }
          if ( v5 > 0x21 )
          {
            if ( (unsigned __int16)v5 <= 0x23u )
              goto LABEL_41;
            if ( (unsigned __int16)v5 == 36 || (unsigned __int16)v5 > 0x27u && (unsigned __int16)v5 <= 0x29u )
            {
LABEL_33:
              *v4++ = 94;
              if ( v4 == v29 )
              {
                if ( dword_4226AC )
                {
                  v10 = v28;
                  v5 = v28 + 1024;
                  if ( v28 + 1024 < v28 || (v11 = (wchar_t *)sub_40AC26(dword_4226AC, 2 * v5), (v26 = v11) == 0) )
                  {
                    sub_4053D9(dword_4226A4, 0x419u);
                    v11 = v26;
                  }
                  v12 = v5;
                  dword_4226AC = v11;
                  LOWORD(v5) = v25;
                  v4 = &v11[v10];
                  v28 = v12;
                  v9 = &v11[v12];
                }
                else
                {
                  dword_4226AC = (wchar_t *)sub_40ABE3(0x1000u);
                  wcsncpy_s(dword_4226AC, 0x800u, Source, 0x400u);
                  v28 = 2048;
                  v4 = dword_4226AC + 1024;
                  v9 = dword_4226AC + 2048;
                }
                v29 = v9;
                a3 = (int)v9;
                Source = dword_4226AC;
              }
LABEL_41:
              v13 = 0;
              goto LABEL_75;
            }
          }
        }
      }
    }
    if ( (unsigned __int16)v5 > 0x3Bu )
    {
      if ( (unsigned __int16)v5 > 0x44u )
      {
        if ( (unsigned __int16)v5 != 70 && (unsigned __int16)v5 != 82 )
        {
          if ( (unsigned __int16)v5 == 92 )
          {
            v13 = 3;
            goto LABEL_75;
          }
          if ( (unsigned __int16)v5 == 0xFFFF )
          {
LABEL_99:
            v13 = 6;
            goto LABEL_75;
          }
          goto LABEL_98;
        }
      }
      else if ( (unsigned __int16)v5 != 68 )
      {
        if ( (unsigned __int16)v5 == 60 )
          goto LABEL_88;
        if ( (unsigned __int16)v5 == 61 )
        {
          v13 = 2;
          goto LABEL_75;
        }
        if ( (unsigned __int16)v5 <= 0x3Eu )
          goto LABEL_98;
        if ( (unsigned __int16)v5 <= 0x40u )
        {
LABEL_88:
          v18 = 12;
          v13 = 12;
          if ( v31 == 24 && (_WORD)v5 == 60 )
          {
            v19 = sub_407F02();
            if ( v19 == 60 )
            {
              v4 = sub_408C25(v4, &Source, (wchar_t **)&a3);
              v18 = 6;
              --dword_4226A4;
              LOWORD(v5) = 10;
              v29 = (wchar_t *)a3;
            }
            else
            {
              ungetwc(v19, Stream);
            }
            v15 = 14 * v6;
            v16 = v18;
            goto LABEL_76;
          }
LABEL_75:
          v15 = 14 * v6;
          v16 = v13;
LABEL_76:
          v6 = byte_4013A0[v15 + v16];
          goto LABEL_77;
        }
        if ( (unsigned __int16)v5 != 66 )
          goto LABEL_98;
      }
      v13 = 13;
      goto LABEL_75;
    }
    if ( (unsigned __int16)v5 == 59 )
    {
      if ( !v6 && byte_422EE1 )
      {
LABEL_66:
        v30 = 0;
        sub_40980F(0);
        ++dword_4226A4;
        goto LABEL_109;
      }
      goto LABEL_41;
    }
    if ( (unsigned __int16)v5 > 0x24u )
    {
      switch ( (unsigned __int16)v5 )
      {
        case '(':
          v13 = 8;
          goto LABEL_75;
        case ')':
          v13 = 9;
          goto LABEL_75;
        case '*':
          v13 = 11;
          goto LABEL_75;
        case ':':
          v13 = 4;
          goto LABEL_75;
      }
LABEL_98:
      v13 = sub_4038CF(v5) ? 0xA : 0;
      goto LABEL_75;
    }
    switch ( (unsigned __int16)v5 )
    {
      case 0x24u:
        v13 = 7;
        goto LABEL_75;
      case 9u:
        goto LABEL_54;
      case 0xAu:
        goto LABEL_99;
      case 0x20u:
LABEL_54:
        v13 = 5;
        goto LABEL_75;
    }
    if ( (unsigned __int16)v5 != 35 )
      goto LABEL_98;
    if ( !v6 )
      goto LABEL_66;
    if ( v3 == 25 )
      goto LABEL_111;
    v6 = byte_4013A1[14 * v6];
LABEL_77:
    if ( v6 == 64 )
      goto LABEL_111;
    if ( (v6 & 0x20) != 0 )
      sub_4053D9(dword_4226A4, (v6 & 0xDF) + 1000, (unsigned __int16)v5);
    if ( !v6 )
    {
      ++dword_4226A4;
      *(v4 - 1) = 32;
      byte_412021 = 1;
      v17 = sub_407F02();
      byte_412021 = 0;
      if ( v17 == 32 || v17 == 9 )
      {
        v6 = 2;
        do
        {
          do
            v17 = sub_407F02();
          while ( v17 == 32 );
        }
        while ( v17 == 9 );
      }
      ungetwc(v17, Stream);
      goto LABEL_108;
    }
    *v4++ = v5;
    if ( v4 == v29 )
      break;
LABEL_108:
    v3 = v31;
LABEL_109:
    LOWORD(v5) = sub_407F02();
  }
  if ( !dword_4226AC )
  {
    dword_4226AC = (wchar_t *)sub_40ABE3(0x1000u);
    wcsncpy_s(dword_4226AC, 0x800u, Source, 0x400u);
    v28 = 2048;
    v4 = dword_4226AC + 1024;
    v20 = dword_4226AC + 2048;
LABEL_107:
    a3 = (int)v20;
    v29 = v20;
    goto LABEL_108;
  }
  v4 = (wchar_t *)v28;
  v5 = v28 + 1024;
  if ( v28 + 1024 >= v28 )
  {
    v21 = (wchar_t *)sub_40AC26(dword_4226AC, 2 * v5);
    v26 = v21;
    if ( v21 )
    {
      dword_4226AC = v21;
      v28 = v5;
      v4 = &v21[(_DWORD)v4];
      v20 = &v21[v5];
      goto LABEL_107;
    }
  }
  sub_4053D9(dword_4226A4, 0x419u);
LABEL_111:
  ungetwc(v5, Stream);
  v22 = (char *)Source;
  while ( v4 > (wchar_t *)v22 && iswspace(*(v4 - 1)) )
    --v4;
  v23 = dword_4226AC;
  *v4 = 0;
  if ( !v23 )
  {
    result = (wchar_t *)sub_40E919(v22);
    goto LABEL_119;
  }
  result = (wchar_t *)sub_40AC26(v23, 2 * (v4 - v23) + 2);
  if ( result )
LABEL_119:
    dword_4226AC = result;
  return result;
}
// 412021: using guessed type char byte_412021;
// 4226A4: using guessed type int dword_4226A4;
// 422EE1: using guessed type char byte_422EE1;

//----- (0040A326) --------------------------------------------------------
const unsigned __int16 *__fastcall sub_40A326(const unsigned __int16 *a1, unsigned int a2)
{
  char v2; // bl
  wchar_t *v3; // edi
  unsigned __int8 v4; // bh
  wint_t v5; // si
  wint_t v6; // ax
  unsigned __int8 v7; // dl
  int v8; // eax
  int v9; // eax
  char v10; // bl
  bool v11; // al
  unsigned __int16 *v15; // [esp+18h] [ebp-8h]
  char v16; // [esp+1Eh] [ebp-2h]
  char v17; // [esp+1Fh] [ebp-1h]

  v2 = 0;
  v3 = (wchar_t *)(a1 + 1);
  v17 = 0;
  v16 = 0;
  v15 = (unsigned __int16 *)(a1 + 1);
  switch ( *a1 )
  {
    case '"':
      v16 = 1;
      v4 = 16;
      break;
    case '$':
      v4 = 2;
      break;
    case '{':
      v4 = 8;
      break;
    default:
      v4 = 0;
      break;
  }
  while ( 1 )
  {
    v5 = sub_407F02();
    if ( v5 == 94 )
    {
      v6 = sub_407F02();
      v5 = v6;
      if ( v6 > 0x5Cu )
      {
        v8 = v6 - 94;
        if ( !v8 || (v9 = v8 - 29) == 0 || v9 == 2 )
        {
LABEL_29:
          *v3++ = 94;
          v15 = v3;
LABEL_30:
          v7 = 0;
          goto LABEL_59;
        }
      }
      else
      {
        if ( v6 == 92 || v6 == 10 || v6 == 35 )
          goto LABEL_30;
        if ( v6 == 36 || v6 > 0x27u && v6 <= 0x29u )
          goto LABEL_29;
      }
    }
    if ( v5 > 0x29u )
    {
      switch ( v5 )
      {
        case 0x3Au:
          v7 = 4;
          goto LABEL_59;
        case 0x3Bu:
          v7 = 3;
          goto LABEL_59;
        case 0x3Du:
          v7 = 2;
          goto LABEL_59;
        case 0x5Cu:
          v7 = 13;
          goto LABEL_59;
        case 0x7Bu:
          v7 = 11;
          goto LABEL_59;
        case 0x7Du:
          v7 = 12;
          goto LABEL_59;
        case 0xFFFFu:
LABEL_52:
          v7 = 6;
          goto LABEL_59;
      }
LABEL_44:
      v10 = byte_4226B4;
      v11 = sub_4038CF(v5);
      if ( (v10 & 0x80) != 0 )
      {
        if ( v11 || v5 == 42 || v5 == 64 )
          v7 = 10;
        else
          v7 = 0;
      }
      else
      {
        v7 = !v11 ? 0 : 0xA;
      }
      v2 = v17;
      goto LABEL_59;
    }
    switch ( v5 )
    {
      case 0x29u:
        v7 = 9;
        goto LABEL_59;
      case 9u:
        goto LABEL_35;
      case 0xAu:
        goto LABEL_52;
      case 0x20u:
LABEL_35:
        v7 = v16 != 0 ? 0 : 5;
        goto LABEL_59;
    }
    if ( v5 != 34 )
    {
      switch ( v5 )
      {
        case '#':
          v7 = 1;
          goto LABEL_59;
        case '$':
          v7 = 7;
          goto LABEL_59;
        case '(':
          v7 = 8;
          goto LABEL_59;
      }
      goto LABEL_44;
    }
    v7 = 14;
    if ( v4 == 18 )
      v16 = 1;
LABEL_59:
    v4 = byte_401280[15 * v4 + v7];
    if ( v16 && v4 == 1 )
      v4 = 16;
    if ( v2 )
    {
      if ( v7 == 6 )
      {
        ++dword_4226A4;
        byte_412021 = 1;
        v5 = sub_407F02();
        byte_412021 = 0;
        if ( v5 == 32 || v5 == 9 )
        {
          v4 = 64;
          do
          {
            do
              v5 = sub_407F02();
            while ( v5 == 32 );
          }
          while ( v5 == 9 );
          v3 = v15;
        }
        else
        {
          v4 = v3 != &word_4226C2;
        }
      }
      else
      {
        *v3++ = 92;
        v15 = v3;
      }
    }
    v2 = 0;
    v17 = 0;
    if ( (unsigned int)v3 >= a2 )
      sub_4053D9(dword_4226A4, 0x434u);
    if ( v4 == 64 )
      break;
    if ( (v4 & 0x20) != 0 )
      sub_4053D9(dword_4226A4, (v4 & 0xDF) + 1000, v5);
    if ( v4 == 15 )
    {
      v2 = 1;
      v17 = 1;
    }
    else
    {
      *v3++ = v5;
      v15 = v3;
    }
  }
  ungetwc(v5, Stream);
  *v3 = 0;
  return sub_40CAEB(a1);
}
// 412021: using guessed type char byte_412021;
// 4226A4: using guessed type int dword_4226A4;
// 4226B4: using guessed type char byte_4226B4;

//----- (0040A5D2) --------------------------------------------------------
unsigned __int8 __thiscall sub_40A5D2(wchar_t *String)
{
  unsigned __int16 *v1; // edi
  __int16 v2; // bx
  wchar_t *v3; // eax
  unsigned __int16 *v4; // esi
  __int16 *i; // ebx
  __int16 v6; // ax
  wchar_t *v7; // ebx
  unsigned __int16 *v8; // eax
  __int16 v9; // cx
  int v10; // eax
  wchar_t *v11; // edi
  wchar_t *v12; // esi
  int v13; // eax
  char *v14; // ecx
  wchar_t *v15; // edi
  wchar_t *v16; // ebx
  int v17; // edx
  int v18; // eax
  wchar_t **v19; // ecx
  wchar_t *v20; // ecx
  wchar_t *v21; // eax
  wchar_t *v22; // ecx
  wchar_t *v23; // edx
  int v25; // ecx
  wchar_t *v26; // edx
  int v27; // ecx
  rsize_t v29; // esi
  wchar_t *v30; // esi
  int v31; // edx
  int v32; // esi
  const wchar_t **v33; // ebx
  int v34; // ecx
  bool v35; // zf
  wint_t v36; // ax
  rsize_t v38; // [esp-8h] [ebp-288h]
  wchar_t *v39; // [esp-4h] [ebp-284h]
  wchar_t **v40; // [esp+14h] [ebp-26Ch]
  int v41; // [esp+18h] [ebp-268h] BYREF
  wchar_t *Destination; // [esp+1Ch] [ebp-264h]
  int v43; // [esp+20h] [ebp-260h]
  wchar_t *Source; // [esp+24h] [ebp-25Ch]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+28h] [ebp-258h] BYREF

  v1 = String;
  v2 = 0;
  if ( !*String || *String == 35 )
  {
    sub_4053D9(dword_4226A4, 0x407u);
    return (unsigned __int8)sub_40AA77(v39);
  }
  else
  {
    v3 = wcspbrk(String, L"\t#");
    v4 = v3;
    v43 = 32;
    Source = (wchar_t *)9;
    if ( v3 )
    {
      if ( *v3 == 35 )
        v2 = 35;
      *v3 = 0;
      if ( !v2 )
      {
        for ( i = (__int16 *)(v3 + 1); ; ++i )
        {
          v6 = *i;
          if ( !*i || v6 == 35 )
            break;
          if ( v6 != (_WORD)v43 && v6 != (_WORD)Source )
            sub_4053D9(dword_4226A4, 0x409u, i);
        }
      }
      v7 = 0;
    }
    else
    {
      v7 = 0;
      v4 = &v1[wcslen(v1)];
    }
    if ( v4 > v1 )
    {
      do
      {
        v8 = v4 - 1;
        v9 = *(v4 - 1);
        if ( v9 != (_WORD)v43 && v9 != (_WORD)Source )
          break;
        --v4;
      }
      while ( v8 > v1 );
    }
    *v4 = 0;
    v10 = *v1;
    if ( v10 == 60 && *(v4 - 1) == 62 )
    {
      v11 = v1 + 1;
      *(v4 - 1) = 0;
      v12 = sub_40F2A9(v11);
      if ( v12 == v11 )
        v12 = (wchar_t *)sub_40E919((char *)v11);
      v13 = sub_40AB4F(L"INCLUDE");
      if ( v13 )
        v14 = *(char **)(*(_DWORD *)(v13 + 8) + 4);
      else
        v14 = 0;
      if ( v14 )
      {
        v15 = (wchar_t *)sub_40E919(v14);
        v7 = sub_40F2A9(v15);
        if ( v7 != v15 )
          free(v15);
      }
      v1 = (unsigned __int16 *)sub_407BE4(v7, v12, &FindFileData, (HANDLE *)&v41);
      if ( !v1 )
        sub_4053D9(dword_4226A4, 0x41Cu, v12);
      if ( v7 )
        free(v7);
      free(v12);
    }
    else
    {
      if ( (_WORD)v10 == 34 && *(v4 - 1) == 34 )
      {
        ++v1;
        *(v4 - 1) = 0;
      }
      v16 = sub_40F2A9(v1);
      if ( v16 == v1 )
        v16 = (wchar_t *)sub_40E919((char *)v1);
      if ( !sub_407A35(v16, &FindFileData, (HANDLE *)&v41) )
      {
        if ( wcspbrk(v16, L"\\/:") )
        {
          sub_4053D9(dword_4226A4, 0x41Cu, v16);
        }
        else
        {
          v17 = dword_433324;
          v18 = dword_433324;
          v43 = dword_433324;
          if ( dword_433324 >= 0 )
          {
            v19 = (wchar_t **)&dword_433334[3 * dword_433324];
            v40 = v19;
            while ( 1 )
            {
              if ( v18 == v17 )
                v20 = (wchar_t *)dword_422EE4;
              else
                v20 = *v19;
              v21 = sub_40AA77(v20);
              Source = v21;
              if ( v21 )
              {
                v22 = v21;
                v23 = v21 + 1;
                while ( *v22++ )
                  ;
                v25 = (char *)v22 - (char *)v23;
                v26 = v16;
                v27 = v25 >> 1;
                while ( *v26++ )
                  ;
                v29 = v26 - (v16 + 1) + v27 + 2;
                Destination = (wchar_t *)sub_40ABE3((unsigned __int64)v29 >> 31 != 0 ? -1 : 2 * v29);
                wcscpy_s(Destination, v29, Source);
                wcscat_s(Destination, v29, L"\\");
                v38 = v29;
                v30 = Destination;
                wcscat_s(Destination, v38, v16);
                if ( sub_407A35(v30, &FindFileData, (HANDLE *)&v41) )
                {
                  v1 = v30;
                  free(Source);
                  break;
                }
                free(Source);
                free(v30);
              }
              v18 = v43 - 1;
              v19 = v40 - 3;
              v43 = v18;
              v40 -= 3;
              if ( v18 < 0 )
                break;
              v17 = dword_433324;
            }
          }
          free(v16);
          if ( v43 < 0 )
            sub_4053D9(dword_4226A4, 0x41Cu, v1);
        }
      }
    }
    v31 = dword_433324;
    v32 = 0;
    if ( dword_433324 > 0 )
    {
      v33 = (const wchar_t **)dword_433334;
      do
      {
        if ( !wcsicmp(v1, *v33) )
          sub_4053D9(dword_4226A4, 0x430u, v1);
        v31 = dword_433324;
        ++v32;
        v33 += 3;
      }
      while ( v32 < dword_433324 );
    }
    v34 = 3 * v31;
    v35 = byte_422EE3 == 0;
    dword_433324 = v31 + 1;
    dword_4226B0 = 0;
    dword_433338[v34] = (int)Stream;
    dword_433330[v34] = dword_4226A4;
    dword_433334[v34] = (int)dword_422EE4;
    if ( !v35 )
      sub_40CE7E((wchar_t *)L"Included: %s\n", v1);
    Stream = sub_410655(v1, (wchar_t *)L"rt,ccs=unicode");
    if ( !Stream )
      sub_4053D9(dword_4226A4, 0x41Cu, v1);
    dword_422EE4 = sub_40E919((char *)v1);
    dword_4226A4 = 1;
    byte_412021 = 1;
    v36 = sub_407F02();
    if ( v36 == 32 || v36 == 9 )
    {
      byte_412021 = 0;
      return 18;
    }
    else
    {
      byte_412021 = 1;
      ungetwc(v36, Stream);
      --dword_4226A4;
      return 17;
    }
  }
}
// 40AA76: variable 'v39' is possibly undefined
// 412021: using guessed type char byte_412021;
// 4226A4: using guessed type int dword_4226A4;
// 4226B0: using guessed type int dword_4226B0;
// 422EE3: using guessed type char byte_422EE3;
// 433324: using guessed type int dword_433324;
// 433330: using guessed type int dword_433330[];
// 433334: using guessed type int dword_433334[];
// 433338: using guessed type int dword_433338[];

//----- (0040AA77) --------------------------------------------------------
wchar_t *__thiscall sub_40AA77(wchar_t *FullPath)
{
  size_t v1; // esi
  wchar_t *v2; // edi
  unsigned int v3; // ecx
  wchar_t v4; // ax
  wchar_t Dir[258]; // [esp+10h] [ebp-210h] BYREF
  wchar_t Drive[4]; // [esp+214h] [ebp-Ch] BYREF

  wsplitpath_s(FullPath, Drive, 3u, Dir, 0x100u, 0, 0, 0, 0);
  v1 = wcslen(Dir) + wcslen(Drive) + 1;
  v2 = (wchar_t *)sub_40ABE3((unsigned __int64)v1 >> 31 != 0 ? -1 : 2 * v1);
  wmakepath_s(v2, v1, Drive, Dir, 0, 0);
  v3 = wcslen(v2);
  v4 = v2[v3 - 1];
  if ( v4 == 92 || v4 == 47 )
    v2[v3 - 1] = 0;
  return v2;
}

//----- (0040AB4F) --------------------------------------------------------
int __thiscall sub_40AB4F(const unsigned __int16 *this)
{
  const unsigned __int16 *v2; // edx
  unsigned __int16 v3; // ax
  unsigned __int8 v4; // cl
  unsigned __int16 v5; // di
  int *v6; // eax
  int v7; // ecx
  int v8; // eax

  v2 = this;
  v3 = *this;
  if ( *this )
  {
    v4 = 0;
    LOBYTE(v5) = v3;
    do
    {
      ++v2;
      v4 += v5;
      v5 = *v2;
    }
    while ( *v2 );
    v6 = &dword_432F10[v4];
    v7 = *v6;
    dword_436624 = (int)v6;
    while ( v7 )
    {
      v8 = wcscmp(*(const unsigned __int16 **)(v7 + 4), this);
      if ( v8 )
        v8 = v8 < 0 ? -1 : 1;
      if ( !v8 )
        return (*(_BYTE *)(v7 + 12) & 0x10) == 0 ? v7 : 0;
      v7 = *(_DWORD *)v7;
    }
  }
  else
  {
    dword_436624 = (int)dword_432F10;
  }
  return 0;
}
// 432F10: using guessed type int dword_432F10[255];
// 436624: using guessed type int dword_436624;

//----- (0040ABE3) --------------------------------------------------------
void *__thiscall sub_40ABE3(size_t Size)
{
  void *v1; // esi

  v1 = malloc(Size);
  if ( !v1 )
    sub_4053D9(dword_4226B0, 0x41Bu);
  return v1;
}
// 4226B0: using guessed type int dword_4226B0;

//----- (0040AC08) --------------------------------------------------------
void *__thiscall sub_40AC08(size_t Size)
{
  void *v2; // edi

  v2 = sub_40ABE3(Size);
  memset(v2, 0, Size);
  return v2;
}

//----- (0040AC26) --------------------------------------------------------
void *__fastcall sub_40AC26(void *Block, size_t Size)
{
  void *v2; // esi

  if ( !Block )
    return sub_40ABE3(Size);
  v2 = realloc(Block, Size);
  if ( !v2 )
    sub_4053D9(dword_4226B0, 0x41Bu);
  return v2;
}
// 4226B0: using guessed type int dword_4226B0;

//----- (0040AC5C) --------------------------------------------------------
int __fastcall sub_40AC5C(wchar_t *Source, wchar_t *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // esi
  DWORD EnvironmentVariableW; // eax
  HMODULE ModuleHandleW; // eax
  BOOL (__stdcall *SetThreadPreferredUILanguages)(DWORD, PCZZWSTR, PULONG); // esi
  HMODULE v12; // eax
  BOOL (__stdcall *GetThreadPreferredUILanguages)(DWORD, PULONG, PZZWSTR, PULONG); // esi
  HANDLE ProcessHeap; // eax
  WCHAR *v15; // eax
  wchar_t **v16; // edi
  int result; // eax
  wchar_t **v18; // esi
  int v19; // ebx
  HANDLE v20; // eax
  LANGID UserDefaultUILanguage; // ax
  int v22; // ebx
  HANDLE FirstFileW; // edi
  unsigned int v24; // kr04_4
  int v25; // eax
  int v26; // eax
  HMODULE Library; // ecx
  SIZE_T v28; // [esp-4h] [ebp-6E4h]
  int v29; // [esp+10h] [ebp-6D0h] BYREF
  char ArgList[4]; // [esp+14h] [ebp-6CCh] BYREF
  int v31; // [esp+18h] [ebp-6C8h] BYREF
  wchar_t *v32; // [esp+1Ch] [ebp-6C4h] BYREF
  int v33; // [esp+20h] [ebp-6C0h] BYREF
  wchar_t *Sourcea; // [esp+24h] [ebp-6BCh] BYREF
  DWORD dwFlags; // [esp+28h] [ebp-6B8h] BYREF
  HMODULE *v36; // [esp+2Ch] [ebp-6B4h] BYREF
  __int16 *v37; // [esp+30h] [ebp-6B0h] BYREF
  rsize_t SizeInWords; // [esp+34h] [ebp-6ACh] BYREF
  char v39[4]; // [esp+38h] [ebp-6A8h] BYREF
  int v40[7]; // [esp+3Ch] [ebp-6A4h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+58h] [ebp-688h] BYREF
  __int16 v42[4]; // [esp+2A8h] [ebp-438h]
  wchar_t *Buffer[3]; // [esp+2B0h] [ebp-430h] BYREF
  wchar_t String[6]; // [esp+2BCh] [ebp-424h] BYREF
  wchar_t FileName[260]; // [esp+2C8h] [ebp-418h] BYREF
  wchar_t Destination[262]; // [esp+4D0h] [ebp-210h] BYREF

  v8 = 0;
  Sourcea = a2;
  v37 = &word_4372DC;
  SizeInWords = 0;
  v32 = 0;
  v36 = &hModule;
  dwFlags = 96;
  if ( !Source || !*Source || !a2 || !*a2 )
    return -2147024809;
  hModule = 0;
  if ( wcsncpy_s(Destination, 0x104u, Source, 0xFFFFFFFF)
    || FileName[wcslen(Destination) + 259] != 92 && wcsncat_s(Destination, 0x104u, L"\\", 0xFFFFFFFF) )
  {
    return -2147467259;
  }
  v29 = -2147024894;
  v40[0] = (int)Destination;
  v40[1] = (int)&Sourcea;
  v40[2] = (int)&dwFlags;
  v40[3] = (int)&v36;
  v40[4] = (int)&v37;
  v40[5] = (int)&v32;
  v40[6] = (int)&SizeInWords;
  memset(Buffer, 0, sizeof(Buffer));
  EnvironmentVariableW = GetEnvironmentVariableW(L"VSLANG", (LPWSTR)Buffer, 6u);
  if ( EnvironmentVariableW )
  {
    if ( EnvironmentVariableW < 6 )
    {
      sub_40B245((int)v40, Buffer, 10, (wchar_t ***)&v29);
      if ( !v29 )
        return 0;
    }
  }
  if ( Ptr )
  {
    SetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PCZZWSTR, PULONG))DecodePointer(Ptr);
  }
  else
  {
    ModuleHandleW = GetModuleHandleW(L"kernel32.dll");
    if ( !ModuleHandleW )
    {
LABEL_35:
      UserDefaultUILanguage = GetUserDefaultUILanguage();
      if ( (UserDefaultUILanguage & 0x3FF) == 1 || (UserDefaultUILanguage & 0x3FF) == 13 )
        UserDefaultUILanguage = 1033;
      v42[0] = UserDefaultUILanguage;
      v42[2] = 1033;
      v42[1] = UserDefaultUILanguage & 0x3FF | 0x400;
      while ( 1 )
      {
        itow_s((unsigned __int16)v42[v8], String, 6u, 10);
        sub_40B245((int)v40, (wchar_t **)String, 10, (wchar_t ***)&v29);
        if ( !v29 )
          return 0;
        if ( (unsigned int)++v8 >= 3 )
          goto LABEL_41;
      }
    }
    SetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PCZZWSTR, PULONG))GetProcAddress(
                                                                                   ModuleHandleW,
                                                                                   "SetThreadPreferredUILanguages");
    Ptr = EncodePointer(SetThreadPreferredUILanguages);
  }
  if ( !SetThreadPreferredUILanguages )
  {
    v8 = 0;
    goto LABEL_35;
  }
  if ( !GetEnvironmentVariableW(L"VS_UNICODE_OUTPUT", 0, 0) && !SetThreadPreferredUILanguages(256, 0, 0) )
    return -2147467259;
  v31 = 0;
  v33 = 0;
  if ( dword_436660 )
  {
    GetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PULONG, PZZWSTR, PULONG))DecodePointer(dword_436660);
  }
  else
  {
    v12 = GetModuleHandleW(L"kernel32.dll");
    if ( !v12 )
      goto LABEL_41;
    GetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PULONG, PZZWSTR, PULONG))GetProcAddress(
                                                                                          v12,
                                                                                          "GetThreadPreferredUILanguages");
    dword_436660 = EncodePointer(GetThreadPreferredUILanguages);
  }
  if ( GetThreadPreferredUILanguages )
  {
    if ( GetThreadPreferredUILanguages(52, (PULONG)&v33, 0, (PULONG)&v31) )
    {
      v28 = 2 * v31;
      ProcessHeap = GetProcessHeap();
      v15 = (WCHAR *)HeapAlloc(ProcessHeap, 0, v28);
      v16 = (wchar_t **)v15;
      if ( !v15 )
        return -2147024882;
      if ( GetThreadPreferredUILanguages(52, (PULONG)&v33, v15, (PULONG)&v31) )
      {
        v18 = v16;
        if ( *(_WORD *)v16 )
        {
          do
          {
            sub_40B245((int)v40, v18, 16, (wchar_t ***)&v29);
            v19 = v29;
            if ( !v29 )
              break;
            v18 = (wchar_t **)((char *)v18 + 10);
          }
          while ( *(_WORD *)v18 );
        }
        else
        {
          v19 = v29;
        }
        v20 = GetProcessHeap();
        HeapFree(v20, 0, v16);
        if ( !v19 )
          return 0;
        goto LABEL_41;
      }
    }
    return -2147467259;
  }
LABEL_41:
  sub_40B245((int)v40, (wchar_t **)L"1033", 10, (wchar_t ***)&v29);
  v22 = v29;
  if ( !v29 )
    return 0;
  if ( wcsncpy_s(FileName, 0x104u, Destination, 0xFFFFFFFF) || wcsncat_s(FileName, 0x104u, L"*", 0xFFFFFFFF) )
    return -2147024893;
  FirstFileW = FindFirstFileW(FileName, &FindFileData);
  if ( FirstFileW == (HANDLE)-1 )
  {
    result = GetLastError();
    if ( result > 0 )
      return (unsigned __int16)result | 0x80070000;
  }
  else
  {
    v24 = wcslen(Destination);
    while ( FindNextFileW(FirstFileW, &FindFileData) )
    {
      if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
      {
        v25 = wcscmp(FindFileData.cFileName, L".");
        if ( v25 )
          v25 = v25 < 0 ? -1 : 1;
        if ( v25 )
        {
          v26 = wcscmp(FindFileData.cFileName, L"..");
          if ( v26 )
            v26 = v26 < 0 ? -1 : 1;
          if ( v26 && sub_40CD16(FindFileData.cFileName, (wchar_t *)L"%hu%c", ArgList, v39, 1) != -1 )
          {
            if ( 2 * v24 >= 0x208 )
              __report_rangecheckfailure();
            FileName[v24] = 0;
            if ( !wcsncat_s(FileName, 0x104u, FindFileData.cFileName, 0xFFFFFFFF)
              && !wcsncat_s(FileName, 0x104u, L"\\", 0xFFFFFFFF)
              && !wcsncat_s(FileName, 0x104u, Sourcea, 0xFFFFFFFF) )
            {
              Library = LoadLibraryExW(FileName, 0, dwFlags);
              if ( Library )
              {
                *v36 = Library;
                if ( v37 )
                  *v37 = *(_WORD *)ArgList;
                if ( v32 )
                  wcscpy_s(v32, SizeInWords, FileName);
                v22 = 0;
                break;
              }
            }
          }
        }
      }
    }
    FindClose(FirstFileW);
    return v22;
  }
  return result;
}
// 401A24: using guessed type wchar_t asc_401A24[3];
// 410AF8: using guessed type void __noreturn __report_rangecheckfailure(void);
// 4372DC: using guessed type __int16 word_4372DC;
// 40AC5C: using guessed type char var_6A8[4];

//----- (0040B245) --------------------------------------------------------
wchar_t **__thiscall sub_40B245(int this, wchar_t **String, int Radix, wchar_t ***a4)
{
  wchar_t **result; // eax
  _WORD *v6; // eax
  __int16 v7; // [esp+Ch] [ebp-220h]
  wchar_t *EndPtr; // [esp+10h] [ebp-21Ch] BYREF
  wchar_t Destination[260]; // [esp+14h] [ebp-218h] BYREF
  wchar_t Buffer[6]; // [esp+21Ch] [ebp-10h] BYREF

  result = String;
  if ( *(_WORD *)String )
  {
    result = (wchar_t **)wcstoul((const wchar_t *)String, &EndPtr, Radix);
    v7 = (__int16)result;
    if ( !*EndPtr )
    {
      itow_s((unsigned __int16)result, Buffer, 6u, 10);
      result = (wchar_t **)wcsncpy_s(Destination, 0x104u, *(const wchar_t **)this, 0xFFFFFFFF);
      if ( !result )
      {
        result = (wchar_t **)wcsncat_s(Destination, 0x104u, Buffer, 0xFFFFFFFF);
        if ( !result )
        {
          result = (wchar_t **)wcsncat_s(Destination, 0x104u, L"\\", 0xFFFFFFFF);
          if ( !result )
          {
            result = (wchar_t **)wcsncat_s(Destination, 0x104u, **(const wchar_t ***)(this + 4), 0xFFFFFFFF);
            if ( !result )
            {
              result = (wchar_t **)LoadLibraryExW(Destination, 0, **(_DWORD **)(this + 8));
              if ( result )
              {
                ***(_DWORD ***)(this + 12) = result;
                v6 = **(_WORD ***)(this + 16);
                if ( v6 )
                  *v6 = v7;
                result = *(wchar_t ***)(this + 20);
                if ( *result )
                  result = (wchar_t **)wcscpy_s(*result, **(_DWORD **)(this + 24), Destination);
                *a4 = 0;
              }
              else if ( *a4 == (wchar_t **)-2147024894 )
              {
                result = (wchar_t **)GetLastError();
                if ( (int)result > 0 )
                  result = (wchar_t **)((unsigned __int16)result | 0x80070000);
                *a4 = result;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (0040B3AE) --------------------------------------------------------
bool sub_40B3AE()
{
  if ( dword_436628 > 0 )
  {
    if ( dword_436628 <= 2 )
      return 0;
    if ( dword_436628 == 3 )
      return !sub_40B3D3();
  }
  return 1;
}
// 436628: using guessed type int dword_436628;

//----- (0040B3D3) --------------------------------------------------------
bool sub_40B3D3()
{
  LSTATUS v1; // esi
  BYTE Data[4]; // [esp+0h] [ebp-10h] BYREF
  DWORD Type; // [esp+4h] [ebp-Ch] BYREF
  DWORD cbData; // [esp+8h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+Ch] [ebp-4h] BYREF

  if ( (unsigned __int8)GetVersion() >= 6u )
    return 1;
  if ( RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Microsoft\\VisualStudio\\9.0\\General", 0, 0x20019u, &phkResult) )
    return 0;
  cbData = 4;
  v1 = RegQueryValueExW(phkResult, L"UserCanAutoSendErrorReport", 0, &Type, Data, &cbData);
  RegCloseKey(phkResult);
  if ( v1 || Type != 4 || cbData != 4 )
    return 0;
  return *(_DWORD *)Data == 1;
}

//----- (0040B452) --------------------------------------------------------
char __thiscall sub_40B452(BYTE *lpDst)
{
  LSTATUS v2; // esi
  DWORD v3; // eax
  DWORD cbData; // [esp+8h] [ebp-Ch] BYREF
  DWORD Type; // [esp+Ch] [ebp-8h] BYREF
  HKEY phkResult; // [esp+10h] [ebp-4h] BYREF

  if ( RegOpenKeyExW(
         HKEY_LOCAL_MACHINE,
         L"Software\\Microsoft\\PCHealth\\ErrorReporting\\DW\\Installed",
         0,
         0x20019u,
         &phkResult) )
  {
    return 0;
  }
  cbData = 520;
  v2 = RegQueryValueExW(phkResult, L"DW0200", 0, &Type, lpDst, &cbData);
  RegCloseKey(phkResult);
  *((_WORD *)lpDst + 259) = 0;
  if ( v2 )
    return 0;
  if ( Type == 2 )
  {
    v3 = ExpandEnvironmentStringsW((LPCWSTR)lpDst, (LPWSTR)lpDst, 0x104u);
    if ( v3 > 0x104 || !v3 )
      return 0;
  }
  else if ( Type != 1 )
  {
    return 0;
  }
  return 1;
}

//----- (0040B4DF) --------------------------------------------------------
char sub_40B4DF()
{
  HANDLE FileMappingW; // eax

  FileMappingW = CreateFileMappingW((HANDLE)0xFFFFFFFF, &MutexAttributes, 4u, 0, 0x9C9Cu, 0);
  ArgList = FileMappingW;
  if ( !FileMappingW )
    return 0;
  lpBaseAddress = MapViewOfFileEx(FileMappingW, 6u, 0, 0, 0, 0);
  if ( !lpBaseAddress )
  {
    CloseHandle(ArgList);
    ArgList = 0;
    return 0;
  }
  return 1;
}

//----- (0040B533) --------------------------------------------------------
int __thiscall sub_40B533(void *this)
{
  HANDLE EventW; // edi
  HANDLE MutexW; // ebx
  HANDLE CurrentProcess; // eax
  void (__stdcall *v4)(HANDLE); // esi
  _DWORD *v5; // esi
  DWORD CurrentThreadId; // eax
  _DWORD *v7; // ecx
  int v8; // eax
  unsigned __int8 Version; // cl
  LPCVOID v10; // edx
  bool v11; // zf
  BOOL v12; // eax
  wchar_t **v13; // eax
  DWORD v14; // eax
  const wchar_t *v16; // [esp-Ch] [ebp-70h]
  char Src[72]; // [esp+8h] [ebp-5Ch] BYREF
  int v18; // [esp+50h] [ebp-14h]
  HANDLE hHandle; // [esp+54h] [ebp-10h]
  HANDLE hMutex; // [esp+58h] [ebp-Ch]
  int v21; // [esp+5Ch] [ebp-8h]
  HANDLE TargetHandle; // [esp+60h] [ebp-4h] BYREF

  v18 = (int)this;
  TargetHandle = 0;
  v21 = 1;
  if ( ::hHandle )
    return 1;
  if ( sub_40B3AE() )
    return 1;
  MutexAttributes.nLength = 12;
  MutexAttributes.lpSecurityDescriptor = 0;
  MutexAttributes.bInheritHandle = 1;
  if ( !lpBaseAddress && !sub_40B4DF() )
    return 1;
  if ( !sub_40B452((BYTE *)Dst) )
    return 1;
  ::hHandle = CreateEventW(&MutexAttributes, 0, 0, 0);
  EventW = CreateEventW(&MutexAttributes, 0, 0, 0);
  hHandle = EventW;
  MutexW = CreateMutexW(&MutexAttributes, 0, 0);
  hMutex = MutexW;
  CurrentProcess = GetCurrentProcess();
  v4 = (void (__stdcall *)(HANDLE))CloseHandle;
  if ( !DuplicateHandle(CurrentProcess, CurrentProcess, CurrentProcess, &TargetHandle, 0x1FFFFFu, 1, 0) || !::hHandle )
    goto LABEL_33;
  if ( EventW )
  {
    if ( MutexW && TargetHandle )
    {
      v5 = lpBaseAddress;
      memset((void *)lpBaseAddress, 0, 0x9C9Cu);
      v5[10] = TargetHandle;
      *((_DWORD *)lpBaseAddress + 2) = GetCurrentProcessId();
      CurrentThreadId = GetCurrentThreadId();
      v7 = lpBaseAddress;
      *((_DWORD *)lpBaseAddress + 3) = CurrentThreadId;
      v7[8] = ::hHandle;
      v8 = v18;
      v7[6] = EventW;
      v7[9] = MutexW;
      *v7 = 40092;
      v7[1] = 0x20000;
      v7[5] = v8;
      v7[4] = *(_DWORD *)(*(_DWORD *)v8 + 12);
      Version = GetVersion();
      switch ( dword_436628 )
      {
        case 1:
          v10 = lpBaseAddress;
          *((_DWORD *)lpBaseAddress + 11) = 0;
          *((_DWORD *)v10 + 12) = 0;
LABEL_18:
          *((_DWORD *)v10 + 13) = 0;
          v11 = byte_4333FB == 0;
          v16 = off_41206C;
          v12 = byte_4333FB == 0;
          *((_DWORD *)v10 + 17) = 1;
          *((_DWORD *)v10 + 15) = 0;
          *((_DWORD *)v10 + 14) = v12 ? 20 : 4;
          *((_DWORD *)v10 + 19) = v11 ? 1 : 17;
          wcsncpy_s((wchar_t *)v10 + 4310, 0x38u, v16, 0xFFFFFFFF);
          v13 = _p__wpgmptr();
          wcsncpy_s((wchar_t *)lpBaseAddress + 300, 0x104u, *v13, 0xFFFFFFFF);
          strcpy(Src, "HKLM\\Software\\Microsoft\\Internet Explorer\\Registration\\DigitalProductID");
          sub_40CC96((char *)lpBaseAddress + 1120, Src, 0x48u);
          wcsncpy_s((wchar_t *)lpBaseAddress + 978, 0x104u, off_412068, 0xFFFFFFFF);
          sub_40CC68(Buffer, 0x104u, (wchar_t *)L"dw20.exe -x -s %u", ArgList);
          memset(&StartupInfo, 0, sizeof(StartupInfo));
          StartupInfo.cb = 68;
          v4 = (void (__stdcall *)(HANDLE))CloseHandle;
          if ( CreateProcessW(
                 Dst,
                 Buffer,
                 0,
                 0,
                 1,
                 0x4000020u,
                 0,
                 0,
                 &StartupInfo,
                 (LPPROCESS_INFORMATION)&ProcessInformation) )
          {
            CloseHandle(ProcessInformation);
            CloseHandle(*(&ProcessInformation + 1));
            MutexW = hMutex;
            EventW = hHandle;
            while ( 1 )
            {
              while ( !WaitForSingleObject(::hHandle, 0x4E20u) )
              {
                if ( !WaitForSingleObject(EventW, 1u) )
                  goto LABEL_30;
              }
              v14 = WaitForSingleObject(MutexW, 0x4E20u);
              if ( v14 == 258 )
                break;
              if ( v14 == 128 )
                goto LABEL_29;
              if ( WaitForSingleObject(::hHandle, 1u) )
              {
                SetEvent(EventW);
LABEL_29:
                ReleaseMutex(MutexW);
                break;
              }
              if ( !WaitForSingleObject(EventW, 1u) )
                goto LABEL_29;
              ReleaseMutex(MutexW);
            }
LABEL_30:
            v21 = (*((_BYTE *)lpBaseAddress + 39556) & 0x10) == 0 ? v21 : 0;
          }
          else
          {
            MutexW = hMutex;
            EventW = hHandle;
          }
          goto LABEL_33;
        case 2:
          v10 = lpBaseAddress;
          *((_DWORD *)lpBaseAddress + 11) = 8;
          goto LABEL_16;
        case 3:
          v10 = lpBaseAddress;
          *((_DWORD *)lpBaseAddress + 11) = 0;
LABEL_16:
          *((_DWORD *)v10 + 12) = Version < 6u;
          goto LABEL_18;
      }
      v4 = (void (__stdcall *)(HANDLE))CloseHandle;
    }
LABEL_33:
    if ( EventW )
      v4(EventW);
  }
  if ( MutexW )
    v4(MutexW);
  if ( TargetHandle )
    v4(TargetHandle);
  if ( ::hHandle )
  {
    v4(::hHandle);
    ::hHandle = 0;
  }
  if ( lpBaseAddress )
  {
    UnmapViewOfFile(lpBaseAddress);
    lpBaseAddress = 0;
  }
  if ( ArgList )
  {
    v4(ArgList);
    ArgList = 0;
  }
  if ( byte_412066 )
    exit(1);
  return v21;
}
// 412066: using guessed type char byte_412066;
// 4333FB: using guessed type char byte_4333FB;
// 436628: using guessed type int dword_436628;
// 436E70: using guessed type WCHAR Dst[260];
// 437078: using guessed type wchar_t Buffer[260];

//----- (0040B905) --------------------------------------------------------
LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  if ( ExceptionInfo->ExceptionRecord->ExceptionCode == -2147483645 || byte_4333FC )
    return 0;
  byte_4333FC = 1;
  off_412068 = L"msvcr140.dll";
  off_41206C = L"Microsoft® Program Maintenance Utility";
  byte_412066 = 0;
  return sub_40B533(ExceptionInfo);
}
// 402558: using guessed type wchar_t aMicrosoftProgr[39];
// 4025A8: using guessed type wchar_t aMsvcr140Dll[13];
// 412066: using guessed type char byte_412066;
// 4333FC: using guessed type char byte_4333FC;

//----- (0040B94D) --------------------------------------------------------
LONG __fastcall sub_40B94D(struct _EXCEPTION_POINTERS *ExceptionInfo, void *a2, void *a3)
{
  if ( !byte_422EE0 )
    sub_405542();
  sub_40CE7E((wchar_t *)L"\nNMAKE : fatal error U1038: Internal error\n");
  sub_40CE60();
  qmemcpy(a2, ExceptionInfo->ExceptionRecord, 0x50u);
  if ( a3 )
    qmemcpy(a3, ExceptionInfo->ContextRecord, 0x2CCu);
  if ( sub_40B3AE() )
    return byte_4333FC == 0;
  else
    return TopLevelExceptionFilter(ExceptionInfo);
}
// 422EE0: using guessed type char byte_422EE0;
// 4333FC: using guessed type char byte_4333FC;

//----- (0040B9B0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl main(int argc, const char **argv, const char **envp)
{
  const char **v3; // edi
  FILE *v4; // eax
  FILE *v5; // eax
  int v6; // esi
  int v7; // ebx
  const char **v8; // edi
  int v9; // eax
  unsigned int i; // eax
  wchar_t *v11; // esi
  wchar_t *v12; // ebx
  rsize_t v14; // ebx
  wchar_t *v15; // edi
  int v16; // esi
  int v18; // [esp-10h] [ebp-588h]
  int v19[179]; // [esp+10h] [ebp-568h] BYREF
  unsigned int v20; // [esp+2F8h] [ebp-280h]
  const char **v21; // [esp+2FCh] [ebp-27Ch]
  int v22; // [esp+300h] [ebp-278h]
  char ArgList[80]; // [esp+304h] [ebp-274h] BYREF
  CPPEH_RECORD ms_exc; // [esp+560h] [ebp-18h]

  v3 = argv;
  v21 = argv;
  SetErrorMode(1u);
  memset(ArgList, 0, sizeof(ArgList));
  memset(v19, 0, sizeof(v19));
  ms_exc.registration.TryLevel = 0;
  setlocale(2, ".ACP");
  v4 = _acrt_iob_func(1u);
  byte_4333FE = sub_40CD40(v4);
  v5 = _acrt_iob_func(2u);
  byte_4333FD = sub_40CD40(v5);
  set_invalid_parameter_handler(_guard_check_icall_nop);
  MutexAttributes.nLength = 12;
  MutexAttributes.lpSecurityDescriptor = 0;
  MutexAttributes.bInheritHandle = 1;
  sub_40B4DF();
  dword_436628 = 2;
  v6 = 1;
  v7 = argc;
  while ( 1 )
  {
    v22 = v6;
    if ( v6 >= v7 )
    {
      if ( dword_436628 == 3 && !sub_40B3D3() )
        sub_4053D9(0, 0xFAEu, L"http://go.microsoft.com/fwlink/?LinkId=79513");
      if ( !sub_40B3AE() )
        SetUnhandledExceptionFilter(TopLevelExceptionFilter);
      if ( byte_4333FA )
        MEMORY[0] = 0;
      for ( i = 0; ; ++i )
      {
        v20 = i;
        if ( i >= 0x100 )
          break;
        dword_432F10[i] = 0;
      }
      if ( !dword_422EE8 )
      {
        v11 = *_p__wpgmptr();
        if ( wcschr(v11, 0x20u) )
        {
          v12 = v11;
          while ( *v12++ )
            ;
          v14 = v12 - (v11 + 1) + 3;
          v15 = (wchar_t *)sub_40ABE3((unsigned __int64)v14 >> 31 != 0 ? -1 : 2 * v14);
          wcscpy_s(v15, v14, L"\"");
          wcscat_s(v15, v14, v11);
          wcscat_s(v15, v14, L"\"");
          v11 = v15;
          v7 = argc;
          v3 = v21;
        }
        dword_422EE8 = (wchar_t *)sub_40E919((char *)v11);
      }
      signal(2, (_crt_signal_t)Function);
      signal(15, (_crt_signal_t)Function);
      v16 = sub_40BF68(v7, (int)v3, v18);
      sub_40CAAD();
      if ( !byte_412020 )
        v16 = 1;
      exit(v16);
    }
    v8 = &v3[v6];
    v9 = *(unsigned __int16 *)*v8;
    if ( v9 == 45 || v9 == 47 )
    {
      if ( wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:none") )
      {
        if ( wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:prompt") )
        {
          if ( wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:queue") )
          {
            if ( wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:send") )
            {
              if ( wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:test") )
                goto LABEL_16;
              byte_4333FA = 1;
            }
            else
            {
              dword_436628 = 3;
            }
          }
          else
          {
            dword_436628 = 2;
          }
        }
        else
        {
          dword_436628 = 1;
        }
      }
      else
      {
        dword_436628 = 0;
      }
      memmove(v8, v8 + 1, 4 * (v7 - v6) - 4);
      --v7;
      v22 = --v6;
      argc = v7;
    }
LABEL_16:
    ++v6;
    v3 = v21;
  }
}
// 40BE04: positive sp value C has been found
// 40BC7B: variable 'v18' is possibly undefined
// 401FB8: using guessed type wchar_t aHttpGoMicrosof[45];
// 412020: using guessed type char byte_412020;
// 432F10: using guessed type int dword_432F10[255];
// 4333FA: using guessed type char byte_4333FA;
// 4333FD: using guessed type char byte_4333FD;
// 4333FE: using guessed type char byte_4333FE;
// 436628: using guessed type int dword_436628;

//----- (0040BE06) --------------------------------------------------------
char *sub_40BE06()
{
  wchar_t *v0; // esi
  wchar_t *v1; // eax
  int v2; // edi
  wchar_t *v3; // esi
  wchar_t *v4; // eax
  wchar_t *v5; // esi
  wchar_t *v6; // eax
  wchar_t *v7; // esi
  wchar_t *v8; // eax
  wchar_t *v9; // esi
  wchar_t *v10; // eax
  wchar_t *v11; // esi
  wchar_t *v12; // eax
  wchar_t *v13; // esi
  wchar_t *v14; // eax
  char *result; // eax
  int v16; // esi
  wchar_t *v17; // eax
  const wchar_t **v18; // esi
  const wchar_t **i; // esi

  v0 = (wchar_t *)sub_40E919((char *)L"CC");
  v1 = (wchar_t *)sub_40E919((char *)L"cl");
  v2 = 0;
  sub_403430(v0, v1, 0);
  v3 = (wchar_t *)sub_40E919((char *)L"CXX");
  v4 = (wchar_t *)sub_40E919((char *)L"cl");
  sub_403430(v3, v4, 0);
  v5 = (wchar_t *)sub_40E919((char *)L"CPP");
  v6 = (wchar_t *)sub_40E919((char *)L"cl");
  sub_403430(v5, v6, 0);
  v7 = (wchar_t *)sub_40E919((char *)L"AS");
  v8 = (wchar_t *)sub_40E919((char *)L"ml");
  sub_403430(v7, v8, 0);
  v9 = (wchar_t *)sub_40E919((char *)L"RC");
  v10 = (wchar_t *)sub_40E919((char *)L"rc");
  sub_403430(v9, v10, 0);
  v11 = (wchar_t *)sub_40E919((char *)L"_NMAKE_VER");
  v12 = (wchar_t *)sub_40E919((char *)L"14.16.27031.1");
  sub_403430(v11, v12, 2);
  v13 = (wchar_t *)sub_40E919((char *)&off_402480);
  v14 = (wchar_t *)sub_40E919((char *)dword_422EE8);
  sub_403430(v13, v14, 76);
  result = (char *)L".SUFFIXES";
  if ( L".SUFFIXES" )
  {
    v16 = 0;
    do
    {
      v17 = (wchar_t *)sub_40E919(result);
      v18 = (const wchar_t **)off_401170[v16];
      Block = v17;
      wcscpy_s(&Src, 0x400u, *v18);
      sub_402CE6();
      for ( i = v18 + 1; *i; ++i )
      {
        wcscpy_s(&Src, 0x400u, *i);
        sub_402B07();
      }
      if ( !v2 )
        sub_4030D2();
      sub_4031EC();
      v16 = ++v2;
      result = (char *)*((_DWORD *)&off_401240 + v2);
    }
    while ( result );
  }
  return result;
}
// 401170: using guessed type wchar_t **off_401170[12];
// 401638: using guessed type wchar_t a1416270311[14];
// 401A38: using guessed type wchar_t aSuffixes_0[10];
// 402428: using guessed type wchar_t aCc[3];
// 402430: using guessed type wchar_t aCl[3];
// 402438: using guessed type wchar_t aCxx[4];
// 402440: using guessed type wchar_t aCpp[4];
// 402448: using guessed type wchar_t aAs[3];
// 402450: using guessed type wchar_t aMl[3];
// 402458: using guessed type wchar_t aRc[3];
// 402460: using guessed type wchar_t aRc_0[3];
// 402468: using guessed type wchar_t aNmakeVer[11];
// 402480: using guessed type void *off_402480;

//----- (0040BF68) --------------------------------------------------------
int __fastcall sub_40BF68(int a1, int a2, int a3)
{
  wchar_t *v4; // esi
  wchar_t *v5; // edi
  wchar_t *v6; // esi
  wchar_t *v7; // eax
  void *v8; // ecx
  const wchar_t *v9; // eax
  int v10; // esi
  wchar_t *Path; // [esp+10h] [ebp-21Ch]
  size_t RequiredCount; // [esp+18h] [ebp-214h] BYREF
  wchar_t *Buffer; // [esp+1Ch] [ebp-210h] BYREF
  wchar_t ResultPath[260]; // [esp+20h] [ebp-20Ch] BYREF

  Buffer = 0;
  v4 = (wchar_t *)sub_40E919((char *)&off_40248C);
  Path = wgetcwd(0, 0);
  sub_403430(v4, Path, 66);
  wdupenv_s(&Buffer, 0, aMa);
  v5 = Buffer;
  if ( Buffer )
    wcsncpy_s(&aMakeflags[10], wcslen(aMakeflags) - 9, Buffer, 0xFFFFFFFF);
  byte_41248D = 1;
  v6 = (wchar_t *)sub_40E919((char *)&aMakeflags[10]);
  v7 = (wchar_t *)sub_40E919((char *)aMa);
  sub_403430(v7, v6, 6);
  for ( ; v5; ++v5 )
  {
    if ( !*v5 )
      break;
    sub_40C801(*v5, 1);
  }
  free(Buffer);
  Buffer = 0;
  if ( !wgetenv_s(&RequiredCount, 0, 0, L"NTMAKEENV") && RequiredCount )
    byte_4333F9 = 1;
  sub_40C423(a1 - 1, a2 + 4);
  if ( !byte_422EE0 )
    sub_405542();
  if ( (byte_41248C & 2) == 0 )
  {
    sub_40BE06();
    dword_422EE4 = (void *)L"tools.ini";
    wsearchenv(L"tools.ini", L"INIT", ResultPath);
    if ( ResultPath[0] )
    {
      Stream = wfsopen(ResultPath, L"rt,ccs=unicode", 32);
      if ( !Stream )
        sub_4053D9(0, 0x41Du, ResultPath);
      if ( sub_4088D8() )
      {
        ++dword_4226A4;
        byte_422EE1 = 1;
        sub_40CF03(v8);
        if ( fclose(Stream) == -1 )
          sub_4053D9(0, 0x424u, dword_422EE4);
      }
      else if ( fclose(Stream) == -1 )
      {
        sub_4053D9(0, 0x424u, ResultPath);
      }
    }
  }
  v9 = (const wchar_t *)sub_40E919((char *)&aMakeflags[10]);
  if ( wputenv_s(aMa, v9) )
    sub_4053D9(0, 0x41Fu);
  if ( !dword_4333F0 )
    sub_40C731();
  sub_40C357();
  sub_40C20D();
  dword_4226B0 = 0;
  sub_40E52E();
  if ( (byte_41248C & 1) != 0 )
  {
    sub_40D3DE();
    sub_40D44F();
    sub_40D4EF();
  }
  if ( dword_432EFC )
    free(dword_432EFC);
  v10 = sub_4038F4();
  wchdir(Path);
  return v10;
}
// 40C14B: variable 'v8' is possibly undefined
// 40248C: using guessed type void *off_40248C;
// 41202C: using guessed type wchar_t aMakeflags[29];
// 41248C: using guessed type char byte_41248C;
// 41248D: using guessed type char byte_41248D;
// 4226A4: using guessed type int dword_4226A4;
// 4226B0: using guessed type int dword_4226B0;
// 422EE0: using guessed type char byte_422EE0;
// 422EE1: using guessed type char byte_422EE1;
// 4333F0: using guessed type int dword_4333F0;
// 4333F9: using guessed type char byte_4333F9;

//----- (0040C20D) --------------------------------------------------------
int sub_40C20D()
{
  _DWORD *v0; // esi
  int v1; // ecx
  FILE *v2; // eax
  void *v3; // ecx
  FILE *v4; // eax
  int v5; // eax
  void *osfhandle; // eax
  void *v8; // [esp-4h] [ebp-14h]
  void *v9; // [esp-4h] [ebp-14h]
  LARGE_INTEGER FileSize; // [esp+8h] [ebp-8h] BYREF

  v0 = (_DWORD *)dword_4333F0;
  if ( dword_4333F0 )
  {
    do
    {
      v1 = v0[1];
      if ( *(_WORD *)v1 != 45 || *(_WORD *)(v1 + 2) )
      {
        dword_422EE4 = sub_40E919((char *)v1);
        v4 = wfsopen((const wchar_t *)dword_422EE4, L"rt,ccs=unicode", 32);
        Stream = v4;
        if ( !v4 )
        {
          sub_4053D9(0, 0x41Cu, dword_422EE4);
          v4 = Stream;
        }
        FileSize.QuadPart = 0i64;
        v5 = fileno(v4);
        osfhandle = (void *)get_osfhandle(v5);
        v3 = v9;
        if ( osfhandle != (void *)-1 )
        {
          if ( GetFileSizeEx(osfhandle, &FileSize) )
          {
            v3 = (void *)(FileSize.LowPart + 1);
            if ( (unsigned __int64)(FileSize.QuadPart - 1) <= 0x7FFFFFFD )
              setvbuf(Stream, 0, 0, FileSize.LowPart + 1);
          }
        }
      }
      else
      {
        dword_422EE4 = sub_40E919((char *)L"STDIN");
        v2 = _acrt_iob_func(0);
        v3 = v8;
        Stream = v2;
      }
      dword_4226A4 = 0;
      byte_422EE1 = 0;
      sub_40CF03(v3);
      if ( Stream != _acrt_iob_func(0) && fclose(Stream) == -1 )
        sub_4053D9(0, 0x424u, dword_422EE4);
      v0 = (_DWORD *)*v0;
    }
    while ( v0 );
    v0 = (_DWORD *)dword_4333F0;
  }
  return sub_404BAE(v0);
}
// 40C24C: variable 'v8' is possibly undefined
// 40C2AB: variable 'v9' is possibly undefined
// 40C302: variable 'v3' is possibly undefined
// 4024F0: using guessed type wchar_t aStdin[6];
// 4226A4: using guessed type int dword_4226A4;
// 422EE1: using guessed type char byte_422EE1;
// 4333F0: using guessed type int dword_4333F0;

//----- (0040C357) --------------------------------------------------------
char *sub_40C357()
{
  char ***v0; // eax
  char **v1; // esi
  char *result; // eax
  wchar_t *v3; // edi
  wchar_t *v4; // eax
  wchar_t *v5; // ebx
  _WORD *v6; // edx
  wchar_t *v8; // eax
  wchar_t *Block; // [esp+4h] [ebp-8h]

  v0 = (char ***)_p__wenviron();
  v1 = *v0;
  result = **v0;
  if ( result )
  {
    do
    {
      v3 = wcschr((const wchar_t *)result, 0x3Du);
      if ( v3 )
      {
        if ( wcsnicmp((const wchar_t *)*v1, aMa, 8u) )
        {
          *v3 = 0;
          if ( *(_WORD *)*v1 )
          {
            v4 = (wchar_t *)sub_40E919(*v1);
            v5 = v4;
            v6 = v4 + 1;
            while ( *v4++ )
              ;
            wcsupr_s(v5, v4 - v6 + 1);
            v8 = (wchar_t *)sub_40E919((char *)v3 + 2);
            *v3 = 61;
            Block = v8;
            byte_41248D = 0;
            if ( !sub_403430(v5, v8, 4) )
            {
              free(v5);
              free(Block);
            }
          }
        }
      }
      result = *++v1;
    }
    while ( *v1 );
  }
  return result;
}
// 41248D: using guessed type char byte_41248D;

//----- (0040C423) --------------------------------------------------------
void __fastcall sub_40C423(unsigned int a1, int a2)
{
  int v2; // edi
  int (__cdecl *v3)(const wchar_t *, const wchar_t *); // ecx
  wchar_t *(__cdecl *v4)(const wchar_t *, wchar_t); // esi
  wchar_t *v5; // ebx
  int v6; // eax
  wchar_t *v7; // eax
  wchar_t *v8; // esi
  wchar_t *v9; // eax
  _WORD *v10; // esi
  int v11; // ecx
  int v12; // eax
  wchar_t *v13; // esi
  int v14; // eax
  wchar_t *v15; // eax
  _DWORD *v16; // esi
  void *v17; // eax
  const wchar_t *v18; // esi
  int v19; // ecx
  const wchar_t *v20; // esi
  wchar_t v21; // cx
  FILE *v22; // eax
  char *v23; // ebx
  _DWORD *v24; // esi
  char v25; // cl
  char v26; // [esp+1Bh] [ebp-25h]
  int v27; // [esp+1Ch] [ebp-24h]
  FILE *Stream; // [esp+30h] [ebp-10h] BYREF
  FILE *(__cdecl *v30)(unsigned int); // [esp+34h] [ebp-Ch]
  errno_t (__cdecl *v31)(FILE **, const wchar_t *, const wchar_t *); // [esp+38h] [ebp-8h]
  int (__cdecl *v32)(FILE *); // [esp+3Ch] [ebp-4h]

  v27 = a2;
  v26 = 0;
  v2 = 0;
  if ( !a1 )
    return;
  v3 = wcsicmp;
  v4 = wcschr;
  v30 = _acrt_iob_func;
  v31 = wfopen_s;
  v32 = fclose;
  while ( 1 )
  {
    v5 = *(wchar_t **)(a2 + 4 * v2);
    v6 = *v5;
    if ( v6 != 64 )
      break;
    sub_4051F1(v5 + 1);
LABEL_50:
    a2 = v27;
LABEL_51:
    v25 = v26;
LABEL_52:
    if ( ++v2 >= a1 )
      goto LABEL_55;
    v3 = wcsicmp;
  }
  if ( (_WORD)v6 != 45 && v6 != 47 )
  {
    v7 = v4(v5, 0x3Du);
    v8 = v7;
    if ( v7 )
    {
      if ( v7 == v5 )
        sub_4053D9(0, 0x427u);
      *v8 = 0;
      v9 = v8 - 1;
      v10 = v8 + 1;
      while ( 1 )
      {
        v11 = *v9;
        if ( (_WORD)v11 != 32 && v11 != 9 )
          break;
        --v9;
      }
      byte_41248D = 1;
      v9[1] = 0;
      v12 = ((int (__cdecl *)(_WORD *))wcsspn)(v10);
      v13 = (wchar_t *)sub_40E919((char *)&v10[v12]);
      v14 = ((int (__cdecl *)(wchar_t *))wcsspn)(v5);
      v15 = (wchar_t *)sub_40E919((char *)&v5[v14]);
      sub_403430(v15, v13, 2);
    }
    else
    {
      sub_40CAEB(v5);
      if ( *v5 )
      {
        v16 = sub_40E8C7();
        if ( (int)wcschr(v5, 32) )
          v17 = sub_40E95D((char *)v5);
        else
          v17 = sub_40E919((char *)v5);
        v16[1] = v17;
        sub_40EA1E((_DWORD **)&dword_422690, v16);
      }
    }
    a2 = v27;
    v4 = wcschr;
    *(_DWORD *)(v27 + 4 * v2) = 0;
    goto LABEL_51;
  }
  v18 = v5 + 1;
  if ( v3(v5 + 1, L"help") )
  {
    if ( *v18 )
    {
      while ( 1 )
      {
        if ( !wcsicmp(v18, L"nologo") )
        {
          sub_40C801(v18[2], 1);
          goto LABEL_49;
        }
        v19 = *v18;
        if ( v19 == 63 )
        {
          a2 = v27;
          v25 = 1;
          v4 = wcschr;
          v26 = 1;
          goto LABEL_52;
        }
        if ( v19 == 102 || v19 == 70 )
          break;
        if ( v19 == 120 || v19 == 88 )
        {
          v20 = v18 + 1;
          v21 = *v20;
          if ( !*v20 )
          {
            if ( ++v2 >= a1 || (v20 = *(const wchar_t **)(v27 + 4 * v2), (v21 = *v20) == 0) )
            {
              sub_4053D9(0, 0x426u);
              v21 = *v20;
            }
          }
          if ( v21 != 45 || v20[1] )
          {
            if ( v31(&Stream, v20, L"wt") )
              sub_4053D9(0, 0x418u, v20);
            sub_40CDD9(Stream);
            v32(Stream);
          }
          else
          {
            v22 = v30(1u);
            sub_40CDD9(v22);
          }
          goto LABEL_49;
        }
        sub_40C801(v19, 1);
        if ( !*++v18 )
          goto LABEL_49;
      }
      v23 = (char *)(v18 + 1);
      if ( !v18[1] )
      {
        if ( ++v2 >= a1 || (v23 = *(char **)(v27 + 4 * v2), !*(_WORD *)v23) )
          sub_4053D9(0, 0x425u);
      }
      v24 = sub_40E8C7();
      v24[1] = sub_40E919(v23);
      sub_40EA1E((_DWORD **)&dword_4333F0, v24);
    }
LABEL_49:
    v4 = wcschr;
    goto LABEL_50;
  }
  v25 = 1;
LABEL_55:
  if ( v25 )
  {
    sub_40556E();
    exit(0);
  }
}
// 402508: using guessed type wchar_t aNologo[7];
// 402518: using guessed type wchar_t aWt[3];
// 41248D: using guessed type char byte_41248D;
// 422690: using guessed type int dword_422690;
// 4333F0: using guessed type int dword_4333F0;

//----- (0040C731) --------------------------------------------------------
void *sub_40C731()
{
  void *result; // eax
  _DWORD *v1; // esi
  wchar_t *v2; // esi
  __int16 *v3; // eax
  int v4; // ecx
  struct _WIN32_FIND_DATAW FindFileData; // [esp+8h] [ebp-460h] BYREF
  wchar_t Destination[262]; // [esp+258h] [ebp-210h] BYREF

  result = (void *)waccess(L"makefile", 4);
  if ( result )
  {
    if ( dword_422690 )
    {
      v2 = *(wchar_t **)(dword_422690 + 4);
      result = (void *)waccess(v2, 4);
      if ( !result )
      {
        v3 = (__int16 *)wcsrchr(v2, 0x2Eu);
        if ( !v3 || (result = sub_40E0BF(Destination, 0x101u, v2, v3, &FindFileData)) == 0 )
        {
          v4 = dword_422690;
          result = *(void **)dword_422690;
          dword_422690 = *(_DWORD *)dword_422690;
          dword_4333F0 = v4;
        }
      }
    }
    else if ( (byte_41248C & 1) == 0 )
    {
      return (void *)sub_4053D9(0, 0x428u);
    }
  }
  else
  {
    v1 = sub_40E8C7();
    result = sub_40E919((char *)L"makefile");
    v1[1] = result;
    dword_4333F0 = (int)v1;
  }
  return result;
}
// 41248C: using guessed type char byte_41248C;
// 422690: using guessed type int dword_422690;
// 4333F0: using guessed type int dword_4333F0;
// 40C731: using guessed type wchar_t Destination[262];

//----- (0040C801) --------------------------------------------------------
int __fastcall sub_40C801(wint_t C, char a2)
{
  char v2; // bl
  char *v3; // esi
  int v4; // edi
  int result; // eax
  int v6; // ecx
  char v7; // al
  wchar_t *v8; // eax
  wchar_t *v9; // eax
  wchar_t v10; // dx
  const wchar_t *v11; // eax

  v2 = 0;
  v3 = &byte_41248E;
  v4 = towupper(C);
  result = v4;
  if ( (unsigned __int16)v4 <= 0x4Cu )
  {
    if ( (unsigned __int16)v4 == 76 )
    {
      v2 = 0x80;
      goto LABEL_10;
    }
    if ( (unsigned __int16)v4 <= 0x44u )
    {
      if ( v4 == 68 )
      {
        v2 = 1;
        goto LABEL_32;
      }
      result = (unsigned __int16)v4 - 32;
      if ( (unsigned __int16)v4 == 32 )
        return result;
      result = (unsigned __int16)v4 - 65;
      if ( (unsigned __int16)v4 == 65 )
      {
        v2 = 16;
        goto LABEL_32;
      }
      result = (unsigned __int16)v4 - 66;
      if ( (unsigned __int16)v4 == 66 )
      {
        byte_4226B6 = 1;
        return result;
      }
      result = (unsigned __int16)v4 - 67;
      if ( (unsigned __int16)v4 == 67 )
      {
        v2 = 32;
LABEL_10:
        v3 = &byte_41248C;
        byte_422EE0 = 1;
        goto LABEL_32;
      }
      goto LABEL_42;
    }
    result = (unsigned __int16)v4 - 69;
    if ( (unsigned __int16)v4 != 69 )
    {
      result = (unsigned __int16)v4 - 71;
      if ( (unsigned __int16)v4 == 71 )
      {
        byte_422EE3 = 1;
        return result;
      }
      result = (unsigned __int16)v4 - 73;
      if ( (unsigned __int16)v4 == 73 )
      {
        v2 = 2;
        goto LABEL_32;
      }
      result = (unsigned __int16)v4 - 75;
      if ( (unsigned __int16)v4 == 75 )
      {
        byte_4226B7 = 1;
        return result;
      }
      goto LABEL_42;
    }
    v2 = 4;
LABEL_22:
    v3 = &byte_41248C;
    goto LABEL_32;
  }
  if ( (unsigned __int16)v4 <= 0x52u )
  {
    if ( v4 == 82 )
    {
      v2 = 2;
      goto LABEL_22;
    }
    result = (unsigned __int16)v4 - 78;
    if ( (unsigned __int16)v4 == 78 )
    {
      v2 = 4;
      goto LABEL_32;
    }
    result = (unsigned __int16)v4 - 79;
    if ( (unsigned __int16)v4 == 79 )
    {
      byte_4226B5 = 1;
      return result;
    }
    result = (unsigned __int16)v4 - 80;
    if ( (unsigned __int16)v4 == 80 )
    {
      v2 = 1;
      goto LABEL_22;
    }
    result = (unsigned __int16)v4 - 81;
    if ( (unsigned __int16)v4 == 81 )
    {
      v3 = &byte_41248C;
LABEL_31:
      v2 = 8;
      goto LABEL_32;
    }
LABEL_42:
    result = sub_4053D9(0, 0x429u, C);
    goto LABEL_32;
  }
  result = (unsigned __int16)v4 - 83;
  if ( (unsigned __int16)v4 == 83 )
    goto LABEL_31;
  result = (unsigned __int16)v4 - 84;
  if ( (unsigned __int16)v4 == 84 )
  {
    v2 = 16;
    goto LABEL_22;
  }
  result = (unsigned __int16)v4 - 85;
  if ( (unsigned __int16)v4 != 85 )
  {
    result = (unsigned __int16)v4 - 89;
    if ( (unsigned __int16)v4 == 89 )
    {
      v2 = 64;
      goto LABEL_22;
    }
    goto LABEL_42;
  }
  v2 = 64;
LABEL_32:
  if ( dword_43332C )
  {
    v6 = dword_433328;
  }
  else
  {
    result = sub_40AB4F(aMa);
    dword_43332C = result;
    v6 = *(_DWORD *)(result + 8);
    dword_433328 = v6;
  }
  if ( a2 )
  {
    v7 = v2 | *v3;
    *v3 = v7;
    if ( v4 == 81 )
      *v3 = v7 | 0x20;
    if ( !wcschr(*(const wchar_t **)(v6 + 4), v4) )
    {
      v8 = wcschr(*(const wchar_t **)(dword_433328 + 4), 0x20u);
      if ( v8 )
        *v8 = v4;
    }
  }
  else
  {
    if ( v3 != &byte_41248E )
      return result;
    *v3 &= ~v2;
    v9 = wcschr(*(const wchar_t **)(v6 + 4), v4);
    if ( v9 )
    {
      do
      {
        v10 = v9[1];
        *v9++ = v10;
      }
      while ( v10 );
    }
  }
  v11 = (const wchar_t *)sub_40E919((char *)&aMakeflags[10]);
  result = wputenv_s(aMa, v11);
  if ( result )
    return sub_4053D9(dword_4226A4, 0x41Fu);
  return result;
}
// 41202C: using guessed type wchar_t aMakeflags[29];
// 41248C: using guessed type char byte_41248C;
// 41248E: using guessed type char byte_41248E;
// 4226A4: using guessed type int dword_4226A4;
// 4226B5: using guessed type char byte_4226B5;
// 4226B6: using guessed type char byte_4226B6;
// 4226B7: using guessed type char byte_4226B7;
// 422EE0: using guessed type char byte_422EE0;
// 422EE3: using guessed type char byte_422EE3;
// 433328: using guessed type int dword_433328;
// 43332C: using guessed type int dword_43332C;

//----- (0040C9FD) --------------------------------------------------------
void __cdecl Function()
{
  int v0; // esi
  const wchar_t *v1; // edi

  signal(2, (_crt_signal_t)1);
  signal(15, (_crt_signal_t)1);
  if ( byte_4333F8 && (byte_41248E & 4) == 0 && (byte_41248C & 0x10) == 0 && dword_422ED4 && waccess(dword_422ED4, 0) )
  {
    v0 = dword_42269C;
    v1 = dword_422ED4;
    if ( dword_42269C )
    {
      while ( wcsicmp(*(const wchar_t **)(v0 + 4), v1) )
      {
        v0 = *(_DWORD *)v0;
        if ( !v0 )
        {
          v1 = dword_422ED4;
          goto LABEL_10;
        }
      }
    }
    else
    {
LABEL_10:
      if ( !wunlink(v1) )
        sub_4053D9(dword_4226A4, 0xFA8u, dword_422ED4);
    }
  }
  sub_4053D9(0, 0x422u);
  sub_40CAAD();
}
// 41248C: using guessed type char byte_41248C;
// 41248E: using guessed type char byte_41248E;
// 42269C: using guessed type int dword_42269C;
// 4226A4: using guessed type int dword_4226A4;
// 4333F8: using guessed type char byte_4333F8;

//----- (0040CAAD) --------------------------------------------------------
int sub_40CAAD()
{
  int result; // eax
  int i; // esi

  result = fcloseall();
  for ( i = dword_4333F4; i; i = *(_DWORD *)i )
  {
    result = wunlink(*(const wchar_t **)(i + 4));
    if ( (byte_41248E & 4) != 0 )
    {
      sub_40CE7E((wchar_t *)L"\tdel %s\n", *(_DWORD *)(i + 4));
      result = sub_40CE60();
    }
  }
  return result;
}
// 41248E: using guessed type char byte_41248E;
// 4333F4: using guessed type int dword_4333F4;

//----- (0040CAEB) --------------------------------------------------------
const unsigned __int16 *__fastcall sub_40CAEB(const unsigned __int16 *a1)
{
  char v1; // bl
  const unsigned __int16 *result; // eax
  int v3; // edx

  v1 = 0;
  result = &a1[wcslen(a1) - 1];
  if ( *a1 != 34 || *result != 34 )
    goto LABEL_7;
  v1 = 1;
  do
  {
    --result;
LABEL_7:
    if ( result <= a1 )
      break;
    v3 = *result;
  }
  while ( v3 == 32 || v3 == 46 );
  if ( v1 )
    *++result = 34;
  *((_WORD *)result + 1) = 0;
  return result;
}

//----- (0040CB41) --------------------------------------------------------
int __fastcall sub_40CB41(unsigned int a1)
{
  int v1; // esi
  wchar_t **v3; // eax
  HMODULE v4; // edi
  HRSRC Resource; // eax
  _WORD *v6; // edx
  int i; // ebx
  int v9; // [esp-18h] [ebp-640h]
  int v10; // [esp-14h] [ebp-63Ch]
  int v11; // [esp-10h] [ebp-638h]
  int v12; // [esp-Ch] [ebp-634h]
  int v13; // [esp-8h] [ebp-630h]
  int v14; // [esp-4h] [ebp-62Ch]
  wchar_t Buffer[260]; // [esp+10h] [ebp-618h] BYREF
  wchar_t Dir[256]; // [esp+218h] [ebp-410h] BYREF
  wchar_t Filename[258]; // [esp+418h] [ebp-210h] BYREF
  wchar_t Drive[4]; // [esp+61Ch] [ebp-Ch] BYREF

  v1 = 0;
  if ( byte_4372D4 )
  {
    v4 = hModule;
  }
  else
  {
    v3 = _p__wpgmptr();
    wsplitpath_s(*v3, Drive, 3u, Dir, 0x100u, Filename, 0x100u, 0, 0);
    wmakepath_s(Buffer, 0x104u, Drive, Dir, 0, 0);
    if ( wcsncat_s(Filename, 0x100u, L"UI.DLL", 0xFFFFFFFF)
      || sub_40AC5C(Buffer, Filename, v9, v10, v11, v12, v13, v14) < 0 )
    {
      v4 = 0;
      hModule = 0;
    }
    else
    {
      v4 = hModule;
    }
    byte_4372D4 = 1;
  }
  Resource = FindResourceExW(v4, (LPCWSTR)6, (LPCWSTR)(unsigned __int16)((a1 >> 4) + 1), word_4372DC);
  if ( Resource )
  {
    v6 = LoadResource(v4, Resource);
    if ( v6 )
    {
      for ( i = a1 & 0xF; i; --i )
        v6 += (unsigned __int16)*v6 + 1;
      return *v6 != 0 ? (unsigned int)(v6 + 1) : 0;
    }
  }
  return v1;
}
// 40CBDD: variable 'v9' is possibly undefined
// 40CBDD: variable 'v10' is possibly undefined
// 40CBDD: variable 'v11' is possibly undefined
// 40CBDD: variable 'v12' is possibly undefined
// 40CBDD: variable 'v13' is possibly undefined
// 40CBDD: variable 'v14' is possibly undefined
// 4372D4: using guessed type char byte_4372D4;
// 4372DC: using guessed type __int16 word_4372DC;

//----- (0040CC62) --------------------------------------------------------
void *sub_40CC62()
{
  return &unk_436648;
}

//----- (0040CC68) --------------------------------------------------------
int sub_40CC68(wchar_t *Buffer, size_t BufferCount, wchar_t *Format, ...)
{
  unsigned __int64 *v3; // eax
  int result; // eax
  va_list va; // [esp+14h] [ebp+14h] BYREF

  va_start(va, Format);
  v3 = (unsigned __int64 *)sub_40CC62();
  result = _stdio_common_vswprintf_s(*v3, Buffer, BufferCount, Format, 0, va);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (0040CC96) --------------------------------------------------------
int __fastcall sub_40CC96(void *a1, void *Src, size_t Size)
{
  int *v5; // eax
  int v6; // [esp-8h] [ebp-Ch]

  if ( !a1 )
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 22;
  }
  if ( Src && Size <= 0x104 )
  {
    memcpy(a1, Src, Size);
    return 0;
  }
  memset(a1, 0, 0x104u);
  if ( !Src )
  {
    v5 = errno();
    v6 = 22;
LABEL_10:
    *v5 = v6;
    invalid_parameter_noinfo();
    return v6;
  }
  if ( Size > 0x104 )
  {
    v5 = errno();
    v6 = 34;
    goto LABEL_10;
  }
  return 22;
}

//----- (0040CD10) --------------------------------------------------------
void *sub_40CD10()
{
  return &unk_436658;
}

//----- (0040CD16) --------------------------------------------------------
int sub_40CD16(wchar_t *Buffer, wchar_t *Format, ...)
{
  _DWORD *v2; // eax
  unsigned __int64 v4; // [esp-1Ch] [ebp-1Ch]
  va_list va; // [esp+10h] [ebp+10h] BYREF

  va_start(va, Format);
  v2 = sub_40CD10();
  HIDWORD(v4) = v2[1];
  LODWORD(v4) = *v2 | 1;
  return _stdio_common_vswscanf(v4, Buffer, 0xFFFFFFFF, Format, 0, va);
}

//----- (0040CD40) --------------------------------------------------------
bool __thiscall sub_40CD40(FILE *Stream)
{
  int v1; // eax
  void *osfhandle; // esi
  DWORD Mode; // [esp+4h] [ebp-4h] BYREF

  v1 = fileno(Stream);
  osfhandle = (void *)get_osfhandle(v1);
  return (GetFileType(osfhandle) & 0xFFFF7FFF) == 2 && GetConsoleMode(osfhandle, &Mode);
}

//----- (0040CD80) --------------------------------------------------------
int sub_40CD80()
{
  FILE *v1; // eax

  if ( byte_4333FD )
    return 0;
  v1 = _acrt_iob_func(2u);
  return fflush(v1);
}
// 4333FD: using guessed type char byte_4333FD;

//----- (0040CD9E) --------------------------------------------------------
int sub_40CD9E(wchar_t *Format, ...)
{
  va_list va; // [esp+Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  return sub_40CE16(Format, va);
}

//----- (0040CDAD) --------------------------------------------------------
int sub_40CDAD()
{
  int result; // eax
  FILE *v1; // eax

  if ( byte_4333FD )
  {
    LOWORD(result) = putwch(0xAu);
  }
  else
  {
    v1 = _acrt_iob_func(2u);
    LOWORD(result) = fputwc(0xAu, v1);
  }
  return (unsigned __int16)result;
}
// 4333FD: using guessed type char byte_4333FD;

//----- (0040CDD9) --------------------------------------------------------
bool __thiscall sub_40CDD9(FILE *Stream)
{
  FILE *v2; // eax
  int v3; // eax
  FILE *v4; // eax
  bool result; // al
  int v6; // [esp-4h] [ebp-8h]

  v2 = _acrt_iob_func(2u);
  v6 = fileno(v2);
  v3 = fileno(Stream);
  dup2(v3, v6);
  v4 = _acrt_iob_func(2u);
  result = sub_40CD40(v4);
  byte_4333FD = result;
  return result;
}
// 4333FD: using guessed type char byte_4333FD;

//----- (0040CE16) --------------------------------------------------------
int __fastcall sub_40CE16(wchar_t *Format, va_list ArgList)
{
  unsigned __int64 *v4; // eax
  unsigned __int64 *v5; // esi
  FILE *v7; // eax

  v4 = (unsigned __int64 *)sub_40CC62();
  v5 = v4;
  if ( byte_4333FD )
    return _conio_common_vcwprintf(*v4, Format, 0, ArgList);
  v7 = _acrt_iob_func(2u);
  return _stdio_common_vfwprintf(*v5, v7, Format, 0, ArgList);
}
// 4333FD: using guessed type char byte_4333FD;

//----- (0040CE60) --------------------------------------------------------
int sub_40CE60()
{
  FILE *v1; // eax

  if ( byte_4333FE )
    return 0;
  v1 = _acrt_iob_func(1u);
  return fflush(v1);
}
// 4333FE: using guessed type char byte_4333FE;

//----- (0040CE7E) --------------------------------------------------------
int sub_40CE7E(wchar_t *Format, ...)
{
  va_list va; // [esp+Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  return sub_40CEB9(Format, va);
}

//----- (0040CE8D) --------------------------------------------------------
int sub_40CE8D()
{
  int result; // eax
  FILE *v1; // eax

  if ( byte_4333FE )
  {
    LOWORD(result) = putwch(0xAu);
  }
  else
  {
    v1 = _acrt_iob_func(1u);
    LOWORD(result) = fputwc(0xAu, v1);
  }
  return (unsigned __int16)result;
}
// 4333FE: using guessed type char byte_4333FE;

//----- (0040CEB9) --------------------------------------------------------
int __fastcall sub_40CEB9(wchar_t *Format, va_list ArgList)
{
  unsigned __int64 *v4; // eax
  unsigned __int64 *v5; // esi
  FILE *v7; // eax

  v4 = (unsigned __int64 *)sub_40CC62();
  v5 = v4;
  if ( byte_4333FE )
    return _conio_common_vcwprintf(*v4, Format, 0, ArgList);
  v7 = _acrt_iob_func(1u);
  return _stdio_common_vfwprintf(*v5, v7, Format, 0, ArgList);
}
// 4333FE: using guessed type char byte_4333FE;

//----- (0040CF03) --------------------------------------------------------
int __thiscall sub_40CF03(void *this)
{
  int v1; // eax
  unsigned int v2; // eax
  int result; // eax
  int v4; // edx
  char v5; // bh
  int v6; // ecx
  unsigned __int8 i; // bl
  char v8; // al
  int v9; // eax
  char v10; // al
  _BYTE *v11; // esi
  int v12; // [esp+10h] [ebp-8h]
  int v13; // [esp+10h] [ebp-8h]
  char v14; // [esp+17h] [ebp-1h]

  v1 = dword_412028;
  byte_422EE2 = 1;
  byte_433311[dword_412028] = 23;
  v2 = v1 + 2;
  dword_412028 = v2;
  if ( v2 >= 0x10 )
    __report_rangecheckfailure();
  byte_433310[v2] = 0;
  dword_4226B0 = dword_4226A4;
  LOBYTE(result) = sub_409B95((int)this, 0);
  v4 = dword_412028;
  BYTE1(v6) = result;
  v5 = 0;
  v14 = result;
  LOBYTE(v6) = byte_433310[dword_412028];
  for ( i = v6; (_BYTE)v6 != 23; i = v6 )
  {
    if ( (i & 0x40) != 0 )
    {
      dword_412028 = v4 - 1;
      result = funcs_40CF81[v6 & 0xF]();
    }
    else
    {
      if ( (i & 0x10) == 0 )
      {
        result = (unsigned __int8)byte_4014A0[8 * i + (BYTE1(v6) & 0xF)];
        v12 = result;
        if ( (result & 0x20) != 0 )
        {
          sub_4053D9(dword_4226B0, result + 1000, &Src);
          v4 = dword_412028;
          result = v12;
        }
        dword_412028 = --v4;
        if ( (result & 0x80u) != 0 )
        {
          v9 = result & 0xF;
          v13 = v9;
          if ( !v5 )
          {
            v10 = sub_409B95(v6, i);
            v4 = dword_412028;
            v5 = v10;
            v9 = v13;
          }
          result = (unsigned __int8)byte_401480[8 * i + (v5 & 0xF)] + v9;
        }
        v11 = (_BYTE *)*((_DWORD *)&off_4014E0 + result);
        v6 = (unsigned __int8)*v11;
        if ( *v11 )
        {
          do
          {
            LOBYTE(result) = v11[v6];
            byte_433310[++v4] = result;
            --v6;
          }
          while ( v6 );
          dword_412028 = v4;
        }
        goto LABEL_25;
      }
      if ( i == BYTE1(v6) )
      {
        LOBYTE(v6) = byte_43330F[v4--];
        dword_412028 = v4;
        if ( (v6 & 0x40) != 0 )
        {
          dword_412028 = v4 - 1;
          funcs_40CF81[v6 & 0xF]();
          v4 = dword_412028;
        }
        result = dword_4226A4;
        dword_4226B0 = dword_4226A4;
        if ( v5 )
        {
          if ( Src == 10 )
          {
            result = dword_4226A4 - 1;
            dword_4226B0 = dword_4226A4 - 1;
          }
          BYTE1(v6) = v5;
          v5 = 0;
          v14 = BYTE1(v6);
        }
        else
        {
          v8 = sub_409B95(v6, byte_433310[v4]);
          v4 = dword_412028;
          BYTE1(v6) = v8;
          result = dword_4226A4;
          v14 = BYTE1(v6);
          dword_4226B0 = dword_4226A4;
        }
        goto LABEL_26;
      }
      result = sub_4053D9(dword_4226B0, 0x409u, &Src);
    }
    v4 = dword_412028;
LABEL_25:
    BYTE1(v6) = v14;
LABEL_26:
    LOBYTE(v6) = byte_433310[v4];
  }
  dword_412028 = v4 - 1;
  return result;
}
// 40D011: variable 'v6' is possibly undefined
// 401460: using guessed type int (*funcs_40CF81[6])();
// 410AF8: using guessed type void __noreturn __report_rangecheckfailure(void);
// 412028: using guessed type int dword_412028;
// 4226A4: using guessed type int dword_4226A4;
// 4226B0: using guessed type int dword_4226B0;
// 422EE2: using guessed type char byte_422EE2;

//----- (0040D0E7) --------------------------------------------------------
int __fastcall sub_40D0E7(int a1, _WORD *a2)
{
  _WORD *v2; // esi
  unsigned int v4; // esi
  bool v5; // cf

  v2 = a2 + 1;
  while ( *a2++ )
    ;
  v4 = a2 - v2 + a1;
  v5 = v4 > 0x28;
  if ( v4 > 0x28 )
  {
    sub_40CE7E((wchar_t *)L"\n\t\t\t");
    v5 = v4 > 0x28;
  }
  return v5 ? 0 : v4;
}

//----- (0040D11B) --------------------------------------------------------
void __fastcall sub_40D11B(int a1, int a2, FILETIME FileTime)
{
  struct _FILETIME LocalFileTime; // [esp+Ch] [ebp-5Ch] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+14h] [ebp-54h] BYREF
  WCHAR DateStr[20]; // [esp+24h] [ebp-44h] BYREF
  WCHAR TimeStr[12]; // [esp+4Ch] [ebp-1Ch] BYREF

  if ( FileTime )
  {
    if ( FileTimeToLocalFileTime(&FileTime, &LocalFileTime)
      && FileTimeToSystemTime(&LocalFileTime, &SystemTime)
      && GetDateFormatW(0x400u, 0, &SystemTime, L"ddd, MMM dd yyyy", DateStr, 20) )
    {
      if ( GetTimeFormatW(0x400u, 0, &SystemTime, L"HH:mm:ss", TimeStr, 12) )
        sub_4054B3(4u, DateStr, TimeStr, a1, 32, a2);
    }
  }
  else
  {
    sub_4054B3(6u, a1 + 26, 32, a2);
  }
}

//----- (0040D1D5) --------------------------------------------------------
void __fastcall sub_40D1D5(int a1, int a2)
{
  int v2; // edi
  int v3; // ebx
  __int16 *v4; // ecx
  wchar_t *v5; // ebx
  int v6; // edi
  WCHAR *i; // eax
  _WORD *v8; // esi
  WCHAR *v9; // eax
  _WORD *v10; // esi
  wchar_t *Block; // [esp+10h] [ebp-270h]
  int v12; // [esp+14h] [ebp-26Ch] BYREF
  int v13; // [esp+18h] [ebp-268h]
  wchar_t *Context; // [esp+1Ch] [ebp-264h] BYREF
  HANDLE hFindFile; // [esp+20h] [ebp-260h] BYREF
  int v16; // [esp+24h] [ebp-25Ch]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+28h] [ebp-258h] BYREF

  v2 = a1;
  v13 = a1;
  v12 = a2;
  sub_4054B3(0xCu);
  v3 = 0;
  v16 = 0;
  while ( v2 )
  {
    if ( wcschr(*(const wchar_t **)(v2 + 4), 0x24u) )
    {
      v4 = *(__int16 **)(v2 + 4);
      Context = 0;
      Block = (wchar_t *)sub_40F311(v4, 1, &v12);
      v5 = wcstok_s(Block, L" \t", &Context);
      if ( v5 )
      {
        v6 = v16;
        do
        {
          if ( wcspbrk(v5, L"*?") )
          {
            for ( i = sub_407A35(v5, &FindFileData, &hFindFile); i; i = sub_407BC1(&FindFileData, hFindFile) )
            {
              v8 = sub_40FF33(v5, i);
              sub_40CE7E((wchar_t *)L"%s ", v8);
              v6 = sub_40D0E7(v6, v8);
              free(v8);
            }
          }
          else
          {
            sub_40CE7E((wchar_t *)L"%s ", v5);
            v6 = sub_40D0E7(v6, v5);
          }
          v5 = wcstok_s(0, L" \t", &Context);
        }
        while ( v5 );
        v16 = v6;
        v2 = v13;
      }
      free(Block);
      v3 = v16;
    }
    else
    {
      if ( wcspbrk(*(const wchar_t **)(v2 + 4), L"*?") )
      {
        v9 = sub_407A35(*(wchar_t **)(v2 + 4), &FindFileData, &hFindFile);
        if ( !v9 )
          goto LABEL_20;
        do
        {
          v10 = sub_40FF33(*(wchar_t **)(v2 + 4), v9);
          sub_40CE7E((wchar_t *)L"%s ", v10);
          v3 = sub_40D0E7(v3, v10);
          free(v10);
          v9 = sub_407BC1(&FindFileData, hFindFile);
        }
        while ( v9 );
      }
      else
      {
        sub_40CE7E((wchar_t *)L"%s ", *(_DWORD *)(v2 + 4));
        v3 = sub_40D0E7(v3, *(_WORD **)(v2 + 4));
      }
      v16 = v3;
    }
LABEL_20:
    v2 = *(_DWORD *)v2;
    v13 = v2;
  }
}

//----- (0040D3DE) --------------------------------------------------------
int sub_40D3DE()
{
  int *v0; // edi
  _DWORD *i; // esi
  int v2; // eax
  _DWORD *j; // ebx

  sub_4054B3(8u);
  v0 = dword_432F10;
  do
  {
    for ( i = (_DWORD *)*v0; i; i = (_DWORD *)*i )
    {
      v2 = i[2];
      if ( v2 && *(_DWORD *)(v2 + 4) )
      {
        sub_4054B3(0xEu, i[1], *(_DWORD *)(v2 + 4));
        for ( j = *(_DWORD **)i[2]; j; j = (_DWORD *)*j )
        {
          if ( j[1] )
            sub_40CE7E((wchar_t *)L"\t\t%s\n", j[1]);
        }
      }
    }
    ++v0;
  }
  while ( (int)v0 < (int)byte_433310 );
  sub_40CE8D();
  return sub_40CE60();
}
// 432F10: using guessed type int dword_432F10[255];

//----- (0040D44F) --------------------------------------------------------
int sub_40D44F()
{
  _BYTE *v0; // esi
  wchar_t *v1; // eax
  _DWORD *v2; // edi
  _DWORD *i; // esi

  sub_4054B3(7u);
  v0 = dword_422694;
  if ( dword_422694 )
  {
    do
    {
      v1 = (wchar_t *)L"%s::";
      if ( !v0[20] )
        v1 = L"%s:";
      sub_40CE7E(v1, *((_DWORD *)v0 + 2));
      sub_4054B3(0xAu);
      v2 = (_DWORD *)*((_DWORD *)v0 + 3);
      if ( v2 )
      {
        sub_40CE7E(L"%s\n", v2[1]);
        while ( 1 )
        {
          v2 = (_DWORD *)*v2;
          if ( !v2 )
            break;
          sub_40CE7E((wchar_t *)L"\t\t\t%s\n", v2[1]);
        }
      }
      sub_40CE8D();
      v0 = *(_BYTE **)v0;
    }
    while ( v0 );
  }
  sub_40CE7E((wchar_t *)L"%s: ", L".SUFFIXES");
  for ( i = (_DWORD *)dword_4226A0; i; i = (_DWORD *)*i )
    sub_40CE7E((wchar_t *)L"%s ", i[1]);
  sub_40CE8D();
  return sub_40CE60();
}
// 401138: using guessed type wchar_t aSuffixes[10];
// 402628: using guessed type wchar_t aS_3[4];
// 402630: using guessed type wchar_t aS_4[4];
// 4226A0: using guessed type int dword_4226A0;

//----- (0040D4EF) --------------------------------------------------------
int sub_40D4EF()
{
  unsigned int v0; // ebx
  _DWORD *v1; // esi
  _DWORD *v2; // ebx
  int v3; // edi
  unsigned __int16 *v4; // esi
  unsigned int v5; // eax
  _DWORD *v6; // edi
  int result; // eax
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]
  unsigned int v10; // [esp+14h] [ebp-4h]

  sub_4054B3(9u);
  v0 = 0;
  v10 = 0;
  do
  {
    v1 = *(_DWORD **)((char *)dword_422490 + v0);
    v9 = v1;
    if ( v1 )
    {
      do
      {
        sub_40CE7E((wchar_t *)L"%s:%c", v1[1], (*(_BYTE *)(*(_DWORD *)(v1[6] + 4) + 16) & 0x20) != 0 ? 58 : 32);
        v2 = (_DWORD *)v1[6];
        dword_422EC8 = v1[1];
        dword_422ED4 = (wchar_t *)dword_422EC8;
        dword_422ED8 = dword_422EC8;
        if ( v2 )
        {
          do
          {
            v3 = v2[1];
            sub_4054B3(0xBu);
            v4 = L"dinsb";
            v5 = 1;
            v8 = 1;
            do
            {
              if ( ((unsigned __int8)v5 & *(_BYTE *)(v3 + 16)) != 0 )
              {
                sub_40CE7E((wchar_t *)L"-%c ", *v4);
                v5 = v8;
              }
              v5 *= 2;
              ++v4;
              v8 = v5;
            }
            while ( v5 < 0x10 );
            sub_40D1D5(*(_DWORD *)v3, *(_DWORD *)(v3 + 4));
            sub_4054B3(0xAu);
            v6 = *(_DWORD **)(v3 + 8);
            if ( v6 )
            {
              if ( v6[1] )
                sub_40CE7E(L"%s\n", v6[1]);
              while ( 1 )
              {
                v6 = (_DWORD *)*v6;
                if ( !v6 )
                  break;
                if ( v6[1] )
                  sub_40CE7E((wchar_t *)L"\t\t\t%s\n", v6[1]);
              }
            }
            else
            {
              sub_40CE8D();
            }
            v2 = (_DWORD *)*v2;
          }
          while ( v2 );
          v1 = v9;
        }
        v1 = (_DWORD *)*v1;
        v9 = v1;
        sub_40CE8D();
      }
      while ( v1 );
      v0 = v10;
    }
    v0 += 4;
    v10 = v0;
  }
  while ( v0 < 0x200 );
  sub_40CE8D();
  sub_40CE60();
  result = 0;
  dword_422EC8 = 0;
  dword_422ED4 = 0;
  dword_422ED8 = 0;
  return result;
}
// 402630: using guessed type wchar_t aS_4[4];
// 40266C: using guessed type wchar_t aDinsb[6];
// 422490: using guessed type int dword_422490[128];
// 422EC8: using guessed type int dword_422EC8;
// 422ED8: using guessed type int dword_422ED8;

//----- (0040D644) --------------------------------------------------------
char __stdcall sub_40D644(char a1)
{
  int v1; // edi
  char v2; // al
  int v3; // esi
  int v4; // eax
  BOOL v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  BOOL v9; // eax
  unsigned int v10; // eax

  v1 = dword_433610;
  v2 = *(_BYTE *)dword_433610;
  v3 = dword_433610 - 8;
  dword_433610 -= 8;
  if ( v2 != 22 )
  {
    if ( v2 != 23 || *(_BYTE *)v3 != 23 )
      return 0;
    v8 = wcscmp(*(const unsigned __int16 **)(v3 + 4), *(const unsigned __int16 **)(v1 + 4));
    if ( v8 )
      v8 = v8 < 0 ? -1 : 1;
    switch ( a1 )
    {
      case 6:
        v9 = v8 != 0;
        goto LABEL_48;
      case 7:
        v9 = v8 == 0;
        goto LABEL_48;
      case 8:
        v9 = v8 > 0;
        goto LABEL_48;
      case 9:
        v10 = v8;
        break;
      case 10:
        v10 = ~v8;
        break;
      case 11:
        v9 = v8 <= 0;
LABEL_48:
        *(_DWORD *)(v3 + 4) = v9;
        *(_BYTE *)v3 = 22;
        return 1;
      default:
        return 0;
    }
    v9 = v10 >> 31;
    goto LABEL_48;
  }
  if ( *(_BYTE *)v3 == 22 )
  {
    switch ( a1 )
    {
      case 1:
        v4 = 0;
        if ( !*(_DWORD *)(v3 + 4) )
          goto LABEL_5;
        goto LABEL_6;
      case 2:
        v4 = 0;
        if ( *(_DWORD *)(v3 + 4) )
        {
LABEL_5:
          if ( *(_DWORD *)(v1 + 4) )
LABEL_6:
            v4 = 1;
        }
        goto LABEL_30;
      case 3:
        *(_DWORD *)(v3 + 4) |= *(_DWORD *)(v1 + 4);
        return 1;
      case 4:
        *(_DWORD *)(v3 + 4) ^= *(_DWORD *)(v1 + 4);
        return 1;
      case 5:
        *(_DWORD *)(v3 + 4) &= *(_DWORD *)(v1 + 4);
        return 1;
      case 6:
        v5 = *(_DWORD *)(v1 + 4) != *(_DWORD *)(v3 + 4);
        goto LABEL_13;
      case 7:
        v4 = *(_DWORD *)(v3 + 4) == *(_DWORD *)(v1 + 4);
        goto LABEL_30;
      case 8:
        v5 = *(_DWORD *)(v3 + 4) > *(_DWORD *)(v1 + 4);
        goto LABEL_13;
      case 9:
        v5 = *(_DWORD *)(v3 + 4) < *(_DWORD *)(v1 + 4);
        goto LABEL_13;
      case 10:
        v5 = *(_DWORD *)(v3 + 4) >= *(_DWORD *)(v1 + 4);
        goto LABEL_13;
      case 11:
        v5 = *(_DWORD *)(v3 + 4) <= *(_DWORD *)(v1 + 4);
LABEL_13:
        *(_DWORD *)(v3 + 4) = v5;
        return 1;
      case 12:
        *(int *)(v3 + 4) >>= *(_DWORD *)(v1 + 4);
        return 1;
      case 13:
        *(_DWORD *)(v3 + 4) <<= *(_DWORD *)(v1 + 4);
        return 1;
      case 14:
        *(_DWORD *)(v3 + 4) -= *(_DWORD *)(v1 + 4);
        return 1;
      case 15:
        *(_DWORD *)(v3 + 4) += *(_DWORD *)(v1 + 4);
        return 1;
      case 16:
        v6 = *(_DWORD *)(v1 + 4);
        if ( !v6 )
        {
          sub_4053D9(dword_4226A4, 0x437u);
          v6 = *(_DWORD *)(v1 + 4);
        }
        *(int *)(v3 + 4) %= v6;
        return 1;
      case 17:
        v7 = *(_DWORD *)(v1 + 4);
        if ( !v7 )
        {
          sub_4053D9(dword_4226A4, 0x437u);
          v7 = *(_DWORD *)(v1 + 4);
        }
        v4 = *(_DWORD *)(v3 + 4) / v7;
        goto LABEL_30;
      case 18:
        v4 = *(_DWORD *)(v1 + 4) * *(_DWORD *)(v3 + 4);
LABEL_30:
        *(_DWORD *)(v3 + 4) = v4;
        break;
      default:
        return 0;
    }
    return 1;
  }
  return 0;
}
// 4226A4: using guessed type int dword_4226A4;
// 433610: using guessed type int dword_433610;

//----- (0040D894) --------------------------------------------------------
char __stdcall sub_40D894(char a1)
{
  if ( *(_BYTE *)dword_433610 == 22 )
  {
    switch ( a1 )
    {
      case 19:
        *(_DWORD *)(dword_433610 + 4) = -*(_DWORD *)(dword_433610 + 4);
        return 1;
      case 20:
        *(_DWORD *)(dword_433610 + 4) = ~*(_DWORD *)(dword_433610 + 4);
        return 1;
      case 21:
        *(_DWORD *)(dword_433610 + 4) = *(_DWORD *)(dword_433610 + 4) == 0;
        return 1;
    }
  }
  return 0;
}
// 433610: using guessed type int dword_433610;

//----- (0040D8D2) --------------------------------------------------------
wchar_t *sub_40D8D2()
{
  wchar_t *v0; // esi
  wchar_t *v1; // ecx
  wchar_t *v2; // edx
  wchar_t v3; // di
  wchar_t *result; // eax

  v0 = EndPtr + 1;
  v1 = EndPtr + 1;
  EndPtr = v1;
  if ( !*v1 )
    goto LABEL_7;
  v2 = v0;
  v3 = *v1;
  do
  {
    if ( v3 == 34 )
    {
      v2 = v1 + 1;
      if ( v1[1] != 34 )
        break;
    }
    v1 = v2 + 1;
    EndPtr = v1;
    ++v2;
    v3 = *v1;
  }
  while ( *v1 );
  if ( !*v1 )
  {
LABEL_7:
    sub_4053D9(dword_4226A4, 0x3FEu, 34);
    v1 = EndPtr;
  }
  *v1 = 0;
  result = v0;
  ++EndPtr;
  return result;
}
// 4226A4: using guessed type int dword_4226A4;

//----- (0040D949) --------------------------------------------------------
wchar_t *sub_40D949()
{
  wchar_t *v0; // edi
  wchar_t *v1; // ecx
  wchar_t *v2; // ebx
  wchar_t v3; // si
  _WORD *v4; // edx
  wchar_t *result; // eax

  v0 = EndPtr + 1;
  v1 = EndPtr + 1;
  EndPtr = v1;
  if ( !*v1 )
    goto LABEL_10;
  v2 = v0;
  v3 = *v1;
  do
  {
    if ( v3 == 94 && (v4 = v1 + 1, v1[1] == 93) )
    {
      while ( *v4++ )
        ;
      memmove(v1, v2 + 1, 2 * (v4 - (v1 + 2)) + 2);
      v1 = EndPtr;
    }
    else if ( v3 == 93 )
    {
      break;
    }
    EndPtr = ++v1;
    v2 = v1;
    v3 = *v1;
  }
  while ( *v1 );
  if ( !*v1 )
  {
LABEL_10:
    sub_4053D9(dword_4226A4, 0x3FEu, 93);
    v1 = EndPtr;
  }
  *v1 = 0;
  result = v0;
  ++EndPtr;
  return result;
}
// 4226A4: using guessed type int dword_4226A4;

//----- (0040DA09) --------------------------------------------------------
int __fastcall sub_40DA09(char a1, int a2)
{
  unsigned __int8 v4; // bl
  int result; // eax

  if ( a1 == 25 )
  {
    v4 = 3;
  }
  else if ( a1 )
  {
    if ( (unsigned __int8)a1 <= 0x15u )
      v4 = ((unsigned __int8)a1 > 0x12u) + 1;
    else
      v4 = 0;
  }
  else
  {
    v4 = 4;
  }
  result = v4;
  if ( !byte_401570[5 * (unsigned __int8)byte_4333FF + v4] )
    result = sub_4053D9(dword_4226A4, 0x3FFu);
  dword_433608 = a2;
  byte_4333FF = v4;
  byte_433603 = a1;
  LOBYTE(dword_433604) = a1;
  return result;
}
// 4226A4: using guessed type int dword_4226A4;
// 4333FF: using guessed type char byte_4333FF;
// 433603: using guessed type char byte_433603;
// 433604: using guessed type int dword_433604;
// 433608: using guessed type int dword_433608;

//----- (0040DA77) --------------------------------------------------------
wchar_t *sub_40DA77()
{
  wchar_t *i; // eax
  wchar_t v1; // cx
  wchar_t v2; // cx
  wchar_t *v3; // eax
  wchar_t *v4; // ecx
  wchar_t *v5; // edi
  wchar_t v6; // dx
  wchar_t *v7; // ebx
  wchar_t v8; // si
  wchar_t *v10; // [esp+Ch] [ebp-4h]

  for ( i = EndPtr; ; EndPtr = i )
  {
    v1 = *i;
    if ( *i != 32 && v1 != 9 )
      break;
    ++i;
  }
  if ( v1 != 40 )
  {
    sub_4053D9(dword_4226A4, 0x3FFu);
    i = EndPtr;
  }
  do
  {
    do
    {
      EndPtr = ++i;
      v2 = *i;
    }
    while ( *i == 32 );
  }
  while ( v2 == 9 );
  v10 = i;
  if ( v2 == 34 )
  {
    v3 = sub_40D8D2();
    v4 = EndPtr;
    v5 = v3;
    while ( 1 )
    {
      v6 = *v4;
      if ( *v4 != 32 && v6 != 9 )
        break;
      EndPtr = ++v4;
    }
    if ( v6 != 41 )
    {
      sub_4053D9(dword_4226A4, 0x3FFu);
      v4 = EndPtr;
    }
    EndPtr = v4 + 1;
  }
  else
  {
    v7 = i;
    while ( 1 )
    {
      v8 = *i++;
      EndPtr = i;
      if ( !v8 )
      {
        sub_4053D9(dword_4226A4, 0x3FFu);
        i = EndPtr;
      }
      if ( v8 == 41 )
        break;
      if ( v8 != 32 && v8 != 9 )
        v7 = i;
    }
    v5 = v10;
    *v7 = 0;
  }
  return v5;
}
// 4226A4: using guessed type int dword_4226A4;

//----- (0040DB84) --------------------------------------------------------
int sub_40DB84()
{
  wchar_t *i; // ecx
  wint_t v1; // si
  wchar_t *v2; // edx
  wchar_t **v3; // edi
  wchar_t *v4; // ebx
  wchar_t v5; // cx
  char v7; // cl
  int v8; // edx
  wchar_t *v9; // edx
  wchar_t *v10; // edx
  wchar_t *v11; // ebx
  int v12; // edi
  wchar_t *v13; // eax
  wchar_t *v14; // eax
  int v15; // [esp-Ch] [ebp-18h]

  for ( i = EndPtr; ; EndPtr = i )
  {
    v1 = *i;
    if ( *i != 32 && v1 != 9 )
      break;
    ++i;
  }
  if ( v1 < 0x80u && (byte_401060[v1] & 2) != 0 )
  {
    v2 = off_412070;
    v3 = &off_412070;
    if ( off_412070 )
    {
      while ( 1 )
      {
        v4 = i;
        if ( *v2 )
        {
          v5 = *v2;
          do
          {
            if ( *v4 != v5 )
              break;
            ++v2;
            ++v4;
            v5 = *v2;
          }
          while ( *v2 );
          i = EndPtr;
        }
        if ( !*v2 )
          break;
        v3 += 2;
        v2 = *v3;
        if ( !*v3 )
          goto LABEL_15;
      }
      i = v4;
      EndPtr = v4;
    }
  }
  else
  {
    v3 = (wchar_t **)&unk_412118;
  }
  if ( *v3 )
  {
    v7 = *((_BYTE *)v3 + 4);
    v8 = 0;
    return sub_40DA09(v7, v8);
  }
LABEL_15:
  switch ( v1 )
  {
    case '-':
      EndPtr = i + 1;
      return sub_40DA09(byte_433603 != 22 ? 19 : 14, 0);
    case '"':
      v9 = sub_40D8D2();
      return sub_40DA09(23, (int)v9);
    case '[':
      v10 = sub_40D949();
      return sub_40DA09(24, (int)v10);
  }
  if ( iswdigit(v1) )
  {
    v11 = EndPtr;
    *errno() = 0;
    v12 = wcstol(EndPtr, &EndPtr, 0);
    if ( *errno() == 34 )
    {
      v15 = dword_4226A4;
      *EndPtr = 0;
      sub_4053D9(v15, 0x436u, v11);
    }
    if ( towupper(*EndPtr) == 76 )
      ++EndPtr;
    v8 = v12;
    goto LABEL_32;
  }
  if ( !v1 )
  {
    byte_433602 = 1;
    return sub_40DA09(0, 0);
  }
  if ( !wcsnicmp(EndPtr, L"DEFINED", 7u) )
  {
    EndPtr += 7;
    v13 = sub_40DA77();
    v8 = sub_40DFF3(v13);
LABEL_32:
    v7 = 22;
    return sub_40DA09(v7, v8);
  }
  if ( !wcsnicmp(EndPtr, L"EXISTS", 6u) )
  {
    EndPtr += 6;
LABEL_39:
    v14 = sub_40DA77();
    v8 = waccess(v14, 0) == 0;
    goto LABEL_32;
  }
  if ( !wcsnicmp(EndPtr, L"EXIST", 5u) )
  {
    EndPtr += 5;
    goto LABEL_39;
  }
  return sub_4053D9(dword_4226A4, 0x3FFu);
}
// 412070: using guessed type wchar_t *off_412070;
// 4226A4: using guessed type int dword_4226A4;
// 433602: using guessed type char byte_433602;
// 433603: using guessed type char byte_433603;

//----- (0040DE62) --------------------------------------------------------
int sub_40DE62()
{
  _DWORD *v0; // ecx
  _DWORD *v1; // edx
  int result; // eax

  v0 = (_DWORD *)dword_433610;
  if ( dword_433610 < (unsigned int)byte_435620 )
  {
    sub_4053D9(dword_4226A4, 0x3FFu);
    v0 = (_DWORD *)dword_433610;
  }
  v1 = (_DWORD *)dword_43360C;
  if ( dword_43360C > (unsigned int)&unk_435618 )
  {
    sub_4053D9(dword_4226A4, 0x412u);
    v1 = (_DWORD *)dword_43360C;
    v0 = (_DWORD *)dword_433610;
  }
  *v1 = *v0;
  result = v0[1];
  v1[1] = result;
  dword_43360C = (int)(v1 + 2);
  dword_433610 = (int)(v0 - 2);
  return result;
}
// 4226A4: using guessed type int dword_4226A4;
// 43360C: using guessed type int dword_43360C;
// 433610: using guessed type int dword_433610;
// 435620: using guessed type unsigned __int8 byte_435620[4088];

//----- (0040DED3) --------------------------------------------------------
bool sub_40DED3()
{
  int v0; // ecx
  char *v1; // esi
  char v2; // al
  wchar_t **v3; // eax
  char (__stdcall *v4)(char); // ecx
  int v6; // ecx
  int v7; // edx
  unsigned __int8 *v8; // ecx
  unsigned __int8 v9; // bl

  dword_43360C = (int)&unk_433620;
  dword_433610 = (int)byte_435620;
  byte_433602 = 0;
  byte_4333FF = 3;
  byte_433603 = 25;
  sub_40DA09(25, 0);
  v6 = dword_433610;
  *(_DWORD *)dword_433610 = dword_433604;
LABEL_15:
  *(_DWORD *)(v6 + 4) = dword_433608;
LABEL_16:
  while ( !byte_433602 )
  {
    sub_40DB84();
    v7 = dword_433604;
    v8 = (unsigned __int8 *)dword_433610;
    if ( (_BYTE)dword_433604 != 25 )
    {
      while ( 1 )
      {
        v9 = byte_401590[(unsigned __int8)v7];
        if ( v9 > (unsigned __int8)byte_401590[*v8] )
          break;
        if ( !v9 )
        {
          while ( *v8 != 25 )
          {
            sub_40DE62();
            v8 = (unsigned __int8 *)dword_433610;
          }
          if ( v8 < byte_435620 )
          {
            sub_4053D9(dword_4226A4, 0x3FFu);
            v8 = (unsigned __int8 *)dword_433610;
          }
          v6 = (int)(v8 - 8);
          dword_433610 = v6;
          goto LABEL_16;
        }
        sub_40DE62();
        v7 = dword_433604;
        v8 = (unsigned __int8 *)dword_433610;
      }
    }
    if ( v8 != (unsigned __int8 *)&unk_436618 )
    {
      v6 = (int)(v8 + 8);
      dword_433610 = v6;
      *(_DWORD *)v6 = v7;
      goto LABEL_15;
    }
    sub_4053D9(dword_4226A4, 0x412u);
    v6 = dword_433610;
  }
  if ( (unsigned __int8 *)v6 != &byte_435620[-8] )
    sub_4053D9(dword_4226A4, 0x3FFu);
  v0 = dword_433610;
  v1 = (char *)&unk_433620;
  if ( dword_43360C > (unsigned int)&unk_433620 )
  {
    do
    {
      v2 = *v1;
      if ( (unsigned __int8)*v1 <= 0x15u )
      {
        v4 = sub_40D894;
        if ( (unsigned __int8)v2 <= 0x12u )
          v4 = sub_40D644;
        if ( !v4(v2) )
          sub_4053D9(dword_4226A4, 0x438u);
        v0 = dword_433610;
      }
      else
      {
        v0 += 8;
        dword_433610 = v0;
        if ( v2 == 24 )
        {
          v3 = sub_406E74(*((wchar_t **)v1 + 1), 0, 1, 0, 0);
          v0 = dword_433610;
          *(_DWORD *)(dword_433610 + 4) = v3;
          *(_BYTE *)v0 = 22;
        }
        else
        {
          *(_DWORD *)v0 = *(_DWORD *)v1;
          *(_DWORD *)(v0 + 4) = *((_DWORD *)v1 + 1);
        }
      }
      v1 += 8;
    }
    while ( (unsigned int)v1 < dword_43360C );
  }
  if ( (unsigned __int8 *)v0 == byte_435620 && *(_BYTE *)v0 == 22 )
    return *(_DWORD *)(v0 + 4) != 0;
  sub_4053D9(dword_4226A4, 0x3FFu);
  return 0;
}
// 4226A4: using guessed type int dword_4226A4;
// 4333FF: using guessed type char byte_4333FF;
// 433602: using guessed type char byte_433602;
// 433603: using guessed type char byte_433603;
// 433604: using guessed type int dword_433604;
// 433608: using guessed type int dword_433608;
// 43360C: using guessed type int dword_43360C;
// 433610: using guessed type int dword_433610;
// 435620: using guessed type unsigned __int8 byte_435620[4088];

//----- (0040DFF3) --------------------------------------------------------
bool __thiscall sub_40DFF3(wchar_t *String)
{
  wchar_t *v1; // edi
  wchar_t *Context; // [esp+Ch] [ebp-4h] BYREF

  Context = 0;
  v1 = wcstok_s(String, L" \t", &Context);
  if ( wcstok_s(0, L" \t", &Context) )
    sub_4053D9(dword_4226A4, 0x409u, v1);
  if ( !v1 )
    sub_4053D9(dword_4226A4, 0x417u);
  return sub_40AB4F(v1) != 0;
}
// 4226A4: using guessed type int dword_4226A4;

//----- (0040E062) --------------------------------------------------------
bool __fastcall sub_40E062(wchar_t *String, char a2)
{
  if ( !*String )
    sub_4053D9(dword_4226A4, 0x3FAu);
  if ( a2 != 4 )
  {
    if ( a2 == 5 )
      return !sub_40DFF3(String);
    if ( a2 != 6 )
    {
      if ( a2 != 7 )
      {
        EndPtr = String;
        return sub_40DED3();
      }
      return !sub_40DFF3(String);
    }
  }
  return sub_40DFF3(String);
}
// 4226A4: using guessed type int dword_4226A4;

//----- (0040E0BF) --------------------------------------------------------
void **__fastcall sub_40E0BF(
        wchar_t *Destination,
        rsize_t a2,
        wchar_t *Str,
        __int16 *a4,
        LPWIN32_FIND_DATAW lpFindFileData)
{
  void *v5; // eax
  wchar_t *v6; // edi
  const wchar_t *v7; // ebx
  wchar_t *v8; // esi
  wchar_t v9; // dx
  wchar_t v10; // cx
  wchar_t *v11; // ebx
  wchar_t v12; // cx
  int v13; // ebx
  wchar_t *v14; // ecx
  const wchar_t *v15; // edi
  int v16; // ecx
  __int16 v17; // ax
  const wchar_t *v18; // edi
  wchar_t *v19; // eax
  __int16 v20; // ax
  const wchar_t *v21; // esi
  wchar_t v22; // cx
  int v23; // esi
  wchar_t *v24; // edi
  wchar_t *v25; // eax
  int v26; // eax
  const wchar_t *v27; // edi
  int v28; // esi
  wchar_t *v29; // edi
  wchar_t v30; // cx
  wchar_t v31; // ax
  wchar_t v32; // dx
  wchar_t *v33; // eax
  int v34; // ebx
  int v35; // esi
  int v36; // ebx
  wchar_t *v37; // eax
  int v38; // edi
  _DWORD *v39; // eax
  DWORD v41; // ecx
  DWORD v42; // edx
  const wchar_t *v43; // [esp-8h] [ebp-3Ch]
  wchar_t *v44; // [esp+10h] [ebp-24h]
  int v45; // [esp+10h] [ebp-24h]
  wchar_t *v46; // [esp+14h] [ebp-20h]
  wchar_t *v47; // [esp+18h] [ebp-1Ch]
  int v48; // [esp+18h] [ebp-1Ch]
  void **v49; // [esp+1Ch] [ebp-18h]
  wchar_t *Source; // [esp+24h] [ebp-10h]

  v5 = dword_422694;
  v49 = (void **)dword_422694;
  v6 = Destination;
  if ( !dword_422694 )
    return 0;
  while ( 1 )
  {
    Source = (wchar_t *)*((_DWORD *)v5 + 2);
    v44 = wcsrchr(Source, 0x2Eu);
    if ( sub_4104DC(v44, a4) )
      goto LABEL_93;
    v7 = Source + 1;
    *v6 = 0;
    v8 = Source + 1;
    v47 = Source + 1;
    v9 = Source[1];
    if ( v9 )
    {
      v10 = *v7;
      do
      {
        v9 = v10;
        if ( v10 == 123 )
          break;
        if ( v10 == 94 )
        {
          ++v8;
        }
        else if ( v10 == 34 )
        {
          do
            ++v8;
          while ( *v8 != 34 );
        }
        v10 = *++v8;
        v9 = *v8;
      }
      while ( *v8 );
      v6 = Destination;
      v47 = v8;
    }
    if ( !v9 )
      break;
    v11 = v8;
    v12 = v9;
    do
    {
      if ( v12 == 125 )
        break;
      if ( v12 == 94 )
        ++v11;
      v12 = *++v11;
    }
    while ( *v11 );
    v8 = v47;
    v46 = v11;
    v48 = ((char *)v11 - (char *)v47 - 2) >> 1;
    v13 = v48;
    v14 = Str;
    if ( *Str == 34 )
      v14 = Str + 1;
    v15 = v8 + 1;
    if ( v48 )
    {
      v16 = (char *)v14 - (char *)v15;
      v45 = v16;
      while ( 1 )
      {
        if ( *v15 == 92 || *v15 == 47 )
        {
          v17 = *(const wchar_t *)((char *)v15 + v16);
          if ( v17 != 92 && v17 != 47 )
          {
            v13 = -1;
            break;
          }
        }
        else
        {
          if ( wcsnicmp(v15, (const wchar_t *)((char *)v15 + v16), 1u) )
            goto LABEL_92;
          v16 = v45;
        }
        ++v15;
        if ( !--v13 )
          goto LABEL_32;
      }
    }
    if ( v13 == -1 )
    {
LABEL_92:
      v6 = Destination;
      goto LABEL_93;
    }
LABEL_32:
    v44 = v8;
    v18 = &Str[v48 + 1];
    v19 = wcschr(v18, 0x5Cu);
    if ( !v19 )
    {
      v19 = wcschr(v18, 0x2Fu);
      if ( !v19 )
      {
        v6 = Destination;
LABEL_39:
        v7 = Source + 1;
        break;
      }
    }
    if ( v19 != v18 )
      goto LABEL_92;
    v20 = *(v46 - 1);
    if ( v20 == 92 )
      goto LABEL_92;
    v6 = Destination;
    if ( v20 != 47 )
      goto LABEL_39;
LABEL_93:
    v5 = *v49;
    v49 = (void **)v5;
    if ( !v5 )
      return 0;
  }
  if ( *Source == 123 )
  {
    v21 = v7;
    if ( *v7 )
    {
      v22 = *v7;
      do
      {
        if ( v22 == 125 )
          break;
        if ( v22 == 94 )
          ++v21;
        v22 = *++v21;
      }
      while ( *v21 );
      v7 = Source + 1;
      v6 = Destination;
    }
    v23 = v21 - v7;
    if ( v23 )
    {
      wcsncpy_s(v6, a2, v7, v23);
      v7 += v23;
      if ( *(v7 - 1) != 92 )
        v6[v23++] = 92;
    }
    else if ( *Str == 34 )
    {
      v23 = 3;
      wcsncpy_s(v6, a2, L"\".\\", 3u);
    }
    else
    {
      v23 = 2;
      wcsncpy_s(v6, a2, L".\\", 2u);
    }
    Source = (wchar_t *)(v7 + 1);
    v24 = wcsrchr(Str, 0x5Cu);
    v25 = wcsrchr(Str, 0x2Fu);
    if ( v25 > v24 )
      v24 = v25;
    if ( v24 )
    {
      wcscpy_s(&Destination[v23], a2 - v23, v24 + 1);
      v26 = (char *)a4 - (char *)v24 - 2;
    }
    else
    {
      v27 = Str + 1;
      if ( *Str != 34 )
        v27 = Str;
      wcscpy_s(&Destination[v23], a2 - v23, v27);
      v26 = (char *)a4 - (char *)v27;
    }
    v6 = Destination;
    v28 = (v26 >> 1) + v23;
  }
  else
  {
    if ( *v8 )
    {
      v29 = wcsrchr(Str, 0x2Eu);
      v30 = *v29;
      v31 = *v29;
      if ( *v29 != 58 )
      {
        v32 = *v29;
        do
        {
          v31 = v32;
          if ( v32 == 92 )
            break;
          v31 = v32;
          if ( v32 == 47 )
            break;
          v31 = v30;
          if ( v29 <= Str )
            break;
          v30 = *--v29;
          v32 = *v29;
          v31 = *v29;
        }
        while ( *v29 != 58 );
      }
      if ( v31 == 58 || v31 == 92 || v31 == 47 )
        ++v29;
      v33 = Str;
    }
    else
    {
      v33 = Str;
      v29 = Str;
    }
    v34 = 0;
    v35 = ((char *)a4 - (char *)v29) >> 1;
    if ( v29 != v33 && *v33 == 34 )
    {
      v34 = 1;
      *Destination = 34;
    }
    if ( v35 >= (int)(a2 - v34) )
      sub_4053D9(0, 0x434u);
    v43 = v29;
    v6 = Destination;
    wcsncpy_s(&Destination[v34], a2 - v34, v43, v35);
    v28 = v34 + v35;
  }
  v36 = v44 - Source;
  if ( v36 >= (int)(a2 - v28) )
    sub_4053D9(0, 0x434u);
  wcsncpy_s(&v6[v28], a2 - v28, Source, v36);
  if ( *v6 == 34 )
  {
    v37 = Destination;
    v38 = v36 + v28;
    if ( Destination[v36 - 1 + v28] != 34 )
    {
      if ( (int)(a2 - v36 - v28) <= 1 )
        sub_4053D9(0, 0x434u);
      v37 = Destination;
      ++v36;
      Destination[v38] = 34;
    }
    v6 = v37;
  }
  v6[v36 + v28] = 0;
  v39 = sub_40EA6B(v6, 0, 0);
  if ( !v39 )
  {
    if ( sub_407CDE(v6, lpFindFileData) )
      return v49;
    goto LABEL_93;
  }
  v41 = v39[4];
  v42 = v39[5];
  lpFindFileData->ftCreationTime.dwLowDateTime = v41;
  lpFindFileData->ftCreationTime.dwHighDateTime = v42;
  lpFindFileData->ftLastWriteTime.dwLowDateTime = v41;
  lpFindFileData->ftLastWriteTime.dwHighDateTime = v42;
  return v49;
}
// 402700: using guessed type wchar_t asc_402700[4];

//----- (0040E52E) --------------------------------------------------------
void sub_40E52E()
{
  int v0; // eax
  void *v1; // esi
  wchar_t *v2; // edx
  _WORD *v3; // ecx
  _DWORD *v5; // ebx
  int v6; // edx
  const wchar_t *v7; // edi
  int v8; // ecx
  int v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // edi
  _DWORD *v12; // ecx
  const wchar_t *v13; // ebx
  int **v14; // ebx
  int v15; // ebx
  void *v16; // edi
  wchar_t *String1; // [esp+Ch] [ebp-14h]
  int *v18; // [esp+10h] [ebp-10h]
  int v19; // [esp+14h] [ebp-Ch]
  _DWORD *v20; // [esp+18h] [ebp-8h]
  int *v21; // [esp+1Ch] [ebp-4h] BYREF

  v0 = dword_4226A0;
  v18 = (int *)dword_4226A0;
  v21 = 0;
  v1 = dword_422694;
  for ( dword_422694 = 0; v0; v18 = (int *)v0 )
  {
    v2 = *(wchar_t **)(v0 + 4);
    String1 = v2;
    v3 = v2 + 1;
    while ( *v2++ )
      ;
    v5 = v1;
    v6 = v2 - v3;
    v19 = v6;
    if ( v1 )
    {
      do
      {
        v7 = (const wchar_t *)v5[2];
        if ( *v7 == 123 )
        {
          LOWORD(v8) = 123;
          do
          {
            if ( (_WORD)v8 == 94 )
              ++v7;
            v8 = *++v7;
          }
          while ( v8 != 125 );
          ++v7;
        }
        if ( !wcsnicmp(String1, v7, v6) && ((v9 = v7[v19], v9 == 46) || (_WORD)v9 == 123) )
        {
          v10 = (_DWORD *)v5[1];
          v11 = v5;
          v12 = (_DWORD *)*v5;
          if ( v10 )
          {
            *v10 = v12;
            v12 = (_DWORD *)*v5;
          }
          else
          {
            v1 = (void *)*v5;
          }
          if ( v12 )
          {
            v12[1] = v5[1];
            v12 = (_DWORD *)*v5;
          }
          v20 = v12;
          *v5 = 0;
          v13 = (const wchar_t *)dword_422694;
          if ( dword_422694 )
          {
            while ( wcsicmp(*((const wchar_t **)v13 + 2), (const wchar_t *)v11[2]) )
            {
              v13 = *(const wchar_t **)v13;
              if ( !v13 )
                goto LABEL_22;
            }
            free((void *)v11[2]);
            while ( 1 )
            {
              v15 = v11[3];
              if ( !v15 )
                break;
              v11[3] = *(_DWORD *)v15;
              free(*(void **)(v15 + 4));
              *(_DWORD *)v15 = dword_433618;
              dword_433618 = v15;
            }
            free(v11);
          }
          else
          {
LABEL_22:
            v14 = (int **)v11[3];
            while ( v14 )
            {
              byte_436640 = *((_BYTE *)v11 + 20);
              if ( byte_436640 )
                dword_436644 = v11[2];
              sub_40EBFB(v14[1], &v21, 0, 0, 0, 0, 0);
              v14 = (int **)*v14;
              byte_436640 = 0;
            }
            v11[4] = v21;
            v21 = 0;
            sub_40EA1E((_DWORD **)&dword_422694, v11);
          }
          v5 = v20;
        }
        else
        {
          v5 = (_DWORD *)*v5;
        }
        v6 = v19;
      }
      while ( v5 );
    }
    v0 = *v18;
  }
  if ( v1 )
  {
    v16 = v1;
    do
    {
      if ( (byte_41248C & 1) != 0 )
        sub_4053D9(0, 0xFA5u, *((_DWORD *)v1 + 2));
      free(*((void **)v1 + 2));
      sub_404BAE(*((_DWORD **)v1 + 3));
      sub_404BAE(*((_DWORD **)v1 + 4));
      v1 = *(void **)v1;
      free(v16);
      v16 = v1;
    }
    while ( v1 );
  }
}
// 41248C: using guessed type char byte_41248C;
// 4226A0: using guessed type int dword_4226A0;
// 433618: using guessed type int dword_433618;
// 436640: using guessed type char byte_436640;
// 436644: using guessed type int dword_436644;

//----- (0040E715) --------------------------------------------------------
void **__fastcall sub_40E715(
        int a1,
        wchar_t *a2,
        int a3,
        unsigned __int64 a4,
        int ***a5,
        int ***a6,
        _DWORD *a7,
        _DWORD *a8,
        wchar_t **a9)
{
  __int16 *v11; // eax
  __int64 v12; // rax
  int **v13; // esi
  char v14; // dl
  int v15; // eax
  int v16; // eax
  unsigned int v17; // edx
  unsigned int v18; // ecx
  _DWORD *v19; // esi
  _DWORD *v20; // edx
  int ***v21; // esi
  _DWORD *v22; // ebx
  unsigned int v23; // esi
  int v24; // eax
  void **result; // eax
  const wchar_t *v26; // [esp-8h] [ebp-298h]
  __int64 v27; // [esp+10h] [ebp-280h] BYREF
  _DWORD *v28; // [esp+1Ch] [ebp-274h] BYREF
  int v29; // [esp+20h] [ebp-270h]
  int ***v30; // [esp+24h] [ebp-26Ch]
  _DWORD *v31; // [esp+28h] [ebp-268h]
  int ***v32; // [esp+2Ch] [ebp-264h]
  _DWORD *v33; // [esp+30h] [ebp-260h]
  void **v34; // [esp+34h] [ebp-25Ch]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+38h] [ebp-258h] BYREF

  v32 = a5;
  v30 = a6;
  v26 = *(const wchar_t **)(a1 + 4);
  v31 = a7;
  v33 = a8;
  v11 = (__int16 *)wcsrchr(v26, 0x2Eu);
  if ( !v11 )
    return 0;
  v34 = sub_40E0BF(a2, 0x101u, *(wchar_t **)(a1 + 4), v11, &FindFileData);
  if ( !v34 )
    return 0;
  v12 = sub_407A1B((char *)&FindFileData);
  *a9 = a2;
  v27 = v12;
  v13 = *v30;
  if ( *v30 )
  {
    do
    {
      if ( !wcsicmp((const wchar_t *)v13[1], a2) )
        break;
      v13 = (int **)*v13;
    }
    while ( v13 );
    if ( v13 )
      *(_BYTE *)(a1 + 8) &= ~1u;
  }
  v14 = *(_BYTE *)(a1 + 8);
  v28 = 0;
  v15 = sub_403A81(a2, v14, &v27, 0, &v28);
  v29 = v15;
  if ( v28 )
  {
    v16 = sub_404E20(v28);
    v29 += v16;
    sub_404E3E(&v28);
    v15 = v29;
  }
  v17 = v27;
  *v31 += v15;
  v18 = HIDWORD(v27);
  if ( (*(_BYTE *)(a1 + 8) & 0x10) != 0
    || a4 < __PAIR64__(HIDWORD(v27), v17)
    || byte_4226B6 && a4 == __PAIR64__(HIDWORD(v27), v17) )
  {
    if ( !v13 )
    {
      v19 = sub_40E8C7();
      v19[1] = sub_40E919((char *)a2);
      v20 = v19;
      v21 = v32;
      sub_40EA1E(v32, v20);
      v17 = v27;
      if ( !*v30 )
        *v30 = *v21;
      v18 = HIDWORD(v27);
    }
    if ( (*(_BYTE *)(a1 + 8) & 0x11) == 1 )
    {
      sub_4054B3(3u, a2, *(_DWORD *)(a1 + 4));
      v18 = HIDWORD(v27);
      v17 = v27;
    }
  }
  v22 = v33;
  v23 = v33[1];
  v24 = *v33;
  if ( *(_QWORD *)v33 <= __PAIR64__(v18, v17) )
  {
    v24 = v17;
    v23 = v18;
  }
  *v33 = v24;
  result = v34;
  v22[1] = v23;
  return result;
}
// 4226B6: using guessed type char byte_4226B6;

//----- (0040E8C7) --------------------------------------------------------
_DWORD *sub_40E8C7()
{
  _DWORD *v0; // edx
  int v1; // esi
  _DWORD *result; // eax

  v0 = (_DWORD *)dword_433618;
  if ( dword_433618 )
  {
    dword_433618 = *(_DWORD *)dword_433618;
  }
  else
  {
    v1 = dword_436620;
    if ( (unsigned int)dword_436620 >= 8 )
    {
      v0 = (_DWORD *)dword_43361C;
    }
    else
    {
      v1 = 0x8000;
      v0 = sub_40ABE3(0x8000u);
    }
    dword_43361C = (int)(v0 + 2);
    dword_436620 = v1 - 8;
  }
  *v0 = 0;
  result = v0;
  v0[1] = 0;
  return result;
}
// 433618: using guessed type int dword_433618;
// 43361C: using guessed type int dword_43361C;
// 436620: using guessed type int dword_436620;

//----- (0040E919) --------------------------------------------------------
void *__thiscall sub_40E919(char *Src)
{
  char *v2; // edi
  char *v3; // ecx
  __int16 v4; // ax
  int v5; // edi
  void *v6; // esi

  v2 = Src;
  v3 = Src + 2;
  do
  {
    v4 = *(_WORD *)v2;
    v2 += 2;
  }
  while ( v4 );
  v5 = ((v2 - v3) >> 1) + 1;
  v6 = sub_40ABE3((unsigned __int64)(unsigned int)v5 >> 31 != 0 ? -1 : 2 * v5);
  memcpy(v6, Src, 2 * v5);
  return v6;
}

//----- (0040E95D) --------------------------------------------------------
_WORD *__thiscall sub_40E95D(char *this)
{
  char *v1; // ebx
  char *v2; // ecx
  __int16 v3; // ax
  int v4; // ebx
  _WORD *v5; // edi

  v1 = this;
  v2 = this + 2;
  do
  {
    v3 = *(_WORD *)v1;
    v1 += 2;
  }
  while ( v3 );
  v4 = (v1 - v2) >> 1;
  v5 = sub_40ABE3((unsigned __int64)(unsigned int)(v4 + 3) >> 31 != 0 ? -1 : 2 * (v4 + 3));
  *v5 = 34;
  memcpy(v5 + 1, this, 2 * v4);
  v5[v4 + 1] = 34;
  v5[v4 + 2] = 0;
  return v5;
}

//----- (0040E9C3) --------------------------------------------------------
wchar_t *__fastcall sub_40E9C3(char *Block, const wchar_t *a2)
{
  char *v3; // esi
  char *v4; // ecx
  __int16 v5; // ax
  int v6; // esi
  const wchar_t *v7; // ecx
  int v8; // esi
  const wchar_t *v9; // edx
  unsigned int v11; // edi
  wchar_t *v12; // esi

  v3 = Block;
  v4 = Block + 2;
  do
  {
    v5 = *(_WORD *)v3;
    v3 += 2;
  }
  while ( v5 );
  v6 = v3 - v4;
  v7 = a2;
  v8 = v6 >> 1;
  v9 = a2 + 1;
  while ( *v7++ )
    ;
  v11 = v7 - v9 + v8 + 1;
  v12 = (wchar_t *)sub_41069D(Block, v11);
  wcscat_s(v12, v11, a2);
  return v12;
}

//----- (0040EA1E) --------------------------------------------------------
_DWORD *__fastcall sub_40EA1E(_DWORD **a1, _DWORD *a2)
{
  _DWORD *v2; // esi
  _DWORD *result; // eax

  v2 = *a1;
  if ( *a1 )
  {
    do
    {
      result = (_DWORD *)*v2;
      a1 = (_DWORD **)v2;
      v2 = result;
    }
    while ( result );
  }
  *a1 = a2;
  return result;
}

//----- (0040EA33) --------------------------------------------------------
int __thiscall sub_40EA33(wint_t *this, int a2)
{
  char v3; // si
  char v4; // al

  v3 = 0;
  while ( *this )
  {
    if ( *this == 47 )
      v4 = 92;
    else
      v4 = towupper(*this);
    v3 += v4;
    ++this;
  }
  return v3 & 0x7F;
}

//----- (0040EA6B) --------------------------------------------------------
_DWORD *__thiscall sub_40EA6B(wchar_t *Source, int a2, int a3)
{
  int v4; // eax
  _DWORD *result; // eax
  int v6; // ecx
  wchar_t *v7; // esi
  rsize_t v9; // esi
  wchar_t *v10; // ebx
  int v11; // eax
  int v12; // ecx
  _DWORD *v13; // esi
  int v14; // eax
  int v15; // ecx
  wchar_t *v16; // esi
  rsize_t v18; // esi
  int v19; // eax
  char v20; // [esp+Fh] [ebp-1h]

  v20 = 0;
  if ( *Source )
  {
    v4 = sub_40EA33(Source, (int)Source);
    result = sub_410424(Source, v4);
    if ( result )
      return result;
    if ( !wcsncmp(Source, L".\\", 2u) || !wcsncmp(Source, L"./", 2u) )
    {
      v10 = Source + 2;
    }
    else
    {
      v7 = Source;
      while ( *v7++ )
        ;
      v9 = v7 - (Source + 1) + 3;
      v10 = (wchar_t *)sub_40ABE3((unsigned __int64)v9 >> 31 != 0 ? -1 : 2 * v9);
      wcscpy_s(v10, v9, L".\\");
      wcscat_s(v10, v9, Source);
      v20 = 1;
    }
    v11 = sub_40EA33(v10, v6);
    v13 = sub_410424(v10, v11);
    if ( v13 )
    {
      if ( !v20 )
        return v13;
    }
    else
    {
      if ( v10 != Source + 2 )
        v10[1] = 47;
      v14 = sub_40EA33(v10, v12);
      v13 = sub_410424(v10, v14);
      if ( v20 )
        free(v10);
      if ( v13 )
        return v13;
      if ( *Source == 34 )
      {
        v10 = sub_4105E0(Source);
      }
      else
      {
        v16 = Source;
        while ( *v16++ )
          ;
        v18 = v16 - (Source + 1) + 3;
        v10 = (wchar_t *)sub_40ABE3((unsigned __int64)v18 >> 31 != 0 ? -1 : 2 * v18);
        wcscpy_s(v10, v18, L"\"");
        wcscat_s(v10, v18, Source);
        wcscat_s(v10, v18, L"\"");
      }
      v19 = sub_40EA33(v10, v15);
      v13 = sub_410424(v10, v19);
    }
    free(v10);
    return v13;
  }
  return 0;
}
// 40EB17: variable 'v6' is possibly undefined
// 40EB50: variable 'v12' is possibly undefined
// 40EBDE: variable 'v15' is possibly undefined

//----- (0040EBFB) --------------------------------------------------------
char __fastcall sub_40EBFB(_WORD *a1, int **a2, int **a3, const unsigned __int16 *a4, int a5, int a6, int a7)
{
  int **v7; // ebx
  int *v9; // ecx
  __int16 v10; // dx
  char v11; // bl
  __int16 v12; // di
  unsigned __int16 *v13; // esi
  int v14; // eax
  unsigned int v15; // kr00_4
  void *v16; // esp
  int *v17; // edi
  int v18; // edx
  int v19; // eax
  int v20; // ecx
  _DWORD *v21; // eax
  void *v22; // eax
  char v23; // al
  int **v24; // ecx
  void *v25; // eax
  int v26; // eax
  bool v27; // zf
  int v28; // eax
  wchar_t v30[6]; // [esp+0h] [ebp-23Ch] BYREF
  int v31[2]; // [esp+Ch] [ebp-230h] BYREF
  int **v32; // [esp+14h] [ebp-228h]
  int **v33; // [esp+18h] [ebp-224h]
  int *v34; // [esp+1Ch] [ebp-220h]
  unsigned __int16 *v35; // [esp+20h] [ebp-21Ch]
  int *v36; // [esp+24h] [ebp-218h] BYREF
  char v37; // [esp+2Ah] [ebp-212h]
  char v38; // [esp+2Bh] [ebp-211h]
  wchar_t v39[2]; // [esp+2Ch] [ebp-210h] BYREF
  __int16 v40[4]; // [esp+230h] [ebp-Ch] BYREF

  v7 = a3;
  v33 = a2;
  v32 = a3;
  v38 = 0;
  if ( !a2 )
  {
    v9 = 0;
    goto LABEL_9;
  }
  if ( a3 )
  {
    v9 = *a3;
LABEL_9:
    v36 = v9;
LABEL_10:
    v34 = v9;
    goto LABEL_11;
  }
  v9 = *a2;
  v34 = v9;
  v36 = v9;
  if ( v9 && *v9 )
  {
    do
    {
      v9 = (int *)*v9;
      v36 = v9;
    }
    while ( *v9 );
    goto LABEL_10;
  }
LABEL_11:
  if ( *a1 )
  {
    v10 = *a1;
    while ( 1 )
    {
      if ( !v10 )
        goto LABEL_86;
      v11 = v38;
      do
      {
        v12 = v10;
        if ( v10 == 36 )
          break;
        if ( v10 == 34 )
          v11 = v11 == 0;
        if ( !v11 && v10 == 94 )
          v11 = *++a1 == 34;
        v10 = *++a1;
        v12 = *a1;
      }
      while ( *a1 );
      v9 = v34;
      v38 = v11;
      v7 = v32;
      if ( !v12 )
        goto LABEL_86;
      v13 = a1 + 1;
      v37 = a7 & 4;
      if ( !*v13 )
      {
        if ( (a7 & 4) != 0 )
        {
          if ( v32 )
            *v32 = v34;
          return 0;
        }
        sub_4053D9(dword_4226B0, 0x3EAu);
        v37 = 0;
      }
      if ( !v38 && *v13 == 94 )
      {
        if ( !sub_4038CF(*++v13) && v37 )
        {
LABEL_91:
          if ( v7 )
            *v7 = v36;
          return 0;
        }
        sub_4053D9(dword_4226B0, 0x3E9u, *v13);
      }
      v14 = *v13;
      if ( (_WORD)v14 == 36 )
      {
        v13 = sub_40F20F(v13);
        goto LABEL_84;
      }
      if ( v14 == 40 )
      {
        v13 = sub_40F10D(v13 + 1, v39);
        v35 = v13;
        if ( wcschr(L"*@<?", v39[0]) )
        {
          if ( !byte_436640 || (byte_41248C & 0x40) != 0 )
            goto LABEL_84;
          v15 = wcslen(v39);
          v16 = alloca(2 * (v15 + 4));
          sub_40CC68(v30, v15 + 4, (wchar_t *)L"$(%s)", v39);
          sub_4053D9(0, 0x44Cu, v30, dword_436644);
          v13 = v35;
        }
      }
      else
      {
        if ( wcschr(L"*@<?", *v13) )
        {
          if ( !byte_436640 || (byte_41248C & 0x40) != 0 || *v13 == 60 )
            goto LABEL_84;
          v40[1] = *v13;
          v40[2] = 0;
          v40[0] = 36;
          sub_4053D9(0, 0x44Cu, v40, dword_436644);
        }
        if ( !sub_4038CF(*v13) )
        {
          if ( v37 )
            goto LABEL_91;
          sub_4053D9(dword_4226B0, 0x3EAu);
        }
        v39[0] = *v13;
        v39[1] = 0;
      }
      if ( v33 )
      {
        v17 = sub_40E8C7();
      }
      else
      {
        v31[0] = 0;
        v31[1] = (int)sub_40E919((char *)L" ");
        v17 = v31;
      }
      v18 = sub_40AB4F(v39);
      v35 = (unsigned __int16 *)v18;
      if ( v18 )
        break;
LABEL_67:
      v24 = v33;
      if ( v33 )
      {
        if ( !v18 || (*(_BYTE *)(v18 + 12) & 0x10) != 0 )
        {
          v25 = sub_40E919((char *)&dword_401690);
          v18 = (int)v35;
          v24 = v33;
          v17[1] = (int)v25;
        }
        *v17 = 0;
        if ( v36 )
          *v36 = (int)v17;
        else
          *v24 = v17;
        v9 = v17;
        v36 = v17;
      }
      else
      {
        v9 = v36;
      }
      v34 = v9;
      if ( !v18 )
        goto LABEL_85;
      if ( wcschr((const wchar_t *)v17[1], 0x24u) )
      {
        *((_BYTE *)v35 + 12) |= 1u;
        if ( !a4 )
          goto LABEL_82;
        v26 = wcscmp(a4, v39);
        if ( v26 )
          v26 = v26 < 0 ? -1 : 1;
        v27 = v26 == 0;
        v28 = a5;
        if ( v27 )
LABEL_82:
          v28 = a6;
        sub_40EBFB(&v36, v39, a5 + 1, v28, a7);
        *((_BYTE *)v35 + 12) &= ~1u;
      }
LABEL_84:
      v9 = v36;
      v34 = v36;
LABEL_85:
      a1 = v13 + 1;
      v10 = *a1;
      if ( !*a1 )
        goto LABEL_86;
    }
    if ( !a4 )
      goto LABEL_60;
    v19 = wcscmp(a4, v39);
    if ( v19 )
      v19 = v19 < 0 ? -1 : 1;
    v18 = (int)v35;
    if ( v19 )
    {
LABEL_60:
      v23 = *(_BYTE *)(v18 + 12);
      if ( (v23 & 1) != 0 )
      {
        if ( v37 )
          goto LABEL_91;
        sub_4053D9(dword_4226B0, 0x42Eu, v39);
        v18 = (int)v35;
        goto LABEL_67;
      }
      if ( (v23 & 0x10) != 0 )
        goto LABEL_59;
      v21 = *(_DWORD **)(v18 + 8);
    }
    else
    {
      v20 = a5;
      v21 = (_DWORD *)*((_DWORD *)v35 + 2);
      v7 = v32;
      if ( a5 != a6 )
      {
        while ( v21 )
        {
          v21 = (_DWORD *)*v21;
          if ( --v20 == a6 )
            goto LABEL_58;
        }
        goto LABEL_59;
      }
LABEL_58:
      if ( !v21 )
      {
LABEL_59:
        v22 = sub_40E919((char *)&dword_401690);
        v18 = (int)v35;
LABEL_66:
        v17[1] = (int)v22;
        goto LABEL_67;
      }
    }
    v22 = (void *)v21[1];
    goto LABEL_66;
  }
LABEL_86:
  if ( v7 )
    *v7 = v9;
  return 1;
}
// 401690: using guessed type int dword_401690;
// 41248C: using guessed type char byte_41248C;
// 4226B0: using guessed type int dword_4226B0;
// 436640: using guessed type char byte_436640;
// 436644: using guessed type int dword_436644;
// 40EBFB: using guessed type int *var_218;

//----- (0040F10D) --------------------------------------------------------
wint_t *__fastcall sub_40F10D(wint_t *a1, wint_t *a2)
{
  wint_t *v2; // esi
  wint_t *v3; // ebx
  wint_t *v4; // edi
  wint_t v5; // dx
  wint_t v6; // cx
  wint_t v7; // ax
  wint_t v8; // cx
  wint_t v9; // ax
  wint_t v10; // dx

  v2 = a1;
  v3 = a2;
  v4 = a2;
  v5 = *a1;
  if ( *a1 )
  {
    v6 = *a1;
    do
    {
      v5 = v6;
      if ( v6 == 41 )
        break;
      v5 = v6;
      if ( v6 == 58 )
        break;
      if ( v6 == 94 && !sub_4038CF(*++v2) )
        sub_4053D9(dword_4226B0, 0x3E9u, *v2);
      v7 = *v2++;
      *v4++ = v7;
      v6 = *v2;
      v5 = *v2;
    }
    while ( *v2 );
    v3 = a2;
  }
  if ( v5 != 41 )
  {
    v8 = v5;
    do
    {
      v9 = v8;
      if ( v8 == 94 )
        v9 = *++v2;
      v10 = v9;
      if ( !v9 )
        break;
      v8 = *++v2;
      v10 = *v2;
    }
    while ( *v2 != 41 );
    v3 = a2;
    if ( v10 != 41 )
      sub_4053D9(dword_4226B0, 0x3E8u);
  }
  *v4 = 0;
  if ( (int)(((char *)v4 - (char *)v3) & 0xFFFFFFFE) > 514 )
    sub_4053D9(dword_4226B0, 0x434u);
  return v2;
}
// 4226B0: using guessed type int dword_4226B0;

//----- (0040F20F) --------------------------------------------------------
_WORD *__thiscall sub_40F20F(_WORD *this)
{
  int v2; // eax
  _WORD *result; // eax
  int v4; // eax
  __int16 v5; // ax
  int v6; // eax
  __int16 v7; // ax
  bool v8; // zf

  if ( *this )
  {
    v2 = (unsigned __int16)this[1];
    if ( (_WORD)v2 == 94 )
      return this + 1;
    if ( v2 == 40 )
    {
      v4 = (unsigned __int16)this[2];
      if ( (_WORD)v4 == 94 || v4 != 64 )
        return this + 2;
      v5 = this[3];
      if ( v5 == 94 )
      {
        v6 = (unsigned __int16)this[4];
      }
      else
      {
        if ( v5 == 41 )
          return this + 3;
        if ( !wcschr(L"DFBR", this[3]) )
          return this;
        v7 = this[4];
        if ( v7 != 94 )
        {
          v8 = v7 == 41;
          result = this + 4;
          if ( v8 )
            return result;
          return this;
        }
        v6 = (unsigned __int16)this[5];
      }
      sub_4053D9(dword_4226B0, 0x3E9u, v6);
    }
  }
  return this;
}
// 4226B0: using guessed type int dword_4226B0;

//----- (0040F2A9) --------------------------------------------------------
wchar_t *__thiscall sub_40F2A9(wchar_t *Str)
{
  wchar_t *v1; // esi
  int *v2; // edi
  int *v3; // eax
  int v4; // ecx
  int *v6; // [esp+8h] [ebp-4h] BYREF

  v1 = Str;
  v6 = 0;
  if ( wcschr(Str, 0x24u) )
  {
    sub_40EBFB(v1, &v6, 0, 0, 0, 0, 0);
    v2 = v6;
    v1 = (wchar_t *)sub_40F311((__int16 *)v1, 255, &v6);
    v3 = v2;
    v6 = v2;
    if ( v2 )
    {
      v4 = dword_433618;
      do
      {
        v2 = (int *)*v2;
        *v3 = v4;
        v4 = (int)v3;
        v3 = v2;
        v6 = v2;
      }
      while ( v2 );
      dword_433618 = v4;
    }
  }
  return v1;
}
// 433618: using guessed type int dword_433618;

//----- (0040F311) --------------------------------------------------------
void *__fastcall sub_40F311(__int16 *a1, char a2, _DWORD *a3)
{
  __int16 *v3; // ebx
  bool v4; // dl
  char *v5; // edi
  __int16 v6; // ax
  char *v7; // esi
  wchar_t *(__cdecl *v8)(const wchar_t *, wchar_t); // edi
  __int16 v9; // cx
  __int16 v10; // ax
  wchar_t *v11; // esi
  wchar_t v12; // ax
  int v13; // eax
  unsigned __int16 *v14; // esi
  int v15; // eax
  _DWORD **v16; // ebx
  _DWORD *v17; // eax
  bool v18; // zf
  _DWORD *v19; // eax
  wchar_t *v20; // esi
  int v21; // esi
  void *v22; // ebx
  int v24; // [esp-4h] [ebp-844h]
  char v25; // [esp+13h] [ebp-82Dh]
  char *v26; // [esp+14h] [ebp-82Ch] BYREF
  char v27; // [esp+1Bh] [ebp-825h]
  char *v28; // [esp+1Ch] [ebp-824h] BYREF
  char v29; // [esp+23h] [ebp-81Dh]
  char *v30; // [esp+24h] [ebp-81Ch] BYREF
  unsigned int v31; // [esp+28h] [ebp-818h] BYREF
  __int16 *v32; // [esp+2Ch] [ebp-814h] BYREF
  int v33; // [esp+30h] [ebp-810h]
  _DWORD *v34; // [esp+34h] [ebp-80Ch]
  char Src[2048]; // [esp+38h] [ebp-808h] BYREF
  char v36; // [esp+838h] [ebp-8h] BYREF

  v34 = a3;
  v3 = a1;
  v29 = a2;
  v4 = 0;
  v27 = 0;
  v32 = a1;
  v5 = Src;
  v28 = &v36;
  v6 = *a1;
  v7 = Src;
  v25 = 0;
  v31 = 1024;
  v30 = Src;
  v26 = Src;
  if ( !v6 )
    goto LABEL_53;
  v8 = wcschr;
  v9 = v6;
  v33 = 34;
  while ( 1 )
  {
    if ( v9 )
    {
      do
      {
        if ( v9 == 36 )
          break;
        if ( v7 == v28 )
        {
          sub_40F673((const void **)&v30, &v26, &v28, &v31, Src);
          v7 = v26;
          v4 = v25;
        }
        v10 = *v3;
        if ( *v3 == 34 )
        {
          v4 = !v4;
          v25 = v4;
        }
        if ( !v4 && v10 == 94 )
        {
          *(_WORD *)v7 = 94;
          v7 += 2;
          v26 = v7;
          if ( v7 == v28 )
          {
            sub_40F673((const void **)&v30, &v26, &v28, &v31, Src);
            v7 = v26;
            v4 = v25;
          }
          v10 = *++v3;
          if ( *v3 == (_WORD)v33 )
          {
            v4 = 1;
            v25 = 1;
          }
        }
        ++v3;
        *(_WORD *)v7 = v10;
        v7 += 2;
        v32 = v3;
        v26 = v7;
        v9 = *v3;
      }
      while ( *v3 );
      v8 = wcschr;
    }
    if ( v7 == v28 )
    {
      sub_40F673((const void **)&v30, &v26, &v28, &v31, Src);
      v7 = v26;
    }
    if ( !*v3 )
      break;
    v11 = (wchar_t *)(v3 + 2);
    if ( v3[1] == 40 && v8(L"*@<?", *v11) )
    {
      sub_40F6E7((const void **)&v30, &v32, &v26, &v28, &v31, (char *)3, Src);
    }
    else
    {
      v12 = v3[1];
      if ( v12 == 36 )
      {
        v13 = *v11;
        if ( (_WORD)v13 != 94 && v29 == 1 )
        {
          if ( v13 == 64 )
          {
            v24 = 2;
LABEL_38:
            sub_40F6E7((const void **)&v30, &v32, &v26, &v28, &v31, (char *)v24, Src);
            goto LABEL_48;
          }
          if ( (_WORD)v13 == 40 )
            v11 = (wchar_t *)(v3 + 3);
          v14 = v11 + 1;
          v15 = *v14;
          if ( (v15 == 70 || v15 == 68 || v15 == 66 || v15 == 82) && v14[1] == 41 )
          {
            v24 = 4;
            goto LABEL_38;
          }
        }
        v24 = 5;
        goto LABEL_38;
      }
      if ( v8(L"*@<?", v12) )
      {
        sub_40F6E7((const void **)&v30, &v32, &v26, &v28, &v31, (char *)1, Src);
      }
      else
      {
        v16 = (_DWORD **)v34;
        v17 = (_DWORD *)*v34;
        if ( !*v34 )
        {
          sub_4053D9(dword_4226B0, 0x410u);
          v17 = *v16;
        }
        v18 = v8((const wchar_t *)v17[1], 0x24u) == 0;
        v19 = (_DWORD *)**v16;
        if ( v18 )
        {
          v20 = (wchar_t *)(*v16)[1];
          *v16 = v19;
        }
        else
        {
          *v16 = v19;
          v20 = (wchar_t *)sub_40F311(v16);
          v27 = 1;
        }
        sub_40FBAB((const void **)&v30, &v32, &v26, &v28, v20, &v31, Src);
        if ( v27 )
        {
          free(v20);
          v27 = 0;
        }
      }
    }
LABEL_48:
    v3 = v32;
    v7 = v26;
    v9 = *v32;
    if ( !*v32 )
      break;
    v4 = v25;
  }
  if ( v7 == v28 )
  {
    sub_40F673((const void **)&v30, &v26, &v28, &v31, Src);
    v7 = v26;
  }
  v5 = v30;
LABEL_53:
  *(_WORD *)v7 = 0;
  v21 = (v7 - v5 + 2) >> 1;
  v22 = sub_40ABE3((unsigned __int64)(unsigned int)v21 >> 31 != 0 ? -1 : 2 * v21);
  if ( !v22 )
    sub_4053D9(dword_4226B0, 0x419u);
  memcpy(v22, v5, 2 * v21);
  return v22;
}
// 4226B0: using guessed type int dword_4226B0;
// 40F311: using guessed type char *var_82C;

//----- (0040F673) --------------------------------------------------------
char **__fastcall sub_40F673(const void **a1, _DWORD *a2, char **a3, unsigned int *a4, const void *a5)
{
  unsigned int v6; // eax
  void *v7; // edi
  unsigned int v8; // esi
  char *v9; // eax
  unsigned int v10; // ecx
  char *v11; // ecx
  char **result; // eax

  v6 = *a4;
  v7 = (void *)*a1;
  if ( *a1 == a5 )
  {
    v7 = sub_40ABE3((unsigned __int64)v6 >> 31 != 0 ? -1 : 2 * v6);
    memcpy(v7, *a1, 2 * *a4);
    v6 = *a4;
    *a1 = v7;
  }
  v8 = v6 + 1024;
  v9 = (char *)sub_41069D(v7, v6 + 1024);
  *a1 = v9;
  v10 = *a4;
  *a4 = v8;
  *a2 = &v9[2 * v10];
  v11 = &v9[2 * v8];
  result = a3;
  *a3 = v11;
  return result;
}

//----- (0040F6E7) --------------------------------------------------------
void __fastcall sub_40F6E7(
        const void **a1,
        __int16 **a2,
        char **a3,
        char **a4,
        unsigned int *a5,
        char *a6,
        const void *a7)
{
  char *v8; // esi
  char v9; // bl
  int v10; // edx
  char *v11; // eax
  __int16 *v12; // edi
  __int16 v13; // dx
  __int16 v14; // si
  __int16 v15; // si
  char *v16; // ebx
  char *v17; // ecx
  unsigned __int16 *v18; // edi
  unsigned int v19; // kr00_4
  void *v20; // eax
  rsize_t v21; // edx
  wchar_t *v22; // eax
  wchar_t *v23; // ebx
  unsigned int v24; // ecx
  rsize_t v25; // edi
  wchar_t *v26; // eax
  char **v27; // [esp+10h] [ebp-34h]
  char *v29; // [esp+20h] [ebp-24h]
  char *v30; // [esp+20h] [ebp-24h]
  unsigned int v31; // [esp+24h] [ebp-20h] BYREF
  rsize_t v32; // [esp+28h] [ebp-1Ch]
  __int16 **v33; // [esp+2Ch] [ebp-18h]
  int v34; // [esp+30h] [ebp-14h]
  void *Block; // [esp+34h] [ebp-10h]
  char *v36; // [esp+38h] [ebp-Ch] BYREF
  char *v37; // [esp+3Ch] [ebp-8h] BYREF
  char v38; // [esp+42h] [ebp-2h]
  char v39; // [esp+43h] [ebp-1h]

  v29 = 0;
  v8 = 0;
  v39 = 0;
  v9 = 0;
  v38 = 0;
  Block = 0;
  v10 = 1;
  v32 = 0;
  v33 = a2;
  v34 = 1;
  if ( a6 == (char *)1 )
    goto LABEL_12;
  if ( a6 != (char *)2 )
  {
    if ( a6 != (char *)3 )
    {
      if ( a6 != (char *)4 )
      {
        if ( a6 == (char *)5 )
        {
          v11 = *a3;
          if ( *a3 == *a4 )
          {
            sub_40F673(a1, a3, a4, a5, a7);
            v11 = *a3;
          }
          *(_WORD *)v11 = 36;
          *a2 += 2;
          *a3 = v11 + 2;
        }
        return;
      }
      v34 = 4;
      v39 = 1;
      goto LABEL_10;
    }
    v10 = 2;
    v39 = 1;
LABEL_12:
    if ( (*a2)[v10] == 42 )
    {
      if ( (*a2)[v10 + 1] == 42 )
      {
        v8 = (char *)dword_422EC4;
        ++v10;
LABEL_22:
        v9 = 1;
        goto LABEL_23;
      }
      v8 = (char *)dword_422ED8;
      v38 = 1;
    }
    else
    {
      if ( (*a2)[v10] != 60 )
      {
        if ( (*a2)[v10] != 63 )
        {
          if ( (*a2)[v10] == 64 )
            v8 = (char *)dword_422ED4;
          goto LABEL_23;
        }
        v8 = (char *)dword_422ED0;
        goto LABEL_22;
      }
      v8 = (char *)dword_422ECC;
    }
LABEL_23:
    v34 = v10 + 1;
    goto LABEL_24;
  }
LABEL_10:
  v8 = (char *)dword_422EC8;
LABEL_24:
  if ( !v8 )
  {
    v12 = *a2;
    v13 = *v12;
    if ( *v12 )
    {
      v14 = *v12;
      do
      {
        v13 = v14;
        if ( v14 == 32 )
          break;
        if ( v14 == 9 )
          break;
        v14 = *++v12;
        v13 = *v12;
      }
      while ( *v12 );
    }
    v15 = v13;
    *v12 = 0;
    sub_4053D9(dword_4226B0, 0xFA6u, *v33);
    *v12 = v15;
    v9 = 0;
    v8 = (char *)sub_40E919((char *)&dword_401690);
    v29 = v8;
  }
  if ( v9 )
  {
    v16 = v8;
    v31 = 1024;
    v30 = v8;
    v8 = (char *)sub_40ABE3(0x800u);
    v36 = v8;
    a6 = v8;
    v17 = v8 + 2048;
    v37 = v8 + 2048;
    if ( v16 )
    {
      do
      {
        v18 = (unsigned __int16 *)*((_DWORD *)v16 + 1);
        v27 = (char **)v16;
        if ( v39 )
        {
          v19 = wcslen(v18);
          v20 = Block;
          v21 = v19 + 1;
          if ( v19 + 1 > v32 )
          {
            if ( Block )
            {
              free(Block);
              v21 = v19 + 1;
            }
            v32 = v21;
            v20 = sub_40ABE3((unsigned __int64)v21 >> 31 != 0 ? -1 : 2 * v21);
            Block = v20;
          }
          v22 = sub_40FA53((*v33)[v34], (wchar_t *)v20, v32, v18);
          v17 = v37;
          v18 = v22;
        }
        if ( *v18 )
        {
          do
          {
            if ( v8 == v17 )
            {
              sub_40F673((const void **)&v36, &a6, &v37, &v31, 0);
              v8 = a6;
              v17 = v37;
            }
            *(_WORD *)v8 = *v18++;
            v8 += 2;
            a6 = v8;
          }
          while ( *v18 );
          v16 = v30;
        }
        if ( v8 == v17 )
        {
          sub_40F673((const void **)&v36, &a6, &v37, &v31, 0);
          v8 = a6;
          v17 = v37;
        }
        *(_WORD *)v8 = 0;
        v16 = *(char **)v16;
        v30 = v16;
        if ( v16 )
        {
          *(_WORD *)v8 = 32;
          v8 += 2;
          a6 = v8;
          if ( v8 == v17 )
          {
            sub_40F673((const void **)&v36, &a6, &v37, &v31, 0);
            v8 = a6;
            v17 = v37;
          }
          *(_WORD *)v8 = 0;
          v16 = *v27;
          v30 = *v27;
        }
      }
      while ( v16 );
      v8 = v36;
    }
    v23 = (wchar_t *)Block;
    v29 = v8;
  }
  else
  {
    v24 = wcslen((const unsigned __int16 *)v8);
    v25 = v24 + 1;
    if ( !v24 )
      v25 = 2;
    v26 = (wchar_t *)sub_40ABE3((unsigned __int64)v25 >> 31 != 0 ? -1 : 2 * v25);
    v23 = v26;
    if ( v38 )
      v8 = (char *)sub_40FA53(82, v26, v25, (wchar_t *)v8);
    if ( v39 )
      v8 = (char *)sub_40FA53((*v33)[v34], v23, v25, (wchar_t *)v8);
  }
  sub_40FBAB(a1, v33, a3, a4, (wchar_t *)v8, a5, a7);
  if ( v29 )
    free(v29);
  if ( v23 )
    free(v23);
}
// 401690: using guessed type int dword_401690;
// 4226B0: using guessed type int dword_4226B0;
// 422EC4: using guessed type int dword_422EC4;
// 422EC8: using guessed type int dword_422EC8;
// 422ED0: using guessed type int dword_422ED0;
// 422ED8: using guessed type int dword_422ED8;

//----- (0040FA53) --------------------------------------------------------
wchar_t *__fastcall sub_40FA53(__int16 a1, wchar_t *a2, rsize_t SizeInWords, wchar_t *Source)
{
  wchar_t *v4; // esi
  wchar_t *v5; // ebx
  wchar_t *v6; // edi
  wchar_t *i; // eax
  int v8; // ecx
  int v9; // eax
  wchar_t *v10; // eax
  unsigned __int16 Sourcea; // [esp+24h] [ebp+Ch]

  v4 = a2;
  v5 = 0;
  v6 = 0;
  if ( wcscpy_s(a2, SizeInWords, Source) )
    sub_4053D9(dword_4226B0, 0x410u);
  Sourcea = *v4;
  for ( i = &v4[wcslen(v4) - 1]; i >= v4; --i )
  {
    v8 = *i;
    if ( v8 == 92 || v8 == 47 )
    {
      v6 = i;
      break;
    }
    if ( v8 == 46 && !v5 )
      v5 = i;
  }
  if ( a1 == 66 )
  {
    if ( v5 )
      *v5 = 0;
LABEL_30:
    if ( v6 )
    {
      v4 = v6 + 1;
    }
    else if ( v4[1] == 58 )
    {
      v4 += 2;
    }
    goto LABEL_34;
  }
  if ( a1 != 68 )
  {
    if ( a1 != 70 )
    {
      if ( a1 == 82 && v5 )
        *v5 = 0;
      goto LABEL_34;
    }
    goto LABEL_30;
  }
  v9 = v4[1];
  if ( v6 )
  {
    if ( v9 == 58 && v6 == v4 + 2 )
      ++v6;
    *v6 = 0;
  }
  else if ( v9 == 58 )
  {
    v4[2] = 0;
  }
  else if ( wcscpy_s(v4, SizeInWords, L".") )
  {
    sub_4053D9(dword_4226B0, 0x410u);
  }
LABEL_34:
  if ( Sourcea == 34 )
  {
    if ( *v4 != 34 && v4 > a2 )
      *--v4 = 34;
    v10 = wcschr(v4, 0);
    if ( *(v10 - 1) != 34 )
      *(_DWORD *)v10 = 34;
  }
  return v4;
}
// 4226B0: using guessed type int dword_4226B0;

//----- (0040FBAB) --------------------------------------------------------
__int16 *__fastcall sub_40FBAB(
        const void **a1,
        __int16 **a2,
        char **a3,
        char **a4,
        wchar_t *String1,
        unsigned int *a6,
        const void *a7)
{
  __int16 **v7; // esi
  const wchar_t *v8; // eax
  __int16 *v9; // eax
  __int16 *v10; // ecx
  __int16 *v11; // ebx
  __int16 *v12; // edx
  __int16 v13; // di
  __int16 v14; // ax
  __int16 *result; // eax
  wchar_t *v16; // edi
  char *v17; // ecx
  __int16 v18; // ax
  __int16 v19; // dx
  __int16 *v22; // [esp+18h] [ebp-4h] BYREF

  v7 = a2;
  v8 = (const wchar_t *)++*a2;
  if ( **a2 == 94 )
    *a2 = (__int16 *)++v8;
  v9 = (__int16 *)wcschr(v8, 0x3Au);
  v10 = *v7;
  v11 = v9;
  v12 = *v7;
  v22 = v9;
  if ( *v12 )
  {
    v13 = *v12;
    do
    {
      if ( v13 == 41 )
        break;
      if ( v13 == 94 )
        ++v12;
      v13 = *++v12;
    }
    while ( *v12 );
    v7 = a2;
    v11 = v22;
  }
  v14 = *v10;
  if ( *v10 == 40 && v11 && v11 < v12 )
  {
    sub_40FCDB(a1, &v22, a3, a4, String1, a6, a7);
    result = v22;
  }
  else
  {
    v16 = String1;
    if ( *String1 )
    {
      v17 = *a3;
      do
      {
        if ( v17 == *a4 )
        {
          sub_40F673(a1, a3, a4, a6, a7);
          v17 = *a3;
        }
        v18 = *v16++;
        *(_WORD *)v17 = v18;
        v17 += 2;
        *a3 = v17;
      }
      while ( *v16 );
      v7 = a2;
      v10 = *a2;
      v14 = **a2;
    }
    v19 = v14;
    if ( v14 == 36 )
    {
      *v7 = ++v10;
      v19 = *v10;
    }
    if ( v19 == 40 )
    {
      do
        v10 = ++*v7;
      while ( **v7 != 41 );
    }
    else if ( v19 == 42 && v10[1] == 42 )
    {
      ++v10;
    }
    result = v10 + 1;
  }
  *v7 = result;
  return result;
}

//----- (0040FCDB) --------------------------------------------------------
void __fastcall sub_40FCDB(
        const void **a1,
        __int16 **a2,
        char **a3,
        char **a4,
        wchar_t *String1,
        unsigned int *a6,
        const void *a7)
{
  __int16 *i; // edi
  __int16 v9; // ax
  __int16 v10; // ax
  __int16 *v11; // ebx
  __int16 v12; // dx
  _WORD *v13; // eax
  __int16 *v14; // esi
  _WORD *v15; // edx
  __int16 j; // cx
  char *v17; // ecx
  char *v18; // edx
  __int16 v19; // ax
  __int16 *v20; // esi
  _WORD *v21; // ecx
  __int16 v22; // dx
  __int16 v23; // ax
  wchar_t *v24; // edi
  wchar_t v25; // ax
  size_t v26; // esi
  _WORD *v27; // ebx
  char *v28; // ecx
  int v29; // eax
  char *v30; // ecx
  _WORD *Block; // [esp+10h] [ebp-1Ch]
  __int16 *v34; // [esp+18h] [ebp-14h]
  int MaxCount; // [esp+1Ch] [ebp-10h]
  wchar_t *String2; // [esp+20h] [ebp-Ch]

  for ( i = ++*a2; ; ++i )
  {
    v9 = *i;
    if ( !*i )
      break;
    if ( v9 == 61 )
      goto LABEL_8;
    if ( v9 == 94 )
      ++i;
  }
  sub_4053D9(dword_4226A4, 0x3EBu);
LABEL_8:
  if ( i == *a2 )
    sub_4053D9(dword_4226A4, 0x3EDu);
  v10 = *i;
  v11 = i;
  v34 = i;
  v12 = *i;
  if ( *i )
  {
    while ( v10 != 41 )
    {
      if ( v10 == 94 )
        ++v11;
      v34 = ++v11;
      v10 = *v11;
      v12 = *v11;
      if ( !*v11 )
        goto LABEL_15;
    }
  }
  else
  {
LABEL_15:
    if ( v12 != 41 )
      sub_4053D9(dword_4226A4, 0x3E8u);
  }
  v13 = sub_40ABE3((unsigned __int64)(unsigned int)(i - *a2 + 1) >> 31 != 0 ? -1 : 2 * (i - *a2 + 1));
  v14 = *a2;
  v15 = v13;
  String2 = v13;
  for ( j = *v14; *v14 != 61; j = *v14 )
  {
    if ( j == 94 )
      ++v14;
    *v15++ = *v14++;
  }
  *v15 = 0;
  v17 = (char *)v13;
  v18 = (char *)(v13 + 1);
  do
  {
    v19 = *(_WORD *)v17;
    v17 += 2;
  }
  while ( v19 );
  MaxCount = (v17 - v18) >> 1;
  v20 = v14 + 1;
  Block = sub_40ABE3((unsigned __int64)(unsigned int)(v11 - i) >> 31 != 0 ? -1 : 2 * (v11 - i));
  v21 = Block;
  v22 = *v20;
  if ( *v20 != 41 )
  {
    do
    {
      if ( v22 == 94 )
        ++v20;
      v23 = *v20++;
      *v21++ = v23;
      v22 = *v20;
    }
    while ( *v20 != 41 );
    v11 = v34;
  }
  v24 = String1;
  *v21 = 0;
  *a2 = v11 + 1;
  v25 = *String1;
  if ( *String1 )
  {
    v26 = MaxCount;
    do
    {
      if ( v25 == *String2 && !wcsncmp(v24, String2, v26) )
      {
        v27 = Block;
        if ( *Block )
        {
          v28 = *a3;
          do
          {
            if ( v28 == *a4 )
            {
              sub_40F673(a1, a3, a4, a6, a7);
              v28 = *a3;
            }
            *(_WORD *)v28 = *v27;
            v28 += 2;
            ++v27;
            *a3 = v28;
          }
          while ( *v27 );
          v26 = MaxCount;
          v24 = String1;
        }
        v29 = 2 * v26;
      }
      else
      {
        v30 = *a3;
        if ( *a3 == *a4 )
        {
          sub_40F673(a1, a3, a4, a6, a7);
          v30 = *a3;
        }
        *(_WORD *)v30 = *v24;
        *a3 = v30 + 2;
        v29 = 2;
      }
      v24 = (wchar_t *)((char *)v24 + v29);
      String1 = v24;
      v25 = *v24;
    }
    while ( *v24 );
  }
  free(String2);
  free(Block);
}
// 4226A4: using guessed type int dword_4226A4;

//----- (0040FF33) --------------------------------------------------------
void *__fastcall sub_40FF33(wchar_t *FullPath, wchar_t *Filename)
{
  wchar_t Buffer[260]; // [esp+8h] [ebp-418h] BYREF
  wchar_t Dir[258]; // [esp+210h] [ebp-210h] BYREF
  wchar_t Drive[4]; // [esp+414h] [ebp-Ch] BYREF

  wsplitpath_s(FullPath, Drive, 3u, Dir, 0x100u, 0, 0, 0, 0);
  wmakepath_s(Buffer, 0x104u, Drive, Dir, Filename, 0);
  return sub_40E919((char *)Buffer);
}

//----- (0040FFA7) --------------------------------------------------------
char __thiscall sub_40FFA7(_WORD *this)
{
  _WORD *v1; // edx
  char v2; // bl
  __int16 v3; // cx
  __int16 v4; // si
  __int16 v5; // cx
  _WORD *v6; // ecx
  __int16 v7; // si
  _WORD *v8; // edx
  _WORD *v9; // ecx
  __int16 v10; // si
  __int16 v11; // dx
  const wchar_t *v12; // esi
  wchar_t *v13; // eax
  _WORD *v15; // [esp+14h] [ebp-4h]

  v1 = this;
  v2 = 0;
  v15 = this;
  v3 = *this;
  if ( v3 == 123 )
  {
    v15 = ++v1;
    v4 = *v1;
    if ( *v1 )
    {
      v5 = *v1;
      do
      {
        v4 = v5;
        if ( v5 == 125 )
          break;
        if ( v5 == 94 )
          ++v1;
        v5 = *++v1;
        v4 = *v1;
      }
      while ( *v1 );
      v15 = v1;
      v2 = 0;
    }
    v3 = v4;
    if ( v4 )
    {
      v15 = ++v1;
      v3 = *v1;
    }
  }
  if ( v3 == 46 )
  {
    v6 = v1;
    v7 = 46;
    do
    {
      if ( v7 == 123 )
        break;
      if ( v7 == 94 )
        ++v6;
      v7 = *++v6;
    }
    while ( *v6 );
    v8 = v15;
    v2 = 0;
    while ( v8 < v6 && *v8 != 92 && *v8 != 47 )
      ++v8;
    if ( !*v6 || v8 != v6 )
    {
      v13 = wcspbrk(v15 + 1, L"./\\");
      if ( !v13 || *v13 != 46 )
        return v2;
      v12 = v13 + 1;
      goto LABEL_37;
    }
    v9 = v6 + 1;
    v10 = *v9;
    if ( *v9 )
    {
      v11 = *v9;
      do
      {
        v10 = v11;
        if ( v11 == 125 )
          break;
        if ( v11 == 94 )
          ++v9;
        v11 = *++v9;
        v10 = *v9;
      }
      while ( *v9 );
      v2 = 0;
    }
    if ( v10 && v9[1] == 46 )
    {
      v12 = v9 + 2;
LABEL_37:
      if ( !wcschr(v12, 0x2Fu) && !wcschr(v12, 0x5Cu) )
      {
        if ( wcschr(v12, 0x2Eu) )
          sub_4053D9(dword_4226B0, 0x444u);
        else
          return 1;
      }
    }
  }
  return v2;
}
// 4226B0: using guessed type int dword_4226B0;

//----- (00410126) --------------------------------------------------------
char __fastcall sub_410126(char *a1, int a2, unsigned __int16 *a3, const wchar_t *a4)
{
  unsigned __int16 *v4; // edi
  char *v5; // esi
  unsigned __int16 v6; // ax
  char *v7; // ebx
  unsigned __int16 *v8; // ecx
  int v9; // eax
  char v10; // bh
  char v11; // bl
  unsigned __int16 *v12; // edx
  const wchar_t *v13; // eax
  unsigned int v14; // kr00_4
  const wchar_t *v15; // ebx
  unsigned int v16; // kr04_4
  unsigned int v17; // kr08_4
  int v18; // ecx
  const wchar_t *j; // eax
  char result; // al
  unsigned int i; // [esp+14h] [ebp-21Ch]
  char v22; // [esp+1Eh] [ebp-212h]
  char v23; // [esp+1Fh] [ebp-211h]
  wchar_t Drive[262]; // [esp+20h] [ebp-210h] BYREF

  v4 = a3;
  v5 = a1;
  v6 = *a3;
  v7 = &a1[2 * a2];
  for ( i = (unsigned int)v7; *v4; v6 = *v4 )
  {
    v8 = v4;
    if ( v5 >= v7 )
      return 1;
    if ( v6 == 37 )
    {
      v9 = *++v4;
      if ( !(_WORD)v9 )
      {
        v4 = v8;
        goto LABEL_55;
      }
      if ( (_WORD)v9 == 37 )
      {
        *(_WORD *)v5 = 37;
        goto LABEL_11;
      }
      if ( v9 == 115 )
      {
        for ( j = a4; j; ++j )
        {
          if ( !*j )
            break;
          if ( v5 >= v7 )
            break;
          *(_WORD *)v5 = *j;
          v5 += 2;
        }
        goto LABEL_55;
      }
      if ( *v4 == 124 )
      {
        v22 = 0;
        v10 = 0;
        v23 = 0;
        v11 = 0;
        Drive[0] = 0;
        do
        {
          v12 = v4++;
          switch ( *v4 )
          {
            case 0u:
              v4 = v12;
LABEL_43:
              v7 = (char *)i;
              while ( v8 <= v4 && (unsigned int)v5 < i )
              {
                *(_WORD *)v5 = *v8;
                v5 += 2;
                ++v8;
              }
              goto LABEL_55;
            case 0x46u:
              if ( *(v4 - 1) == 124 )
              {
                v11 = 1;
                v10 = 1;
                v23 = 1;
                v22 = 1;
              }
              break;
            case 0x64u:
              v11 = 1;
              break;
            case 0x65u:
              v22 = 1;
              break;
            case 0x66u:
              v23 = 1;
              break;
            case 0x70u:
              v10 = 1;
              break;
            default:
              goto LABEL_43;
          }
        }
        while ( *v4 != 70 );
        v13 = a4;
        if ( !a4 )
        {
          sub_4053D9(0, 0x449u);
          v13 = 0;
        }
        if ( v11 )
          wsplitpath_s(v13, Drive, 0x104u, 0, 0, 0, 0, 0, 0);
        if ( v10 )
        {
          v14 = wcslen(Drive);
          v15 = a4;
          wsplitpath_s(a4, 0, 0, &Drive[v14], 260 - v14, 0, 0, 0, 0);
        }
        else
        {
          v15 = a4;
        }
        if ( v23 )
        {
          v16 = wcslen(Drive);
          wsplitpath_s(v15, 0, 0, 0, 0, &Drive[v16], 260 - v16, 0, 0);
        }
        if ( v22 )
        {
          v17 = wcslen(Drive);
          wsplitpath_s(v15, 0, 0, 0, 0, 0, 0, &Drive[v17], 260 - v17);
        }
        v7 = (char *)i;
        if ( Drive[0] )
        {
          v18 = (char *)Drive - v5;
          do
          {
            if ( (unsigned int)v5 >= i )
              break;
            *(_WORD *)v5 = *(_WORD *)&v5[v18];
            v5 += 2;
          }
          while ( *(_WORD *)&v5[v18] );
        }
        goto LABEL_55;
      }
      *(_WORD *)v5 = 37;
      v5 += 2;
      if ( v5 == v7 )
        return 1;
      v6 = *v4;
    }
    *(_WORD *)v5 = v6;
LABEL_11:
    v5 += 2;
LABEL_55:
    ++v4;
  }
  if ( v5 >= v7 )
    return 1;
  result = 0;
  *(_WORD *)v5 = 0;
  return result;
}
// 410126: using guessed type wchar_t Drive[262];

//----- (00410424) --------------------------------------------------------
_DWORD *__thiscall sub_410424(wint_t *this, int a2)
{
  _DWORD *v2; // edi
  wint_t *v3; // ebx
  wint_t *v4; // eax
  wint_t v5; // cx
  wint_t v6; // si
  bool v7; // zf
  wint_t *v9; // [esp+Ch] [ebp-8h]
  _DWORD *v10; // [esp+10h] [ebp-4h]
  wint_t *v11; // [esp+1Ch] [ebp+8h]

  v2 = (_DWORD *)dword_422490[a2];
  v9 = this;
  v10 = v2;
  if ( !v2 )
    return 0;
  while ( 1 )
  {
    v3 = this;
    v4 = (wint_t *)v2[1];
    v11 = v4;
    if ( *this )
    {
      do
      {
        v5 = *v4;
        if ( !*v4 )
          break;
        if ( *v3 == 92 || *v3 == 47 )
        {
          if ( v5 != 92 && v5 != 47 )
            break;
        }
        else
        {
          v6 = towupper(*v4);
          v7 = towupper(*v3) == v6;
          v4 = v11;
          if ( !v7 )
            break;
        }
        ++v3;
        v11 = ++v4;
      }
      while ( *v3 );
      v2 = v10;
      this = v9;
    }
    if ( !*v3 && !*v4 )
      return v2;
    v2 = (_DWORD *)*v2;
    v10 = v2;
    if ( !v2 )
      return 0;
  }
}
// 422490: using guessed type int dword_422490[128];

//----- (004104DC) --------------------------------------------------------
int __fastcall sub_4104DC(_WORD *a1, __int16 *a2)
{
  char *v3; // esi
  _WORD *v4; // edx
  void *v6; // esp
  __int16 *v7; // ecx
  __int16 v8; // ax
  void *v9; // esp
  wchar_t v10; // ax
  wchar_t v11; // cx
  wchar_t *v12; // eax
  int v13; // esi
  __int16 v14; // si
  wchar_t v15; // cx
  wchar_t *v16; // eax
  int v17; // edi
  wchar_t v19[6]; // [esp+0h] [ebp-14h] BYREF
  int v20; // [esp+Ch] [ebp-8h]

  v3 = (char *)a1;
  v20 = 0;
  v4 = a1 + 1;
  while ( *a1++ )
    ;
  v6 = alloca(2 * (a1 - v4) + 2);
  v7 = a2;
  do
    v8 = *v7++;
  while ( v8 != (_WORD)v20 );
  v9 = alloca(2 * (v7 - (a2 + 1)) + 2);
  v10 = *(_WORD *)v3;
  v20 = 34;
  v11 = v10;
  if ( v10 == 34 )
  {
    v3 += 2;
    v11 = *(_WORD *)v3;
  }
  v12 = v19;
  if ( v11 )
  {
    v13 = v3 - (char *)v19;
    do
    {
      *v12++ = v11;
      v11 = *(wchar_t *)((char *)v12 + v13);
    }
    while ( v11 );
    v14 = v20;
    if ( v12 != v19 && *(v12 - 1) == (_WORD)v20 )
      --v12;
  }
  else
  {
    v14 = v20;
  }
  *v12 = 0;
  v15 = *a2;
  if ( *a2 == v14 )
    v15 = *++a2;
  v16 = v19;
  if ( v15 )
  {
    v17 = (char *)a2 - (char *)v19;
    do
    {
      *v16++ = v15;
      v15 = *(wchar_t *)((char *)v16 + v17);
    }
    while ( v15 );
    if ( v16 != v19 && *(v16 - 1) == v14 )
      --v16;
  }
  *v16 = 0;
  return wcsicmp(v19, v19);
}

//----- (004105E0) --------------------------------------------------------
_WORD *__fastcall sub_4105E0(_WORD *a1)
{
  char *v1; // esi
  _WORD *v2; // edx
  __int64 v4; // rax
  _WORD *v5; // edx
  __int16 v6; // ax
  _WORD *v7; // ecx
  int v8; // esi
  __int16 v9; // di

  v1 = (char *)a1;
  v2 = a1 + 1;
  while ( *a1++ )
    ;
  v4 = 2i64 * (unsigned int)(a1 - v2 + 1);
  v5 = sub_40ABE3(HIDWORD(v4) != 0 ? -1 : v4);
  v6 = *(_WORD *)v1;
  if ( *(_WORD *)v1 == 34 )
  {
    v1 += 2;
    v6 = *(_WORD *)v1;
  }
  v7 = v5;
  if ( v6 )
  {
    v8 = v1 - (char *)v5;
    v9 = v6;
    do
    {
      *v7++ = v9;
      v9 = *(_WORD *)((char *)v7 + v8);
    }
    while ( v9 );
  }
  if ( *(v7 - 1) == 34 )
    --v7;
  *v7 = 0;
  return v5;
}

//----- (00410655) --------------------------------------------------------
FILE *__fastcall sub_410655(wchar_t *FileName, wchar_t *Mode)
{
  wchar_t *v4; // eax
  wchar_t *v5; // edx
  wchar_t v6; // ax
  wchar_t *v7; // ecx

  if ( *FileName == 34 )
  {
    v4 = wcsrchr(FileName, 0x22u);
    v5 = FileName + 1;
    *v4 = 0;
    v6 = FileName[1];
    *FileName = v6;
    while ( v6 )
    {
      v7 = v5++;
      v6 = *v5;
      *v7 = *v5;
    }
  }
  return wfsopen(FileName, Mode, 32);
}

//----- (0041069D) --------------------------------------------------------
void *__fastcall sub_41069D(void *Block, unsigned int a2)
{
  void *v2; // esi
  void *v3; // eax

  v2 = 0;
  if ( Block )
  {
    if ( a2 <= 0x7FFFFFFC )
    {
      v3 = realloc(Block, 2 * a2);
      goto LABEL_6;
    }
LABEL_7:
    sub_4053D9(dword_4226B0, 0x41Bu);
    return v2;
  }
  if ( a2 > 0x7FFFFFFC )
    goto LABEL_7;
  v3 = malloc(2 * a2);
LABEL_6:
  v2 = v3;
  if ( !v3 )
    goto LABEL_7;
  return v2;
}
// 4226B0: using guessed type int dword_4226B0;

//----- (004106E9) --------------------------------------------------------
WCHAR *__thiscall sub_4106E9(wchar_t *FullPath)
{
  WCHAR *result; // eax
  wchar_t *v3; // esi
  _DWORD *v4; // edi
  _DWORD *v5; // esi
  void *v6; // eax
  WCHAR *Filename; // [esp+10h] [ebp-260h]
  HANDLE hFindFile; // [esp+14h] [ebp-25Ch] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+18h] [ebp-258h] BYREF

  result = sub_407A35(FullPath, &FindFileData, &hFindFile);
  v3 = result;
  if ( result )
  {
    v4 = sub_40E8C7();
    v4[1] = sub_40FF33(FullPath, v3);
    while ( 1 )
    {
      Filename = sub_407BC1(&FindFileData, hFindFile);
      if ( !Filename )
        break;
      v5 = sub_40E8C7();
      v6 = sub_40FF33(FullPath, Filename);
      *v5 = v4;
      v4 = v5;
      v5[1] = v6;
    }
    return (WCHAR *)v4;
  }
  return result;
}

//----- (00410820) --------------------------------------------------------
int sub_410820()
{
  __scrt_initialize_default_local_stdio_options();
  return 0;
}
// 410F47: using guessed type int __scrt_initialize_default_local_stdio_options(void);

//----- (00410F0A) --------------------------------------------------------
int __cdecl UserMathErrorFunction()
{
  return 0;
}

//----- (00410F0D) --------------------------------------------------------
int sub_410F0D()
{
  return 1;
}

//----- (00410F17) --------------------------------------------------------
void sub_410F17()
{
  InitializeSListHead(&ListHead);
}

//----- (00410F23) --------------------------------------------------------
char sub_410F23()
{
  return 1;
}

//----- (00410F64) --------------------------------------------------------
BOOL sub_410F64()
{
  return dword_412004 == 0;
}
// 412004: using guessed type int dword_412004;

//----- (00410F70) --------------------------------------------------------
void *sub_410F70()
{
  return &unk_4372E4;
}

//----- (00410F76) --------------------------------------------------------
void *sub_410F76()
{
  return &unk_4372E0;
}

//----- (004110DE) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_4110DE()
{
  return SetUnhandledExceptionFilter(__scrt_unhandled_exception_filter);
}

//----- (0041112B) --------------------------------------------------------
void sub_41112B()
{
  dword_412468 = 0;
}
// 412468: using guessed type int dword_412468;

//----- (00411133) --------------------------------------------------------
void sub_411133()
{
  ;
}
// 411133: could not find valid save-restore pair for edi

//----- (0041115F) --------------------------------------------------------
void __cdecl sub_41115F()
{
  ;
}
// 41115F: could not find valid save-restore pair for edi

//----- (0041142A) --------------------------------------------------------
int sub_41142A()
{
  _DWORD *v0; // eax
  int v1; // ecx
  _DWORD *v2; // eax
  int v3; // ecx

  v0 = sub_40CC62();
  v1 = v0[1];
  *v0 |= 4u;
  v0[1] = v1;
  v2 = sub_40CD10();
  v3 = v2[1];
  *v2 |= 2u;
  v2[1] = v3;
  return 0;
}

// nfuncs=252 queued=188 decompiled=188 lumina nreq=0 worse=0 better=0
// ALL OK, 188 function(s) have been successfully decompiled
