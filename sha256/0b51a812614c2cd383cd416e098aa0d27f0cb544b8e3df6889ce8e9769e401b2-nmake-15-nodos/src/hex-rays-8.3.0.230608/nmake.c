/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

char *sub_401000();
_DWORD *sub_401030();
void sub_401170();
_DWORD *sub_401230();
int __stdcall sub_401310(unsigned __int8 *Str1); // idb
void __stdcall sub_4013D0(unsigned __int8 *Control, int *a2, int a3);
_BYTE *__stdcall sub_401550(_BYTE **a1);
int sub_4015E0();
int sub_401710();
int sub_401870();
int __stdcall sub_401980(char *VarName, unsigned __int8 *Str, char a3);
int __stdcall sub_4019F0(char *VarName, unsigned __int8 *Str, char a3); // idb
int __stdcall sub_401BC0(int a1);
void __stdcall sub_401BF0(char *Block, int a2, int *a3);
_DWORD *sub_401CC0();
void __stdcall sub_401D00(_DWORD *a1, _DWORD *a2);
int __stdcall sub_401E00(const char *a1, const char *a2);
_DWORD *__stdcall sub_401ED0(int a1);
int sub_401F10();
int __stdcall sub_402080(unsigned __int8 *Str1, char a2, unsigned int *a3, char *a4);
int __stdcall sub_4020E0(int a1, char a2, unsigned int *a3, int a4, char *a5);
_DWORD *__stdcall sub_402870(int *a1, int a2);
unsigned int __stdcall sub_402AE0(_DWORD **a1, _DWORD *a2);
int __stdcall sub_402B20(_BYTE **a1, _DWORD *a2);
_DWORD *__stdcall sub_402C40(_DWORD *a1);
_DWORD *__stdcall sub_402C70(char *a1, char a2);
void __stdcall sub_402CC0(unsigned __int8 *String);
char *__stdcall sub_402E60(void **a1, char **a2);
void __stdcall sub_402F60(unsigned __int8 *Str, int *a2, void **a3);
unsigned __int8 *__stdcall sub_403120(unsigned __int8 *Str, int *a2, void **a3);
char *__stdcall sub_4031B0(const char *a1, int a2, void **a3);
int sub_403220(int a1, unsigned int a2, ...);
FILE *sub_403370(unsigned int a1, ...);
int __cdecl nullsub_1(_DWORD, _DWORD);
char *__stdcall sub_403410(int a1);
void sub_403420();
FILE *sub_403490();
void __stdcall sub_403580(unsigned int *a1, const unsigned __int8 **a2, unsigned __int8 *Str);
unsigned int __stdcall sub_4036C0(unsigned __int8 *a1, int **a2, int a3, char a4, char *a5);
intptr_t __stdcall sub_403AF0(char *String, int a2, int a3, int a4, char **a5);
char *sub_404180();
int __stdcall sub_4043A0(unsigned __int8 *String, int *a2, int *a3);
int __stdcall sub_404680(int a1, char **a2, int *a3);
char *sub_404830();
int __stdcall sub_4048B0(char *a1, int a2, char a3, char a4, char *a5, unsigned int *a6);
BOOL __stdcall sub_404AF0(unsigned __int8 *String, int a2);
int __stdcall sub_404BB0(int a1, char **a2);
FILE *__stdcall sub_404C10(unsigned __int8 *String, int a2);
int __stdcall sub_404C90(_DWORD *a1);
int __stdcall sub_404CA0(_DWORD *a1);
int __stdcall sub_404CC0(_DWORD *a1, int a2);
int __stdcall sub_404CF0(FILE *Stream); // idb
int __stdcall sub_404D70(int Character, FILE *Stream); // idb
int sub_404DE0();
char *sub_404F80();
int __stdcall sub_4050B0(unsigned __int8 *Str1, char *a2);
void __stdcall sub_4051E0(char *a1);
char __stdcall sub_405360(unsigned __int8 *Str1, int a2, const unsigned __int8 **a3);
int __stdcall sub_405530(unsigned __int8 *a1, unsigned __int8 a2);
int sub_405710();
int __stdcall sub_405860(char *VarName, unsigned __int8 *a2, unsigned __int8 *a3);
char *__stdcall sub_405930(char *a1, unsigned __int8 *String, int a3, intptr_t *a4);
int __stdcall sub_405A20(unsigned __int8 *Str2);
unsigned __int8 *__stdcall sub_405B20(char *Filename, char *Ext, char *VarName, char *a4);
unsigned __int8 *__stdcall sub_405BC0(char *Filename, char *a2);
char *__stdcall sub_405C20(char *a1, const unsigned __int8 **a2, char **a3);
unsigned __int8 *__stdcall sub_405E60(unsigned __int8 *Str);
const char *__stdcall sub_405EF0(unsigned __int8 *a1);
_DWORD *__stdcall sub_405F40(_DWORD *a1, int a2);
void *__stdcall sub_405F60(const unsigned __int8 **a1);
int __stdcall sub_406020(unsigned __int8 *Str, unsigned __int8 **a2, int a3);
int __stdcall sub_4062A0(const char **a1, const char *a2);
int __stdcall sub_4063B0(FILE *Stream, const unsigned __int8 **a2);
unsigned int __stdcall sub_406430(unsigned __int8 *Str);
int __stdcall sub_406490(_BYTE *a1, int a2);
char __stdcall sub_406500(int a1, char a2);
char __stdcall sub_4065D0(int Character, char *a2, unsigned int a3);
int __stdcall sub_406880(char a3);
int __thiscall sub_406940(void *this, char a2);
int __stdcall sub_4069D0(int a3, char a4);
unsigned __int8 *__stdcall sub_406A80(char a1, unsigned __int8 *a2, char *a3);
const char *__stdcall sub_407070(char *a1, unsigned int a2);
FILE *__stdcall sub_407450(char *Buffer);
int sub_407550();
char __stdcall sub_4075C0(int a1);
char __stdcall sub_407680(unsigned __int8 *String);
char *__stdcall sub_407AD0(char *FullPath);
unsigned int __stdcall sub_407B70(unsigned __int8 *Str2);
_DWORD *__stdcall sub_407BF0(_DWORD *a1);
int __stdcall sub_407C10(void *a1);
void __cdecl __noreturn sub_407C30(int a1, int a2, int a3);
int nullsub_2(void); // weak
const char *sub_407D90();
int __stdcall sub_407F70(int a1, int a2, int a3);
unsigned int __stdcall sub_408140(char *FullPath, char **a2);
_DWORD *sub_408190();
void sub_408270();
void __stdcall sub_408320(int a1, const char **a2);
const char *sub_4085F0();
int __stdcall sub_4086D0(char a1, int a2);
void __cdecl Function();
char __stdcall sub_4089E0(unsigned __int8 *Str2);
int sub_408A20();
const char *__stdcall sub_408A90(const char *a1);
char sub_408AE0();
unsigned int __stdcall sub_408CD0(int a1, const char *a2);
FILE *__stdcall sub_408D10(int ArgList, int a2, int a3);
FILE *__stdcall sub_408D80(FILE *a1, char a2);
int sub_409000();
int sub_4090A0();
int sub_409170();
BOOL __stdcall sub_409300(char a1);
int __stdcall sub_4095C0(char a1);
char *sub_409620();
char *sub_409690();
int __stdcall sub_409730(unsigned __int8 a1);
int __stdcall sub_409790(unsigned __int8 a1, int a2);
char __stdcall sub_4097C0(_BYTE *a1);
int sub_409800();
intptr_t __stdcall sub_409A90(int a1);
int sub_409AE0();
int sub_409B70();
int sub_409BE0();
BOOL __stdcall sub_409D70(unsigned __int8 *Str);
int __stdcall sub_409DE0(unsigned __int8 *Str);
int __stdcall sub_409E80(unsigned __int8 *a1, char a2);
_DWORD *__stdcall sub_409EF0(unsigned __int8 *Dest, unsigned __int8 *String, const char *a3, int a4);
void __stdcall sub_40A2A0(void *Block, int a2);
int __stdcall sub_40A310(const unsigned __int8 **Block, int a2);
_BYTE *__stdcall sub_40A390(_BYTE *a1);
void sub_40A3C0();
_DWORD *__stdcall sub_40A500(int a1, unsigned __int8 *Str2, unsigned int a3, int ***a4, int ***a5, _DWORD *a6, unsigned int *a7, _DWORD *a8);
int sub_40A630();
char *__stdcall sub_40A660(int a1);
char *__stdcall sub_40A6F0(int a1, char *Buffer, int MaxCount);
char *__stdcall sub_40A7A0(char *a1);
_BYTE *__stdcall sub_40A820(_BYTE *a1, int *a2);
int __stdcall sub_40A890(char *FileName, char *FullPath, int a3); // idb
void __cdecl Func();
int __stdcall sub_40AA20(int a1, int a2);
int __stdcall sub_40AA70(int a1);
bool sub_40AAF0();
bool sub_40AB20();
int __stdcall sub_40AB40(char *FullPath, _DWORD *a2);
void *__stdcall sub_40ACC0(size_t Size);
void *__stdcall sub_40ACF0(size_t a1);
_DWORD *sub_40AD20();
_DWORD *__stdcall sub_40ADA0(_DWORD *a1);
char *__stdcall sub_40ADD0(const char *a1);
_DWORD *__stdcall sub_40AE10(_DWORD *a1, _DWORD *a2);
_DWORD *__stdcall sub_40AE30(_DWORD *a1, int a2);
int __stdcall sub_40AE50(char *a1, unsigned int a2, int a3);
int *__stdcall sub_40AEC0(char *Str1, int a2, int a3, int a4);
int __stdcall sub_40B110(unsigned __int8 *Ptr, int **a2, int *a3, unsigned __int8 *Str1, int a5, int a6, char a7);
char *__stdcall sub_40B520(char *a1, _BYTE *a2);
_BYTE *__stdcall sub_40B5D0(_BYTE *a1);
char *__stdcall sub_40B690(unsigned __int8 *Str);
char *__stdcall sub_40B700(char *a1, int a2);
_DWORD *__stdcall sub_40BB00(const void **a1, _DWORD *a2, _DWORD *a3, size_t *a4, const void *a5);
void __stdcall sub_40BB90(const void **a1, const unsigned __int8 **a2, _DWORD *a3, _DWORD *a4, size_t *a5, int a6, const void *a7);
const unsigned __int8 *__stdcall sub_40BF30(char a1, unsigned __int8 *Str, const char *a3);
void __stdcall sub_40C060(const void **a1, const unsigned __int8 **a2, _DWORD *a3, _DWORD *a4, unsigned __int8 *a5, size_t *a6, const void *a7);
void __stdcall sub_40C170(const void **a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, unsigned __int8 *Str1, size_t *a6, const void *a7);
char *__stdcall sub_40C340(char *FullPath, char *Filename);
int __stdcall sub_40C3A0(_BYTE *a1);
int __stdcall sub_40C510(char *a1, int a2, char *a3, char *FullPath);
int __stdcall sub_40C790(char *a1, char *ArgList, char *a3);
BOOL __stdcall sub_40C7D0(char *FullPath, char *Drive);
BOOL __stdcall sub_40C810(char *FullPath, char *Ext);
BOOL __stdcall sub_40C850(char *FullPath, char *Filename);
BOOL __stdcall sub_40C890(char *FullPath, char *Dir);
_DWORD *__stdcall sub_40C8D0(char *a1, int a2, int a3);
int __stdcall sub_40C980(const char *a1, const char *a2);
_BYTE *__stdcall sub_40CA30(const char *a1);
FILE *__stdcall sub_40CA80(unsigned __int8 *String, char *Mode);
void __stdcall sub_40CAE0(_BYTE *a1, unsigned int a2);
_DWORD *__stdcall sub_40CB30(char *FullPath);
int __stdcall sub_40CBD0(int Drive); // idb
int __stdcall sub_40CBF0(const char *a1, _DWORD *a2);
void __stdcall sub_40CC50(char *FullPath);
int __stdcall sub_40CD20(unsigned __int8 *String, _DWORD *a2, intptr_t *a3);
int __stdcall sub_40CE00(_DWORD *a1, intptr_t FindHandle);
char *sub_40CE40();
__time32_t __stdcall sub_40CEA0(__time32_t *Time);
// int __cdecl sub_40CF7B(_onexit_t Func); idb
// int _p___mb_cur_max(void); weak
// int __cdecl findfirst(_DWORD, _DWORD); weak
// int __cdecl findnext(_DWORD, _DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

char Drive[8]; // idb
char Filename[255]; // idb
_UNKNOWN unk_40E107; // weak
char Command[3]; // idb
unsigned __int8 Str; // idb
char Dir[256]; // idb
char byte_40EA08; // weak
int dword_40EA0C; // weak
int dword_40EA10; // weak
int dword_40EA14; // weak
char *EndPtr; // idb
char byte_40EA1C; // weak
int dword_40EA20; // weak
int dword_40EA24; // weak
char Buffer[1024]; // idb
int dword_40EE28; // weak
_UNKNOWN unk_40EE30; // weak
_UNKNOWN unk_40FE28; // weak
_UNKNOWN unk_40FE30; // weak
char byte_410E30[272]; // idb
_UNKNOWN unk_410F40; // weak
char FileName[512]; // idb
char byte_411250[2048]; // weak
int dword_411A50[]; // weak
int dword_411A54[]; // weak
int dword_411A58[46]; // weak
int dword_411B10; // weak
unsigned __int8 Control = 42u; // idb
unsigned __int8 byte_413004 = 36u; // idb
unsigned __int8 Delim = 32u; // idb
int dword_413010 = 0; // weak
char aRt[3] = "rt"; // idb
unsigned __int8 byte_413018 = 32u; // idb
char aNmake[6] = "NMAKE"; // weak
char a198894[8] = "1988-94"; // weak
char a150[5] = "1.50"; // weak
char byte_413060[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
unsigned __int8 *off_413068 = &aBreak; // idb
unsigned __int8 Dest = 0u; // idb
char aPath[] = "PATH"; // idb
unsigned __int8 byte_413268 = 73u; // idb
char aFor[4] = "FOR"; // weak
unsigned __int8 asc_4132E0[] = { 32u, 9u, 34u, 47u, 0u }; // idb
char aC_0[3] = "/c"; // weak
unsigned __int8 aCmd[] = { 46u, 99u, 109u, 100u, 0u }; // idb
unsigned __int8 aSet[] = { 115u, 101u, 116u, 0u }; // idb
unsigned __int8 asc_41335C[] = { 34u, 60u, 62u, 124u, 0u }; // idb
unsigned __int8 aChdir[] = { 99u, 104u, 100u, 105u, 114u, 0u }; // idb
unsigned __int8 aCd[] = { 99u, 100u, 0u }; // idb
char aCmdExe[8] = "CMD.EXE"; // weak
char VarName[] = "COMSPEC"; // idb
unsigned __int8 aDfbr[] = { 68u, 70u, 66u, 82u, 0u }; // idb
char aA[2] = "a"; // weak
char aW[] = "w"; // idb
char Mode[] = "r"; // idb
unsigned __int8 asc_413394[] = { 32u, 9u, 60u, 62u, 13u, 0u }; // idb
char aRB[] = "r+b"; // idb
int dword_4133A4 = 0; // weak
int dword_4133A8 = 0; // weak
int dword_4133B0 = 1; // weak
int dword_4133B4 = 0; // weak
int dword_4133B8 = 0; // weak
int dword_4133BC = 0; // weak
int dword_4133C0 = 0; // weak
char *off_4133C4 = "MAKEFLAGS=              "; // weak
int dword_4133C8 = 0; // weak
int dword_4133CC = 0; // weak
char byte_4133D0 = '\0'; // weak
char byte_4133D4 = '\0'; // weak
FILE *Stream = NULL; // idb
int dword_4133DC = 0; // weak
int dword_4133E0 = 0; // weak
int dword_4133E8 = 0; // weak
int dword_4133EC = 0; // weak
int dword_4133F0 = 1; // weak
int dword_4133F4 = 0; // idb
char *dword_4133F8 = NULL; // idb
unsigned __int8 *dword_4133FC = NULL; // idb
int dword_413400 = 0; // weak
int dword_413404 = 0; // weak
int dword_413408 = 0; // weak
char byte_413410[] = { '\0' }; // weak
int dword_413420 = -1; // weak
int dword_413424 = 0; // idb
_UNKNOWN unk_413428; // weak
_DWORD dword_413828[128] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_413A28 = 0; // weak
int dword_413A2C = 0; // weak
int dword_413A30 = 0; // weak
int dword_413A34 = 0; // idb
int dword_413A38 = 0; // weak
char *ArgList = NULL; // idb
int dword_413A40 = 0; // weak
char byte_413A44 = '\0'; // weak
char byte_413A48 = '\0'; // weak
int dword_413A4C = 0; // weak
int dword_413A50 = 0; // weak
char *FullPath = NULL; // idb
int dword_413A58 = 0; // weak
void *dword_413A5C = NULL; // idb
char byte_413A60[] = { '\0' }; // weak
char byte_413A61[] = { '\0' }; // weak
int dword_413A70 = -1; // weak
unsigned __int8 *dword_413A74 = NULL; // idb
void *dword_413A78 = NULL; // idb
int dword_413A7C = 0; // weak
int dword_413A80 = -1; // weak
int dword_413A84 = 0; // weak
int dword_413A88 = 0; // weak
int dword_413A8C = 0; // weak
char *dword_413A90 = NULL; // idb
int dword_413A94 = 0; // weak
int dword_413A98 = 0; // weak
char byte_413A9E[] = { '\0' }; // weak
char byte_413A9F[] = { '\0' }; // weak
char String[] = { '\0', '\0' }; // idb
unsigned __int8 aSuffixes[] = { 46u, 83u, 85u, 70u, 70u, 73u, 88u, 69u, 83u, 0u }; // idb
unsigned __int8 aIgnore[] = { 46u, 73u, 71u, 78u, 79u, 82u, 69u, 0u }; // idb
unsigned __int8 Str2[] = { 46u, 83u, 73u, 76u, 69u, 78u, 84u, 0u }; // idb
unsigned __int8 aPrecious[] = { 46u, 80u, 82u, 69u, 67u, 73u, 79u, 85u, 83u, 0u }; // idb
int dword_413ED4 = 4; // weak
int dword_413ED8 = 8; // weak
int dword_413EDC = 13; // weak
int dword_413EE0 = 36; // weak
unsigned __int8 byte_413F04 = 92u; // idb
unsigned __int8 aUndef[] = { 85u, 78u, 68u, 69u, 70u, 0u }; // idb
unsigned __int8 aMessage[] = { 77u, 69u, 83u, 83u, 65u, 71u, 69u, 0u }; // idb
unsigned __int8 aError[] = { 69u, 82u, 82u, 79u, 82u, 0u }; // idb
unsigned __int8 aCmdswitches[] = { 67u, 77u, 68u, 83u, 87u, 73u, 84u, 67u, 72u, 69u, 83u, 0u }; // idb
unsigned __int8 aInclude[] = { 73u, 78u, 67u, 76u, 85u, 68u, 69u, 0u }; // idb
unsigned __int8 aAbceklmpqrtv[] = { 65u, 66u, 67u, 69u, 75u, 76u, 77u, 80u, 81u, 82u, 84u, 86u, 0u }; // idb
unsigned __int8 aDins[] = { 68u, 73u, 78u, 83u, 0u }; // idb
unsigned __int8 aEndif[] = { 69u, 78u, 68u, 73u, 70u, 0u }; // idb
unsigned __int8 aElseifndef[] = { 69u, 76u, 83u, 69u, 73u, 70u, 78u, 68u, 69u, 70u, 0u }; // idb
unsigned __int8 aElseifdef[] = { 69u, 76u, 83u, 69u, 73u, 70u, 68u, 69u, 70u, 0u }; // idb
unsigned __int8 aElseif[] = { 69u, 76u, 83u, 69u, 73u, 70u, 0u }; // idb
unsigned __int8 aElse[] = { 69u, 76u, 83u, 69u, 0u }; // idb
unsigned __int8 aIfndef[] = { 73u, 70u, 78u, 68u, 69u, 70u, 0u }; // idb
unsigned __int8 aIfdef[] = { 73u, 70u, 68u, 69u, 70u, 0u }; // idb
unsigned __int8 asc_413F8C[] = { 47u, 92u, 58u, 0u }; // idb
char aBat[] = ".bat"; // idb
char aExe[] = ".exe"; // idb
char Ext[] = ".com"; // idb
char aEof[4] = "EOF"; // weak
unsigned __int8 asc_413FAC[] = { 60u, 60u, 0u }; // idb
unsigned __int8 aNokeep[] = { 110u, 111u, 107u, 101u, 101u, 112u, 0u }; // idb
unsigned __int8 aKeep[] = { 107u, 101u, 101u, 112u, 0u }; // idb
char aTmp[] = "TMP"; // idb
char aNmxxxxxx[] = "nmXXXXXX"; // idb
char asc_413FD4[2] = "."; // weak
unsigned __int8 aInclude_0[] = { 105u, 110u, 99u, 108u, 117u, 100u, 101u, 0u }; // idb
__int16 word_413FE0 = 46; // weak
unsigned __int8 byte_413FE8 = 92u; // idb
unsigned __int8 byte_413FEC = 32u; // idb
int dword_413FF0 = 0; // weak
unsigned __int8 *dword_413FF8 = NULL; // idb
int dword_414004 = 0; // weak
char byte_414008 = '\0'; // weak
char byte_41400C = '\0'; // weak
char byte_414010 = '\0'; // weak
char byte_414014 = '\0'; // weak
char *off_414018[17] =
{
  ".SUFFIXES",
  ".c.obj",
  ".c.exe",
  ".cpp.obj",
  ".cpp.exe",
  ".cxx.obj",
  ".cxx.exe",
  ".asm.obj",
  ".asm.exe",
  ".bas.obj",
  ".cbl.obj",
  ".cbl.exe",
  ".for.obj",
  ".for.exe",
  ".pas.obj",
  ".pas.exe",
  ".rc.res"
}; // weak
char **off_414118[17] =
{
  &off_414060,
  &off_414098,
  &off_4140A0,
  &off_4140A8,
  &off_4140B0,
  &off_4140B8,
  &off_4140C0,
  &off_4140C8,
  &off_4140D0,
  &off_4140D8,
  &off_4140E0,
  &off_4140E8,
  &off_4140F0,
  &off_4140F8,
  &off_414100,
  &off_414108,
  &off_414110
}; // weak
char aNmakeErr[] = "nmake.err"; // idb
char a1[2] = "1"; // weak
char aVc20chicspwn[] = "vc20chicspwn"; // idb
char aMake[5] = "MAKE"; // weak
char aRc[3] = "rc"; // weak
char aRc_1[3] = "RC"; // weak
char aPl[3] = "pl"; // weak
char aPascal[7] = "PASCAL"; // weak
char aFl[3] = "fl"; // weak
char aCobol_0[6] = "cobol"; // weak
char aCobol[6] = "COBOL"; // weak
char aBc[3] = "bc"; // weak
char aBc_0[3] = "BC"; // weak
char aMl[3] = "ml"; // weak
char aAs[3] = "AS"; // weak
char aCpp_0[4] = "CPP"; // weak
char aCxx_0[4] = "CXX"; // weak
char aCl[3] = "cl"; // weak
char aCc[3] = "CC"; // weak
char aInit[] = "INIT"; // idb
char aToolsIni[10] = "tools.ini"; // weak
char aMakeflags[] = "MAKEFLAGS"; // idb
char aMakedir[8] = "MAKEDIR"; // weak
char aStdin[6] = "STDIN"; // weak
char aWt[] = "wt"; // idb
unsigned __int8 aNologo[] = { 110u, 111u, 108u, 111u, 103u, 111u, 0u }; // idb
unsigned __int8 aHelp[] = { 104u, 101u, 108u, 112u, 0u }; // idb
char aMakefile[] = "makefile"; // idb
void *off_414588 = &unk_414528; // weak
char byte_4145D8[64] =
{
  '\"',
  '\x81',
  '\x01',
  '!',
  '%',
  '%',
  ' ',
  '\0',
  '!',
  '\x8D',
  '\x0F',
  '!',
  '!',
  '!',
  '!',
  '\r',
  '\'',
  '\x8B',
  '\n',
  '\'',
  '!',
  '!',
  '!',
  '\v',
  '\'',
  '\a',
  '\b',
  '\t',
  '!',
  '!',
  '!',
  '\a',
  '\x03',
  '#',
  '#',
  '\"',
  '\x03',
  '\x03',
  '\x04',
  '#',
  '\x06',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '$',
  '\x05',
  '\x11',
  '\x10',
  '\x11',
  '\x11',
  '!',
  '!',
  '!',
  '\x10',
  '\'',
  '\"',
  '\"',
  '\"',
  '\x12',
  '\x13',
  '!',
  '\"'
}; // weak
char byte_414618[24] =
{
  '\x01',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
int (*off_414630)() = &sub_401000; // weak
char byte_414648[184] =
{
  '\x01',
  '\x02',
  '\x01',
  '\x03',
  '\x01',
  '\x02',
  '@',
  '\x04',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x03',
  '\x01',
  '\x02',
  '@',
  '\x04',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x03',
  '\x01',
  '\x02',
  '@',
  '\x04',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x02',
  '\0',
  '\x04',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '!',
  '!',
  '!',
  '!',
  '!',
  '\"',
  '\"',
  '\x01',
  '\x05',
  '!',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '!',
  '!',
  '!',
  '!',
  '!',
  '$',
  ' ',
  '!',
  '!',
  '$',
  '\x06',
  '\v',
  '\b',
  '\x06',
  '!',
  '!',
  '!',
  '!',
  '\t',
  ' ',
  ' ',
  '!',
  '!',
  '\x02',
  '\x06',
  '\"',
  '\"',
  '\x06',
  '!',
  '!',
  '!',
  '!',
  '\t',
  ' ',
  ' ',
  '!',
  '!',
  '\x02',
  '\"',
  '\"',
  '\"',
  '\"',
  '!',
  '!',
  '!',
  '!',
  '\t',
  ' ',
  ' ',
  '!',
  '!',
  '\x02',
  '\"',
  '\"',
  '\"',
  '\a',
  '\n',
  '\n',
  '%',
  '\n',
  '\n',
  '\n',
  ' ',
  '\n',
  '\n',
  '%',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\f',
  '\n',
  '\n',
  '\n',
  ' ',
  '\n',
  '\n',
  '#',
  '\n',
  '\n',
  '\n',
  '\n',
  '!',
  '!',
  '!',
  '!',
  '\t',
  ' ',
  ' ',
  '!',
  '!',
  '\x02',
  '\"',
  '\b',
  '\"',
  '\a',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  ' ',
  '\f',
  '\f',
  '\x02',
  '\f',
  '\f',
  '\f',
  '\f',
  '\0',
  '\0'
}; // weak
char byte_414700[272] =
{
  '\x01',
  '@',
  '@',
  '@',
  '\x01',
  '@',
  '@',
  '\x02',
  '\x01',
  '\x01',
  '\x01',
  '\b',
  '\x01',
  '\x0F',
  '\x10',
  '\x01',
  '@',
  '@',
  '@',
  '@',
  '@',
  '@',
  '\x02',
  '\x01',
  '\x01',
  '\x01',
  '\b',
  '\x01',
  '\x0F',
  '\'',
  '!',
  '\"',
  '!',
  '!',
  '!',
  '\"',
  '\"',
  '\x01',
  '\x03',
  '!',
  '\x01',
  '!',
  '!',
  '!',
  '!',
  '!',
  ' ',
  '!',
  '!',
  '$',
  '$',
  ' ',
  '!',
  '!',
  '$',
  '\x04',
  '!',
  '!',
  '!',
  '!',
  '!',
  ' ',
  '!',
  '!',
  '\x05',
  ' ',
  ' ',
  '!',
  '!',
  '\x01',
  '\x04',
  '!',
  '!',
  '!',
  '!',
  '\x06',
  '\x06',
  '%',
  '\x06',
  '\x06',
  '\x06',
  ' ',
  '\x06',
  '\x06',
  '#',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\a',
  '\x06',
  '\x06',
  '\x06',
  '%',
  '\x06',
  '\x06',
  '%',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '%',
  '\a',
  '\a',
  '\x01',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\b',
  '@',
  '\b',
  '\b',
  '\b',
  '@',
  '@',
  '\t',
  '\b',
  '\b',
  '\b',
  '\b',
  '\x01',
  '\b',
  '\b',
  '!',
  '\"',
  '!',
  '!',
  '!',
  '\"',
  '\"',
  '\b',
  '\n',
  '!',
  '\b',
  '!',
  '!',
  '!',
  '!',
  '!',
  ' ',
  '!',
  '!',
  '$',
  '\n',
  ' ',
  '!',
  '!',
  '$',
  '\v',
  '!',
  '!',
  '!',
  '!',
  '!',
  ' ',
  '!',
  '!',
  '\f',
  ' ',
  ' ',
  '!',
  '!',
  '\b',
  '\v',
  '!',
  '!',
  '!',
  '!',
  '\r',
  '\r',
  '%',
  '\r',
  '\r',
  '\r',
  ' ',
  '\r',
  '\r',
  '#',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\x0E',
  '\r',
  '\r',
  '\r',
  '%',
  '\r',
  '\r',
  '%',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '%',
  '\x0E',
  '\x0E',
  '\b',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x01',
  '@',
  '@',
  '@',
  '@',
  '@',
  '@',
  '\x02',
  '\x01',
  '\x01',
  '\x01',
  '\b',
  '\x01',
  '\x01',
  '\x01',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '&',
  '\x02',
  '\x10',
  '\x10',
  '\x10',
  '\b',
  '\x10',
  '\x0F',
  '\x11',
  '@',
  '@',
  '@',
  '@',
  '@',
  '@',
  '@',
  '@',
  '@',
  '@',
  '@',
  '@',
  '@',
  '@',
  '@',
  '\0',
  '\0'
}; // weak
char (*off_414810)[8] = &byte_413060; // weak
char *off_414814 = "dinsb"; // weak
char byte_414860[32] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\x06',
  '\a',
  '\a',
  '\a',
  '\a',
  '\b',
  '\b',
  '\t',
  '\t',
  '\n',
  '\n',
  '\n',
  '\v',
  '\v',
  '\v',
  '\f',
  '\f',
  '\f',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_414880[32] =
{
  '\0',
  '\x01',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
void *off_4148A0 = &unk_4149A4; // weak
_UNKNOWN unk_414948; // weak
void *off_414950 = &unk_410E28; // weak
void *off_414954 = &unk_40FE28; // weak
unsigned __int8 byte_4149A0 = 41u; // idb
unsigned __int8 aExist[] = { 69u, 88u, 73u, 83u, 84u, 0u }; // idb
unsigned __int8 aDefined[] = { 68u, 69u, 70u, 73u, 78u, 69u, 68u, 0u }; // idb
unsigned __int8 Source[] = { 46u, 92u, 0u }; // idb
char byte_4149C0[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x80',
  '\0',
  '\0',
  '\0',
  '\x80',
  '\x80',
  '\0',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\0',
  '\0',
  '\0',
  '\x80',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x80',
  '\x80',
  '\x80',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x80',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x80',
  '\0',
  '\x80',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01'
}; // weak
FILE *dword_414AC0 = NULL; // idb
char *dword_414AC4 = NULL; // idb
int dword_414AC8[] = { 0 }; // weak
int dword_414ACC[39] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
char aWarningMissing[] = "WARNING:  missing %s; displaying error numbers without messages.\n"; // idb
CHAR ProcName[] = "IsTNT"; // idb
CHAR ModuleName[] = "kernel32.dll"; // idb
char aPe[3] = "PE"; // weak
char aMz[3] = "MZ"; // weak
unsigned __int8 asc_414BCC[] = { 42u, 64u, 60u, 63u, 0u }; // idb
unsigned __int8 aDfbr_0[] = { 68u, 70u, 66u, 82u, 0u }; // idb
int dword_414BDC = 0; // weak
int dword_414BE0 = 0; // weak
__int16 word_414BE4 = 34; // weak
unsigned __int8 byte_414BE8 = 46u; // idb
unsigned __int8 byte_414BF0 = 46u; // idb
unsigned __int8 asc_414BF4[] = { 34u, 42u, 63u, 94u, 0u }; // idb
// extern HFILE (__stdcall *OpenFile)(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle);
// extern LONG (__stdcall *llseek)(HFILE hFile, LONG lOffset, int iOrigin);
// extern HFILE (__stdcall *lclose)(HFILE hFile);
// extern UINT (__stdcall *lread)(HFILE hFile, LPVOID lpBuffer, UINT uBytes);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern DWORD (__stdcall *GetVersion)();
// extern int (__cdecl *fclose)(FILE *Stream);
// extern void *(__cdecl *realloc)(void *Block, size_t Size);
// extern void (__cdecl __noreturn *exit)(int Code);
// extern int (__cdecl *fflush)(FILE *Stream);
// extern int (__cdecl *putc)(int Character, FILE *Stream);
// extern int (__cdecl *vfprintf)(FILE *const Stream, const char *const Format, va_list ArgList);
// extern int (*fprintf)(FILE *const Stream, const char *const Format, ...);
// extern FILE *(__cdecl *_p__iob)();
// extern size_t (__cdecl *mbsspn)(const unsigned __int8 *Str, const unsigned __int8 *Control);
// extern int *(__cdecl *errno)();
// extern int (__cdecl *strtol)(const char *String, char **EndPtr, int Radix);
// extern int (__cdecl *ismbcdigit)(unsigned int C);
// extern int (__cdecl *ismbcspace)(unsigned int C);
// extern char *(__cdecl *strerror)(int ErrorMessage);
// extern intptr_t (__cdecl *spawnvp)(int Mode, const char *FileName, const char *const *Arguments);
// extern int (__cdecl *system)(const char *Command);
// extern int (*printf)(const char *const Format, ...);
// extern int (__cdecl *dup2)(int FileHandleSrc, int FileHandleDst);
// extern int (__cdecl *close)(int FileHandle);
// extern unsigned int (__cdecl *mbctoupper)(unsigned int Ch);
// extern void (__cdecl *makepath)(char *Buffer, const char *Drive, const char *Dir, const char *Filename, const char *Ext);
// extern void (__cdecl *splitpath)(const char *FullPath, char *Drive, char *Dir, char *Filename, char *Ext);
// extern unsigned __int8 *(__cdecl *mbsnbcpy)(unsigned __int8 *Dest, const unsigned __int8 *Source, size_t Count);
// extern char **(__cdecl *_p__pgmptr)();
// extern int (__cdecl *dup)(int FileHandle);
// extern int (__cdecl *chdir)(const char *Path);
// extern const unsigned __int16 **(__cdecl *_p__pctype)();
// extern int (__cdecl *isctype)(int C, int Type);
// extern int (__cdecl *mbsnbicmp)(const unsigned __int8 *Str1, const unsigned __int8 *Str2, size_t MaxCount);
// extern int (__cdecl *ismbcalpha)(unsigned int C);
// extern int (__cdecl *lseek)(int FileHandle, int Offset, int Origin);
// extern FILE *(__cdecl *freopen)(const char *FileName, const char *Mode, FILE *Stream);
// extern int (__cdecl *write)(int FileHandle, const void *Buf, unsigned int MaxCharCount);
// extern int (__cdecl *read)(int FileHandle, void *DstBuf, unsigned int MaxCharCount);
// extern unsigned __int8 *(__cdecl *_p__mbctype)();
// extern int (__cdecl *getc)(FILE *Stream);
// extern int (__cdecl *ungetc)(int Character, FILE *Stream);
// extern int (__cdecl *putenv)(const char *EnvString);
// extern char *(__cdecl *fgets)(char *Buffer, int MaxCount, FILE *Stream);
// extern void (__cdecl *free)(void *Block);
// extern int (__cdecl *fputc)(int Character, FILE *Stream);
// extern char *(__cdecl *mktemp)(char *TemplateName);
// extern _crt_signal_t (__cdecl *signal)(int Signal, _crt_signal_t Function);
// extern unsigned __int8 *(__cdecl *mbsupr)(unsigned __int8 *String);
// extern char ***(__cdecl *_p__environ)();
// extern FILE *(__cdecl *fopen)(const char *FileName, const char *Mode);
// extern int (__cdecl *access)(const char *FileName, int AccessMode);
// extern int (__cdecl *unlink)(const char *FileName);
// extern int (__cdecl *fcloseall)();
// extern char *(__cdecl *ctime)(const __time32_t *const Time);
// extern int (__cdecl *putchar)(int Character);
// extern void *(__cdecl *memmove)(void *, const void *Src, size_t Size);
// extern size_t (__cdecl *mbscspn)(const unsigned __int8 *String, const unsigned __int8 *Control);
// extern int (__cdecl *ismbcalnum)(unsigned int C);
// extern int (__cdecl *fseek)(FILE *Stream, int Offset, int Origin);
// extern int (__cdecl *ftell)(FILE *Stream);
// extern char *(__cdecl *strdup)(const char *String);
// extern void *(__cdecl *malloc)(size_t Size);
// extern unsigned __int8 *(__cdecl *mbsinc)(const unsigned __int8 *Ptr);
// extern FILE *(__cdecl *fsopen)(const char *FileName, const char *Mode, int ShFlag);
// extern int (__cdecl *chdrive)(int Drive);
// extern int (__cdecl *findclose)(intptr_t FindHandle);
// extern char *(__cdecl *getcwd)(char *DstBuf, int SizeInBytes);
// extern __time32_t (__cdecl *time)(__time32_t *const Time);
// extern unsigned __int8 *(__cdecl *mbschr)(const unsigned __int8 *Str, unsigned int C);
// extern unsigned __int8 *(__cdecl *mbstok)(unsigned __int8 *Str, const unsigned __int8 *Delim);
// extern char *(__cdecl *getenv)(const char *VarName);
// extern int (__cdecl *mbscmp)(const unsigned __int8 *Str1, const unsigned __int8 *Str2);
// extern unsigned __int8 *(__cdecl *mbspbrk)(const unsigned __int8 *String, const unsigned __int8 *Control);
// extern int (__cdecl *mbsicmp)(const unsigned __int8 *Str1, const unsigned __int8 *Str2);
// extern unsigned __int8 *(__cdecl *mbsrchr)(const unsigned __int8 *String, unsigned int C);
// extern void (__cdecl *searchenv)(const char *Filename, const char *VarName, char *Buffer);
// extern int (__cdecl *mbsnbcmp)(const unsigned __int8 *Str1, const unsigned __int8 *Str2, size_t MaxCount);
// extern int (__cdecl *memicmp)(const void *Buf1, const void *Buf2, size_t Size);
// extern int (__cdecl *strnicmp)(const char *String1, const char *String2, size_t MaxCount);


//----- (00401000) --------------------------------------------------------
char *sub_401000()
{
  char *result; // eax

  sub_40B110((unsigned __int8 *)String, (int **)&dword_413A28, 0, 0, 0, 0, 0);
  result = sub_40ADD0(String);
  ArgList = result;
  return result;
}
// 413A28: using guessed type int dword_413A28;

//----- (00401030) --------------------------------------------------------
_DWORD *sub_401030()
{
  _DWORD *v0; // esi
  _DWORD *v1; // esi
  int v3; // [esp+4h] [ebp-4h] BYREF

  if ( ArgList )
  {
    byte_413A48 |= 0x20u;
    sub_401170();
    ArgList = 0;
  }
  if ( (byte_413A48 & 0x20) != 0 && sub_40C3A0(String) )
  {
    if ( (byte_413A48 & 0x10) != 0 )
      sub_403220(dword_413424, 0x444u);
    sub_403220(dword_413424, 0x43Du);
  }
  v0 = sub_40AD20();
  if ( (byte_413A48 & 0x40) != 0 )
  {
    v0[1] = dword_4133FC;
    dword_4133FC = 0;
  }
  else
  {
    v0[1] = sub_40ADD0(String);
  }
  v3 = (int)v0;
  if ( (byte_413A48 & 0x10) == 0 || (byte_413A48 & 0x20) != 0 )
  {
    sub_40B110((unsigned __int8 *)v0[1], (int **)&dword_413A28, 0, 0, 0, 0, 0);
    if ( (byte_413A48 & 0x20) != 0 )
    {
      v1 = (_DWORD *)dword_413A28;
      sub_4013D0(&byte_413004, &v3, (int)&dword_413A28);
      sub_4013D0(&Control, &v3, 0);
      for ( dword_413A28 = (int)v1; v1; dword_413A28 = (int)v1 )
      {
        v1 = (_DWORD *)*v1;
        sub_40ADA0((_DWORD *)dword_413A28);
      }
    }
  }
  return sub_40AE30(&dword_413A38, v3);
}
// 413A28: using guessed type int dword_413A28;
// 413A38: using guessed type int dword_413A38;
// 413A48: using guessed type char byte_413A48;

//----- (00401170) --------------------------------------------------------
void sub_401170()
{
  _DWORD *v0; // eax
  _DWORD *v1; // esi

  byte_413A44 = byte_4133D0;
  v0 = sub_40AD20();
  v0[1] = ArgList;
  v1 = (_DWORD *)dword_413A28;
  dword_413A38 = (int)v0;
  sub_4013D0(&byte_413004, &dword_413A38, (int)&dword_413A28);
  sub_4013D0(&Control, &dword_413A38, 0);
  for ( dword_413A28 = (int)v1; v1; dword_413A28 = (int)v1 )
  {
    v1 = (_DWORD *)*v1;
    sub_40ADA0((_DWORD *)dword_413A28);
  }
  if ( dword_413A38 )
    goto LABEL_11;
  if ( (byte_413A48 & 0x20) == 0 )
    sub_403220(dword_4133F4, 0x43Bu, ArgList);
  if ( dword_413A38 )
  {
LABEL_11:
    if ( sub_40C3A0(*(_BYTE **)(dword_413A38 + 4)) )
      byte_413A48 |= 0x10u;
  }
}
// 4133D0: using guessed type char byte_4133D0;
// 413A28: using guessed type int dword_413A28;
// 413A38: using guessed type int dword_413A38;
// 413A44: using guessed type char byte_413A44;
// 413A48: using guessed type char byte_413A48;

//----- (00401230) --------------------------------------------------------
_DWORD *sub_401230()
{
  _DWORD *result; // eax

  if ( ArgList )
  {
    sub_401170();
    ArgList = 0;
  }
  else
  {
    byte_413A48 &= ~0x20u;
  }
  if ( String[1] )
    byte_413A44 |= 0x20u;
  if ( !dword_413A38 )
    sub_403220(dword_413424, 0x40Du);
  if ( (byte_413A48 & 0x10) != 0 )
  {
    if ( (byte_413A44 & 0x20) != 0 )
      sub_403220(dword_413424, 0x440u);
    sub_401BC0(dword_413A38);
    result = sub_40ADA0((_DWORD *)dword_413A38);
  }
  else if ( *(_DWORD *)dword_413A38 || !sub_401310(*(unsigned __int8 **)(dword_413A38 + 4)) )
  {
    result = (_DWORD *)dword_413A38;
    dword_411B10 = dword_413A38;
  }
  else
  {
    free(*(void **)(dword_413A38 + 4));
    result = sub_40ADA0((_DWORD *)dword_413A38);
  }
  dword_413A38 = 0;
  byte_413A48 |= 0x80u;
  return result;
}
// 411B10: using guessed type int dword_411B10;
// 413A38: using guessed type int dword_413A38;
// 413A44: using guessed type char byte_413A44;
// 413A48: using guessed type char byte_413A48;

//----- (00401310) --------------------------------------------------------
int __stdcall sub_401310(unsigned __int8 *Str1)
{
  int v1; // esi

  v1 = 0;
  if ( !mbsicmp(Str1, Str2) )
  {
    v1 = 1;
    byte_413A48 |= 2u;
    sub_4086D0(115, 1);
  }
  if ( mbsicmp(Str1, aIgnore) )
  {
    if ( mbscmp(Str1, aSuffixes) )
    {
      if ( !mbscmp(Str1, aPrecious) )
      {
        v1 = 1;
        byte_413A48 |= 8u;
      }
      return v1;
    }
    else
    {
      byte_413A48 |= 1u;
      return 1;
    }
  }
  else
  {
    byte_413A48 |= 4u;
    sub_4086D0(105, 1);
    return 1;
  }
}
// 413A48: using guessed type char byte_413A48;

//----- (004013D0) --------------------------------------------------------
void __stdcall sub_4013D0(unsigned __int8 *Control, int *a2, int a3)
{
  int *j; // ebx
  _DWORD *v4; // edi
  char **v5; // ebp
  char *v6; // eax
  char *v7; // ecx
  int v8; // eax
  const char *i; // ebp
  char *v10; // eax
  int *v11; // [esp+10h] [ebp-10h] BYREF
  _BYTE *v12; // [esp+14h] [ebp-Ch] BYREF
  void *Block; // [esp+18h] [ebp-8h]
  void *v14; // [esp+1Ch] [ebp-4h]

  Block = 0;
  v14 = 0;
  j = 0;
  v4 = (_DWORD *)*a2;
  if ( *a2 )
  {
    do
    {
      v5 = (char **)(v4 + 1);
      if ( mbspbrk((const unsigned __int8 *)v4[1], Control) )
      {
        if ( *Control == 36 )
        {
          v6 = sub_40B700(*v5, a3);
          v7 = *v5;
          Block = v6;
          free(v7);
          goto LABEL_9;
        }
        if ( !sub_40C3A0(*v5) )
        {
          v11 = sub_40CB30(*v5);
          if ( v11 )
          {
            v14 = *v5;
LABEL_9:
            v8 = *v4;
            if ( j )
            {
              *j = v8;
              sub_40ADA0(v4);
              v4 = (_DWORD *)*j;
            }
            else
            {
              *a2 = v8;
              sub_40ADA0(v4);
              v4 = (_DWORD *)*a2;
            }
            if ( *Control == 36 )
            {
              v12 = Block;
              for ( i = sub_401550(&v12); i; i = sub_401550(&v12) )
              {
                v11 = sub_40AD20();
                v10 = sub_40ADD0(i);
                v11[1] = (int)v10;
                sub_40AE10(a2, v11);
                if ( !j )
                  j = v11;
              }
              free(Block);
            }
            else
            {
              if ( v11 )
              {
                if ( !j )
                {
                  for ( j = v11; *j; j = (int *)*j )
                    ;
                }
                sub_40AE30(&v11, *a2);
                *a2 = (int)v11;
              }
              free(v14);
            }
            continue;
          }
        }
        j = v4;
        v4 = (_DWORD *)*v4;
      }
      else
      {
        j = v4;
        v4 = (_DWORD *)*v4;
      }
    }
    while ( v4 );
  }
}

//----- (00401550) --------------------------------------------------------
_BYTE *__stdcall sub_401550(_BYTE **a1)
{
  _BYTE *i; // edx
  _BYTE *result; // eax
  char v3; // bl
  char v4; // bl

  for ( i = *a1; *i == 32 || *i == 9; ++i )
    ;
  result = i;
  v3 = *i;
  if ( !*i )
    return 0;
  if ( v3 == 34 )
  {
    if ( *++i )
    {
      do
      {
        if ( *i == 34 )
          break;
        ++i;
      }
      while ( *i );
    }
  }
  else if ( v3 )
  {
    do
    {
      if ( *i == 32 )
        break;
      if ( *i == 9 )
        break;
      ++i;
    }
    while ( *i );
  }
  v4 = *i;
  if ( *i == 32 || v4 == 9 )
  {
    *i = 0;
  }
  else
  {
    if ( v4 == 34 )
    {
      i[1] = 0;
      *a1 = i + 2;
      return result;
    }
    if ( !v4 )
    {
      *a1 = i;
      return result;
    }
  }
  *a1 = i + 1;
  return result;
}

//----- (004015E0) --------------------------------------------------------
int sub_4015E0()
{
  unsigned __int8 *v0; // eax
  int result; // eax

  v0 = 0;
  if ( byte_413A48 < 0 )
    byte_413A48 &= ~0x80u;
  if ( (byte_413A48 & 0x10) != 0 )
  {
    if ( dword_413A38 )
      sub_403220(dword_413424, 0x43Eu);
  }
  else if ( (byte_413A48 & 2) != 0 || (byte_413A48 & 4) != 0 )
  {
    if ( dword_413A38 )
    {
      if ( (byte_413A48 & 2) != 0 )
      {
        v0 = Str2;
      }
      else if ( (byte_413A48 & 4) != 0 )
      {
        v0 = aIgnore;
      }
      sub_403220(dword_413424, 0x442u, v0);
    }
  }
  else if ( (byte_413A48 & 1) != 0 )
  {
    if ( dword_413A38 )
      sub_401D00(&dword_413A2C, (_DWORD *)dword_413A38);
    else
      sub_401CC0();
  }
  else if ( (byte_413A48 & 8) != 0 )
  {
    if ( dword_413A38 )
      sub_401D00(&dword_413A30, (_DWORD *)dword_413A38);
  }
  else
  {
    dword_413A40 = (int)sub_40ACF0(0x18u);
    *(_DWORD *)dword_413A40 = dword_413A38;
    *(_DWORD *)(dword_413A40 + 4) = dword_413A28;
  }
  byte_413A48 |= 0x40u;
  result = 0;
  dword_413A38 = 0;
  dword_413A28 = 0;
  return result;
}
// 413A28: using guessed type int dword_413A28;
// 413A2C: using guessed type int dword_413A2C;
// 413A30: using guessed type int dword_413A30;
// 413A38: using guessed type int dword_413A38;
// 413A40: using guessed type int dword_413A40;
// 413A48: using guessed type char byte_413A48;

//----- (00401710) --------------------------------------------------------
int sub_401710()
{
  unsigned __int8 *v0; // eax
  int v1; // esi
  int v2; // edi
  int i; // ebx
  int result; // eax

  v0 = 0;
  v1 = 1;
  v2 = 1;
  if ( (byte_413A48 & 0x10) != 0 )
  {
    *(_DWORD *)(dword_413A34 + 12) = dword_413A38;
  }
  else if ( (byte_413A48 & 2) != 0 || (byte_413A48 & 0xD) != 0 )
  {
    if ( dword_413A38 )
    {
      if ( (byte_413A48 & 2) != 0 )
      {
        v0 = Str2;
      }
      else if ( (byte_413A48 & 4) != 0 )
      {
        v0 = aIgnore;
      }
      else if ( (byte_413A48 & 8) != 0 )
      {
        v0 = aPrecious;
      }
      else if ( (byte_413A48 & 1) != 0 )
      {
        v0 = aSuffixes;
      }
      sub_403220(dword_413424, 0x441u, v0);
    }
  }
  else
  {
    *(_DWORD *)(dword_413A40 + 8) = dword_413A38;
    *(_DWORD *)(dword_413A40 + 12) = dword_413A28;
    *(_BYTE *)(dword_413A40 + 16) = byte_413A44;
    for ( i = dword_411B10; dword_411B10; i = dword_411B10 )
    {
      if ( sub_401310(*(unsigned __int8 **)(i + 4)) )
        sub_403220(dword_413424, 0x445u);
      sub_401BF0(*(char **)(i + 4), v2, &dword_413A40);
      if ( !dword_4133DC )
      {
        v1 = 0;
        dword_4133DC = i;
      }
      dword_411B10 = *(_DWORD *)i;
      if ( v1 )
        sub_40ADA0((_DWORD *)i);
      if ( v2 )
        v2 = 0;
    }
  }
  result = 0;
  dword_411B10 = 0;
  dword_413A38 = 0;
  dword_413A28 = 0;
  dword_413A40 = 0;
  byte_413A48 = 0;
  return result;
}
// 411B10: using guessed type int dword_411B10;
// 4133DC: using guessed type int dword_4133DC;
// 413A28: using guessed type int dword_413A28;
// 413A38: using guessed type int dword_413A38;
// 413A40: using guessed type int dword_413A40;
// 413A44: using guessed type char byte_413A44;
// 413A48: using guessed type char byte_413A48;

//----- (00401870) --------------------------------------------------------
int sub_401870()
{
  _DWORD *v0; // esi
  char *v1; // edi
  void (__cdecl *v2)(void *); // esi
  char *i; // ecx
  int result; // eax

  if ( mbschr((const unsigned __int8 *)ArgList, 0x24u) )
  {
    v0 = (_DWORD *)dword_413A28;
    v1 = sub_40B700(ArgList, (int)&dword_413A28);
    if ( !*v1 )
      sub_403220(dword_413424, 0x3ECu);
    for ( dword_413A28 = (int)v0; v0; dword_413A28 = (int)v0 )
    {
      v0 = (_DWORD *)*v0;
      sub_40ADA0((_DWORD *)dword_413A28);
    }
    v2 = free;
    free(ArgList);
    ArgList = v1;
  }
  else
  {
    v2 = free;
  }
  for ( i = ArgList; *i; ++i )
  {
    if ( (byte_4149C0[(unsigned __int8)*i] & 1) == 0 )
      break;
  }
  if ( *i )
    sub_403220(dword_413424, 0x3E9u, *i);
  dword_4133B4 = 1;
  if ( !sub_4019F0(ArgList, dword_4133FC, 0) )
  {
    v2(ArgList);
    v2(dword_4133FC);
  }
  result = 0;
  dword_4133FC = 0;
  ArgList = 0;
  return result;
}
// 4133B4: using guessed type int dword_4133B4;
// 413A28: using guessed type int dword_413A28;

//----- (00401980) --------------------------------------------------------
int __stdcall sub_401980(char *VarName, unsigned __int8 *Str, char a3)
{
  char *i; // eax
  char v4; // al

  for ( i = VarName; *i; ++i )
  {
    if ( (byte_4149C0[(unsigned __int8)*i] & 1) == 0 )
      break;
  }
  v4 = *i;
  if ( v4 )
  {
    if ( (a3 & 4) != 0 )
      return 0;
    sub_403220(dword_413424, 0x3E9u, v4);
  }
  return sub_4019F0(VarName, Str, a3);
}

//----- (004019F0) --------------------------------------------------------
int __stdcall sub_4019F0(char *VarName, unsigned __int8 *Str, char a3)
{
  unsigned __int8 *v3; // ebp
  char *v4; // eax
  unsigned __int8 *v5; // ebx
  unsigned int v6; // eax
  char v7; // al
  int result; // eax
  char *v9; // eax
  unsigned int v10; // eax
  _DWORD *v11; // esi
  char v12; // al
  _DWORD *v13; // eax
  _DWORD *v14; // edi
  _DWORD *v15; // eax
  char v16; // al
  int v17; // eax
  int v18; // [esp+10h] [ebp-8h]
  int v19; // [esp+14h] [ebp-4h]

  v19 = 0;
  v18 = 1;
  if ( (a3 & 2) != 0 )
  {
    v3 = Str;
    if ( !*Str )
    {
      v5 = (unsigned __int8 *)VarName;
      goto LABEL_19;
    }
    v4 = sub_40B690(Str);
    v5 = (unsigned __int8 *)VarName;
    if ( sub_401E00(VarName, v4) == -1 )
LABEL_4:
      sub_403220(dword_413424, 0x41Fu);
  }
  else
  {
    if ( !dword_4133B4 )
    {
      v5 = (unsigned __int8 *)VarName;
      v3 = Str;
      goto LABEL_19;
    }
    v5 = (unsigned __int8 *)VarName;
    if ( (byte_4133D4 & 4) != 0 )
    {
      v3 = Str;
      goto LABEL_19;
    }
    if ( !getenv(VarName) )
    {
      v3 = Str;
      goto LABEL_19;
    }
    v6 = sub_407B70((unsigned __int8 *)VarName);
    if ( v6 )
    {
      v7 = *(_BYTE *)(v6 + 12);
      if ( (v7 & 2) != 0 || (byte_4133D4 & 4) != 0 && (v7 & 4) != 0 )
        return 0;
    }
    v3 = Str;
    v9 = sub_40B690(Str);
    if ( sub_401E00(VarName, v9) == -1 )
      goto LABEL_4;
  }
LABEL_19:
  dword_4133B4 = 0;
  v10 = sub_407B70(v5);
  v11 = (_DWORD *)v10;
  if ( v10 )
  {
    v12 = *(_BYTE *)(v10 + 12);
    if ( (v12 & 2) != 0 || (byte_4133D4 & 4) != 0 && (v12 & 4) != 0 )
      return 0;
  }
  v13 = sub_40AD20();
  v13[1] = v3;
  v14 = v13;
  if ( v11 )
  {
    v19 = 1;
  }
  else
  {
    v15 = sub_40ACF0(0x10u);
    v15[1] = v5;
    v11 = v15;
  }
  v16 = v11[3] & 0xEF;
  *((_BYTE *)v11 + 12) = v16;
  *((_BYTE *)v11 + 12) = v16 | a3;
  sub_40AE10(v11 + 2, v14);
  if ( !v19 )
    sub_407BF0(v11);
  if ( mbschr(v3, 0x24u) )
  {
    *((_BYTE *)v11 + 12) |= 1u;
    v17 = sub_40B110(v3, 0, 0, v5, 1, 0, a3);
    *((_BYTE *)v11 + 12) &= ~1u;
    v18 = v17;
  }
  if ( v18 )
    return 1;
  result = 0;
  v11[2] = 0;
  *((_BYTE *)v11 + 12) &= 0x10u;
  return result;
}
// 4133B4: using guessed type int dword_4133B4;
// 4133D4: using guessed type char byte_4133D4;

//----- (00401BC0) --------------------------------------------------------
int __stdcall sub_401BC0(int a1)
{
  int *v1; // esi
  int result; // eax

  v1 = (int *)sub_40ACF0(0x14u);
  v1[2] = *(_DWORD *)(a1 + 4);
  sub_40AE10(&dword_413A34, v1);
  result = *v1;
  if ( *v1 )
    *(_DWORD *)(result + 4) = v1;
  return result;
}

//----- (00401BF0) --------------------------------------------------------
void __stdcall sub_401BF0(char *Block, int a2, int *a3)
{
  _DWORD *v3; // edi
  int *v4; // eax
  int *v5; // ebx
  int v6; // eax
  _DWORD *v7; // [esp-4h] [ebp-10h]

  if ( !*a3 )
    *a3 = (int)sub_40ACF0(0x18u);
  if ( a2 )
  {
    v3 = sub_40ACF0(8u);
    v3[1] = *a3;
  }
  else
  {
    v3 = sub_401ED0(*a3);
  }
  v4 = sub_40AEC0(Block, 128, (int)dword_413828, 1);
  v5 = v4;
  if ( v4 )
  {
    if ( (((unsigned __int8)byte_413A44 ^ *((_BYTE *)v4 + 8)) & 0x20) != 0 )
      sub_403220(dword_413424, 0x43Fu);
    sub_40AE30(v5 + 4, (int)v3);
    free(Block);
  }
  else
  {
    *v3 = 0;
    v7 = sub_40ACF0(0x14u);
    v7[1] = Block;
    v7[4] = v3;
    *((_BYTE *)v7 + 8) = byte_413A44;
    v6 = sub_40AE50(Block, 0x80u, 1);
    sub_40AE10(&dword_413828[v6], v7);
  }
}
// 413828: using guessed type _DWORD dword_413828[128];
// 413A44: using guessed type char byte_413A44;

//----- (00401CC0) --------------------------------------------------------
_DWORD *sub_401CC0()
{
  int i; // edi
  _DWORD *result; // eax

  for ( i = dword_413A2C; dword_413A2C; i = dword_413A2C )
  {
    dword_413A2C = *(_DWORD *)dword_413A2C;
    free(*(void **)(i + 4));
    result = sub_40ADA0((_DWORD *)i);
  }
  return result;
}
// 413A2C: using guessed type int dword_413A2C;

//----- (00401D00) --------------------------------------------------------
void __stdcall sub_401D00(_DWORD *a1, _DWORD *a2)
{
  int i; // edi
  _DWORD *v3; // ebx
  unsigned __int8 *j; // ebp
  _DWORD *v5; // ebx
  _DWORD *v6; // [esp-4h] [ebp-18h]
  unsigned __int8 *Str; // [esp+10h] [ebp-4h]

  for ( i = (int)a2; a2; i = (int)a2 )
  {
    if ( mbschr(*(const unsigned __int8 **)(i + 4), 0x24u) )
    {
      v3 = (_DWORD *)dword_413A28;
      Str = (unsigned __int8 *)sub_40B700(*(char **)(i + 4), (int)&dword_413A28);
      while ( (_DWORD *)dword_413A28 != v3 )
      {
        v6 = v3;
        v3 = (_DWORD *)*v3;
        sub_40ADA0(v6);
      }
      for ( j = mbstok(Str, &Delim); j; j = mbstok(0, &Delim) )
      {
        v5 = sub_40AD20();
        v5[1] = sub_40ADD0((const char *)j);
        sub_40AE30(a1, (int)v5);
      }
      free(Str);
      free(*(void **)(i + 4));
      a2 = (_DWORD *)*a2;
      sub_40ADA0((_DWORD *)i);
    }
    else
    {
      a2 = (_DWORD *)*a2;
      *(_DWORD *)i = 0;
      sub_40AE30(a1, i);
    }
  }
}
// 413A28: using guessed type int dword_413A28;

//----- (00401E00) --------------------------------------------------------
int __stdcall sub_401E00(const char *a1, const char *a2)
{
  char *v2; // edx

  v2 = (char *)sub_40ACC0(strlen(a2) + strlen(a1) + 2);
  strcpy(v2, a1);
  strcat(v2, "=");
  strcat(v2, a2);
  return putenv(v2);
}

//----- (00401ED0) --------------------------------------------------------
_DWORD *__stdcall sub_401ED0(int a1)
{
  _DWORD *v1; // esi
  _DWORD *v2; // eax

  v1 = sub_40ACF0(8u);
  v2 = sub_40ACF0(0x18u);
  *v2 = *(_DWORD *)a1;
  v2[1] = *(_DWORD *)(a1 + 4);
  v2[2] = *(_DWORD *)(a1 + 8);
  v2[3] = *(_DWORD *)(a1 + 12);
  *((_BYTE *)v2 + 16) = *(_BYTE *)(a1 + 16);
  v2[5] = *(_DWORD *)(a1 + 20);
  v1[1] = v2;
  return v1;
}

//----- (00401F10) --------------------------------------------------------
int sub_401F10()
{
  int *v0; // esi
  void *v1; // esp
  char *v2; // eax
  unsigned __int8 *v3; // edi
  int v4; // ebx
  int v6; // [esp+0h] [ebp-18h] BYREF
  intptr_t FindHandle; // [esp+Ch] [ebp-Ch] BYREF
  int v8; // [esp+10h] [ebp-8h] BYREF
  int v9; // [esp+14h] [ebp-4h] BYREF

  v0 = (int *)dword_4133DC;
  if ( !dword_4133DC )
    return 0;
  while ( !mbspbrk(*(const unsigned __int8 **)(dword_4133DC + 4), &Control) )
  {
    v8 = 0;
    if ( sub_402080(*(unsigned __int8 **)(dword_4133DC + 4), byte_4133D0, (unsigned int *)&v8, 0) < 0
      && (byte_4133D4 & 8) != 0 )
    {
      sub_402C40(v0);
      return 255;
    }
LABEL_11:
    dword_4133DC = *v0;
    sub_40ADA0(v0);
    v0 = (int *)dword_4133DC;
    if ( !dword_4133DC )
      return 0;
  }
  v1 = alloca(dword_413EE0);
  v9 = (int)&v6;
  if ( !sub_40CD20(*(unsigned __int8 **)(dword_4133DC + 4), &v9, &FindHandle) )
  {
    sub_403220(0, 0x42Du, *(_DWORD *)(dword_4133DC + 4));
    goto LABEL_11;
  }
  while ( 1 )
  {
    v2 = (char *)sub_404C90(&v9);
    v3 = (unsigned __int8 *)sub_40C340(*(char **)(dword_4133DC + 4), v2);
    v8 = sub_404CA0(&v9);
    v4 = sub_402080(v3, byte_4133D0, (unsigned int *)&v8, 0);
    free(v3);
    if ( v4 < 0 && (byte_4133D4 & 8) != 0 )
      break;
    if ( !sub_40CE00(&v9, FindHandle) )
      goto LABEL_11;
  }
  sub_402C40(v0);
  return -1;
}
// 4133D0: using guessed type char byte_4133D0;
// 4133D4: using guessed type char byte_4133D4;
// 4133DC: using guessed type int dword_4133DC;
// 413EE0: using guessed type int dword_413EE0;

//----- (00402080) --------------------------------------------------------
int __stdcall sub_402080(unsigned __int8 *Str1, char a2, unsigned int *a3, char *a4)
{
  int v4; // edi
  int *v5; // eax
  int result; // eax

  v4 = 1;
  ++dword_413010;
  v5 = sub_40AEC0((char *)Str1, 128, (int)dword_413828, 1);
  if ( !v5 )
  {
    v4 = 0;
    v5 = sub_402C70((char *)Str1, a2);
  }
  result = sub_4020E0((int)v5, a2, a3, v4, a4);
  --dword_413010;
  return result;
}
// 413010: using guessed type int dword_413010;
// 413828: using guessed type _DWORD dword_413828[128];

//----- (004020E0) --------------------------------------------------------
int __stdcall sub_4020E0(int a1, char a2, unsigned int *a3, int a4, char *a5)
{
  int result; // eax
  void *v6; // esp
  char *v7; // eax
  int *v8; // edx
  unsigned int v9; // esi
  unsigned int v10; // ecx
  int v11; // eax
  void *i; // ebx
  int v13; // eax
  char *v14; // eax
  char *v15; // eax
  void **j; // ebx
  char v17; // bl
  unsigned int v18; // eax
  int v19; // eax
  unsigned int v20; // esi
  char v21; // al
  char v22; // al
  bool v23; // cc
  char v24; // al
  unsigned int v25; // ecx
  _DWORD *v26; // eax
  char v27; // cl
  unsigned int v28; // eax
  unsigned int v29; // eax
  unsigned int v30; // eax
  char v31; // al
  char v32; // al
  char v33; // al
  __time32_t v34; // eax
  int v35; // ecx
  int v36; // [esp-4h] [ebp-158h]
  int v37; // [esp-4h] [ebp-158h]
  int v38; // [esp-4h] [ebp-158h]
  _DWORD *v39; // [esp-4h] [ebp-158h]
  _DWORD *v40; // [esp-4h] [ebp-158h]
  _DWORD *v41; // [esp-4h] [ebp-158h]
  int v42; // [esp+0h] [ebp-154h] BYREF
  unsigned __int8 Str2[260]; // [esp+Ch] [ebp-148h] BYREF
  int **v44; // [esp+110h] [ebp-44h]
  int *v45; // [esp+114h] [ebp-40h]
  int *v46; // [esp+118h] [ebp-3Ch]
  int *v47; // [esp+11Ch] [ebp-38h]
  int v48; // [esp+120h] [ebp-34h] BYREF
  __time32_t Time; // [esp+124h] [ebp-30h] BYREF
  int *v50; // [esp+128h] [ebp-2Ch]
  int v51; // [esp+12Ch] [ebp-28h] BYREF
  int v52; // [esp+130h] [ebp-24h] BYREF
  int v53; // [esp+134h] [ebp-20h] BYREF
  int v54; // [esp+138h] [ebp-1Ch] BYREF
  int v55; // [esp+13Ch] [ebp-18h] BYREF
  void *Block; // [esp+140h] [ebp-14h]
  int *v57; // [esp+144h] [ebp-10h]
  unsigned int v58; // [esp+148h] [ebp-Ch] BYREF
  _DWORD *v59; // [esp+14Ch] [ebp-8h]
  unsigned int v60; // [esp+150h] [ebp-4h]

  v52 = 0;
  if ( !a1 )
  {
    result = 0;
    *a3 = 0;
    return result;
  }
  if ( (*(_BYTE *)(a1 + 9) & 1) != 0 )
    sub_403220(0, 0x42Fu, *(_DWORD *)(a1 + 4));
  if ( (*(_BYTE *)(a1 + 9) & 2) != 0 )
  {
    if ( (a2 & 1) != 0 )
      sub_408D10(2 * dword_413010, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 12));
    *a3 = *(_DWORD *)(a1 + 12);
    return (*(_BYTE *)(a1 + 9) & 4) != 0;
  }
  v6 = alloca(dword_413EE0);
  v54 = (int)&v42;
  v53 = 0;
  v55 = 0;
  v44 = 0;
  v46 = 0;
  v60 = 0;
  Time = 0;
  v7 = *(char **)(a1 + 4);
  v58 = 0;
  v48 = 0;
  v45 = 0;
  *(_BYTE *)(a1 + 9) |= 1u;
  dword_413A90 = v7;
  dword_413A8C = (int)v7;
  v8 = *(int **)(a1 + 16);
  v50 = v8;
  if ( v8 && (*(_BYTE *)(v8[1] + 16) & 0x20) != 0 && sub_40CD20(*(unsigned __int8 **)(a1 + 4), &v54, &v51) )
    v60 = sub_404CA0(&v54);
  for ( ; v50; v50 = (int *)*v50 )
  {
    v9 = 0;
    v57 = (int *)v50[1];
    v47 = v57 + 5;
    v10 = v57[5];
    if ( v10 )
    {
      v11 = v60;
      if ( v60 <= v10 )
        v11 = v57[5];
      v60 = v11;
    }
    else
    {
      v36 = *(_DWORD *)(a1 + 4);
      v45 = v47;
      Block = sub_402870(v57, v36);
      for ( i = Block; i; i = *(void **)i )
      {
        v58 = *((_DWORD *)i + 2);
        v13 = sub_402080(*((unsigned __int8 **)i + 1), *((_BYTE *)v57 + 16), &v58, 0);
        v52 += v13;
        if ( dword_4133A4 && v13 )
        {
          if ( (*((_BYTE *)sub_40AEC0(*((char **)i + 1), 128, (int)dword_413828, 1) + 9) & 8) == 0 )
          {
            dword_4133B0 = 0;
            sub_403220(0, 0xFAAu, *((_DWORD *)i + 1));
          }
          *(_BYTE *)(a1 + 9) |= 8u;
        }
        if ( v9 <= v58 )
          v9 = v58;
        if ( !v60 && (v57[4] & 0x20) == 0 && sub_40CD20(*(unsigned __int8 **)(a1 + 4), &v54, &v51) )
        {
          v60 = sub_404CA0(&v54);
          *(_DWORD *)(a1 + 12) = v60;
        }
        if ( (*(_BYTE *)(a1 + 8) & 0x10) != 0 || v58 > v60 || dword_4133B8 && v58 == v60 )
        {
          v59 = sub_40AD20();
          v14 = sub_40ADD0(*((const char **)i + 1));
          v37 = (int)v59;
          v59[1] = v14;
          sub_40AE30(&v53, v37);
        }
        v59 = sub_40AD20();
        v15 = sub_40ADD0(*((const char **)i + 1));
        v38 = (int)v59;
        v59[1] = v15;
        sub_40AE30(&v55, v38);
      }
      for ( j = (void **)Block; Block; j = (void **)Block )
      {
        free(j[1]);
        Block = *j;
        free(j);
      }
      if ( (v57[4] & 0x20) != 0 )
      {
        if ( v57[2] )
        {
          dword_413A94 = v53;
          dword_413A90 = *(char **)(a1 + 4);
          dword_413A8C = (int)dword_413A90;
          dword_413A84 = 0;
          dword_413A88 = 0;
          dword_413A98 = v55;
          if ( (dword_4133A4 && (*(_BYTE *)(a1 + 9) & 8) == 0 || !v52) && v9 > v60
            || dword_4133B8 && v9 == v60
            || !v60 && !v9
            || !*v57 )
          {
            v17 = byte_414008;
            byte_414008 = 1;
            if ( !a5 )
            {
              if ( v55 )
                a5 = *(char **)(v55 + 4);
              else
                a5 = 0;
            }
            v18 = sub_4036C0(*(unsigned __int8 **)(a1 + 4), (int **)v57[2], v57[3], *((_BYTE *)v57 + 16), a5);
            v52 += v18;
            if ( (*(_BYTE *)(a1 + 8) & 4) != 0 || !sub_40CD20(*(unsigned __int8 **)(a1 + 4), &v54, &v51) )
            {
              if ( v48 )
                Time = v48;
              else
                sub_40CEA0(&Time);
            }
            else
            {
              Time = sub_404CA0(&v54);
            }
            *v47 = Time;
            v39 = (_DWORD *)v55;
            if ( v55 != v53 )
            {
              sub_402C40((_DWORD *)v55);
              v39 = (_DWORD *)v53;
            }
            sub_402C40(v39);
            v53 = 0;
            v55 = 0;
            byte_414008 = v17;
          }
          if ( dword_4133A4 && (*(_BYTE *)(a1 + 9) & 8) != 0 )
            sub_403220(0, 0xFABu, *(_DWORD *)(a1 + 4));
        }
      }
      else
      {
        if ( v57[2] )
        {
          if ( v46 )
            sub_403220(0, 0xFA4u, *(_DWORD *)(a1 + 4));
          else
            v46 = v57;
        }
        v19 = v48;
        if ( v48 <= v9 )
          v19 = v9;
        v48 = v19;
      }
      if ( (v57[4] & 0x20) != 0 && !*v50 )
      {
        v21 = *(_BYTE *)(a1 + 9) & 0xFE;
        *(_BYTE *)(a1 + 9) = v21;
        v22 = v21 | 2;
        v23 = v52 <= 0;
        *(_BYTE *)(a1 + 9) = v22;
        if ( v23 )
          v24 = v22 & 0xFB;
        else
          v24 = v22 | 4;
        v25 = Time;
        *(_BYTE *)(a1 + 9) = v24;
        if ( v25 <= v60 )
          v25 = v60;
        *(_DWORD *)(a1 + 12) = v25;
        *a3 = v25;
        return v52;
      }
    }
  }
  dword_413A84 = 0;
  dword_413A88 = 0;
  v20 = *a3;
  if ( !*a3 )
  {
    if ( *(_DWORD *)(a1 + 12) )
    {
      v20 = *(_DWORD *)(a1 + 12);
    }
    else if ( sub_40CD20(*(unsigned __int8 **)(a1 + 4), &v54, &v51) )
    {
      v20 = sub_404CA0(&v54);
    }
  }
  if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
    sub_408D10(2 * dword_413010, *(_DWORD *)(a1 + 4), v20);
  v26 = sub_40A500(a1, Str2, v20, (int ***)&v53, (int ***)&v55, &v52, (unsigned int *)&v48, &a5);
  if ( v26 && !v46 )
  {
    dword_413A88 = (int)Str2;
    v44 = (int **)v26[3];
  }
  dword_413A90 = *(char **)(a1 + 4);
  dword_413A8C = (int)dword_413A90;
  dword_413A94 = v53;
  dword_413A98 = v55;
  if ( (!dword_4133A4 || (*(_BYTE *)(a1 + 9) & 8) != 0) && v52
    || v48 <= v20 && (!dword_4133B8 || v48 != v20) && (v20 || v48) && (*(_BYTE *)(a1 + 8) & 0x10) == 0 )
  {
    if ( (byte_4133D4 & 8) == 0 && dword_413010 == 1 && (*(_BYTE *)(a1 + 9) & 8) == 0 )
      sub_403370(2u, *(_DWORD *)(a1 + 4));
  }
  else
  {
    v27 = byte_414008;
    byte_414008 = 1;
    LOBYTE(v60) = v27;
    if ( v46 )
    {
      if ( !a5 )
      {
        if ( v55 )
          a5 = *(char **)(v55 + 4);
        else
          a5 = 0;
      }
      v28 = sub_4036C0(*(unsigned __int8 **)(a1 + 4), (int **)v46[2], v46[3], *((_BYTE *)v46 + 16), a5);
      v52 += v28;
    }
    else if ( v44 )
    {
      v29 = sub_4036C0(*(unsigned __int8 **)(a1 + 4), v44, v26[4], *(_BYTE *)(a1 + 8), a5);
      v52 += v29;
    }
    else if ( (byte_4133D4 & 0x10) != 0 )
    {
      v30 = sub_4036C0(*(unsigned __int8 **)(a1 + 4), (int **)v57[2], v57[3], *((_BYTE *)v57 + 16), a5);
      v52 += v30;
    }
    else if ( !a4 && !v20 )
    {
      if ( dword_4133A4 )
        v52 = 1;
      else
        sub_403220(0, 0x431u, *(_DWORD *)(a1 + 4));
    }
    byte_414008 = v60;
    if ( v46 || v44 || !dword_413A98 )
    {
      sub_40CEA0(&Time);
      Time += 2;
    }
    else
    {
      Time = v48;
    }
    if ( v45 && v46 )
      *v45 = Time;
  }
  if ( dword_4133A4 && v52 )
  {
    dword_4133B0 = 0;
    if ( (*(_BYTE *)(a1 + 9) & 8) != 0 )
    {
      sub_403220(0, 0xFABu, *(_DWORD *)(a1 + 4));
    }
    else if ( dword_413010 == 1 )
    {
      sub_403220(0, 0xFAAu, *(_DWORD *)(a1 + 4));
    }
  }
  if ( (byte_4133D4 & 8) == 0 || dword_413010 != 1 )
  {
    v31 = *(_BYTE *)(a1 + 9) & 0xFE;
    *(_BYTE *)(a1 + 9) = v31;
    v32 = v31 | 2;
    v23 = v52 <= 0;
    *(_BYTE *)(a1 + 9) = v32;
    if ( v23 )
      v33 = v32 & 0xFB;
    else
      v33 = v32 | 4;
    *(_BYTE *)(a1 + 9) = v33;
    v34 = Time;
    if ( Time <= v20 )
      v34 = v20;
    v35 = v53;
    *(_DWORD *)(a1 + 12) = v34;
    *a3 = v34;
    v41 = (_DWORD *)v55;
    if ( v55 != v35 )
    {
      sub_402C40((_DWORD *)v55);
      v41 = (_DWORD *)v53;
    }
    sub_402C40(v41);
    return v52;
  }
  v40 = (_DWORD *)v55;
  if ( v55 != v53 )
  {
    sub_402C40((_DWORD *)v55);
    v40 = (_DWORD *)v53;
  }
  sub_402C40(v40);
  return (dword_413A50 == 0) - 1;
}
// 413010: using guessed type int dword_413010;
// 4133A4: using guessed type int dword_4133A4;
// 4133B0: using guessed type int dword_4133B0;
// 4133B8: using guessed type int dword_4133B8;
// 4133D4: using guessed type char byte_4133D4;
// 413828: using guessed type _DWORD dword_413828[128];
// 413A50: using guessed type int dword_413A50;
// 413A84: using guessed type int dword_413A84;
// 413A88: using guessed type int dword_413A88;
// 413A8C: using guessed type int dword_413A8C;
// 413A94: using guessed type int dword_413A94;
// 413A98: using guessed type int dword_413A98;
// 413EE0: using guessed type int dword_413EE0;
// 414008: using guessed type char byte_414008;

//----- (00402870) --------------------------------------------------------
_DWORD *__stdcall sub_402870(int *a1, int a2)
{
  int v2; // edx
  _BYTE *v3; // eax
  char *v4; // esi
  char *v5; // ebp
  char *v6; // eax
  char *v7; // edi
  char *v8; // eax
  _DWORD *v9; // edi
  char *v10; // eax
  void *v12; // [esp+10h] [ebp-28h] BYREF
  intptr_t FindHandle; // [esp+14h] [ebp-24h] BYREF
  _DWORD *v14; // [esp+18h] [ebp-20h] BYREF
  unsigned __int8 *String; // [esp+1Ch] [ebp-1Ch] BYREF
  int v16; // [esp+20h] [ebp-18h]
  _BYTE *v17; // [esp+24h] [ebp-14h] BYREF
  int i; // [esp+28h] [ebp-10h]
  void *Block; // [esp+2Ch] [ebp-Ch]
  void *v20; // [esp+30h] [ebp-8h]
  int v21; // [esp+34h] [ebp-4h] BYREF

  v14 = 0;
  v12 = sub_40ACF0(dword_413EE0);
  v2 = *a1;
  v21 = a1[1];
  for ( i = v2; i; i = *(_DWORD *)i )
  {
    v3 = *(_BYTE **)(i + 4);
    if ( !*v3 )
      goto LABEL_9;
    do
    {
      if ( *v3 == 36 )
        break;
      if ( *v3 == 94 )
        ++v3;
      ++v3;
    }
    while ( *v3 );
    if ( *v3 )
    {
      dword_413A84 = a2;
      Block = sub_40B700(*(char **)(i + 4), (int)&v21);
    }
    else
    {
LABEL_9:
      Block = *(void **)(i + 4);
    }
    v20 = sub_40ADD0((const char *)Block);
    v17 = v20;
    while ( sub_402B20(&v17, &String) )
    {
      v4 = (char *)String;
      if ( *String == 123 )
      {
        do
        {
          if ( *v4 == 125 )
            break;
          if ( *v4 == 94 )
            ++v4;
          ++v4;
        }
        while ( *v4 );
        if ( *v4 )
        {
          *v4++ = 0;
          ++String;
        }
      }
      else
      {
        String = 0;
      }
      v16 = 0;
      sub_404CC0(&v12, 0);
      v5 = sub_40ADD0(v4);
      if ( mbspbrk((const unsigned __int8 *)v4, &Control) || String )
      {
        v6 = sub_405930((char *)String, (unsigned __int8 *)v4, (int)v12, &FindHandle);
        v7 = v6;
        if ( v6 )
        {
          v4 = v6;
          v16 = 1;
          free(v5);
          v8 = (char *)sub_404C90(&v12);
          v5 = sub_40C340(v7, v8);
        }
      }
      do
      {
        v9 = sub_40ACF0(0xCu);
        v9[1] = sub_40ADD0(v5);
        if ( !dword_4133A8 || sub_40CD20((unsigned __int8 *)v5, &v12, &FindHandle) )
          v9[2] = sub_404CA0(&v12);
        else
          v9[2] = 0;
        if ( dword_4133A8 )
          sub_402AE0(&v14, v9);
        else
          sub_40AE30(&v14, (int)v9);
        free(v5);
        if ( !v16 )
          break;
        if ( !mbspbrk((const unsigned __int8 *)v4, &Control) )
          break;
        if ( !sub_40CE00(&v12, FindHandle) )
          break;
        v10 = (char *)sub_404C90(&v12);
        v5 = sub_40C340(v4, v10);
      }
      while ( v5 );
    }
    if ( *(void **)(i + 4) != Block )
      free(Block);
    free(v20);
  }
  free(v12);
  return v14;
}
// 4133A8: using guessed type int dword_4133A8;
// 413A84: using guessed type int dword_413A84;
// 413EE0: using guessed type int dword_413EE0;

//----- (00402AE0) --------------------------------------------------------
unsigned int __stdcall sub_402AE0(_DWORD **a1, _DWORD *a2)
{
  unsigned int result; // eax
  _DWORD *v3; // edx
  _DWORD *i; // ecx

  result = a2[2];
  v3 = *a1;
  for ( i = *a1; i; i = (_DWORD *)*i )
  {
    if ( i[2] < result )
      break;
    v3 = i;
  }
  if ( v3 == i )
  {
    *a1 = a2;
  }
  else
  {
    *v3 = a2;
    *a2 = i;
  }
  return result;
}

//----- (00402B20) --------------------------------------------------------
int __stdcall sub_402B20(_BYTE **a1, _DWORD *a2)
{
  _BYTE *i; // edi
  int result; // eax
  _BYTE *v4; // edi
  _BYTE *v5; // edi

  for ( i = *a1; *i; ++i )
  {
    if ( *i != 32 && *i != 9 )
      break;
  }
  *a2 = i;
  if ( !*i )
    return 0;
  *a2 = i;
  if ( *i == 34 )
  {
    while ( *i )
    {
      if ( *++i == 34 )
      {
        if ( *i )
          goto LABEL_36;
        break;
      }
    }
    sub_403220(0, 0x40Eu);
LABEL_36:
    v5 = i + 1;
    if ( *v5 )
      *v5++ = 0;
    result = 1;
    *a1 = v5;
  }
  else
  {
    if ( *i != 123 )
      goto LABEL_41;
    do
    {
      if ( *i == 34 )
      {
        do
        {
          if ( *i == 34 )
            break;
          ++i;
        }
        while ( *i );
      }
      else if ( *++i == 125 )
      {
        break;
      }
    }
    while ( *i );
    if ( !*i )
      sub_403220(0, 0x423u);
    if ( *++i == 34 )
    {
      while ( *i )
      {
        if ( *++i == 34 )
        {
          if ( *i )
            goto LABEL_22;
          break;
        }
      }
      sub_403220(0, 0x40Eu);
LABEL_22:
      v4 = i + 1;
      if ( *v4 )
        *v4++ = 0;
      result = 1;
      *a1 = v4;
    }
    else
    {
LABEL_41:
      if ( *i )
      {
        do
        {
          if ( *i == 32 )
            break;
          if ( *i == 9 )
            break;
          ++i;
        }
        while ( *i );
        if ( *i )
          *i++ = 0;
      }
      result = 1;
      *a1 = i;
    }
  }
  return result;
}

//----- (00402C40) --------------------------------------------------------
_DWORD *__stdcall sub_402C40(_DWORD *a1)
{
  _DWORD *v1; // edi
  _DWORD *i; // ebx
  _DWORD *result; // eax

  v1 = a1;
  for ( i = a1; v1; i = v1 )
  {
    v1 = (_DWORD *)*v1;
    free((void *)i[1]);
    result = sub_40ADA0(i);
  }
  return result;
}

//----- (00402C70) --------------------------------------------------------
_DWORD *__stdcall sub_402C70(char *a1, char a2)
{
  _DWORD *v2; // esi
  int v3; // eax

  v2 = sub_40ACF0(0x14u);
  v2[1] = sub_40ADD0(a1);
  *((_BYTE *)v2 + 8) = a2;
  *((_BYTE *)v2 + 9) = 0;
  v2[3] = 0;
  v2[4] = 0;
  v3 = sub_40AE50(a1, 0x80u, 1);
  sub_40AE10(&dword_413828[v3], v2);
  return v2;
}
// 413828: using guessed type _DWORD dword_413828[128];

//----- (00402CC0) --------------------------------------------------------
void __stdcall sub_402CC0(unsigned __int8 *String)
{
  unsigned int v1; // kr04_4
  char *v2; // ecx
  char *v3; // eax
  unsigned int v6; // [esp+10h] [ebp-10h] BYREF
  void *Block; // [esp+14h] [ebp-Ch] BYREF
  int v8; // [esp+18h] [ebp-8h] BYREF
  void *v9; // [esp+1Ch] [ebp-4h] BYREF

  v8 = 0;
  Stream = sub_40CA80(String, aRt);
  if ( !Stream )
    sub_403220(0, 0x41Cu, String);
  v9 = 0;
  while ( fgets(::String, 1024, Stream) )
  {
    v1 = strlen(::String) + 1;
    v6 = v1 - 1;
    if ( v1 == 1024 && (v2 = &byte_413A9F[1023], byte_413A9F[1023] != 10)
      || (v2 = &byte_413A9F[v6], byte_413A9F[v6] == 10) && byte_413A9E[v6] == 92 )
    {
      v3 = &byte_413A9E[v6];
      if ( byte_413A9E[v6] == 92 )
      {
        *v2 = 0;
        --v6;
        *v3 = 32;
      }
      Block = sub_40ADD0(::String);
      sub_402E60(&Block, (char **)&v6);
    }
    else
    {
      Block = ::String;
    }
    sub_402F60((unsigned __int8 *)Block, &v8, &v9);
    if ( Block != ::String )
      free(Block);
  }
  if ( fclose(Stream) == -1 )
    sub_403220(0, 0x424u, String);
  sub_408320(v8, (const char **)v9);
  while ( v8-- )
  {
    if ( *((_DWORD *)v9 + v8) )
      free(*((void **)v9 + v8));
  }
  free(v9);
}

//----- (00402E60) --------------------------------------------------------
char *__stdcall sub_402E60(void **a1, char **a2)
{
  char *result; // eax
  unsigned int v3; // ecx
  char *v4; // edx
  unsigned int v5; // kr08_4
  void *v6; // eax
  char *v7; // [esp+10h] [ebp-4h]

  for ( result = *a2; *((_BYTE *)*a1 + (_DWORD)*a2 - 1) != 10; result = (char *)*a1 )
  {
    result = fgets(String, 1024, Stream);
    if ( !result )
      break;
    v3 = strlen(String);
    if ( byte_413A9E[v3] == 92 && byte_413A9F[v3] == 10 )
    {
      byte_413A9F[v3] = 0;
      byte_413A9E[v3] = 32;
    }
    v4 = *a2;
    v7 = *a2;
    v5 = strlen(String) + 1;
    *a2 = &(*a2)[v5 - 1];
    v6 = realloc(*a1, (size_t)&v4[v5]);
    *a1 = v6;
    if ( !v6 )
      sub_403220(dword_4133F4, 0x419u);
    strcpy((char *)*a1 + (_DWORD)v7, String);
  }
  return result;
}

//----- (00402F60) --------------------------------------------------------
void __stdcall sub_402F60(unsigned __int8 *Str, int *a2, void **a3)
{
  int v3; // ebx
  unsigned __int8 *v4; // edi
  bool v5; // zf
  unsigned __int8 v6; // al
  char *v7; // ebp
  char v8; // al
  char *v9; // ebp
  void *Block; // [esp+10h] [ebp-8h] BYREF
  char *i; // [esp+14h] [ebp-4h] BYREF

  v3 = 0;
  Block = mbschr(Str, 0x22u);
  if ( Block )
  {
    if ( Str == Block || *((char *)Block - 1) != 61 )
    {
      *(_BYTE *)Block = 0;
      Block = (char *)Block + 1;
      sub_403120(Str, a2, a3);
    }
    else
    {
      *(_BYTE *)Block = 32;
      Block = (char *)Block - 1;
      v4 = (unsigned __int8 *)Block;
      v5 = Str == Block;
      if ( Str < Block )
      {
        do
        {
          v6 = *v4;
          if ( *v4 == 32 )
            break;
          if ( v6 == 9 )
            break;
          if ( v6 == 10 )
            break;
          --v4;
        }
        while ( Str < v4 );
        v5 = Str == v4;
      }
      if ( !v5 )
      {
        *v4++ = 0;
        sub_403120(Str, a2, a3);
      }
      Block = v4;
    }
    v7 = (char *)Block;
    for ( i = (char *)strlen((const char *)Block); *v7; ++v7 )
    {
      if ( *v7 == 34 )
      {
        if ( v7[1] != 34 )
        {
          *v7++ = 0;
          sub_4031B0((const char *)Block, *a2, a3);
          ++*a2;
          sub_402F60((unsigned __int8 *)v7 + 1, (int)a2, (int)a3);
          break;
        }
        strcpy(v7, v7 + 1);
      }
      else if ( *v7 == 92 )
      {
        v8 = *(v7 - 1);
        if ( (v8 == 32 || v8 == 9) && v7[1] == 10 )
        {
          *v7 = 0;
          i -= 2;
          v9 = i;
          if ( !v3 )
          {
            v3 = 1;
            Block = sub_40ADD0((const char *)Block);
          }
          sub_402E60(&Block, &i);
          v7 = &v9[(_DWORD)Block];
        }
      }
    }
    if ( &i[(_DWORD)Block] == v7 )
      sub_403220(0, 0x3EEu);
    if ( v3 )
      free(Block);
  }
  else
  {
    sub_403120(Str, a2, a3);
  }
}

//----- (00403120) --------------------------------------------------------
unsigned __int8 *__stdcall sub_403120(unsigned __int8 *Str, int *a2, void **a3)
{
  unsigned __int8 *v3; // eax
  char v4; // cl
  unsigned __int8 *result; // eax

  v3 = mbschr(Str, 0x5Cu);
  if ( v3 )
  {
    v4 = *(v3 - 1);
    if ( (v4 == 32 || v4 == 9) && v3[1] == 10 )
      *v3 = 0;
  }
  result = mbstok(Str, &byte_413018);
  if ( result )
  {
    while ( *result != 64 )
    {
      sub_4031B0((const char *)result, *a2, a3);
      ++*a2;
      result = mbstok(0, &byte_413018);
      if ( !result )
        return result;
    }
    return (unsigned __int8 *)sub_403220(0, 0xFA1u, result + 1);
  }
  return result;
}

//----- (004031B0) --------------------------------------------------------
char *__stdcall sub_4031B0(const char *a1, int a2, void **a3)
{
  int v3; // esi
  void *v4; // eax
  char *result; // eax

  if ( *a3 )
  {
    v3 = a2;
    if ( (a2 & 7) == 0 )
    {
      v4 = realloc(*a3, 4 * a2 + 32);
      *a3 = v4;
      if ( !v4 )
        sub_403220(0, 0x41Bu);
    }
  }
  else
  {
    v3 = a2;
    *a3 = sub_40ACF0(0x20u);
  }
  result = sub_40ADD0(a1);
  *((_DWORD *)*a3 + v3) = result;
  return result;
}

//----- (00403220) --------------------------------------------------------
int sub_403220(int a1, unsigned int a2, ...)
{
  int v2; // esi
  int result; // eax
  FILE *v4; // eax
  void (*v5)(FILE *const, const char *const, ...); // ebx
  FILE *v6; // eax
  unsigned int v7; // ebp
  FILE *v8; // eax
  FILE *v9; // eax
  FILE *v10; // eax
  FILE *v11; // eax
  FILE *v12; // eax
  const char *v13; // [esp-8h] [ebp-18h]
  char *v14; // [esp-8h] [ebp-18h]
  va_list va; // [esp+1Ch] [ebp+Ch] BYREF

  va_start(va, a2);
  v2 = 2;
  if ( (byte_4133D4 & 0x20) == 0 || (result = a2 / 0x3E8, a2 / 0x3E8 != 4) )
  {
    sub_403420();
    if ( a1 )
    {
      v13 = dword_4133F8;
      v4 = _p__iob();
      v5 = (void (*)(FILE *const, const char *const, ...))fprintf;
      fprintf(v4 + 2, "%s(%d) : ", v13, a1);
    }
    else
    {
      v6 = _p__iob();
      v5 = (void (*)(FILE *const, const char *const, ...))fprintf;
      fprintf(v6 + 2, "%s : ", aNmake);
    }
    v7 = a2 / 0x3E8;
    if ( a2 / 0x3E8 == 1 )
    {
      sub_403370(0x14u);
      if ( a2 == 1051 )
        v2 = 4;
    }
    else if ( v7 == 2 )
    {
      sub_403370(0x15u);
    }
    else if ( v7 == 4 )
    {
      sub_403370(0x16u);
    }
    v8 = _p__iob();
    v5(v8 + 2, " U%04d: ", a2);
    v14 = sub_403410(a2);
    v9 = _p__iob();
    vfprintf(v9 + 2, v14, va);
    v10 = _p__iob();
    putc(10, v10 + 2);
    v11 = _p__iob();
    result = fflush(v11 + 2);
    if ( v7 == 1 )
    {
      v12 = _p__iob();
      v5(v12 + 2, "Stop.\n");
      sub_408A20();
      exit(v2);
    }
  }
  return result;
}
// 4133D4: using guessed type char byte_4133D4;

//----- (00403370) --------------------------------------------------------
FILE *sub_403370(unsigned int a1, ...)
{
  FILE *result; // eax
  FILE *v2; // edi
  char *v3; // eax
  va_list va; // [esp+10h] [ebp+8h] BYREF

  va_start(va, a1);
  result = _p__iob();
  v2 = result + 1;
  if ( (byte_4133D4 & 0x20) == 0 )
  {
    sub_403420();
    if ( a1 >= 0x14 && a1 <= 0x19 )
      v2 = _p__iob() + 2;
    if ( a1 == 24 )
      putc(10, v2);
    v3 = sub_403410(a1);
    vfprintf(v2, v3, va);
    if ( (a1 < 0xA || a1 > 0x17) && a1 != 120 )
      putc(10, v2);
    return (FILE *)fflush(v2);
  }
  return result;
}
// 4133D4: using guessed type char byte_4133D4;

//----- (00403410) --------------------------------------------------------
char *__stdcall sub_403410(int a1)
{
  return sub_40A660(a1);
}

//----- (00403420) --------------------------------------------------------
void sub_403420()
{
  FILE *v0; // eax

  if ( !dword_4133CC )
  {
    dword_4133CC = 1;
    nullsub_1(1, 24);
    nullsub_1(2, 25);
    sub_403370(0x18u, a150);
    sub_403370(0x19u, a198894);
    v0 = _p__iob();
    fflush(v0 + 2);
  }
}
// 4133CC: using guessed type int dword_4133CC;

//----- (00403490) --------------------------------------------------------
FILE *sub_403490()
{
  unsigned int v0; // esi
  BOOL v1; // ebp
  unsigned int i; // ebx
  unsigned int v4; // [esp-8h] [ebp-B8h]
  char ArgList[80]; // [esp+10h] [ebp-A0h] BYREF
  char v6[80]; // [esp+60h] [ebp-50h] BYREF

  v0 = 100;
  v1 = 0;
  do
  {
    v4 = v0++;
    sub_403370(v4, aNmake);
  }
  while ( v0 < 0x67 );
  for ( i = 103; i < 0x78; ++i )
  {
    if ( i == 111 )
      i = 112;
    if ( i == 119 )
      i = 120;
    if ( i == 120 )
      break;
    if ( v1 )
    {
      strcpy(v6, sub_403410(i));
      sub_403370(0x7Du, ArgList, v6);
    }
    else
    {
      strcpy(ArgList, sub_403410(i));
    }
    v1 = !v1;
  }
  if ( v1 )
    sub_403370(0x7Du, ArgList, byte_413060);
  return sub_403370(0x78u);
}

//----- (00403580) --------------------------------------------------------
void __stdcall sub_403580(unsigned int *a1, const unsigned __int8 **a2, unsigned __int8 *Str)
{
  int v3; // ebx
  unsigned __int8 *v4; // edi
  unsigned __int8 *i; // esi
  const unsigned __int8 *v7; // esi
  unsigned __int8 *v8; // esi
  const unsigned __int8 *j; // esi
  unsigned int v10; // eax

  v3 = 1;
  v4 = Str;
  for ( i = Str; *v4; ++v4 )
    ;
  *a1 = 0;
  do
  {
    if ( v4 <= i )
      break;
    v7 = &i[mbsspn(i, &Delim)];
    if ( v4 <= v7 )
      break;
    *a2++ = v7;
    if ( *v7 == 34 )
    {
      i = (unsigned __int8 *)(v7 + 1);
      if ( v4 <= i )
        goto LABEL_32;
      do
      {
        if ( *i == 92 )
        {
          ++i;
        }
        else if ( *i == 34 )
        {
          break;
        }
        ++i;
      }
      while ( v4 > i );
      if ( v4 <= i )
        goto LABEL_32;
      v8 = mbspbrk(i + 1, &Delim);
    }
    else
    {
      v8 = mbspbrk(v7, asc_4132E0);
      if ( v8 )
      {
        do
        {
          if ( v4 <= v8 )
            break;
          if ( *v8 != 47 )
            break;
          if ( v3 )
            break;
          v8 = mbspbrk(v8 + 1, asc_4132E0);
        }
        while ( v8 );
        if ( v8 && *v8 == 34 )
        {
          for ( j = v8 + 1; v4 > j; ++j )
          {
            if ( *j == 34 )
              break;
          }
          v8 = mbspbrk(j, &Delim);
        }
      }
      if ( v3 )
      {
        v3 = 0;
        if ( !v8 )
          goto LABEL_30;
        if ( *v8 == 47 )
        {
          *v8-- = 0;
          *(a2 - 1) = (const unsigned __int8 *)sub_40ADD0((const char *)*(a2 - 1));
          v8[1] = 47;
        }
      }
    }
    if ( !v8 )
LABEL_30:
      v8 = v4;
    *v8 = 0;
    i = v8 + 1;
LABEL_32:
    v10 = *a1 + 1;
    *a1 = v10;
  }
  while ( v10 < 0x7F );
  *a2 = 0;
}

//----- (004036C0) --------------------------------------------------------
unsigned int __stdcall sub_4036C0(unsigned __int8 *a1, int **a2, int a3, char a4, char *a5)
{
  int **v6; // edi
  int v7; // eax
  _BYTE *v8; // ecx
  char i; // bl
  char *v10; // ebp
  int v11; // eax
  char *v12; // ebx
  char *v13; // ebp
  int v14; // ecx
  int v15; // edx
  intptr_t v16; // eax
  char v17; // bl
  char v18; // [esp+13h] [ebp-15h]
  char *String; // [esp+14h] [ebp-14h] BYREF
  unsigned int v20; // [esp+18h] [ebp-10h] BYREF
  void *Block; // [esp+1Ch] [ebp-Ch] BYREF
  char ArgList[4]; // [esp+20h] [ebp-8h] BYREF
  int v23; // [esp+24h] [ebp-4h]

  ++dword_413A50;
  v20 = 0;
  if ( (byte_4133D4 & 8) != 0 )
    return 0;
  nullsub_1(3, 15);
  if ( (byte_4133D4 & 0x10) != 0 )
  {
    sub_404C10(a1, a4 & 4);
    return 0;
  }
  v6 = a2;
  if ( !a2 )
    goto LABEL_69;
  while ( 2 )
  {
    v7 = sub_406020((unsigned __int8 *)v6[1], (unsigned __int8 **)&Block, (int)&a3);
    v8 = Block;
    v23 = v7;
    v18 = 0;
    dword_413A4C = 0;
    String = (char *)Block;
    for ( i = *(_BYTE *)Block; *v8; ++v8 )
    {
      if ( *v8 == 94 || *v8 == 36 )
        ++v8;
    }
    while ( i == 33 || i == 45 || i == 64 || i == 94 || i == 32 || i == 9 )
    {
      switch ( i )
      {
        case '!':
          v18 |= 4u;
          goto LABEL_33;
        case '-':
          ++String;
          v18 |= 2u;
          if ( !ismbcdigit(*String) )
          {
            dword_413A4C = 255;
LABEL_26:
            --String;
            goto LABEL_33;
          }
          v10 = String;
          dword_413A4C = strtol(String, &String, 10);
          if ( *errno() == 34 )
          {
            *String = 0;
            sub_403220(dword_4133F4, 0x436u, v10);
          }
          if ( !ismbcspace(*String) )
            goto LABEL_26;
          do
            ++String;
          while ( ismbcspace(*String) );
          --String;
LABEL_33:
          if ( i == 94 )
            goto LABEL_35;
          i = *++String;
          break;
        case '@':
          if ( (byte_4133D0 & 4) == 0 )
            v18 |= 1u;
          goto LABEL_33;
        case '^':
          if ( *++String == 32 || (v11 = 0, *String == 9) )
            v11 = 1;
          i = v11 == 0 ? 94 : 32;
          goto LABEL_33;
        default:
          goto LABEL_33;
      }
    }
LABEL_35:
    if ( (v18 & 4) != 0 && sub_4048B0(String, a3, a4, v18, a5, &v20) )
    {
      v12 = String;
      if ( mbschr((const unsigned __int8 *)String, 0x24u) )
        String = sub_40B700(String, (int)&a3);
      if ( v12 != String )
        free(String);
      if ( (a4 & 2) != 0 || !dword_4133A4 || !v20 || v20 <= dword_413A4C )
      {
LABEL_68:
        v6 = (int **)*v6;
        if ( !v6 )
          break;
        continue;
      }
    }
    else
    {
      v13 = String;
      if ( !v23 && mbschr((const unsigned __int8 *)String, 0x24u) )
        String = sub_40B700(String, (int)&a3);
      sub_40C790(byte_411250, String, a5);
      if ( (a4 & 4) == 0 || (v14 = 0, (v18 & 8) != 0) )
        v14 = 1;
      v15 = (a4 & 4) != 0 || (a4 & 8) == 0 && (v18 & 1) == 0;
      v16 = sub_403AF0(byte_411250, v15, v14, v18 & 2, (char **)ArgList);
      v20 = v16;
      v17 = a4 & 2;
      if ( (a4 & 2) == 0 && v16 && v20 > dword_413A4C && !dword_4133A4 )
        sub_403220(0, 0x435u, *(_DWORD *)ArgList, v20);
      if ( v13 != String )
        free(String);
      free(Block);
      if ( v17 || !dword_4133A4 || !v20 || v20 <= dword_413A4C )
        goto LABEL_68;
    }
    break;
  }
LABEL_69:
  if ( (a4 & 2) != 0 || !dword_4133A4 )
    return 0;
  else
    return v20;
}
// 4133A4: using guessed type int dword_4133A4;
// 4133D0: using guessed type char byte_4133D0;
// 4133D4: using guessed type char byte_4133D4;
// 413A4C: using guessed type int dword_413A4C;
// 413A50: using guessed type int dword_413A50;

//----- (00403AF0) --------------------------------------------------------
intptr_t __stdcall sub_403AF0(char *String, int a2, int a3, int a4, char **a5)
{
  int v5; // ebp
  int v6; // eax
  char *v7; // esi
  FILE *v8; // eax
  BOOL v9; // ebx
  char **v10; // esi
  int v11; // esi
  int v12; // ebp
  int v13; // edi
  int v14; // eax
  unsigned __int8 *v15; // eax
  unsigned __int8 *i; // esi
  unsigned __int8 *v17; // esi
  FILE *v18; // eax
  int (__cdecl *v19)(int, int); // esi
  void (__cdecl *v20)(int); // edi
  FILE *v21; // eax
  int v22; // eax
  char *v23; // ecx
  int v24; // eax
  FILE *v25; // eax
  int v26; // eax
  unsigned __int8 *v27; // eax
  char **v28; // esi
  unsigned int v30; // [esp-4h] [ebp-234h]
  char *v31; // [esp-4h] [ebp-234h]
  intptr_t v32; // [esp+10h] [ebp-220h] BYREF
  int v33; // [esp+14h] [ebp-21Ch] BYREF
  int FileHandle; // [esp+18h] [ebp-218h] BYREF
  int FileHandleSrc; // [esp+1Ch] [ebp-214h] BYREF
  int v36; // [esp+20h] [ebp-210h] BYREF
  unsigned __int8 *Str1[2]; // [esp+24h] [ebp-20Ch] BYREF
  _DWORD ArgList[129]; // [esp+2Ch] [ebp-204h] BYREF

  FileHandleSrc = -1;
  FileHandle = -1;
  v5 = 0;
  FullPath = 0;
  if ( !dword_413A58 )
    dword_413A58 = (int)sub_404830();
  v6 = *String;
  if ( v6 == 45 )
  {
    a4 = 1;
    if ( ismbcdigit(*++String) )
    {
      v7 = String;
      dword_413A4C = strtol(String, &String, 10);
      if ( *errno() == 34 )
      {
        *String = 0;
        sub_403220(0, 0x436u, v7);
      }
      for ( ; ismbcspace(*String); ++String )
        ;
    }
    else
    {
      dword_413A4C = 255;
    }
  }
  else if ( v6 == 64 )
  {
    ++String;
    if ( a3 )
      a2 = 0;
  }
  if ( *String )
  {
    if ( strlen(String) >= 0x800 )
      sub_403220(0, 0x447u, String);
    else
      strcpy(Command, String);
    if ( a2 )
    {
      printf("\t%s\n", Command);
      v8 = _p__iob();
      fflush(v8 + 1);
    }
    v9 = !byte_41400C && !byte_414010
      || (byte_4133D0 & 4) == 0 && sub_4043A0((unsigned __int8 *)Command, &FileHandleSrc, &FileHandle);
    dword_413A5C = sub_40ADD0(Command);
    sub_403580((unsigned int *)&v33, (const unsigned __int8 **)Str1, (unsigned __int8 *)dword_413A5C);
    if ( Str1[0] && dword_413FF8 && !mbsicmp(Str1[0], dword_413FF8) )
      Str1[0] = (unsigned __int8 *)*_p__pgmptr();
    if ( v33 )
    {
      FullPath = (char *)mbsnbcpy(&Dest, Str1[0], 0x100u);
      if ( a3 )
      {
        if ( sub_404680(v33, (char **)Str1, &v32) )
        {
          v9 = 0;
        }
        else if ( !v9 )
        {
          v11 = 0;
          v12 = 35;
          v13 = 17;
          *errno() = 0;
          while ( 1 )
          {
            v14 = mbsicmp(Str1[0], (&off_413068)[v13]);
            if ( !v14 )
              break;
            if ( v14 >= 0 )
              v11 = v13;
            else
              v12 = v13;
            v13 = (v11 + v12) / 2;
            if ( v12 - v11 <= 1 )
              goto LABEL_48;
          }
          v9 = 1;
LABEL_48:
          v5 = 1;
          if ( !v9 )
          {
            splitpath(FullPath, Drive, Dir, Filename, 0);
            makepath(FullPath, Drive, Dir, Filename, 0);
            v15 = sub_405BC0(FullPath, FileName);
            if ( v15 )
            {
              if ( v15[1] == 98 || !mbsicmp(v15, aCmd) )
              {
                v9 = 1;
              }
              else
              {
                for ( i = Str1[0]; *i; *(i - 1) = mbctoupper(v30) )
                  v30 = (char)*i++;
                v17 = Str1[0];
                Str1[0] = (unsigned __int8 *)FileName;
                if ( !byte_414014 || sub_40AB40(FileName, &v36) )
                {
                  v32 = spawnvp(0, FileName, (const char *const *)Str1);
                  Str1[0] = v17;
                }
                else
                {
                  printf("NMAKE : Cannot execute command;  see README.WRI\n");
                  *errno() = 1;
                  v32 = -1;
                }
              }
            }
            else
            {
              *errno() = 2;
              v32 = -1;
            }
          }
        }
        if ( FileHandleSrc == -1 )
        {
          v20 = (void (__cdecl *)(int))close;
          v19 = dup2;
        }
        else
        {
          v18 = _p__iob();
          v19 = dup2;
          if ( dup2(FileHandleSrc, v18->_file) == -1 )
            sub_403220(0, 0x411u);
          v20 = (void (__cdecl *)(int))close;
          close(FileHandleSrc);
        }
        if ( FileHandle != -1 )
        {
          v21 = _p__iob();
          if ( v19(FileHandle, v21[1]._file) == -1 )
            sub_403220(0, 0x411u);
          v20(FileHandle);
        }
        if ( v9 )
        {
          if ( byte_414014 )
          {
            printf("NMAKE : Cannot execute command;  see README.WRI\n");
            *errno() = 1;
            v32 = -1;
          }
          else
          {
            strcpy(Command, String);
            if ( v5 )
            {
              v22 = system(Command);
            }
            else
            {
              if ( v33 >= 0 )
              {
                v23 = (char *)&ArgList[v33];
                do
                {
                  v24 = *((_DWORD *)v23 - 2);
                  v23 -= 4;
                  *((_DWORD *)v23 + 1) = v24;
                }
                while ( v23 >= (char *)ArgList );
              }
              Str1[1] = (unsigned __int8 *)aC_0;
              Str1[0] = (unsigned __int8 *)dword_413A58;
              v22 = spawnvp(0, (const char *)dword_413A58, (const char *const *)Str1);
            }
            v32 = v22;
          }
        }
        if ( v32 == -1073741749 )
        {
          v25 = _p__iob();
          fprintf(v25 + 2, "spawn returned 0xc000004b ... Benign\n");
          v32 = 0;
        }
        if ( v32 == -1 )
        {
          if ( a4 )
          {
            v32 = 0;
          }
          else
          {
            v26 = *errno();
            if ( v26 )
            {
              if ( v26 == 2 )
              {
                sub_403220(0, 0x439u, Str1[0]);
              }
              else if ( v26 == 12 )
              {
                v27 = (unsigned __int8 *)ArgList[0];
                if ( !v9 )
                  v27 = Str1[0];
                sub_403220(0, 0x43Au, v27);
              }
              else
              {
                v31 = strerror(0);
                sub_403220(0, 0x415u, v31);
              }
            }
          }
        }
        if ( v32 )
        {
          v28 = a5;
          if ( a5 )
            *v28 = sub_40ADD0((const char *)Str1[0]);
        }
        free(dword_413A5C);
        return v32;
      }
      if ( sub_404680(v33, (char **)Str1, &v32) )
      {
        if ( v32 )
        {
          v10 = a5;
          if ( a5 )
            *v10 = sub_40ADD0((const char *)Str1[0]);
        }
        return v32;
      }
    }
  }
  return 0;
}
// 4133D0: using guessed type char byte_4133D0;
// 413A4C: using guessed type int dword_413A4C;
// 413A58: using guessed type int dword_413A58;
// 41400C: using guessed type char byte_41400C;
// 414010: using guessed type char byte_414010;
// 414014: using guessed type char byte_414014;
// 403AF0: using guessed type _DWORD ArgList[129];

//----- (00404180) --------------------------------------------------------
char *sub_404180()
{
  unsigned __int8 *v0; // ebx
  unsigned __int8 *i; // ebp
  unsigned __int8 v2; // al
  char *v4; // esi
  _BYTE *k; // ebp
  char v6; // al
  _BYTE *v7; // eax
  char *v8; // eax
  unsigned __int8 *j; // [esp+10h] [ebp-1108h]
  char VarName[260]; // [esp+14h] [ebp-1104h] BYREF
  char v11[2048]; // [esp+118h] [ebp-1000h] BYREF
  _DWORD v12[512]; // [esp+918h] [ebp-800h] BYREF

  v0 = (unsigned __int8 *)v12 + 3;
  v12[0] = *(_DWORD *)aSet;
  for ( i = &Str; ; ++i )
  {
    v2 = *i;
    if ( *i != 32 && v2 != 9 )
      break;
    *v0++ = v2;
  }
  if ( !mbschr(i, 0x3Du) )
    return byte_413060;
  for ( j = v0; *i != 61; *(v0 - 1) = mbctoupper((char)*(i - 1)) )
  {
    ++v0;
    ++i;
  }
  while ( *i )
  {
    if ( *i == 37 )
    {
      v4 = VarName;
      for ( k = i + 1; *k != 37; *(v4 - 1) = mbctoupper(v6) )
      {
        v6 = *k;
        if ( !*k )
          break;
        ++v4;
        ++k;
      }
      v7 = k;
      *v4 = 0;
      i = k + 1;
      if ( *v7 )
      {
        v11[0] = 0;
        v8 = getenv(VarName);
        if ( v8 )
        {
          strcat(v11, v8);
          *v0 = 0;
          strcat((char *)v12, v11);
          v0 += strlen(v11);
        }
      }
      else
      {
        *v0 = 0;
        strcat((char *)v12, VarName);
        v0 += strlen(VarName);
      }
    }
    else
    {
      *v0++ = *i++;
    }
  }
  *v0 = 0;
  strcpy(Command, (const char *)v12);
  *j = 0;
  return (char *)&unk_40E107 + strlen((const char *)v12) + 1;
}

//----- (004043A0) --------------------------------------------------------
int __stdcall sub_4043A0(unsigned __int8 *String, int *a2, int *a3)
{
  int v3; // ebx
  unsigned __int8 *v4; // ebp
  unsigned int v5; // kr04_4
  unsigned __int8 *v6; // edi
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // edi
  FILE *v9; // eax
  int v10; // eax
  unsigned __int8 *v11; // edi
  FILE *v12; // eax
  int v13; // eax
  int v14; // esi
  FILE *v15; // eax
  int v16; // esi
  FILE *v17; // eax
  char *Block; // [esp+10h] [ebp-10h]
  int v20; // [esp+14h] [ebp-Ch]
  int v21; // [esp+18h] [ebp-8h]
  int v22; // [esp+1Ch] [ebp-4h]

  v3 = 0;
  v4 = String;
  v22 = 0;
  v21 = 0;
  Block = 0;
  v5 = strlen((const char *)String) + 1;
  do
  {
    v6 = mbspbrk(v4, asc_41335C);
    if ( !v6 )
      break;
    switch ( *v6 )
    {
      case '"':
        v7 = mbschr(v6 + 1, 0x22u);
        if ( !v7 )
          goto LABEL_23;
        v4 = v7 + 1;
        break;
      case '<':
        if ( v22 || v5 - 1 < 0x7C )
          goto LABEL_23;
        if ( !Block )
          Block = sub_40ADD0((const char *)v4);
        *v6 = 32;
        v8 = v6 + 1;
        v22 = 1;
        v4 = v8;
        v9 = _p__iob();
        v10 = dup(v9->_file);
        *a2 = v10;
        if ( v10 == -1 || !sub_404AF0(v8, 4) )
          goto LABEL_23;
        break;
      case '>':
        if ( v21 || v5 - 1 < 0x7C )
          goto LABEL_23;
        if ( !Block )
          Block = sub_40ADD0((const char *)v4);
        *v6 = 32;
        v11 = v6 + 1;
        v21 = 1;
        v4 = v11;
        if ( *v11 == 62 )
        {
          *v11++ = 32;
          v20 = 3;
        }
        else
        {
          v20 = 2;
        }
        v12 = _p__iob();
        v13 = dup(v12[1]._file);
        *a3 = v13;
        if ( v13 == -1 || !sub_404AF0(v11, v20) )
          goto LABEL_23;
        break;
      case '|':
LABEL_23:
        v3 = 1;
        break;
      default:
        sub_403220(0, 0x411u);
        break;
    }
  }
  while ( !v3 );
  if ( v3 )
  {
    if ( Block )
    {
      strcpy((char *)v4, Block);
      free(Block);
    }
    if ( v22 )
    {
      v14 = *a2;
      if ( *a2 != -1 )
      {
        v15 = _p__iob();
        if ( dup2(v14, v15[1]._file) == -1 )
          sub_403220(0, 0x411u);
        close(*a2);
        *a2 = -1;
      }
    }
    if ( v21 )
    {
      v16 = *a3;
      if ( *a3 != -1 )
      {
        v17 = _p__iob();
        if ( dup2(v16, v17[1]._file) == -1 )
          sub_403220(0, 0x411u);
        close(*a3);
        *a3 = -1;
      }
    }
  }
  return v3;
}

//----- (00404680) --------------------------------------------------------
int __stdcall sub_404680(int a1, char **a2, int *a3)
{
  char *v3; // ebx
  const char *v4; // esi
  unsigned int v5; // eax
  int result; // eax
  char *v7; // eax
  char *v8; // eax
  int v9; // eax
  int *v10; // esi
  const char *v11; // ebx
  char v12; // al
  int v13; // eax
  int v14; // eax

  v3 = *a2;
  v4 = a2[1];
  if ( ismbcalpha(**a2) && v3[1] == 58 && !v3[2] )
  {
    v5 = mbctoupper(*v3);
    sub_40CBD0(v5 - 64);
    result = 1;
    *a3 = 0;
    return result;
  }
  if ( mbsicmp((const unsigned __int8 *)v3, aSet) )
  {
    if ( mbsnbicmp((const unsigned __int8 *)v3, aCd, 2u) )
    {
      if ( mbsnbicmp((const unsigned __int8 *)v3, aChdir, 5u) )
        return 0;
      v11 = v3 + 5;
    }
    else
    {
      v11 = v3 + 2;
    }
    sub_404BB0(a1, a2);
    if ( a1 > 2 )
      return 0;
    v12 = *v11;
    if ( *v11 || !v4 )
    {
      if ( v12 != 46 && v12 != 92 && v12 != 47 )
        return 0;
      v14 = chdir(v11);
    }
    else
    {
      if ( *(int *)_p___mb_cur_max() <= 1 )
        v13 = (*_p__pctype())[*v4] & 0x103;
      else
        v13 = isctype(*v4, 259);
      if ( v13 && v4[1] == 58 && !v4[2] )
        return 0;
      v14 = chdir(v4);
    }
    v10 = a3;
    *a3 = v14;
  }
  else
  {
    if ( a1 == 1 )
      return 0;
    v7 = sub_404180();
    if ( !*v7 )
      return 0;
    v8 = sub_40ADD0(v7);
    v9 = putenv(v8);
    v10 = a3;
    *a3 = v9;
    if ( v9 == -1 )
      sub_403220(dword_413424, 0x41Fu);
  }
  if ( *v10 )
    *v10 = 1;
  return 1;
}
// 41525C: using guessed type int _p___mb_cur_max(void);

//----- (00404830) --------------------------------------------------------
char *sub_404830()
{
  void *v0; // esp
  char *result; // eax
  char *v2; // eax
  char *v3; // esi
  int v4; // [esp+0h] [ebp-Ch] BYREF
  intptr_t v5; // [esp+8h] [ebp-4h] BYREF

  v0 = alloca(dword_413EE0);
  result = getenv(VarName);
  if ( !result )
  {
    v2 = getenv(aPath);
    if ( !v2 )
      v2 = byte_413060;
    v3 = sub_405930(v2, (unsigned __int8 *)aCmdExe, (int)&v4, &v5);
    if ( !v3 )
      sub_403220(0, 0x420u);
    return v3;
  }
  return result;
}
// 413EE0: using guessed type int dword_413EE0;

//----- (004048B0) --------------------------------------------------------
int __stdcall sub_4048B0(char *a1, int a2, char a3, char a4, char *a5, unsigned int *a6)
{
  int v6; // ebx
  char *v7; // esi
  int v8; // ecx
  _BYTE *v9; // edi
  char v10; // al
  int *v12; // eax
  char *v13; // edi
  int v14; // ecx
  int v15; // edx
  unsigned int v16; // eax
  char i; // [esp+13h] [ebp-11h]
  char ArgList[4]; // [esp+18h] [ebp-Ch] BYREF
  char *v19; // [esp+1Ch] [ebp-8h]
  int v20; // [esp+20h] [ebp-4h]

  v6 = 0;
  v7 = a1;
  for ( i = 0; *v7; ++v7 )
  {
    v8 = 0;
    if ( *v7 == 36 )
    {
      if ( v7[1] == 40 )
      {
        ++v7;
        v8 = 1;
      }
      v9 = v7 + 1;
      v10 = v7[1];
      if ( v10 == 63 )
      {
        if ( !v8 || mbschr(aDfbr, v7[2]) && v7[3] == 41 || v7[2] == 41 )
        {
          i = 63;
          v6 = dword_413A94;
          break;
        }
      }
      else
      {
        ++v7;
        if ( v10 == 42 && v9[1] == 42 && (!v8 || mbschr(aDfbr, (char)v9[2]) && v9[3] == 41 || v9[2] == 41) )
        {
          i = 42;
          v6 = dword_413A98;
          break;
        }
      }
    }
  }
  if ( !*v7 )
    return 0;
  v19 = a1;
  v20 = v6;
  while ( v6 )
  {
    dword_413A28 = a2;
    if ( i == 42 )
      v12 = (int *)dword_413A98;
    else
      v12 = (int *)dword_413A94;
    v6 = *v12;
    *v12 = 0;
    v13 = sub_40B700(v19, (int)&dword_413A28);
    sub_40C790(byte_411250, v13, a5);
    if ( (a3 & 4) != 0 )
    {
      v14 = 0;
      if ( (a4 & 8) == 0 )
        continue;
    }
    v14 = 1;
    v15 = (a3 & 4) != 0 || (a3 & 8) == 0 && (a4 & 1) == 0;
    *a6 = sub_403AF0(byte_411250, v15, v14, a4 & 2, (char **)ArgList);
    if ( (a3 & 2) == 0 )
    {
      v16 = *a6;
      if ( *a6 )
      {
        if ( dword_413A4C < v16 && !dword_4133A4 )
          sub_403220(0, 0x435u, *(_DWORD *)ArgList, v16);
      }
    }
    if ( i == 42 )
    {
      *(_DWORD *)dword_413A98 = v6;
      dword_413A98 = *(_DWORD *)dword_413A98;
    }
    else
    {
      *(_DWORD *)dword_413A94 = v6;
      dword_413A94 = *(_DWORD *)dword_413A94;
    }
    free(v13);
    if ( (a3 & 2) == 0 && dword_4133A4 && *a6 && dword_413A4C < *a6 )
      break;
  }
  if ( i == 42 )
    dword_413A98 = v20;
  else
    dword_413A94 = v20;
  return 1;
}
// 4133A4: using guessed type int dword_4133A4;
// 413A28: using guessed type int dword_413A28;
// 413A4C: using guessed type int dword_413A4C;
// 413A94: using guessed type int dword_413A94;
// 413A98: using guessed type int dword_413A98;

//----- (00404AF0) --------------------------------------------------------
BOOL __stdcall sub_404AF0(unsigned __int8 *String, int a2)
{
  unsigned __int8 *v3; // esi
  const char *v4; // ebx
  FILE *v5; // eax
  FILE *v6; // eax
  BOOL v7; // ebx
  unsigned __int8 v9; // [esp+13h] [ebp-1h]

  v9 = 0;
  while ( *String == 32 || *String == 9 )
    ++String;
  v3 = mbspbrk(String, asc_413394);
  if ( v3 )
  {
    v9 = *v3;
    *v3 = 0;
  }
  if ( a2 == 4 )
  {
    v4 = Mode;
    v5 = _p__iob();
  }
  else
  {
    v4 = aW;
    v5 = _p__iob() + 1;
    if ( a2 != 2 )
      v4 = aA;
  }
  v6 = freopen((const char *)String, v4, v5);
  v7 = v6 != 0;
  if ( v6 && a2 == 3 )
    lseek(v6->_file, 0, 2);
  for ( ; *String; ++String )
    *String = 32;
  if ( v3 )
    *v3 = v9;
  return v7;
}

//----- (00404BB0) --------------------------------------------------------
int __stdcall sub_404BB0(int a1, char **a2)
{
  int result; // eax
  int v3; // esi
  char *v5; // edi
  char *v6; // eax
  char v7; // bl

  result = a1;
  v3 = a1 - 1;
  if ( a1 )
  {
    while ( 1 )
    {
      v5 = *a2;
      v6 = *a2;
      if ( **a2 )
        break;
LABEL_13:
      ++a2;
      result = v3--;
      *v5 = 0;
      if ( !result )
        return result;
    }
    while ( 1 )
    {
      v7 = *v6;
      if ( *v6 == 92 || v7 == 94 )
        break;
      if ( v7 != 34 )
      {
        *v5 = v7;
LABEL_11:
        ++v6;
        ++v5;
        goto LABEL_12;
      }
      ++v6;
LABEL_12:
      if ( !*v6 )
        goto LABEL_13;
    }
    if ( v6[1] == 34 )
    {
      *v5 = v7;
      ++v6;
      ++v5;
    }
    *v5 = *v6;
    goto LABEL_11;
  }
  return result;
}

//----- (00404C10) --------------------------------------------------------
FILE *__stdcall sub_404C10(unsigned __int8 *String, int a2)
{
  FILE *result; // eax
  int file; // esi
  char DstBuf; // [esp+7h] [ebp-1h] BYREF

  result = sub_403370(5u, String);
  if ( !a2 )
  {
    result = sub_40CA80(String, aRB);
    if ( result )
    {
      file = result->_file;
      if ( read(file, &DstBuf, 1u) > 0 )
      {
        lseek(file, 0, 0);
        write(file, &DstBuf, 1u);
      }
      return (FILE *)close(file);
    }
  }
  return result;
}

//----- (00404C90) --------------------------------------------------------
int __stdcall sub_404C90(_DWORD *a1)
{
  return *a1 + 20;
}

//----- (00404CA0) --------------------------------------------------------
int __stdcall sub_404CA0(_DWORD *a1)
{
  _BYTE *v1; // ecx
  int result; // eax

  v1 = (_BYTE *)*a1;
  if ( (*(_BYTE *)*a1 & 0x10) == 0 )
    return *((_DWORD *)v1 + 3);
  result = *((_DWORD *)v1 + 1);
  if ( result == -1 )
    return *((_DWORD *)v1 + 3);
  return result;
}

//----- (00404CC0) --------------------------------------------------------
int __stdcall sub_404CC0(_DWORD *a1, int a2)
{
  _BYTE *v2; // ecx
  _DWORD *v3; // ecx
  int result; // eax

  v2 = (_BYTE *)*a1;
  if ( (*(_BYTE *)*a1 & 0x10) != 0 )
    v3 = v2 + 4;
  else
    v3 = v2 + 12;
  result = a2;
  *v3 = a2;
  return result;
}

//----- (00404CF0) --------------------------------------------------------
int __stdcall sub_404CF0(FILE *Stream)
{
  int v1; // ebx

  if ( dword_413A80 == -1 )
  {
    v1 = getc(Stream);
    if ( (_p__mbctype()[(unsigned __int8)v1 + 1] & 4) != 0 )
    {
      dword_413A80 = getc(Stream) | (v1 << 8);
      if ( dword_413A80 == 33088 )
        return 32;
    }
  }
  else
  {
    v1 = 32;
    if ( dword_413A80 != 33088 )
      v1 = dword_413A80;
    dword_413A80 = -1;
  }
  return v1;
}
// 413A80: using guessed type int dword_413A80;

//----- (00404D70) --------------------------------------------------------
int __stdcall sub_404D70(int Character, FILE *Stream)
{
  int result; // eax

  if ( dword_413A80 == -1 )
  {
    result = Character;
    if ( (Character & 0xFFFFFF00) != 0 )
      dword_413A80 = Character;
    else
      return ungetc(Character, Stream);
  }
  else
  {
    ungetc((unsigned __int8)dword_413A80, Stream);
    result = ungetc(Character, Stream);
    dword_413A80 = -1;
  }
  return result;
}
// 413A80: using guessed type int dword_413A80;

//----- (00404DE0) --------------------------------------------------------
int sub_404DE0()
{
  int result; // eax
  unsigned __int8 *v1; // esi
  char *v2; // eax
  unsigned __int8 *v3; // edi
  unsigned __int8 *v4; // edi
  unsigned int v5; // eax
  unsigned __int8 v6; // [esp+13h] [ebp-1h] BYREF

  for ( result = sub_404CF0(Stream); dword_413A78 || dword_4133F0 && result == 33; result = sub_404CF0(Stream) )
  {
    dword_4133F0 = 0;
    if ( dword_413A78 )
    {
      sub_404D70(result, Stream);
      v1 = (unsigned __int8 *)dword_413A78;
      dword_413A78 = 0;
    }
    else
    {
      v1 = (unsigned __int8 *)sub_404F80();
    }
    v2 = (char *)sub_4050B0(v1, (char *)&v6);
    v3 = (unsigned __int8 *)v2;
    switch ( v6 )
    {
      case 9u:
        if ( dword_413408 )
          sub_403220(dword_4133F4, 0x409u, v1);
        if ( sub_407680(v3) == 18 )
          return 32;
        break;
      case 0xAu:
        sub_4051E0(v2);
        break;
      case 0xBu:
        sub_403220(dword_4133F4, 0x41Au, v2);
        break;
      case 0xCu:
        if ( !mbsnbicmp((const unsigned __int8 *)v2, &byte_413F04, 2u) )
        {
          v3 += 2;
          printf("\t");
        }
        sub_403370(0xDu, v3);
        break;
      case 0xDu:
        v4 = mbstok((unsigned __int8 *)v2, &Delim);
        if ( mbstok(0, &Delim) )
          sub_403220(dword_4133F4, 0x409u, v4);
        v5 = sub_407B70(v4);
        if ( v5 )
          *(_BYTE *)(v5 + 12) |= 0x10u;
        break;
      default:
        sub_405530((unsigned __int8 *)v2, v6);
        break;
    }
    dword_4133F0 = 1;
    if ( dword_413A74 != v1 )
      free(v1);
    ++dword_4133F4;
  }
  return result;
}
// 4133F0: using guessed type int dword_4133F0;
// 413408: using guessed type int dword_413408;

//----- (00404F80) --------------------------------------------------------
char *sub_404F80()
{
  int v2; // esi
  int v3; // eax
  int v4; // edi
  int v5; // eax
  int v6; // eax
  int v7; // ebx

  v2 = 0;
  v3 = sub_406880(1);
  v4 = v3;
  if ( v3 == 10 || v3 == -1 )
    sub_403220(dword_4133F4, 0x3FAu);
  sub_404D70(v4, Stream);
  while ( 1 )
  {
    v5 = sub_404CF0(Stream);
    v6 = sub_4069D0(v5, 1);
    v7 = v6;
    if ( v6 == 35 || v6 == 10 || v6 == -1 )
      break;
    if ( v2 + 2 > (unsigned int)dword_413A7C )
    {
      dword_413A7C += 1024;
      if ( dword_413A74 )
      {
        dword_413A74 = (unsigned __int8 *)realloc(dword_413A74, dword_413A7C + 1);
        if ( !dword_413A74 )
          sub_403220(dword_4133F4, 0x419u);
      }
      else
      {
        dword_413A74 = (unsigned __int8 *)sub_40ACF0(dword_413A7C + 1);
      }
    }
    dword_413A74[v2++] = v7;
  }
  dword_413A74[v2] = 0;
  if ( v6 == 35 )
  {
    v7 = sub_404CF0(Stream);
    if ( v7 != 10 )
    {
      while ( v7 != -1 )
      {
        v7 = sub_404CF0(Stream);
        if ( v7 == 10 )
          goto LABEL_18;
      }
      goto LABEL_19;
    }
  }
LABEL_18:
  if ( v7 == -1 )
LABEL_19:
    sub_404D70(v7, Stream);
  return sub_40B690(dword_413A74);
}
// 413A7C: using guessed type int dword_413A7C;

//----- (004050B0) --------------------------------------------------------
int __stdcall sub_4050B0(unsigned __int8 *Str1, char *a2)
{
  int i; // ebx
  int v4; // [esp+10h] [ebp-4h] BYREF

  v4 = (int)Str1;
  for ( *a2 = 0; *(_BYTE *)v4; ++v4 )
  {
    if ( *(_BYTE *)v4 == 32 )
      break;
    if ( *(_BYTE *)v4 == 9 )
      break;
  }
  for ( i = v4 - (_DWORD)Str1; *(_BYTE *)v4; ++v4 )
  {
    if ( *(_BYTE *)v4 != 32 && *(_BYTE *)v4 != 9 )
      break;
  }
  if ( mbsnbicmp(Str1, aInclude, 7u) || i != 7 )
  {
    if ( mbsnbicmp(Str1, aCmdswitches, 0xBu) || i != 11 )
    {
      if ( mbsnbicmp(Str1, aError, 5u) || i != 5 )
      {
        if ( mbsnbicmp(Str1, aMessage, 7u) || i != 7 )
        {
          if ( mbsnbicmp(Str1, aUndef, 5u) || i != 5 )
            *a2 = sub_405360(Str1, i, (const unsigned __int8 **)&v4);
          else
            *a2 = 13;
        }
        else
        {
          *a2 = 12;
        }
      }
      else
      {
        *a2 = 11;
      }
    }
    else
    {
      *a2 = 10;
    }
  }
  else
  {
    *a2 = 9;
  }
  if ( !*a2 )
    sub_403220(dword_4133F4, 0x3F9u, dword_413A74);
  return v4;
}

//----- (004051E0) --------------------------------------------------------
void __stdcall sub_4051E0(char *a1)
{
  char *v1; // ebx
  char v2; // al
  int v3; // ecx
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // ax
  unsigned __int16 v6; // ax
  unsigned __int16 v7; // ax

  v1 = a1;
  if ( *a1 )
  {
    while ( 1 )
    {
      v2 = *v1;
      v3 = *v1;
      if ( v3 == 43 )
      {
        if ( *++v1 )
        {
          do
          {
            if ( *v1 == 45 )
              break;
            v4 = mbctoupper(*v1);
            if ( mbschr(aDins, v4) || dword_413408 && (v5 = mbctoupper(*v1), mbschr(aAbceklmpqrtv, v5)) )
              sub_4086D0(*v1, 1);
            else
              sub_403220(dword_4133F4, 0x400u);
            ++v1;
          }
          while ( *v1 );
          if ( !*v1 )
            return;
LABEL_16:
          if ( !*++v1 )
            return;
          do
          {
            if ( *v1 == 43 )
              break;
            v6 = mbctoupper(*v1);
            if ( mbschr(aDins, v6) || dword_413408 && (v7 = mbctoupper(*v1), mbschr(aAbceklmpqrtv, v7)) )
              sub_4086D0(*v1, 0);
            else
              sub_403220(dword_4133F4, 0x400u);
            ++v1;
          }
          while ( *v1 );
        }
      }
      else
      {
        if ( v3 == 45 )
          goto LABEL_16;
        if ( v2 != 32 && v2 != 9 )
          sub_403220(dword_4133F4, 0x400u);
      }
      if ( *v1 )
      {
        if ( *++v1 )
          continue;
      }
      return;
    }
  }
}
// 413408: using guessed type int dword_413408;

//----- (00405360) --------------------------------------------------------
char __stdcall sub_405360(unsigned __int8 *Str1, int a2, const unsigned __int8 **a3)
{
  char v3; // bl
  const unsigned __int8 *v5; // ecx
  const unsigned __int8 *v6; // edi
  int i; // ebp

  v3 = 0;
  if ( !mbsnbicmp(Str1, &byte_413268, 2u) && a2 == 2 )
    return 1;
  if ( !mbsnbicmp(Str1, aIfdef, 5u) && a2 == 5 )
    return 6;
  if ( !mbsnbicmp(Str1, aIfndef, 6u) && a2 == 6 )
    return 7;
  if ( mbsnbicmp(Str1, aElse, 4u) || a2 != 4 )
  {
    if ( !mbsnbicmp(Str1, aElseif, 6u) && a2 == 6 )
      return 3;
    if ( !mbsnbicmp(Str1, aElseifdef, 9u) && a2 == 9 )
      return 4;
    if ( !mbsnbicmp(Str1, aElseifndef, 0xAu) && a2 == 10 )
      return 5;
    if ( !mbsnbicmp(Str1, aEndif, 5u) && a2 == 5 )
      return 8;
  }
  else
  {
    v5 = *a3;
    if ( !**a3 )
      return 2;
    v6 = *a3;
    do
    {
      if ( *v5 == 32 )
        break;
      if ( *v5 == 9 )
        break;
      ++v5;
    }
    while ( *v5 );
    for ( i = v5 - v6; *v5; ++v5 )
    {
      if ( *v5 != 32 && *v5 != 9 )
        break;
    }
    *a3 = v5;
    if ( !mbsnbicmp(v6, &byte_413268, 2u) && i == 2 )
      return 3;
    if ( !mbsnbicmp(v6, aIfdef, 5u) && i == 5 )
      return 4;
    if ( !mbsnbicmp(v6, aIfndef, 6u) && i == 6 )
      return 5;
  }
  return v3;
}

//----- (00405530) --------------------------------------------------------
int __stdcall sub_405530(unsigned __int8 *a1, unsigned __int8 a2)
{
  int result; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  char v6; // cl
  char v7; // cl
  char v8; // cl
  int v9; // eax
  char *v10; // eax
  char v11; // cl
  char v12; // cl
  char v13; // cl
  int v14; // eax

  result = a2 - 1;
  switch ( a2 )
  {
    case 1u:
    case 6u:
    case 7u:
      v3 = dword_413A70;
      if ( dword_413A70 == 15 )
      {
        sub_403220(dword_4133F4, 0x3FBu);
        v3 = dword_413A70;
      }
      byte_413A61[v3] = 1;
      v4 = v3 + 1;
      dword_413A70 = v4;
      if ( !v4 || (*((_BYTE *)&dword_413A5C + v4 + 3) & 2) != 0 )
      {
        if ( !sub_409E80(a1, a2) )
          goto LABEL_32;
        result = dword_413A70;
        byte_413A60[dword_413A70] |= 2u;
      }
      else
      {
        byte_413A60[v4] = 5;
        result = sub_405710();
      }
      break;
    case 2u:
      v5 = dword_413A70;
      if ( dword_413A70 < 0 || (byte_413A60[dword_413A70] & 9) == 0 )
      {
        sub_403220(dword_4133F4, 0x3FDu);
        v5 = dword_413A70;
      }
      result = (int)&byte_413A60[v5];
      v6 = *(_BYTE *)result & 0xFE;
      *(_BYTE *)result = v6;
      v7 = v6 & 0xF7;
      *(_BYTE *)result = v7;
      if ( (v7 & 4) != 0 )
        goto LABEL_32;
      v8 = (v7 & 2) != 0 ? v7 & 0xFD : v7 | 2;
      *(_BYTE *)result = v8;
      if ( (*(_BYTE *)result & 2) == 0 )
        goto LABEL_32;
      break;
    case 3u:
    case 4u:
    case 5u:
      v9 = dword_413A70;
      if ( dword_413A70 < 0 || (byte_413A60[dword_413A70] & 9) == 0 )
      {
        sub_403220(dword_4133F4, 0x3FDu);
        v9 = dword_413A70;
      }
      v10 = &byte_413A60[v9];
      v11 = *v10 & 0xFE;
      *v10 = v11;
      v12 = v11 | 8;
      *v10 = v12;
      if ( (v12 & 4) != 0 )
        goto LABEL_32;
      if ( (v12 & 2) != 0 )
      {
        v13 = v12 | 4;
        *v10 = v13;
        *v10 = v13 & 0xFD;
        result = sub_405710();
      }
      else
      {
        if ( !sub_409E80(a1, a2) )
          goto LABEL_32;
        result = dword_413A70;
        byte_413A60[dword_413A70] |= 2u;
      }
      break;
    case 8u:
      v14 = dword_413A70;
      if ( dword_413A70 < 0 )
      {
        sub_403220(dword_4133F4, 0x3FDu);
        v14 = dword_413A70;
      }
      result = v14 - 1;
      dword_413A70 = result;
      if ( result >= 0 && (byte_413A60[result] & 2) == 0 )
LABEL_32:
        result = sub_405710();
      break;
    default:
      return result;
  }
  return result;
}
// 413A70: using guessed type int dword_413A70;

//----- (00405710) --------------------------------------------------------
int sub_405710()
{
  FILE *v0; // ecx
  int v1; // eax
  FILE *v2; // edx
  int result; // eax
  unsigned __int8 v4; // [esp+Bh] [ebp-1h] BYREF

  v0 = Stream;
  while ( 1 )
  {
    v1 = sub_404CF0(v0);
    v2 = Stream;
    if ( v1 == 33 )
      break;
LABEL_3:
    if ( v1 == -1 )
      break;
    ++dword_4133F4;
    while ( 1 )
    {
      if ( v1 == 92 )
      {
        v1 = sub_4069D0(92, 1);
        v2 = Stream;
        if ( v1 == 33 && dword_4133F0 )
          goto LABEL_17;
        dword_4133F0 = 0;
      }
      if ( v1 == 35 )
        break;
      if ( v1 == 10 || v1 == -1 )
        goto LABEL_17;
      v1 = sub_404CF0(v2);
      v2 = Stream;
    }
    v1 = sub_404CF0(v2);
    v2 = Stream;
    if ( v1 != 10 )
    {
      while ( v1 != -1 )
      {
        v1 = sub_404CF0(v2);
        v2 = Stream;
        if ( v1 == 10 )
          goto LABEL_17;
      }
      break;
    }
LABEL_17:
    if ( v1 == -1 )
      break;
    if ( v1 != 33 )
    {
      v1 = sub_404CF0(v2);
      v2 = Stream;
      if ( v1 != 33 )
        goto LABEL_3;
      break;
    }
LABEL_21:
    if ( dword_413A78 )
    {
      if ( dword_413A78 != dword_413A74 )
        free(dword_413A78);
    }
    dword_413A78 = sub_404F80();
    sub_4050B0((unsigned __int8 *)dword_413A78, (char *)&v4);
    result = dword_4133F4;
    v0 = Stream;
    if ( v4 <= 8u )
      return result;
    ++dword_4133F4;
  }
  if ( v1 == 33 )
    goto LABEL_21;
  return sub_403220(dword_4133F4, 0x3FCu);
}
// 405796: conditional instruction was optimized away because eax.4 is in (==A|==21|==FFFFFFFF)
// 405838: conditional instruction was optimized away because eax.4==FFFFFFFF
// 4133F0: using guessed type int dword_4133F0;

//----- (00405860) --------------------------------------------------------
int __stdcall sub_405860(char *VarName, unsigned __int8 *a2, unsigned __int8 *a3)
{
  void *v3; // esp
  char *v4; // eax
  unsigned __int8 *v5; // eax
  unsigned __int8 *v6; // esi
  int v8; // [esp+0h] [ebp-8h] BYREF
  intptr_t v9; // [esp+4h] [ebp-4h] BYREF

  v3 = alloca(dword_413EE0);
  v4 = getenv(VarName);
  v5 = (unsigned __int8 *)sub_405930(v4, a2, (int)&v8, &v9);
  v6 = v5;
  if ( !v5 )
    return 0;
  Stream = sub_40CA80(v5, aRt);
  if ( !Stream )
    sub_403220(0, 0x41Du, v6);
  free(v6);
  if ( sub_405A20(a3) )
    return 1;
  if ( fclose(Stream) == -1 )
    sub_403220(0, 0x424u, v6);
  return 0;
}
// 413EE0: using guessed type int dword_413EE0;

//----- (00405930) --------------------------------------------------------
char *__stdcall sub_405930(char *a1, unsigned __int8 *String, int a3, intptr_t *a4)
{
  char *v5; // ebx
  char *v6; // ebp
  char v7; // al
  char v8; // al

  if ( sub_40CD20(String, &a3, a4) )
    return sub_40ADD0((const char *)String);
  v5 = a1;
  if ( !a1 )
    return 0;
  while ( 1 )
  {
    v6 = ::String;
    while ( 1 )
    {
      while ( 1 )
      {
        v7 = *v5;
        if ( !*v5 )
          break;
        ++v5;
        *v6 = v7;
        if ( v7 == 59 )
          break;
        ++v6;
      }
      if ( v6 != ::String )
        break;
      if ( !*v5 )
        return 0;
    }
    v8 = *(v6 - 1);
    if ( v8 != 92 && v8 != 47 )
      *v6++ = 92;
    *v6 = 0;
    if ( !mbspbrk((const unsigned __int8 *)::String, &Control) )
    {
      strcpy(v6, (const char *)String);
      if ( sub_40CD20((unsigned __int8 *)::String, &a3, a4) )
        break;
    }
  }
  return sub_40ADD0(::String);
}

//----- (00405A20) --------------------------------------------------------
int __stdcall sub_405A20(unsigned __int8 *Str2)
{
  int v1; // ebp
  unsigned __int8 *v2; // edx
  unsigned __int8 *v3; // eax

  for ( dword_4133F4 = 0; fgets(String, 1024, Stream); ++dword_4133F4 )
  {
    if ( String[0] == 91 )
    {
      v1 = 0;
      v2 = mbstok((unsigned __int8 *)&String[1], &byte_413018);
      if ( v2 )
      {
        while ( !v1 )
        {
          v3 = &v2[strlen((const char *)v2) - 1];
          if ( *v3 == 93 )
          {
            v1 = 1;
            *v3 = 0;
          }
          if ( !mbsicmp(v2, Str2) )
            return 1;
          v2 = mbstok(0, &byte_413018);
          if ( !v2 )
            break;
        }
      }
    }
  }
  if ( (Stream->_flag & 0x10) == 0 )
  {
    dword_413424 = dword_4133F4;
    sub_403220(0, 0x41Du);
  }
  return 0;
}

//----- (00405B20) --------------------------------------------------------
unsigned __int8 *__stdcall sub_405B20(char *Filename, char *Ext, char *VarName, char *a4)
{
  char Buffer[260]; // [esp+Ch] [ebp-104h] BYREF

  makepath(Buffer, 0, 0, Filename, Ext);
  searchenv(Buffer, VarName, a4);
  if ( *a4 && mbspbrk((const unsigned __int8 *)Filename, asc_413F8C) )
    strcpy(a4, Buffer);
  return mbsrchr((const unsigned __int8 *)a4, 0x2Eu);
}

//----- (00405BC0) --------------------------------------------------------
unsigned __int8 *__stdcall sub_405BC0(char *Filename, char *a2)
{
  unsigned __int8 *result; // eax
  unsigned __int8 *v3; // eax

  result = sub_405B20(Filename, Ext, aPath, a2);
  if ( !result )
  {
    result = sub_405B20(Filename, aExe, aPath, a2);
    if ( !result )
    {
      v3 = sub_405B20(Filename, aBat, aPath, a2);
      return v3 == 0 ? 0 : v3;
    }
  }
  return result;
}

//----- (00405C20) --------------------------------------------------------
char *__stdcall sub_405C20(char *a1, const unsigned __int8 **a2, char **a3)
{
  char *v3; // esi
  unsigned int v4; // edi
  char *v5; // ebx
  int *v6; // eax
  unsigned __int8 *v7; // eax
  unsigned int v8; // ebp
  char *result; // eax
  int *v10; // [esp+10h] [ebp-408h]
  int v11; // [esp+14h] [ebp-404h]
  int v12[256]; // [esp+18h] [ebp-400h] BYREF

  strcpy((char *)v12, "<<");
  v3 = 0;
  v11 = 0;
  if ( !sub_406490((_BYTE *)v12 + 2, 1022) )
  {
    if ( (Stream->_flag & 0x10) != 0 )
      sub_403220(dword_4133F4, 0x409u, aEof);
    sub_403220(dword_4133F4, 0x41Du);
  }
  sub_405EF0((unsigned __int8 *)v12);
  if ( dword_413404 )
  {
    v4 = v12[0];
    v5 = a1;
    do
    {
      while ( 1 )
      {
        v10 = v12;
        do
        {
          v6 = v10;
          ++v5;
          v10 = (int *)((char *)v10 + 1);
          *(v5 - 1) = *(_BYTE *)v6;
          if ( *a3 == v5 )
          {
            if ( v3 )
            {
              v8 = v4 + 1024;
              if ( v4 > v4 + 1024 || (v3 = (char *)realloc(v3, v4 + 1024)) == 0 )
                sub_403220(dword_4133F4, 0x419u);
              v5 = &v3[v4];
              v4 += 1024;
              *a3 = &v3[v8];
            }
            else
            {
              v4 = 2048;
              v7 = (unsigned __int8 *)sub_40ACF0(0x800u);
              v5 = (char *)(v7 + 1024);
              v3 = (char *)v7;
              mbsnbcpy(v7, *a2, 0x400u);
              *a3 = v3 + 2048;
            }
            *a2 = (const unsigned __int8 *)v3;
          }
        }
        while ( *(_BYTE *)v10 );
        if ( v11 && LOWORD(v12[0]) == 15420 )
          break;
        v11 = 1;
        if ( !sub_406490(v12, 1024) )
        {
          if ( (Stream->_flag & 0x10) != 0 )
            sub_403220(dword_4133F4, 0x409u, aEof);
          sub_403220(dword_4133F4, 0x41Du);
        }
      }
      if ( *(_DWORD *)dword_413404 && !sub_406490(v12, 1024) )
      {
        if ( (Stream->_flag & 0x10) != 0 )
          sub_403220(dword_4133F4, 0x409u, aEof);
        sub_403220(dword_4133F4, 0x41Du);
      }
      dword_413404 = *(_DWORD *)dword_413404;
    }
    while ( dword_413404 );
  }
  else
  {
    v5 = a1;
  }
  result = v5;
  *v5 = 0;
  return result;
}
// 413404: using guessed type int dword_413404;

//----- (00405E60) --------------------------------------------------------
unsigned __int8 *__stdcall sub_405E60(unsigned __int8 *Str)
{
  const unsigned __int8 *v1; // esi
  unsigned __int8 *result; // eax

  v1 = Str;
  while ( 1 )
  {
    result = mbschr(v1, 0xAu);
    if ( !result || *(result - 1) != 94 )
      break;
    v1 = result + 1;
    if ( !fgets((char *)result + 1, Str - (result + 1) + 1024, Stream) )
    {
      if ( (Stream->_flag & 0x10) != 0 )
        sub_403220(dword_4133F4, 0x409u, aEof);
      sub_403220(dword_4133F4, 0x41Du);
    }
    ++dword_4133F4;
  }
  return result;
}

//----- (00405EF0) --------------------------------------------------------
const char *__stdcall sub_405EF0(unsigned __int8 *a1)
{
  const char *result; // eax
  const char *i; // edi
  _DWORD *v3; // esi

  sub_405E60(a1);
  result = (const char *)sub_405F60((const unsigned __int8 **)&a1);
  for ( i = result; result; i = result )
  {
    v3 = sub_40ACF0(0xCu);
    v3[1] = sub_40ADD0(i);
    sub_405F40(&dword_413404, (int)v3);
    result = (const char *)sub_405F60((const unsigned __int8 **)&a1);
  }
  return result;
}
// 413404: using guessed type int dword_413404;

//----- (00405F40) --------------------------------------------------------
_DWORD *__stdcall sub_405F40(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  for ( result = a1; *result; result = (_DWORD *)*result )
    ;
  *result = a2;
  return result;
}

//----- (00405F60) --------------------------------------------------------
void *__stdcall sub_405F60(const unsigned __int8 **a1)
{
  unsigned __int8 *v1; // edi
  const unsigned __int8 *v2; // eax
  int v3; // ebp
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // eax
  unsigned __int8 v6; // dl
  _BYTE *v7; // ecx
  unsigned __int8 v8; // cl

  v1 = (unsigned __int8 *)&unk_410F40;
  v2 = *a1;
  v3 = 0;
  do
  {
    v4 = mbschr(v2, 0x3Cu);
    if ( !v4 )
      return 0;
    v2 = v4 + 1;
    if ( *v2 == 60 )
      v3 = 1;
  }
  while ( !v3 );
  v5 = (unsigned __int8 *)(v2 + 1);
  while ( *v5 )
  {
    v6 = *v5;
    if ( *v5 == 32 || v6 == 62 || v6 == 60 || v6 == 94 || v6 == 44 || v6 == 9 || v6 == 10 )
      break;
    if ( v6 == 36 && (v7 = v5 + 1, v5[1] == 40) )
    {
      *v1++ = 36;
      ++v5;
      *v1 = 40;
      if ( *v7 != 10 )
      {
        do
        {
          v8 = *v5;
          if ( *v5 == 41 )
            break;
          ++v5;
          *v1++ = v8;
        }
        while ( *v5 != 10 );
      }
      if ( *v5 == 10 )
        break;
    }
    else
    {
      *v1++ = v6;
      ++v5;
    }
  }
  *v1 = 0;
  *a1 = v5;
  return &unk_410F40;
}

//----- (00406020) --------------------------------------------------------
int __stdcall sub_406020(unsigned __int8 *Str, unsigned __int8 **a2, int a3)
{
  unsigned __int8 *v3; // eax
  char *v4; // eax
  const char *v5; // eax
  unsigned __int8 *v6; // eax
  char *v7; // ebp
  char *v8; // eax
  FILE *v9; // ebx
  unsigned __int8 *v10; // eax
  int v11; // edi
  _DWORD *v12; // edi
  unsigned __int8 *Str1; // [esp+10h] [ebp-118h] BYREF
  int v15; // [esp+14h] [ebp-114h]
  unsigned __int8 *v16; // [esp+18h] [ebp-110h] BYREF
  char *v17; // [esp+1Ch] [ebp-10Ch]
  void *Block; // [esp+20h] [ebp-108h]
  unsigned __int8 Dest[260]; // [esp+24h] [ebp-104h] BYREF

  v3 = mbschr(Str, 0xAu);
  v17 = (char *)v3;
  if ( v3 )
  {
    *v3 = 0;
    *a2 = (unsigned __int8 *)sub_40B700((char *)Str, a3);
    v4 = v17++;
    *v4 = 10;
    if ( *a2 == Str )
      *a2 = (unsigned __int8 *)sub_40ADD0((const char *)Str);
    v16 = *a2;
    Block = sub_40B700(v17, a3);
    Str1 = (unsigned __int8 *)Block;
    while ( 1 )
    {
      v5 = (const char *)sub_405F60((const unsigned __int8 **)&v16);
      if ( !v5 )
        break;
      v15 = 0;
      v6 = (unsigned __int8 *)sub_40ADD0(v5);
      v7 = (char *)v6;
      if ( *v6 )
      {
        v9 = sub_40CA80(v6, aW);
        if ( v9 )
          sub_406430(*a2);
        else
          sub_403220(dword_4133F4, 0x41Eu, v7);
      }
      else
      {
        v8 = getenv(aTmp);
        if ( v8 && *v8 )
          mbsnbcpy(Dest, (const unsigned __int8 *)v8, 0x101u);
        else
          Dest[0] = 0;
        v9 = sub_407450((char *)Dest);
        if ( !v9 )
          sub_403220(dword_4133F4, 0x41Eu, Dest);
        sub_4062A0((const char **)a2, (const char *)Dest);
        free(v7);
        v7 = sub_40ADD0((const char *)Dest);
      }
      v16 = *a2;
      sub_4063B0(v9, (const unsigned __int8 **)&Str1);
      v10 = mbschr(Str1, 0xAu);
      if ( v10 )
        v11 = v10 - Str1;
      else
        v11 = strlen((const char *)Str1);
      if ( v11 <= 3 || mbsnbicmp(Str1, aKeep, 4u) )
      {
        if ( v11 <= 5 || mbsnbicmp(Str1, aNokeep, 6u) )
        {
          if ( v11 )
            sub_403220(dword_4133F4, 0x446u);
        }
        else
        {
          Str1 += 6;
        }
      }
      else
      {
        Str1 += 4;
        v15 = 1;
      }
      if ( *Str1 == 10 )
        ++Str1;
      fclose(v9);
      if ( !v15 )
      {
        v12 = sub_40AD20();
        v12[1] = sub_40ADD0(v7);
        sub_40AE30(&dword_4133BC, (int)v12);
      }
      free(v7);
    }
    if ( Block != v17 )
      free(Block);
    return 1;
  }
  else
  {
    *a2 = (unsigned __int8 *)sub_40ADD0((const char *)Str);
    return 0;
  }
}
// 4133BC: using guessed type int dword_4133BC;

//----- (004062A0) --------------------------------------------------------
int __stdcall sub_4062A0(const char **a1, const char *a2)
{
  void *v2; // esp
  const char *v3; // edx
  _BYTE *i; // esi
  const char *v5; // eax
  const char *v6; // edi
  int result; // eax
  _BYTE v8[12]; // [esp+0h] [ebp-14h] BYREF
  unsigned int v9; // [esp+Ch] [ebp-8h]
  char *v10; // [esp+10h] [ebp-4h]

  v2 = alloca(strlen(a2) + strlen(*a1) + 1 - 2);
  v10 = v8;
  v3 = *a1;
  for ( i = v8; ; ++i )
  {
    while ( *v3 != 60 )
      *i++ = *v3++;
    if ( v3[1] == 60 )
      break;
    *i = 60;
    ++v3;
  }
  *i = 0;
  v9 = strlen(a2);
  qmemcpy(&v10[strlen(v10)], a2, ++v9);
  strcat(v10, v3 + 2);
  v5 = (const char *)realloc((void *)*a1, strlen(v10) + 1);
  v6 = v10;
  *a1 = v5;
  result = 0;
  strcpy((char *)*a1, v6);
  return result;
}

//----- (004063B0) --------------------------------------------------------
int __stdcall sub_4063B0(FILE *Stream, const unsigned __int8 **a2)
{
  unsigned __int8 *v2; // ebx
  int result; // eax
  const unsigned __int8 *i; // ebp

  while ( 1 )
  {
    v2 = mbschr(*a2, 0xAu);
    if ( !v2 )
      break;
    result = mbsnbcmp(*a2, asc_413FAC, 2u);
    if ( !result )
    {
      *a2 += 2;
      return result;
    }
    for ( i = *a2; i <= v2; fputc(*((char *)i - 1), Stream) )
      ++i;
    *a2 = i;
  }
  result = mbsnbcmp(*a2, asc_413FAC, 2u);
  if ( !result )
    *a2 += 2;
  return result;
}
// 40640A: conditional instruction was optimized away because ebx.4!=0

//----- (00406430) --------------------------------------------------------
unsigned int __stdcall sub_406430(unsigned __int8 *Str)
{
  unsigned __int8 *i; // edx
  unsigned int result; // eax

  for ( i = mbschr(Str, 0x3Cu); i[1] != 60; i = mbschr(i + 1, 0x3Cu) )
    ;
  result = strlen((const char *)i + 2) + 1;
  qmemcpy(i, i + 2, result);
  return result;
}

//----- (00406490) --------------------------------------------------------
int __stdcall sub_406490(_BYTE *a1, int a2)
{
  _BYTE *v2; // edi
  int result; // eax

  v2 = a1;
  while ( 1 )
  {
    result = sub_404DE0();
    if ( !result )
      break;
    if ( result == -1 )
    {
      result = 0;
      *v2 = 0;
      return result;
    }
    *v2++ = result;
    if ( &a1[a2] == v2 )
    {
      *(v2 - 1) = 0;
      sub_404D70(result, Stream);
      return (int)v2;
    }
    if ( result == 10 )
    {
      result = (int)v2;
      ++dword_4133F4;
      dword_4133F0 = 1;
      *v2 = 0;
      return result;
    }
    dword_4133F0 = 0;
  }
  return result;
}
// 4133F0: using guessed type int dword_4133F0;

//----- (00406500) --------------------------------------------------------
char __stdcall sub_406500(int a1, char a2)
{
  char *v2; // esi
  int v3; // eax
  int v5; // eax

  v2 = &String[a1];
  if ( dword_4133C8 )
  {
    dword_4133C8 = 0;
    ++dword_4133F4;
    v3 = sub_404DE0();
    if ( v3 == 32 || (dword_4133F0 = 1, v3 == 9) )
      dword_4133F0 = 0;
    if ( dword_4133F0 )
    {
      if ( v3 == -1 )
      {
        return sub_4065D0(-1, String, (unsigned int)v2);
      }
      else
      {
        sub_404D70(v3, Stream);
        return 17;
      }
    }
    else
    {
      return 18;
    }
  }
  else if ( a2 == 24 || a2 == 25 )
  {
    sub_406A80(a2, (unsigned __int8 *)String, &String[a1]);
    return a2;
  }
  else
  {
    v5 = sub_406880(0);
    String[0] = v5;
    String[1] = 0;
    return sub_4065D0(v5, &String[1], (unsigned int)v2);
  }
}
// 4133C8: using guessed type int dword_4133C8;
// 4133F0: using guessed type int dword_4133F0;

//----- (004065D0) --------------------------------------------------------
char __stdcall sub_4065D0(int Character, char *a2, unsigned int a3)
{
  void *v4; // ecx
  char result; // al
  int v6; // eax
  char *v7; // esi
  int v8; // eax
  int v9; // edi

  while ( 2 )
  {
    switch ( Character )
    {
      case -1:
        if ( (Stream->_flag & 0x10) == 0 )
          sub_403220(dword_4133F4, 0x40Eu);
        if ( dword_413400 )
        {
          sub_407550();
          goto LABEL_8;
        }
        if ( dword_413A70 >= 0 )
        {
          sub_403220(dword_4133F4, 0x3FCu);
          goto LABEL_8;
        }
        result = 23;
        break;
      case 10:
LABEL_8:
        ++dword_4133F4;
        dword_4133F0 = 1;
        Character = sub_404DE0();
        if ( Character == 59 && dword_413408 || Character == 35 )
        {
          sub_406940(v4, 0);
          ++dword_4133F4;
          dword_4133F0 = 1;
          Character = sub_404DE0();
        }
        if ( Character == 32 || (dword_4133F0 = 1, Character == 9) )
          dword_4133F0 = 0;
        if ( dword_4133F0 )
        {
          if ( Character == -1 )
            continue;
          sub_404D70(Character, Stream);
          result = 17;
        }
        else
        {
          result = 18;
        }
        break;
      case 58:
        dword_4133F0 = 0;
        v6 = sub_404DE0();
        if ( v6 == 58 )
        {
          *a2 = 58;
          result = 21;
          a2[1] = 0;
        }
        else
        {
          sub_404D70(v6, Stream);
          result = 20;
        }
        break;
      case 59:
        result = 19;
        dword_4133F0 = 0;
        break;
      case 61:
        result = 22;
        dword_4133F0 = 0;
        break;
      case 91:
        if ( !dword_413408 || !dword_4133F0 )
          goto LABEL_29;
        result = 23;
        break;
      case 94:
LABEL_29:
        sub_404D70(Character, Stream);
        v7 = a2 - 1;
        goto LABEL_31;
      default:
        v7 = a2;
LABEL_31:
        sub_407070(v7, a3);
        if ( !dword_4133F0 || mbsicmp((const unsigned __int8 *)String, aInclude_0) )
        {
          result = 16;
          dword_4133F0 = 0;
        }
        else
        {
          dword_4133F0 = 0;
          v8 = sub_406880(0);
          v9 = v8;
          if ( v8 == 58 || v8 == 61 )
          {
            sub_404D70(v8, Stream);
            result = 16;
          }
          else
          {
            if ( dword_413408 )
              sub_403220(dword_4133F4, 0x409u, v7);
            result = sub_4075C0(v9);
          }
        }
        break;
    }
    return result;
  }
}
// 406669: variable 'v4' is possibly undefined
// 4133F0: using guessed type int dword_4133F0;
// 413400: using guessed type int dword_413400;
// 413408: using guessed type int dword_413408;
// 413A70: using guessed type int dword_413A70;

//----- (00406880) --------------------------------------------------------
int __stdcall sub_406880(char a3)
{
  int result; // eax
  void *v4; // ecx

  while ( 1 )
  {
    if ( a3 )
      result = sub_404CF0(Stream);
    else
      result = sub_404DE0();
    if ( result != 32 && result != 9 && result != 94 )
      goto LABEL_14;
    if ( result == 94 )
    {
      result = a3 ? sub_404CF0(Stream) : sub_404DE0();
      if ( result != 32 && result != 9 )
        break;
    }
    dword_4133F0 = 0;
LABEL_14:
    if ( result == 92 )
      result = sub_4069D0(92, a3);
    if ( result != 32 && result != 9 )
      goto LABEL_20;
  }
  sub_404D70(result, Stream);
  result = 94;
LABEL_20:
  if ( result == 59 && dword_4133F0 && dword_413408 || result == 35 )
  {
    sub_406940(v4, a3);
    dword_4133F0 = 1;
    return 10;
  }
  return result;
}
// 406922: variable 'v4' is possibly undefined
// 4133F0: using guessed type int dword_4133F0;
// 413408: using guessed type int dword_413408;

//----- (00406940) --------------------------------------------------------
int __thiscall sub_406940(void *this, char a2)
{
  FILE *v2; // edx
  int result; // eax
  int v4; // eax

  v2 = Stream;
LABEL_2:
  dword_4133F0 = 0;
  while ( 1 )
  {
    result = a2 ? sub_404CF0(v2) : sub_404DE0();
    v2 = Stream;
    if ( result == -1 )
      return result;
    if ( result == 10 )
    {
      dword_4133F0 = 1;
      if ( a2 )
        v4 = sub_404CF0(Stream);
      else
        v4 = sub_404DE0();
      v2 = Stream;
      if ( v4 == 59 && dword_413408 || v4 == 35 )
      {
        ++dword_4133F4;
        goto LABEL_2;
      }
      return sub_404D70(v4, Stream);
    }
  }
}
// 4133F0: using guessed type int dword_4133F0;
// 413408: using guessed type int dword_413408;

//----- (004069D0) --------------------------------------------------------
int __stdcall sub_4069D0(int a3, char a4)
{
  int result; // eax
  int v5; // eax

  result = a3;
  if ( a3 == 92 )
  {
    while ( 1 )
    {
      v5 = a4 ? sub_404CF0(Stream) : sub_404DE0();
      if ( v5 != 10 )
        break;
      dword_4133F0 = 1;
      ++dword_4133F4;
      if ( a4 )
        result = sub_404CF0(Stream);
      else
        result = sub_404DE0();
      if ( result == 59 && dword_413408 || result == 35 )
      {
        sub_406940((void *)dword_413408, a4);
        ++dword_4133F4;
        if ( a4 )
          result = sub_404CF0(Stream);
        else
          result = sub_404DE0();
      }
      if ( result != 92 )
        return result;
    }
    sub_404D70(v5, Stream);
    return 92;
  }
  return result;
}
// 4133F0: using guessed type int dword_4133F0;
// 413408: using guessed type int dword_413408;

//----- (00406A80) --------------------------------------------------------
unsigned __int8 *__stdcall sub_406A80(char a1, unsigned __int8 *a2, char *a3)
{
  unsigned __int8 *v3; // esi
  void *v4; // ecx
  int v5; // eax
  unsigned __int8 v6; // bl
  unsigned int v7; // edi
  int v8; // ebp
  unsigned __int8 *v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  unsigned __int8 *v13; // eax
  unsigned int v14; // edi
  unsigned __int8 *result; // eax
  unsigned __int8 v16; // [esp+13h] [ebp-Dh]
  int Character; // [esp+14h] [ebp-Ch]
  unsigned __int8 *Source; // [esp+18h] [ebp-8h] BYREF
  BOOL v19; // [esp+1Ch] [ebp-4h]

  v19 = 0;
  v3 = a2;
  Source = a2;
  Character = sub_404DE0();
  if ( a1 == 24 )
  {
    v16 = 2;
  }
  else
  {
    if ( Character == 32 || Character == 9 )
      goto LABEL_10;
    if ( Character != 94 )
    {
      v16 = 1;
      goto LABEL_11;
    }
    v5 = sub_404DE0();
    if ( v5 == 32 || v5 == 9 )
    {
LABEL_10:
      v16 = 2;
      Character = sub_406880(0);
      goto LABEL_11;
    }
    sub_404D70(v5, Stream);
    Character = 94;
  }
LABEL_11:
  v6 = v19;
  v7 = v19;
  while ( 1 )
  {
    if ( Character == 34 )
      v19 = !v19;
    v8 = 1;
    if ( Character == 94 )
    {
      if ( v19 || a1 != 25 )
      {
        v10 = sub_404DE0();
        sub_404D70(v10, Stream);
        Character = 94;
      }
      else
      {
        Character = sub_404DE0();
        v4 = 0;
        switch ( Character )
        {
          case 10:
          case 34:
          case 35:
          case 92:
            goto LABEL_26;
          case 33:
          case 36:
          case 40:
          case 41:
          case 45:
          case 64:
          case 94:
          case 123:
          case 125:
            *v3++ = 94;
            if ( a3 == (char *)v3 )
            {
              if ( dword_4133FC )
              {
                if ( v7 > v7 + 1024 || (dword_4133FC = (unsigned __int8 *)realloc(dword_4133FC, v7 + 1024)) == 0 )
                  sub_403220(dword_4133F4, 0x419u);
                v3 = &dword_4133FC[v7];
                v9 = &dword_4133FC[v7 + 1024];
                v7 += 1024;
              }
              else
              {
                dword_4133FC = (unsigned __int8 *)sub_40ACF0(0x800u);
                v7 = 2048;
                mbsnbcpy(dword_4133FC, Source, 0x400u);
                v3 = dword_4133FC + 1024;
                v9 = dword_4133FC + 2048;
              }
              a3 = (char *)v9;
              Source = dword_4133FC;
            }
LABEL_26:
            v6 = 0;
            v8 = 0;
            break;
          default:
            break;
        }
      }
    }
    if ( v8 )
    {
      v4 = 0;
      switch ( Character )
      {
        case -1:
        case 10:
          v6 = 6;
          break;
        case 9:
        case 32:
          v6 = 5;
          break;
        case 35:
          v6 = 1;
          break;
        case 36:
          v6 = 7;
          break;
        case 40:
          v6 = 8;
          break;
        case 41:
          v6 = 9;
          break;
        case 42:
          v6 = 11;
          break;
        case 58:
          v6 = 4;
          break;
        case 59:
          v6 = !v16 && dword_413408;
          break;
        case 60:
        case 63:
        case 64:
          v6 = 12;
          break;
        case 61:
          v6 = 2;
          break;
        case 66:
        case 68:
        case 70:
        case 82:
          v6 = 13;
          break;
        case 92:
          v6 = 3;
          break;
        default:
          v6 = (byte_4149C0[(unsigned __int8)Character] & 1) == 0 ? 0 : 0xA;
          break;
      }
    }
    if ( v6 == 12 && a1 == 24 && Character == 60 )
    {
      v11 = sub_404DE0();
      if ( v11 == 60 )
      {
        v6 = 6;
        Character = 10;
        v3 = (unsigned __int8 *)sub_405C20((char *)v3, (const unsigned __int8 **)&Source, &a3);
      }
      else
      {
        sub_404D70(v11, Stream);
      }
    }
    else if ( v6 == 1 )
    {
      if ( !v16 )
      {
        v19 = 0;
        sub_406940(v4, 0);
        ++dword_4133F4;
        goto LABEL_77;
      }
      if ( a1 == 25 )
      {
        v16 = 64;
        goto LABEL_59;
      }
    }
    v16 = byte_414648[14 * v16 + v6];
LABEL_59:
    if ( v16 == 64 )
      break;
    if ( (v16 & 0x20) != 0 )
      sub_403220(dword_4133F4, (v16 & 0xDF) + 1000, Character);
    if ( v16 )
    {
      *v3++ = Character;
      if ( a3 == (char *)v3 )
      {
        if ( dword_4133FC )
        {
          if ( v7 > v7 + 1024 || (dword_4133FC = (unsigned __int8 *)realloc(dword_4133FC, v7 + 1024)) == 0 )
            sub_403220(dword_4133F4, 0x419u);
          v3 = &dword_4133FC[v7];
          v13 = &dword_4133FC[v7 + 1024];
          v7 += 1024;
        }
        else
        {
          dword_4133FC = (unsigned __int8 *)sub_40ACF0(0x800u);
          v7 = 2048;
          mbsnbcpy(dword_4133FC, Source, 0x400u);
          v3 = dword_4133FC + 1024;
          v13 = dword_4133FC + 2048;
        }
        a3 = (char *)v13;
      }
    }
    else
    {
      *(v3 - 1) = 32;
      ++dword_4133F4;
      dword_4133F0 = 1;
      v12 = sub_404DE0();
      dword_4133F0 = 0;
      if ( v12 == 32 || v12 == 9 )
      {
        v16 = 2;
        do
        {
          do
            v12 = sub_404DE0();
          while ( v12 == 32 );
        }
        while ( v12 == 9 );
      }
      sub_404D70(v12, Stream);
    }
LABEL_77:
    Character = sub_404DE0();
  }
  sub_404D70(Character, Stream);
  if ( Source < v3 )
  {
    do
    {
      v14 = (unsigned int)(v3 - 1);
      if ( !ismbcspace((char)*(v3 - 1)) )
        break;
      --v3;
    }
    while ( (unsigned int)Source < v14 );
  }
  *v3 = 0;
  if ( dword_4133FC )
  {
    result = (unsigned __int8 *)realloc(dword_4133FC, v3 - dword_4133FC + 1);
    if ( result )
      dword_4133FC = result;
  }
  else
  {
    result = (unsigned __int8 *)sub_40ADD0((const char *)Source);
    dword_4133FC = result;
  }
  return result;
}
// 406C1F: conditional instruction was optimized away because %Character.4==5E
// 406C97: variable 'v16' is possibly undefined
// 406D18: variable 'v4' is possibly undefined
// 4133F0: using guessed type int dword_4133F0;
// 413408: using guessed type int dword_413408;

//----- (00407070) --------------------------------------------------------
const char *__stdcall sub_407070(char *a1, unsigned int a2)
{
  char *v2; // esi
  int v3; // eax
  int v4; // ebx
  char v5; // al
  int v6; // eax
  int v7; // eax
  unsigned __int8 v9; // [esp+Ah] [ebp-12h]
  unsigned __int8 v10; // [esp+Bh] [ebp-11h]
  int v11; // [esp+Ch] [ebp-10h]
  int v12; // [esp+10h] [ebp-Ch]
  int v13; // [esp+14h] [ebp-8h]

  v11 = 0;
  v13 = 0;
  v2 = a1;
  v3 = *(a1 - 1);
  switch ( v3 )
  {
    case '"':
      v13 = 1;
      v10 = 16;
      break;
    case '$':
      v10 = 2;
      break;
    case '{':
      v10 = 8;
      break;
    default:
      v10 = 0;
      break;
  }
  while ( 1 )
  {
    v4 = sub_404DE0();
    v12 = 1;
    if ( v4 == 94 )
    {
      v4 = sub_404DE0();
      switch ( v4 )
      {
        case 10:
        case 35:
        case 92:
          goto LABEL_11;
        case 36:
        case 40:
        case 41:
        case 94:
        case 123:
        case 125:
          *v2++ = 94;
LABEL_11:
          v9 = 0;
          v12 = 0;
          break;
        default:
          break;
      }
    }
    if ( v12 )
    {
      switch ( v4 )
      {
        case -1:
        case 10:
          v9 = 6;
          break;
        case 9:
        case 32:
          v9 = v13 == 0 ? 5 : 0;
          break;
        case 34:
          v9 = 14;
          break;
        case 35:
          v9 = 1;
          break;
        case 36:
          v9 = 7;
          break;
        case 40:
          v9 = 8;
          break;
        case 41:
          v9 = 9;
          break;
        case 58:
          v9 = 4;
          break;
        case 59:
          v9 = 3;
          break;
        case 61:
          v9 = 2;
          break;
        case 92:
          v9 = 13;
          break;
        case 123:
          v9 = 11;
          break;
        case 125:
          v9 = 12;
          break;
        default:
          if ( byte_413A48 >= 0 )
          {
            v9 = (byte_4149C0[(unsigned __int8)v4] & 1) == 0 ? 0 : 0xA;
          }
          else if ( (byte_4149C0[(unsigned __int8)v4] & 1) != 0 || v4 == 42 || v4 == 64 )
          {
            v9 = 10;
          }
          else
          {
            v9 = 0;
          }
          break;
      }
    }
    v5 = byte_414700[15 * v10 + v9];
    v10 = v5;
    if ( v13 && v5 == 1 )
      v10 = 16;
    if ( v11 )
    {
      if ( v9 == 6 )
      {
        dword_4133F0 = 1;
        ++dword_4133F4;
        v6 = sub_404DE0();
        v4 = v6;
        dword_4133F0 = 0;
        if ( v6 == 32 || v6 == 9 )
        {
          v10 = 64;
          do
          {
            do
            {
              v7 = sub_404DE0();
              v4 = v7;
            }
            while ( v7 == 32 );
          }
          while ( v7 == 9 );
        }
        else
        {
          v10 = v2 != &String[1];
        }
      }
      else
      {
        *v2++ = 92;
      }
    }
    v11 = 0;
    if ( v10 == 64 )
      break;
    if ( (v10 & 0x20) != 0 )
      sub_403220(dword_4133F4, (v10 & 0xDF) + 1000, v4);
    if ( v10 == 15 )
      v11 = 1;
    else
      *v2++ = v4;
  }
  if ( (unsigned int)v2 >= a2 )
    sub_403220(dword_4133F4, 0x434u);
  sub_404D70(v4, Stream);
  *v2 = 0;
  return sub_408A90(a1 - 1);
}
// 4071DC: variable 'v9' is possibly undefined
// 4133F0: using guessed type int dword_4133F0;
// 413A48: using guessed type char byte_413A48;

//----- (00407450) --------------------------------------------------------
FILE *__stdcall sub_407450(char *Buffer)
{
  bool v1; // zf
  FILE *result; // eax
  char Dir[2]; // [esp+Ch] [ebp-104h] BYREF

  if ( Buffer && *Buffer )
    strcpy(Dir, Buffer);
  else
    strcpy(Dir, ".");
  makepath(Buffer, 0, Dir, aNmxxxxxx, 0);
  if ( mktemp(Buffer)
    || (aNmxxxxxx[1] != 122 ? ++aNmxxxxxx[1] : (aNmxxxxxx[1] = 97),
        makepath(Buffer, 0, Dir, aNmxxxxxx, 0),
        v1 = mktemp(Buffer) == 0,
        result = 0,
        !v1) )
  {
    strcat(Buffer, asc_413FD4);
    return sub_40CA80((unsigned __int8 *)Buffer, aW);
  }
  return result;
}
// 413FE0: using guessed type __int16 word_413FE0;

//----- (00407550) --------------------------------------------------------
int sub_407550()
{
  bool v0; // zf
  char *v1; // eax
  int result; // eax

  v0 = fclose(Stream) == -1;
  v1 = dword_4133F8;
  if ( v0 )
  {
    sub_403220(0, 0x424u, dword_4133F8);
    v1 = dword_4133F8;
  }
  free(v1);
  --dword_413400;
  Stream = (FILE *)dword_411A58[3 * dword_413400];
  dword_4133F8 = (char *)dword_411A54[3 * dword_413400];
  result = dword_411A50[3 * dword_413400];
  dword_4133F4 = result;
  return result;
}
// 411A50: using guessed type int dword_411A50[];
// 411A54: using guessed type int dword_411A54[];
// 411A58: using guessed type int dword_411A58[46];
// 413400: using guessed type int dword_413400;

//----- (004075C0) --------------------------------------------------------
char __stdcall sub_4075C0(int a1)
{
  unsigned int v1; // kr04_4
  unsigned __int8 *i; // eax

  if ( a1 == 10 || a1 == -1 )
    sub_403220(dword_4133F4, 0x407u);
  String[0] = a1;
  if ( !fgets(&String[1], 1023, Stream) )
  {
    if ( (Stream->_flag & 0x10) != 0 )
      sub_403220(dword_4133F4, 0x409u, aEof);
    sub_403220(dword_4133F4, 0x41Du);
  }
  v1 = strlen(String) + 1;
  if ( String[v1 - 2] == 10 )
    String[v1 - 2] = 0;
  for ( i = (unsigned __int8 *)String; *i == 32 || *i == 9; ++i )
    ;
  return sub_407680(i);
}

//----- (00407680) --------------------------------------------------------
char __stdcall sub_407680(unsigned __int8 *String)
{
  int v1; // edi
  void *v2; // esp
  unsigned __int8 *v3; // ebx
  unsigned __int8 *v4; // esi
  char *v5; // edi
  char v6; // al
  unsigned __int8 *v7; // esi
  unsigned int v8; // eax
  const char *v9; // eax
  unsigned __int8 *v10; // ebx
  char *v11; // edi
  unsigned __int8 *v12; // esi
  char *v13; // eax
  int v14; // edi
  const unsigned __int8 **v15; // esi
  char *v16; // esi
  int v17; // edx
  int v18; // ecx
  int v19; // eax
  int v21; // [esp+0h] [ebp-28h] BYREF
  int v22; // [esp+Ch] [ebp-1Ch] BYREF
  int v23; // [esp+10h] [ebp-18h] BYREF
  int v24; // [esp+14h] [ebp-14h]
  char **v25; // [esp+18h] [ebp-10h]
  unsigned __int8 *v26; // [esp+1Ch] [ebp-Ch]
  void *Block; // [esp+20h] [ebp-8h]
  unsigned __int8 *v28; // [esp+24h] [ebp-4h]

  v1 = 0;
  v2 = alloca(dword_413EE0);
  v3 = String;
  v23 = (int)&v21;
  if ( !*String || *String == 35 )
    sub_403220(dword_4133F4, 0x407u);
  v4 = mbspbrk(String, &byte_413FEC);
  if ( v4 )
  {
    if ( *v4 == 35 )
      v1 = 35;
    *v4 = 0;
    if ( !v1 )
    {
      v5 = (char *)(v4 + 1);
      if ( v4[1] )
      {
        do
        {
          v6 = *v5;
          if ( *v5 == 35 )
            break;
          if ( v6 != 32 && v6 != 9 )
            sub_403220(dword_4133F4, 0x409u, v5);
          ++v5;
        }
        while ( *v5 );
      }
    }
  }
  else
  {
    v4 = &String[strlen((const char *)String)];
  }
  if ( *String == 60 && *(v4 - 1) == 62 )
  {
    *(v4 - 1) = 0;
    v7 = (unsigned __int8 *)sub_40B690(String + 1);
    if ( v7 == String + 1 )
      v7 = (unsigned __int8 *)sub_40ADD0((const char *)String + 1);
    v8 = sub_407B70(aInclude);
    if ( v8 )
      v9 = *(const char **)(*(_DWORD *)(v8 + 8) + 4);
    else
      v9 = 0;
    if ( v9 )
    {
      v10 = (unsigned __int8 *)sub_40ADD0(v9);
      v11 = sub_40B690(v10);
      if ( v11 != (char *)v10 )
        free(v10);
    }
    else
    {
      v11 = 0;
    }
    v3 = (unsigned __int8 *)sub_405930(v11, v7, v23, &v22);
    if ( !v3 )
      sub_403220(dword_4133F4, 0x41Cu, v7);
    if ( v11 )
      free(v11);
    free(v7);
  }
  else
  {
    if ( *String == 34 )
    {
      v12 = v4 - 1;
      if ( *v12 == 34 )
      {
        v3 = String + 1;
        *v12 = 0;
      }
    }
    v26 = (unsigned __int8 *)sub_40B690(v3);
    if ( v26 == v3 )
      v26 = (unsigned __int8 *)sub_40ADD0((const char *)v3);
    if ( !sub_40CD20(v26, &v23, &v22) )
    {
      if ( mbspbrk(v26, &byte_413FE8) )
      {
        sub_403220(dword_4133F4, 0x41Cu, v26);
      }
      else
      {
        v24 = dword_413400;
        if ( dword_413400 >= 0 )
        {
          v25 = (char **)&dword_411A54[3 * dword_413400];
          do
          {
            if ( dword_413400 == v24 )
              v13 = dword_4133F8;
            else
              v13 = *v25;
            Block = sub_407AD0(v13);
            if ( Block )
            {
              v28 = (unsigned __int8 *)sub_40ACF0(strlen((const char *)Block) + strlen((const char *)v26) + 2);
              strcpy((char *)v28, (const char *)Block);
              strcat((char *)v28, "\\");
              strcat((char *)v28, (const char *)v26);
              if ( sub_40CD20(v28, &v23, &v22) )
              {
                v3 = v28;
                free(Block);
                break;
              }
              free(Block);
              free(v28);
            }
            v25 -= 3;
            --v24;
          }
          while ( v25 >= (char **)dword_411A54 );
        }
        free(v26);
        if ( v24 < 0 )
          sub_403220(dword_4133F4, 0x41Cu, v3);
      }
    }
  }
  v14 = 0;
  if ( dword_413400 > 0 )
  {
    v15 = (const unsigned __int8 **)dword_411A54;
    do
    {
      if ( !mbsicmp(v3, *v15) )
        sub_403220(dword_4133F4, 0x430u, v3);
      v15 += 3;
      ++v14;
    }
    while ( dword_413400 > v14 );
  }
  v16 = dword_4133F8;
  v17 = 3 * dword_413400;
  dword_413424 = 0;
  dword_411A58[v17] = (int)Stream;
  v18 = v17;
  dword_411A50[v18] = dword_4133F4;
  dword_411A54[v18] = (int)v16;
  ++dword_413400;
  Stream = sub_40CA80(v3, aRt);
  if ( !Stream )
    sub_403220(dword_4133F4, 0x41Cu, v3);
  dword_4133F8 = sub_40ADD0((const char *)v3);
  dword_4133F4 = 1;
  dword_4133F0 = 1;
  v19 = sub_404DE0();
  if ( v19 == 32 || (dword_4133F0 = 1, v19 == 9) )
    dword_4133F0 = 0;
  if ( !dword_4133F0 )
    return 18;
  sub_404D70(v19, Stream);
  return 17;
}
// 411A50: using guessed type int dword_411A50[];
// 411A54: using guessed type int dword_411A54[];
// 411A58: using guessed type int dword_411A58[46];
// 4133F0: using guessed type int dword_4133F0;
// 413400: using guessed type int dword_413400;
// 413EE0: using guessed type int dword_413EE0;

//----- (00407AD0) --------------------------------------------------------
char *__stdcall sub_407AD0(char *FullPath)
{
  char *v1; // esi
  char *v2; // eax
  char Drive[4]; // [esp+8h] [ebp-104h] BYREF
  char Dir[256]; // [esp+Ch] [ebp-100h] BYREF

  splitpath(FullPath, Drive, Dir, 0, 0);
  v1 = (char *)sub_40ACC0(strlen(Drive) + strlen(Dir) + 1);
  makepath(v1, Drive, Dir, 0, 0);
  v2 = &v1[strlen(v1) - 1];
  if ( *v2 == 92 || *v2 == 47 )
    *v2 = 0;
  return v1;
}
// 407AD0: using guessed type char Drive[4];

//----- (00407B70) --------------------------------------------------------
unsigned int __stdcall sub_407B70(unsigned __int8 *Str2)
{
  unsigned __int8 *v1; // ecx
  unsigned __int8 v2; // al
  int **v3; // edi

  v1 = Str2;
  if ( !*Str2 )
  {
    dword_413FF0 = (int)&unk_413428;
    return 0;
  }
  v2 = 0;
  do
    v2 += *v1++;
  while ( *v1 );
  dword_413FF0 = (int)&unk_413428 + 4 * v2;
  v3 = *(int ***)dword_413FF0;
  if ( !*(_DWORD *)dword_413FF0 )
    return 0;
  while ( mbscmp((const unsigned __int8 *)v3[1], Str2) )
  {
    v3 = (int **)*v3;
    if ( !v3 )
      return 0;
  }
  return ((_BYTE)v3[3] & 0x10) == 0 ? (unsigned int)v3 : 0;
}
// 413FF0: using guessed type int dword_413FF0;

//----- (00407BF0) --------------------------------------------------------
_DWORD *__stdcall sub_407BF0(_DWORD *a1)
{
  _DWORD *result; // eax

  result = sub_40AE10((_DWORD *)dword_413FF0, a1);
  dword_413FF0 = 0;
  return result;
}
// 413FF0: using guessed type int dword_413FF0;

//----- (00407C10) --------------------------------------------------------
int __stdcall sub_407C10(void *a1)
{
  int result; // eax

  result = 0;
  memset(a1, 0, 0x400u);
  return result;
}

//----- (00407C30) --------------------------------------------------------
void __cdecl __noreturn sub_407C30(int a1, int a2, int a3)
{
  char *v3; // eax
  char **v4; // eax
  int v5; // esi

  nullsub_2();
  byte_41400C = sub_40AAF0();
  byte_414010 = sub_40AB20();
  if ( byte_414010 )
  {
    v3 = getenv(aVc20chicspwn);
    if ( v3 )
    {
      if ( !strcmp(v3, ::a1) )
        byte_414014 = 1;
    }
  }
  sub_40A630();
  sub_407C10(&unk_413428);
  dword_413EE0 = 280;
  dword_413EDC = 260;
  dword_414004 = a3;
  dword_413ED4 = 256;
  dword_413ED8 = 256;
  if ( !dword_413FF8 )
  {
    strcpy(byte_410E30, *_p__pgmptr());
    if ( !sub_408140(byte_410E30, (char **)&dword_413FF8) )
      dword_413FF8 = (unsigned __int8 *)aNmake;
  }
  v4 = _p__pgmptr();
  sub_40A890(aNmakeErr, *v4, 1);
  signal(2, (_crt_signal_t)Function);
  signal(15, (_crt_signal_t)Function);
  nullsub_1(0, 0);
  v5 = sub_407F70(a1, a2, 0);
  sub_408A20();
  if ( !dword_4133B0 )
    v5 = 1;
  exit(v5);
}
// 407D80: using guessed type int nullsub_2(void);
// 4133B0: using guessed type int dword_4133B0;
// 413ED4: using guessed type int dword_413ED4;
// 413ED8: using guessed type int dword_413ED8;
// 413EDC: using guessed type int dword_413EDC;
// 413EE0: using guessed type int dword_413EE0;
// 414004: using guessed type int dword_414004;
// 41400C: using guessed type char byte_41400C;
// 414010: using guessed type char byte_414010;
// 414014: using guessed type char byte_414014;

//----- (00407D90) --------------------------------------------------------
const char *sub_407D90()
{
  char *v0; // esi
  unsigned __int8 *v1; // eax
  char *v2; // ebx
  unsigned __int8 *v3; // eax
  char *v4; // ebp
  unsigned __int8 *v5; // eax
  char *v6; // esi
  unsigned __int8 *v7; // eax
  char *v8; // ebx
  unsigned __int8 *v9; // eax
  char *v10; // ebp
  unsigned __int8 *v11; // eax
  char *v12; // esi
  unsigned __int8 *v13; // eax
  char *v14; // ebx
  unsigned __int8 *v15; // eax
  char *v16; // ebp
  unsigned __int8 *v17; // eax
  char *v18; // esi
  unsigned __int8 *v19; // eax
  const char *result; // eax
  char ***v21; // ebx
  char **v22; // ebp
  const char **v23; // [esp+10h] [ebp-4h]

  v0 = sub_40ADD0(aCc);
  v1 = (unsigned __int8 *)sub_40ADD0(aCl);
  sub_401980(v0, v1, 0);
  v2 = sub_40ADD0(aCxx_0);
  v3 = (unsigned __int8 *)sub_40ADD0(aCl);
  sub_401980(v2, v3, 0);
  v4 = sub_40ADD0(aCpp_0);
  v5 = (unsigned __int8 *)sub_40ADD0(aCl);
  sub_401980(v4, v5, 0);
  v6 = sub_40ADD0(aAs);
  v7 = (unsigned __int8 *)sub_40ADD0(aMl);
  sub_401980(v6, v7, 0);
  v8 = sub_40ADD0(aBc_0);
  v9 = (unsigned __int8 *)sub_40ADD0(aBc);
  sub_401980(v8, v9, 0);
  v10 = sub_40ADD0(aCobol);
  v11 = (unsigned __int8 *)sub_40ADD0(aCobol_0);
  sub_401980(v10, v11, 0);
  v12 = sub_40ADD0(aFor);
  v13 = (unsigned __int8 *)sub_40ADD0(aFl);
  sub_401980(v12, v13, 0);
  v14 = sub_40ADD0(aPascal);
  v15 = (unsigned __int8 *)sub_40ADD0(aPl);
  sub_401980(v14, v15, 0);
  v16 = sub_40ADD0(aRc_1);
  v17 = (unsigned __int8 *)sub_40ADD0(aRc);
  sub_401980(v16, v17, 0);
  v18 = sub_40ADD0(aMake);
  v19 = (unsigned __int8 *)sub_40ADD0((const char *)dword_413FF8);
  sub_401980(v18, v19, 12);
  result = off_414018[0];
  if ( off_414018[0] )
  {
    v23 = (const char **)off_414018;
    v21 = off_414118;
    do
    {
      ArgList = sub_40ADD0(result);
      strcpy(String, ":");
      sub_401230();
      v22 = *v21;
      while ( *v22 )
      {
        strcpy(String, *++v22);
        sub_401030();
      }
      if ( v21 == off_414118 )
        sub_4015E0();
      ++v21;
      sub_401710();
      result = *++v23;
    }
    while ( *v23 );
  }
  return result;
}
// 414018: using guessed type char *off_414018[17];
// 414118: using guessed type char **off_414118[17];

//----- (00407F70) --------------------------------------------------------
int __stdcall sub_407F70(int a1, int a2, int a3)
{
  char *v3; // edi
  unsigned __int8 *v4; // esi
  char *v5; // ebx
  char *v6; // eax
  char *v7; // eax
  int v8; // edi
  unsigned __int8 *v10; // [esp-8h] [ebp-14h]

  dword_4133C0 = 0;
  v3 = sub_40ADD0(aMakedir);
  v4 = (unsigned __int8 *)sub_40CE40();
  sub_401980(v3, v4, 0);
  v5 = getenv(aMakeflags);
  if ( v5 )
    mbsnbcpy((unsigned __int8 *)off_4133C4 + 10, (const unsigned __int8 *)v5, strlen(off_4133C4 + 10));
  dword_4133B4 = 1;
  v10 = (unsigned __int8 *)sub_40ADD0(off_4133C4 + 10);
  v6 = sub_40ADD0(aMakeflags);
  sub_401980(v6, v10, 6);
  while ( v5 )
  {
    if ( !*v5 )
      break;
    sub_4086D0(*v5++, 1);
  }
  sub_408320(a1 - 1, (const char **)(a2 + 4));
  if ( !dword_4133CC )
    sub_403420();
  if ( (byte_4133D4 & 2) == 0 )
  {
    sub_407D90();
    dword_4133F8 = aToolsIni;
    if ( sub_405860(aInit, (unsigned __int8 *)aToolsIni, dword_413FF8) )
    {
      dword_413408 = 1;
      ++dword_4133F4;
      sub_408AE0();
      if ( fclose(Stream) == -1 )
        sub_403220(0, 0x424u, dword_4133F8);
    }
  }
  v7 = sub_40ADD0(off_4133C4);
  if ( putenv(v7) == -1 )
    sub_403220(0, 0x41Fu);
  if ( !dword_4133E0 )
    sub_4085F0();
  sub_408270();
  sub_408190();
  dword_413424 = 0;
  sub_40A3C0();
  if ( (byte_4133D4 & 1) != 0 )
  {
    sub_409000();
    sub_4090A0();
    sub_409170();
  }
  if ( dword_413A74 )
    free(dword_413A74);
  v8 = sub_401F10();
  chdir((const char *)v4);
  return v8;
}
// 4133B4: using guessed type int dword_4133B4;
// 4133C0: using guessed type int dword_4133C0;
// 4133C4: using guessed type char *off_4133C4;
// 4133CC: using guessed type int dword_4133CC;
// 4133D4: using guessed type char byte_4133D4;
// 4133E0: using guessed type int dword_4133E0;
// 413408: using guessed type int dword_413408;

//----- (00408140) --------------------------------------------------------
unsigned int __stdcall sub_408140(char *FullPath, char **a2)
{
  char *v2; // edi
  char Filename[256]; // [esp+4h] [ebp-100h] BYREF

  splitpath(FullPath, 0, 0, Filename, 0);
  v2 = sub_40ADD0(Filename);
  *a2 = v2;
  return strlen(v2);
}

//----- (00408190) --------------------------------------------------------
_DWORD *sub_408190()
{
  int i; // ebp
  _BYTE *v1; // eax

  for ( i = dword_4133E0; i; i = *(_DWORD *)i )
  {
    v1 = *(_BYTE **)(i + 4);
    if ( *v1 != 45 || v1[1] )
    {
      dword_4133F8 = sub_40ADD0(*(const char **)(i + 4));
      Stream = sub_40CA80((unsigned __int8 *)dword_4133F8, aRt);
      if ( !Stream )
        sub_403220(0, 0x41Cu, dword_4133F8);
    }
    else
    {
      dword_4133F8 = sub_40ADD0(aStdin);
      Stream = _p__iob();
    }
    dword_4133F4 = 0;
    dword_413408 = 0;
    sub_408AE0();
    if ( _p__iob() != Stream && fclose(Stream) == -1 )
      sub_403220(0, 0x424u, dword_4133F8);
  }
  return sub_402C40((_DWORD *)dword_4133E0);
}
// 4133E0: using guessed type int dword_4133E0;
// 413408: using guessed type int dword_413408;

//----- (00408270) --------------------------------------------------------
void sub_408270()
{
  char ***v0; // eax
  const unsigned __int8 **v1; // esi
  unsigned __int8 *v2; // edi
  unsigned __int8 *v3; // eax
  unsigned __int8 *v4; // ebx
  char *v5; // ebp

  v0 = _p__environ();
  v1 = (const unsigned __int8 **)*v0;
  if ( **v0 )
  {
    do
    {
      v2 = mbschr(*v1, 0x3Du);
      if ( v2 )
      {
        if ( mbsnbicmp(*v1, (const unsigned __int8 *)aMakeflags, 8u) )
        {
          *v2 = 0;
          if ( **v1 )
          {
            v3 = (unsigned __int8 *)sub_40ADD0((const char *)*v1);
            v4 = mbsupr(v3);
            v5 = sub_40ADD0((const char *)v2 + 1);
            *v2 = 61;
            dword_4133B4 = 0;
            if ( !sub_401980((char *)v4, (unsigned __int8 *)v5, 4) )
            {
              free(v4);
              free(v5);
            }
          }
        }
      }
      ++v1;
    }
    while ( *v1 );
  }
}
// 4133B4: using guessed type int dword_4133B4;

//----- (00408320) --------------------------------------------------------
void __stdcall sub_408320(int a1, const char **a2)
{
  int i; // esi
  const char *v4; // ebx
  char v5; // al
  unsigned __int8 *v6; // eax
  unsigned __int8 *v7; // ebp
  unsigned __int8 *v8; // ecx
  const unsigned __int8 *v9; // ebp
  const unsigned __int8 *v10; // ebx
  size_t v11; // eax
  size_t v12; // eax
  char *v13; // eax
  _DWORD *v14; // ebx
  _BYTE *v15; // ebx
  char v16; // al
  const char *v17; // ebx
  const char *v18; // eax
  FILE *v19; // eax
  FILE *v20; // ebp
  FILE *v21; // eax
  const char *v22; // ebx
  const char *v23; // eax
  _DWORD *v24; // ebp
  unsigned __int8 *v25; // [esp-8h] [ebp-20h]
  int file; // [esp-4h] [ebp-1Ch]
  int v27; // [esp+10h] [ebp-8h]
  int v28; // [esp+14h] [ebp-4h]

  v28 = 0;
  v27 = 0;
  for ( i = a1; i; ++a2 )
  {
    v4 = *a2;
    v5 = **a2;
    if ( v5 == 64 )
    {
      sub_402CC0((unsigned __int8 *)v4 + 1);
    }
    else if ( v5 == 45 || v5 == 47 )
    {
      v15 = v4 + 1;
      if ( !mbsicmp(v15, aHelp) )
      {
        v28 = 1;
        break;
      }
      if ( *v15 )
      {
        while ( 1 )
        {
          if ( !mbsicmp(v15, aNologo) )
          {
            sub_4086D0(v15[2], 1);
            goto LABEL_46;
          }
          v16 = *v15;
          if ( *v15 == 63 )
          {
            v27 = 1;
            goto LABEL_46;
          }
          if ( v16 == 102 || v16 == 70 )
            break;
          if ( v16 == 120 || v16 == 88 )
          {
            v17 = v15 + 1;
            if ( !*v17 )
            {
              if ( !--i || (v18 = a2[1], ++a2, !v18) || (v17 = v18, !*v18) )
                sub_403220(0, 0x426u);
            }
            if ( *v17 != 45 || v17[1] )
            {
              v20 = fopen(v17, aWt);
              if ( !v20 )
                sub_403220(0, 0x418u, v17);
              v21 = _p__iob();
              dup2(v20->_file, v21[2]._file);
              fclose(v20);
            }
            else
            {
              file = _p__iob()[2]._file;
              v19 = _p__iob();
              dup2(v19[1]._file, file);
            }
            goto LABEL_46;
          }
          ++v15;
          sub_4086D0(v16, 1);
          if ( !*v15 )
            goto LABEL_46;
        }
        v22 = v15 + 1;
        if ( !*v22 )
        {
          if ( !--i || (v23 = a2[1], ++a2, !v23) || (v22 = v23, !*v23) )
            sub_403220(0, 0x425u);
        }
        v24 = sub_40AD20();
        v24[1] = sub_40ADD0(v22);
        sub_40AE30(&dword_4133E0, (int)v24);
      }
    }
    else
    {
      v6 = mbschr((const unsigned __int8 *)v4, 0x3Du);
      v7 = v6;
      if ( v6 )
      {
        if ( *a2 == (const char *)v6 )
          sub_403220(0, 0x427u);
        v8 = v7 - 1;
        *v7 = 0;
        v9 = v7 + 1;
        while ( *v8 == 32 || *v8 == 9 )
          --v8;
        v8[1] = 0;
        dword_4133B4 = 1;
        v10 = (const unsigned __int8 *)*a2;
        v11 = mbsspn(v9, &Delim);
        v25 = (unsigned __int8 *)sub_40ADD0((const char *)&v9[v11]);
        v12 = mbsspn(v10, &Delim);
        v13 = sub_40ADD0((const char *)&v10[v12]);
        sub_401980(v13, v25, 2);
        *a2 = 0;
      }
      else
      {
        sub_408A90(*a2);
        if ( **a2 )
        {
          v14 = sub_40AD20();
          v14[1] = sub_40ADD0(*a2);
          sub_40AE30(&dword_4133DC, (int)v14);
        }
        *a2 = 0;
      }
    }
LABEL_46:
    --i;
  }
  if ( v28 )
  {
    sub_403490();
    exit(0);
  }
  if ( v27 )
  {
    sub_403490();
    exit(0);
  }
}
// 4133B4: using guessed type int dword_4133B4;
// 4133DC: using guessed type int dword_4133DC;
// 4133E0: using guessed type int dword_4133E0;

//----- (004085F0) --------------------------------------------------------
const char *sub_4085F0()
{
  void *v0; // esp
  const char *result; // eax
  _DWORD *v2; // esi
  char *v3; // esi
  int v4; // ecx
  int v5; // [esp+0h] [ebp-110h] BYREF
  unsigned __int8 v6[260]; // [esp+Ch] [ebp-104h] BYREF

  v0 = alloca(dword_413EE0);
  result = (const char *)access(aMakefile, 4);
  if ( result )
  {
    if ( dword_4133DC )
    {
      v3 = *(char **)(dword_4133DC + 4);
      result = (const char *)access(v3, 4);
      if ( !result )
      {
        result = (const char *)mbsrchr((const unsigned __int8 *)v3, 0x2Eu);
        if ( !result || (result = (const char *)sub_409EF0(v6, (unsigned __int8 *)v3, result, (int)&v5)) == 0 )
        {
          v4 = dword_4133DC;
          dword_4133DC = *(_DWORD *)dword_4133DC;
          dword_4133E0 = v4;
        }
      }
    }
    else if ( (byte_4133D4 & 1) == 0 )
    {
      return (const char *)sub_403220(0, 0x428u);
    }
  }
  else
  {
    v2 = sub_40AD20();
    result = sub_40ADD0(aMakefile);
    v2[1] = result;
    dword_4133E0 = (int)v2;
  }
  return result;
}
// 4133D4: using guessed type char byte_4133D4;
// 4133DC: using guessed type int dword_4133DC;
// 4133E0: using guessed type int dword_4133E0;
// 413EE0: using guessed type int dword_413EE0;
// 4085F0: using guessed type unsigned __int8 var_104[260];

//----- (004086D0) --------------------------------------------------------
int __stdcall sub_4086D0(char a1, int a2)
{
  int v2; // ebx
  char *v3; // edi
  signed __int8 v4; // al
  unsigned int v5; // esi
  int result; // eax
  char v7; // bl
  char v8; // al
  unsigned __int8 *v9; // eax
  char *v10; // eax
  unsigned __int8 *v11; // eax
  char *v12; // eax
  char v13; // [esp+Fh] [ebp-1h]
  unsigned __int8 v14; // [esp+14h] [ebp+4h]

  v2 = a1;
  v3 = &byte_4133D0;
  v4 = mbctoupper(a1);
  v5 = v4;
  v14 = v4;
  result = v4 - 32;
  switch ( result )
  {
    case 0:
      return result;
    case 33:
      v7 = 16;
      break;
    case 34:
      dword_4133B8 = 1;
      return result;
    case 35:
      v7 = 32;
      v3 = &byte_4133D4;
      dword_4133CC = 1;
      break;
    case 36:
      v7 = 1;
      break;
    case 37:
      v7 = 4;
      goto LABEL_18;
    case 41:
      v7 = 2;
      break;
    case 43:
      dword_4133A4 = 1;
      return result;
    case 44:
      v7 = 0x80;
      v3 = &byte_4133D4;
      dword_4133CC = 1;
      break;
    case 46:
      v7 = 4;
      break;
    case 47:
      dword_4133A8 = 1;
      return result;
    case 48:
      v7 = 1;
      goto LABEL_18;
    case 49:
      v7 = 8;
      goto LABEL_18;
    case 50:
      v7 = 2;
      goto LABEL_18;
    case 51:
      v7 = 8;
      break;
    case 52:
      v7 = 16;
LABEL_18:
      v3 = &byte_4133D4;
      break;
    default:
      result = sub_403220(0, 0x429u, v2);
      v7 = v13;
      break;
  }
  if ( !dword_4133E8 )
  {
    result = sub_407B70((unsigned __int8 *)aMakeflags);
    dword_4133E8 = result;
    dword_4133EC = *(_DWORD *)(result + 8);
  }
  if ( a2 )
  {
    v8 = v7 | *v3;
    *v3 = v8;
    if ( v14 == 81 )
      *v3 = v8 | 0x20;
    result = (int)mbschr(*(const unsigned __int8 **)(dword_4133EC + 4), v5);
    if ( !result )
    {
      v9 = mbschr(*(const unsigned __int8 **)(dword_4133EC + 4), 0x20u);
      if ( v9 )
        *v9 = v14;
      v10 = sub_40ADD0(off_4133C4);
      result = putenv(v10);
      if ( result == -1 )
        return sub_403220(dword_4133F4, 0x41Fu);
    }
  }
  else if ( v3 == &byte_4133D0 )
  {
    *v3 &= ~v7;
    v11 = mbschr(*(const unsigned __int8 **)(dword_4133EC + 4), v5);
    if ( v11 )
    {
      do
      {
        *v11 = v11[1];
        ++v11;
      }
      while ( *v11 );
    }
    v12 = sub_40ADD0(off_4133C4);
    result = putenv(v12);
    if ( result == -1 )
      return sub_403220(dword_4133F4, 0x41Fu);
  }
  return result;
}
// 408715: variable 'v13' is possibly undefined
// 4133A4: using guessed type int dword_4133A4;
// 4133A8: using guessed type int dword_4133A8;
// 4133B8: using guessed type int dword_4133B8;
// 4133C4: using guessed type char *off_4133C4;
// 4133CC: using guessed type int dword_4133CC;
// 4133D0: using guessed type char byte_4133D0;
// 4133D4: using guessed type char byte_4133D4;
// 4133E8: using guessed type int dword_4133E8;
// 4133EC: using guessed type int dword_4133EC;

//----- (00408940) --------------------------------------------------------
void __cdecl Function()
{
  signal(2, (_crt_signal_t)1);
  signal(15, (_crt_signal_t)1);
  sub_408A20();
  if ( byte_414008
    && (byte_4133D0 & 4) == 0
    && (byte_4133D4 & 0x10) == 0
    && dword_413A90
    && access(dword_413A90, 0)
    && !sub_4089E0((unsigned __int8 *)dword_413A90)
    && !unlink(dword_413A90) )
  {
    sub_403220(dword_4133F4, 0xFA8u, dword_413A90);
  }
  sub_403220(0, 0x422u);
}
// 4133D0: using guessed type char byte_4133D0;
// 4133D4: using guessed type char byte_4133D4;
// 414008: using guessed type char byte_414008;

//----- (004089E0) --------------------------------------------------------
char __stdcall sub_4089E0(unsigned __int8 *Str2)
{
  int v1; // edi

  v1 = dword_413A30;
  if ( !dword_413A30 )
    return 0;
  while ( mbsicmp(*(const unsigned __int8 **)(v1 + 4), Str2) )
  {
    v1 = *(_DWORD *)v1;
    if ( !v1 )
      return 0;
  }
  return 1;
}
// 413A30: using guessed type int dword_413A30;

//----- (00408A20) --------------------------------------------------------
int sub_408A20()
{
  int result; // eax
  int i; // ebp
  FILE *v2; // eax

  result = fcloseall();
  for ( i = dword_4133BC; i; i = *(_DWORD *)i )
  {
    result = unlink(*(const char **)(i + 4));
    if ( (byte_4133D0 & 4) != 0 )
    {
      printf("\tdel %s\n", *(const char **)(i + 4));
      v2 = _p__iob();
      result = fflush(v2 + 1);
    }
  }
  return result;
}
// 4133BC: using guessed type int dword_4133BC;
// 4133D0: using guessed type char byte_4133D0;

//----- (00408A90) --------------------------------------------------------
const char *__stdcall sub_408A90(const char *a1)
{
  unsigned int v1; // kr04_4
  const char *result; // eax
  int v3; // ecx

  v1 = strlen(a1) + 1;
  result = &a1[v1 - 2];
  v3 = 0;
  if ( *a1 == 34 && *result == 34 )
  {
    result = &a1[v1 - 3];
    v3 = 1;
  }
  for ( ; result > a1; --result )
  {
    if ( *result != 32 && *result != 46 )
      break;
  }
  if ( v3 )
    *++result = 34;
  *((_BYTE *)result + 1) = 0;
  return result;
}

//----- (00408AE0) --------------------------------------------------------
char sub_408AE0()
{
  int v0; // eax
  int v1; // edx
  char result; // al
  unsigned __int8 i; // bl
  int v4; // eax
  char v5; // al
  char v6; // al
  int v7; // edi
  int v8; // esi
  int v9; // esi
  unsigned __int8 *v10; // eax
  int v11; // ecx
  char v12; // [esp+Eh] [ebp-2h]
  char v13; // [esp+Fh] [ebp-1h]

  dword_4133C8 = 1;
  v12 = 0;
  v0 = ++dword_413420;
  v1 = dword_4133F4;
  ++dword_413420;
  byte_413410[v0] = 23;
  dword_413424 = v1;
  byte_413410[dword_413420] = 0;
  result = sub_406500(1024, 0);
  v13 = result;
  for ( i = byte_413410[dword_413420]; i != 23; i = byte_413410[dword_413420] )
  {
    if ( (i & 0x40) != 0 )
    {
      v4 = dword_413420--;
      (*(&off_414630 + (byte_413410[v4] & 0xF)))();
    }
    else if ( (i & 0x10) != 0 )
    {
      if ( v13 == i )
      {
        v5 = byte_413410[--dword_413420];
        if ( (v5 & 0x40) != 0 )
        {
          --dword_413420;
          (*(&off_414630 + (v5 & 0xF)))();
        }
        dword_413424 = dword_4133F4;
        if ( v12 )
        {
          if ( String[0] == 10 )
            dword_413424 = dword_4133F4 - 1;
          v6 = v12;
          v12 = 0;
          v13 = v6;
        }
        else
        {
          v13 = sub_406500(1024, byte_413410[dword_413420]);
        }
      }
      else
      {
        sub_403220(dword_413424, 0x409u, String);
      }
    }
    else
    {
      v7 = 8 * i;
      v8 = (unsigned __int8)byte_4145D8[v7 + (v13 & 0xF)];
      if ( (v8 & 0x20) != 0 )
        sub_403220(dword_413424, v8 + 1000, String);
      --dword_413420;
      if ( (v8 & 0x80) != 0 )
      {
        v9 = v8 & 0xF;
        if ( !v12 )
          v12 = sub_406500(1024, i);
        v8 = (unsigned __int8)byte_414618[v7 + (v12 & 0xF)] + v9;
      }
      v10 = (unsigned __int8 *)*(&off_414588 + v8);
      v11 = *v10;
      if ( *v10 )
      {
        do
          byte_413410[++dword_413420] = v10[v11--];
        while ( v11 );
      }
    }
    result = dword_413420;
  }
  --dword_413420;
  return result;
}
// 4133C8: using guessed type int dword_4133C8;
// 413420: using guessed type int dword_413420;
// 414588: using guessed type void *off_414588;
// 414630: using guessed type int (*off_414630)();

//----- (00408CD0) --------------------------------------------------------
unsigned int __stdcall sub_408CD0(int a1, const char *a2)
{
  unsigned int result; // eax

  result = strlen(a2) + a1;
  if ( result > 0x28 )
  {
    printf("\n\t\t\t");
    return 0;
  }
  return result;
}

//----- (00408D10) --------------------------------------------------------
FILE *__stdcall sub_408D10(int ArgList, int a2, int a3)
{
  char *v4; // eax
  __time32_t Time; // [esp+0h] [ebp-4h] BYREF

  if ( !a3 )
    return sub_403370(6u, ArgList, off_414810, a2);
  Time = a3;
  v4 = ctime(&Time);
  v4[24] = 0;
  return sub_403370(4u, ArgList, off_414810, a2, 40 - ArgList, v4);
}
// 414810: using guessed type char (*off_414810)[8];
// 408D10: using guessed type _DWORD ArgList;

//----- (00408D80) --------------------------------------------------------
FILE *__stdcall sub_408D80(FILE *a1, char a2)
{
  int v2; // edi
  FILE *result; // eax
  unsigned __int8 *i; // eax
  char *v5; // ebx
  char *v6; // eax
  char *v7; // ebp
  char *v8; // eax
  char *v9; // ebp
  char *v10; // eax
  char *v11; // ebx
  char *v12; // eax
  char *v13; // ebx
  int v14; // [esp+10h] [ebp-Ch] BYREF
  intptr_t FindHandle; // [esp+14h] [ebp-8h] BYREF
  void *Block; // [esp+18h] [ebp-4h]

  v2 = 0;
  v14 = (int)sub_40ACF0(dword_413EE0);
  for ( result = sub_403370(0xCu); a1; a1 = (FILE *)a1->_ptr )
  {
    if ( mbschr((const unsigned __int8 *)a1->_cnt, 0x24u) )
    {
      Block = sub_40B700((char *)a1->_cnt, (int)&a2);
      for ( i = mbstok((unsigned __int8 *)Block, &Delim); ; i = mbstok(0, &Delim) )
      {
        v5 = (char *)i;
        if ( !i )
          break;
        if ( mbspbrk(i, &Control) )
        {
          if ( sub_40CD20((unsigned __int8 *)v5, &v14, &FindHandle) )
          {
            v6 = (char *)sub_404C90(&v14);
            v7 = sub_40C340(v5, v6);
            printf("%s ", v7);
            v2 = sub_408CD0(v2, v7);
            free(v7);
            while ( sub_40CE00(&v14, FindHandle) )
            {
              v8 = (char *)sub_404C90(&v14);
              v9 = sub_40C340(v5, v8);
              printf("%s ", v9);
              v2 = sub_408CD0(v2, v9);
              free(v9);
            }
          }
        }
        else
        {
          printf("%s ", v5);
          v2 = sub_408CD0(v2, v5);
        }
      }
      free(Block);
    }
    else if ( mbspbrk((const unsigned __int8 *)a1->_cnt, &Control) )
    {
      if ( sub_40CD20((unsigned __int8 *)a1->_cnt, &v14, &FindHandle) )
      {
        v10 = (char *)sub_404C90(&v14);
        v11 = sub_40C340((char *)a1->_cnt, v10);
        printf("%s ", v11);
        v2 = sub_408CD0(v2, v11);
        free(v11);
        while ( sub_40CE00(&v14, FindHandle) )
        {
          v12 = (char *)sub_404C90(&v14);
          v13 = sub_40C340((char *)a1->_cnt, v12);
          printf("%s ", v13);
          v2 = sub_408CD0(v2, v13);
          free(v13);
        }
      }
    }
    else
    {
      printf("%s ", (const char *)a1->_cnt);
      v2 = sub_408CD0(v2, (const char *)a1->_cnt);
    }
    result = a1;
  }
  return result;
}
// 413EE0: using guessed type int dword_413EE0;

//----- (00409000) --------------------------------------------------------
int sub_409000()
{
  _DWORD *v0; // ebx
  _DWORD *v1; // esi
  int v2; // eax
  int v3; // eax
  int **i; // ebp
  FILE *v5; // eax

  v0 = &unk_413428;
  sub_403370(8u);
  do
  {
    v1 = (_DWORD *)*v0;
    if ( *v0 )
    {
      do
      {
        v2 = v1[2];
        if ( v2 )
        {
          v3 = *(_DWORD *)(v2 + 4);
          if ( v3 )
          {
            sub_403370(0xEu, v1[1], v3);
            for ( i = *(int ***)v1[2]; i; i = (int **)*i )
            {
              if ( i[1] )
                printf("\t\t%s\n", (const char *)i[1]);
            }
          }
        }
        v1 = (_DWORD *)*v1;
      }
      while ( v1 );
    }
    ++v0;
  }
  while ( v0 < dword_413828 );
  putchar(10);
  v5 = _p__iob();
  return fflush(v5 + 1);
}
// 413828: using guessed type _DWORD dword_413828[128];

//----- (004090A0) --------------------------------------------------------
int sub_4090A0()
{
  int i; // ebx
  int ***v1; // ebp
  int **j; // ebp
  int k; // ebx
  FILE *v4; // eax

  sub_403370(7u);
  for ( i = dword_413A34; i; i = *(_DWORD *)i )
  {
    printf("%s:", *(const char **)(i + 8));
    sub_403370(0xAu);
    v1 = *(int ****)(i + 12);
    if ( v1 )
    {
      printf("%s\n", (const char *)v1[1]);
      for ( j = *v1; j; j = (int **)*j )
        printf("\t\t\t%s\n", (const char *)j[1]);
    }
    putchar(10);
  }
  printf("%s: ", (const char *)aSuffixes);
  for ( k = dword_413A2C; k; k = *(_DWORD *)k )
    printf("%s ", *(const char **)(k + 4));
  putchar(10);
  v4 = _p__iob();
  return fflush(v4 + 1);
}
// 413A2C: using guessed type int dword_413A2C;

//----- (00409170) --------------------------------------------------------
int sub_409170()
{
  _DWORD *i; // esi
  int v1; // edi
  int v2; // ebp
  unsigned int j; // ebx
  int ***v4; // edi
  int **k; // edi
  FILE *v6; // eax
  int v8; // [esp+10h] [ebp-8h]
  int *v9; // [esp+14h] [ebp-4h]

  sub_403370(9u);
  v9 = dword_413828;
  do
  {
    v8 = *v9;
    while ( v8 )
    {
      printf(
        "%s:%c",
        *(const char **)(v8 + 4),
        (*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v8 + 16) + 4) + 16) & 0x20) == 0 ? 32 : 58);
      dword_413A84 = *(_DWORD *)(v8 + 4);
      dword_413A90 = (char *)dword_413A84;
      dword_413A8C = dword_413A84;
      for ( i = *(_DWORD **)(v8 + 16); i; i = (_DWORD *)*i )
      {
        v1 = i[1];
        v2 = 0;
        sub_403370(0xBu);
        for ( j = 1; j < 0x10; j *= 2 )
        {
          if ( ((unsigned __int8)j & *(_BYTE *)(v1 + 16)) != 0 )
            printf("-%c ", off_414814[v2]);
          ++v2;
        }
        sub_408D80(*(FILE **)v1, *(_DWORD *)(v1 + 4));
        sub_403370(0xAu);
        v4 = *(int ****)(v1 + 8);
        if ( v4 )
        {
          if ( v4[1] )
            printf("%s\n", (const char *)v4[1]);
          for ( k = *v4; k; k = (int **)*k )
          {
            if ( k[1] )
              printf("\t\t\t%s\n", (const char *)k[1]);
          }
        }
        else
        {
          putchar(10);
        }
      }
      v8 = *(_DWORD *)v8;
      putchar(10);
    }
    ++v9;
  }
  while ( v9 < &dword_413A28 );
  dword_413A84 = 0;
  dword_413A90 = 0;
  dword_413A8C = 0;
  putchar(10);
  v6 = _p__iob();
  return fflush(v6 + 1);
}
// 413828: using guessed type _DWORD dword_413828[128];
// 413A28: using guessed type int dword_413A28;
// 413A84: using guessed type int dword_413A84;
// 413A8C: using guessed type int dword_413A8C;
// 414814: using guessed type char *off_414814;

//----- (00409300) --------------------------------------------------------
BOOL __stdcall sub_409300(char a1)
{
  _BYTE *v1; // eax
  const unsigned __int8 **v2; // edi
  const unsigned __int8 **v3; // esi
  BOOL result; // eax

  v1 = (_BYTE *)dword_40EA24;
  dword_40EA24 -= 8;
  v2 = (const unsigned __int8 **)(v1 + 4);
  v3 = (const unsigned __int8 **)(dword_40EA24 + 4);
  if ( *v1 == 22 && *(_BYTE *)dword_40EA24 == 22 )
  {
    switch ( a1 )
    {
      case 1:
        if ( !*v3 && !*v2 )
        {
          *v3 = 0;
          return 1;
        }
        result = 1;
        *v3 = (const unsigned __int8 *)1;
        break;
      case 2:
        if ( *v3 && *v2 )
        {
          result = 1;
          *v3 = (const unsigned __int8 *)1;
        }
        else
        {
          result = 1;
          *v3 = 0;
        }
        break;
      case 3:
        *v3 = (const unsigned __int8 *)((unsigned int)*v2 | (unsigned int)*v3);
        result = 1;
        break;
      case 4:
        *v3 = (const unsigned __int8 *)((unsigned int)*v2 ^ (unsigned int)*v3);
        result = 1;
        break;
      case 5:
        *v3 = (const unsigned __int8 *)((unsigned int)*v2 & (unsigned int)*v3);
        result = 1;
        break;
      case 6:
        *v3 = (const unsigned __int8 *)(*v2 != *v3);
        result = 1;
        break;
      case 7:
        *v3 = (const unsigned __int8 *)(*v2 == *v3);
        result = 1;
        break;
      case 8:
        *v3 = (const unsigned __int8 *)((int)*v2 < (int)*v3);
        result = 1;
        break;
      case 9:
        *v3 = (const unsigned __int8 *)((int)*v2 > (int)*v3);
        result = 1;
        break;
      case 10:
        *v3 = (const unsigned __int8 *)((int)*v2 <= (int)*v3);
        result = 1;
        break;
      case 11:
        *v3 = (const unsigned __int8 *)((int)*v2 >= (int)*v3);
        result = 1;
        break;
      case 12:
        result = 1;
        *v3 = (const unsigned __int8 *)((int)*v3 >> *(_BYTE *)v2);
        break;
      case 13:
        result = 1;
        *v3 = (const unsigned __int8 *)((_DWORD)*v3 << *(_BYTE *)v2);
        break;
      case 14:
        *v3 -= (int)*v2;
        result = 1;
        break;
      case 15:
        *v3 = &(*v3)[(_DWORD)*v2];
        result = 1;
        break;
      case 16:
        if ( !*v2 )
          sub_403220(dword_4133F4, 0x437u);
        result = 1;
        *v3 = (const unsigned __int8 *)((int)*v3 % (int)*v2);
        break;
      case 17:
        if ( !*v2 )
          sub_403220(dword_4133F4, 0x437u);
        *v3 = (const unsigned __int8 *)((int)*v3 / (int)*v2);
        result = 1;
        break;
      case 18:
        *v3 = (const unsigned __int8 *)((_DWORD)*v3 * (_DWORD)*v2);
        result = 1;
        break;
      default:
        result = 0;
        break;
    }
  }
  else if ( *v1 == 23 && *(_BYTE *)dword_40EA24 == 23 && (a1 == 7 || a1 == 6) )
  {
    *(_BYTE *)dword_40EA24 = 22;
    *v3 = (const unsigned __int8 *)(mbscmp(*v3, *v2) == 0);
    return a1 != 6 || sub_4095C0(21);
  }
  else
  {
    return 0;
  }
  return result;
}
// 40EA24: using guessed type int dword_40EA24;

//----- (004095C0) --------------------------------------------------------
int __stdcall sub_4095C0(char a1)
{
  int *v1; // ecx

  v1 = (int *)(dword_40EA24 + 4);
  if ( *(_BYTE *)dword_40EA24 != 22 )
    return 0;
  switch ( a1 )
  {
    case 19:
      *v1 = -*v1;
      return 1;
    case 20:
      *v1 = ~*v1;
      return 1;
    case 21:
      *v1 = *v1 == 0;
      return 1;
    default:
      return 0;
  }
}
// 40EA24: using guessed type int dword_40EA24;

//----- (00409620) --------------------------------------------------------
char *sub_409620()
{
  char *i; // esi
  char *result; // eax

  for ( i = ++EndPtr; *EndPtr; ++EndPtr )
  {
    if ( *EndPtr == 34 )
    {
      if ( EndPtr[1] != 34 )
        break;
      ++EndPtr;
    }
  }
  if ( !*EndPtr )
    sub_403220(dword_4133F4, 0x3FEu, 34);
  *EndPtr = 0;
  result = i;
  ++EndPtr;
  return result;
}

//----- (00409690) --------------------------------------------------------
char *sub_409690()
{
  char *i; // esi
  char *result; // eax

  for ( i = ++EndPtr; *EndPtr; ++EndPtr )
  {
    if ( *EndPtr == 94 && EndPtr[1] == 93 )
    {
      memmove(EndPtr, EndPtr + 1, strlen(EndPtr + 1) + 1);
    }
    else if ( *EndPtr == 93 )
    {
      break;
    }
  }
  if ( !*EndPtr )
    sub_403220(dword_4133F4, 0x3FEu, 93);
  *EndPtr = 0;
  result = i;
  ++EndPtr;
  return result;
}

//----- (00409730) --------------------------------------------------------
int __stdcall sub_409730(unsigned __int8 a1)
{
  unsigned __int8 v1; // bl
  int result; // eax

  if ( a1 == 25 )
  {
    v1 = 3;
  }
  else if ( a1 )
  {
    v1 = 0;
    if ( a1 <= 0x15u )
      v1 = (a1 > 0x12u) + 1;
  }
  else
  {
    v1 = 4;
  }
  result = (unsigned __int8)byte_40EA1C;
  if ( !byte_414880[5 * (unsigned __int8)byte_40EA1C + v1] )
    result = sub_403220(dword_4133F4, 0x3FFu);
  byte_40EA1C = v1;
  return result;
}
// 40EA1C: using guessed type char byte_40EA1C;

//----- (00409790) --------------------------------------------------------
int __stdcall sub_409790(unsigned __int8 a1, int a2)
{
  int result; // eax

  sub_409730(a1);
  result = a2;
  byte_40EA08 = a1;
  LOBYTE(dword_40EA10) = a1;
  dword_40EA14 = a2;
  return result;
}
// 40EA08: using guessed type char byte_40EA08;
// 40EA10: using guessed type int dword_40EA10;
// 40EA14: using guessed type int dword_40EA14;

//----- (004097C0) --------------------------------------------------------
char __stdcall sub_4097C0(_BYTE *a1)
{
  char *v1; // ecx
  _BYTE *v2; // eax
  char result; // al

  v1 = EndPtr;
  v2 = a1;
  if ( *a1 )
  {
    do
    {
      if ( *v1 != *v2 )
        break;
      ++v1;
      ++v2;
    }
    while ( *v2 );
    if ( *v2 )
      return 0;
  }
  result = 1;
  EndPtr = v1;
  return result;
}

//----- (00409800) --------------------------------------------------------
int sub_409800()
{
  unsigned __int8 v0; // bl
  void **v1; // esi
  char *v3; // eax
  char *v4; // eax
  char *v5; // ebx
  int v6; // esi
  unsigned __int8 *v7; // esi
  unsigned __int8 *v8; // esi
  int v9; // eax
  unsigned __int8 *v10; // esi
  unsigned __int8 *v11; // esi
  int v12; // eax

  v0 = *EndPtr;
  if ( (*EndPtr == 32 || v0 == 9) && ismbcspace((char)v0) )
  {
    do
      v0 = *++EndPtr;
    while ( ismbcspace(*EndPtr) );
  }
  if ( byte_4149C0[v0] >= 0 )
  {
    v1 = (void **)&unk_414948;
  }
  else
  {
    v1 = &off_4148A0;
    if ( off_4148A0 )
    {
      do
      {
        if ( sub_4097C0(*v1) )
          break;
        v1 += 2;
      }
      while ( *v1 );
    }
  }
  if ( *v1 )
    return sub_409790(*((_BYTE *)v1 + 4), 0);
  switch ( v0 )
  {
    case '-':
      ++EndPtr;
      if ( byte_40EA08 == 22 )
        return sub_409790(0xEu, 0);
      else
        return sub_409790(0x13u, 0);
    case '"':
      v3 = sub_409620();
      return sub_409790(0x17u, (int)v3);
    case '[':
      v4 = sub_409690();
      return sub_409790(0x18u, (int)v4);
    default:
      if ( ismbcdigit((char)v0) )
      {
        v5 = EndPtr;
        *errno() = 0;
        v6 = strtol(EndPtr, &EndPtr, 0);
        if ( *errno() == 34 )
        {
          *EndPtr = 0;
          sub_403220(dword_4133F4, 0x436u, v5);
        }
        if ( mbctoupper(*EndPtr) == 76 )
          ++EndPtr;
        return sub_409790(0x16u, v6);
      }
      else if ( v0 )
      {
        if ( mbsnbicmp((const unsigned __int8 *)EndPtr, aDefined, 7u) )
        {
          if ( mbsnbicmp((const unsigned __int8 *)EndPtr, aExist, 5u) )
          {
            return sub_403220(dword_4133F4, 0x3FFu);
          }
          else
          {
            v10 = mbschr((const unsigned __int8 *)EndPtr, 0x28u);
            if ( !v10 )
              sub_403220(dword_4133F4, 0x3FFu);
            v11 = v10 + 1;
            EndPtr = (char *)&v11[mbscspn(v11, &byte_4149A0)];
            *EndPtr++ = 0;
            v12 = sub_409DE0(v11);
            return sub_409790(0x16u, v12);
          }
        }
        else
        {
          v7 = mbschr((const unsigned __int8 *)EndPtr, 0x28u);
          if ( !v7 )
            sub_403220(dword_4133F4, 0x3FFu);
          v8 = v7 + 1;
          EndPtr = (char *)&v8[mbscspn(v8, &byte_4149A0)];
          *EndPtr++ = 0;
          v9 = sub_409D70(v8);
          return sub_409790(0x16u, v9);
        }
      }
      else
      {
        dword_40EA20 = 1;
        return sub_409790(0, 0);
      }
  }
}
// 40EA08: using guessed type char byte_40EA08;
// 40EA20: using guessed type int dword_40EA20;
// 4148A0: using guessed type void *off_4148A0;

//----- (00409A90) --------------------------------------------------------
intptr_t __stdcall sub_409A90(int a1)
{
  intptr_t result; // eax
  int v2; // ecx

  dword_40EA24 += 8;
  if ( *(_BYTE *)a1 == 24 )
  {
    result = sub_403AF0(*(char **)(a1 + 4), 0, 1, 0, 0);
    *(_DWORD *)(dword_40EA24 + 4) = result;
    *(_BYTE *)dword_40EA24 = 22;
  }
  else
  {
    v2 = dword_40EA24;
    result = *(_DWORD *)(a1 + 4);
    *(_DWORD *)dword_40EA24 = *(_DWORD *)a1;
    *(_DWORD *)(v2 + 4) = result;
  }
  return result;
}
// 40EA24: using guessed type int dword_40EA24;

//----- (00409AE0) --------------------------------------------------------
int sub_409AE0()
{
  char *v0; // esi
  char v1; // cl
  int (__stdcall *v2)(char); // eax

  v0 = (char *)&unk_40EE30;
  if ( dword_40EA0C > (unsigned int)&unk_40EE30 )
  {
    do
    {
      v1 = *v0;
      if ( (unsigned __int8)*v0 <= 0x15u )
      {
        v2 = sub_4095C0;
        if ( (unsigned __int8)v1 <= 0x12u )
          v2 = sub_409300;
        if ( !v2(v1) )
          sub_403220(dword_4133F4, 0x438u);
      }
      else
      {
        sub_409A90((int)v0);
      }
      v0 += 8;
    }
    while ( (unsigned int)v0 < dword_40EA0C );
  }
  if ( (_UNKNOWN *)dword_40EA24 == &unk_40FE30 && *(_BYTE *)dword_40EA24 == 22 )
    return *(_DWORD *)(dword_40EA24 + 4) != 0;
  else
    return sub_403220(dword_4133F4, 0x3FFu);
}
// 40EA0C: using guessed type int dword_40EA0C;
// 40EA24: using guessed type int dword_40EA24;

//----- (00409B70) --------------------------------------------------------
int sub_409B70()
{
  int v0; // ecx
  int result; // eax

  if ( dword_40EA24 < (unsigned int)&unk_40FE30 )
    sub_403220(dword_4133F4, 0x3FFu);
  if ( (unsigned int)off_414954 < dword_40EA0C )
    sub_403220(dword_4133F4, 0x412u);
  v0 = dword_40EA0C;
  result = *(_DWORD *)(dword_40EA24 + 4);
  *(_DWORD *)dword_40EA0C = *(_DWORD *)dword_40EA24;
  *(_DWORD *)(v0 + 4) = result;
  dword_40EA24 -= 8;
  dword_40EA0C += 8;
  return result;
}
// 40EA0C: using guessed type int dword_40EA0C;
// 40EA24: using guessed type int dword_40EA24;
// 414954: using guessed type void *off_414954;

//----- (00409BE0) --------------------------------------------------------
int sub_409BE0()
{
  int v0; // edx
  int v1; // ecx
  int v2; // esi
  int v3; // edx
  int v4; // ecx

  dword_40EA24 = (int)&unk_40FE30;
  dword_40EA0C = (int)&unk_40EE30;
  byte_40EA1C = 3;
  byte_40EA08 = 25;
  dword_40EA20 = 0;
  sub_409790(0x19u, 0);
  v0 = dword_40EA24;
  v1 = dword_40EA14;
  *(_DWORD *)dword_40EA24 = dword_40EA10;
  *(_DWORD *)(v0 + 4) = v1;
  while ( !dword_40EA20 )
  {
    v2 = 0;
    sub_409800();
    if ( (_BYTE)dword_40EA10 != 25
      && (unsigned __int8)byte_414860[*(unsigned __int8 *)dword_40EA24] >= (unsigned __int8)byte_414860[(unsigned __int8)dword_40EA10] )
    {
      do
      {
        if ( byte_414860[(unsigned __int8)dword_40EA10] )
        {
          sub_409B70();
        }
        else
        {
          while ( *(_BYTE *)dword_40EA24 != 25 )
            sub_409B70();
          v2 = 1;
          if ( dword_40EA24 >= (unsigned int)&unk_40FE30 )
          {
            dword_40EA24 -= 8;
            break;
          }
          sub_403220(dword_4133F4, 0x3FFu);
        }
      }
      while ( (unsigned __int8)byte_414860[*(unsigned __int8 *)dword_40EA24] >= (unsigned __int8)byte_414860[(unsigned __int8)dword_40EA10] );
    }
    if ( !v2 )
    {
      if ( off_414950 == (void *)dword_40EA24 )
      {
        sub_403220(dword_4133F4, 0x412u);
      }
      else
      {
        dword_40EA24 += 8;
        v3 = dword_40EA24;
        v4 = dword_40EA14;
        *(_DWORD *)dword_40EA24 = dword_40EA10;
        *(_DWORD *)(v3 + 4) = v4;
      }
    }
  }
  if ( (_UNKNOWN *)dword_40EA24 != &unk_40FE28 )
    sub_403220(dword_4133F4, 0x3FFu);
  return sub_409AE0();
}
// 40EA08: using guessed type char byte_40EA08;
// 40EA0C: using guessed type int dword_40EA0C;
// 40EA10: using guessed type int dword_40EA10;
// 40EA14: using guessed type int dword_40EA14;
// 40EA1C: using guessed type char byte_40EA1C;
// 40EA20: using guessed type int dword_40EA20;
// 40EA24: using guessed type int dword_40EA24;
// 414950: using guessed type void *off_414950;

//----- (00409D70) --------------------------------------------------------
BOOL __stdcall sub_409D70(unsigned __int8 *Str)
{
  unsigned __int8 *v1; // edi

  v1 = mbstok(Str, &Delim);
  if ( mbstok(0, &Delim) )
    sub_403220(dword_4133F4, 0x409u, v1);
  if ( !v1 )
    sub_403220(dword_4133F4, 0x417u);
  return sub_407B70(v1) != 0;
}

//----- (00409DE0) --------------------------------------------------------
int __stdcall sub_409DE0(unsigned __int8 *Str)
{
  int v1; // esi
  unsigned __int8 *v2; // ebx
  char *v3; // edi
  char *v5; // [esp+Ch] [ebp-4h]

  v1 = 0;
  v2 = mbstok(Str, &Delim);
  if ( mbstok(0, &Delim) )
    sub_403220(dword_4133F4, 0x409u, v2);
  if ( v2 )
  {
    v3 = sub_40CA30((const char *)v2);
    if ( v3 )
      goto LABEL_8;
  }
  else
  {
    v3 = v5;
  }
  sub_403220(dword_4133F4, 0x417u);
LABEL_8:
  if ( !access(v3, 0) )
    v1 = 1;
  free(v3);
  return v1;
}
// 409E34: variable 'v5' is possibly undefined

//----- (00409E80) --------------------------------------------------------
int __stdcall sub_409E80(unsigned __int8 *a1, char a2)
{
  int result; // eax

  if ( !*a1 )
    sub_403220(dword_4133F4, 0x3FAu);
  switch ( a2 )
  {
    case 4:
    case 6:
      result = sub_409D70(a1);
      break;
    case 5:
    case 7:
      result = !sub_409D70(a1);
      break;
    default:
      EndPtr = (char *)a1;
      result = sub_409BE0();
      break;
  }
  return result;
}

//----- (00409EF0) --------------------------------------------------------
_DWORD *__stdcall sub_409EF0(unsigned __int8 *Dest, unsigned __int8 *String, const char *a3, int a4)
{
  _BYTE *v4; // ebx
  char v5; // al
  _BYTE *v6; // edi
  unsigned __int8 *v7; // esi
  int v8; // ebp
  const unsigned __int8 *v9; // esi
  unsigned __int8 *v10; // eax
  char v11; // al
  unsigned __int8 *i; // ebx
  size_t v13; // ebx
  unsigned __int8 *v14; // esi
  unsigned __int8 *v15; // eax
  int v16; // ebx
  unsigned __int8 *j; // eax
  char v18; // cl
  int v19; // esi
  size_t v20; // esi
  unsigned __int8 *v21; // eax
  int *v22; // esi
  char v24; // [esp+10h] [ebp-14h]
  unsigned __int8 *Source; // [esp+14h] [ebp-10h]
  unsigned __int8 *Sourcea; // [esp+14h] [ebp-10h]
  unsigned __int8 *v27; // [esp+18h] [ebp-Ch]
  char *v28; // [esp+18h] [ebp-Ch]
  unsigned int v29; // [esp+1Ch] [ebp-8h]
  _DWORD *v30; // [esp+20h] [ebp-4h]

  v30 = (_DWORD *)dword_413A34;
  if ( !dword_413A34 )
    return 0;
  while ( 1 )
  {
    Source = (unsigned __int8 *)v30[2];
    v27 = mbsrchr(Source, 0x2Eu);
    if ( sub_40C980((const char *)v27, a3) )
      goto LABEL_71;
    v4 = Source + 1;
    for ( *Dest = 0; *v4; ++v4 )
    {
      v5 = *v4;
      if ( *v4 == 123 )
        break;
      if ( v5 == 94 )
      {
        ++v4;
      }
      else if ( v5 == 34 && *++v4 != 34 )
      {
        do
          ++v4;
        while ( *v4 != 34 );
      }
    }
    if ( *v4 )
    {
      v6 = v4;
      do
      {
        if ( *v6 == 125 )
          break;
        if ( *v6 == 94 )
          ++v6;
        ++v6;
      }
      while ( *v6 );
      v7 = String;
      v8 = v6 - v4 - 1;
      if ( *String == 34 )
        v7 = String + 1;
      v28 = v4 + 1;
      if ( v6 - v4 != 1 )
      {
        do
        {
          v24 = *v28;
          if ( *v28 == 92 || *v28 == 47 )
          {
            if ( *v7 != 92 && *v7 != 47 )
            {
LABEL_28:
              v8 = -1;
              break;
            }
          }
          else
          {
            v29 = mbctoupper((char)*v7);
            if ( v29 != mbctoupper(v24) )
              goto LABEL_28;
          }
          --v8;
          ++v7;
          ++v28;
        }
        while ( v8 );
      }
      if ( v8 == -1 )
        goto LABEL_71;
      v9 = &String[v6 - v4];
      v27 = v4;
      v10 = mbschr(v9, 0x5Cu);
      if ( v10 || (v10 = mbschr(v9, 0x2Fu)) != 0 )
      {
        if ( v10 != v9 )
          goto LABEL_71;
        v11 = *(v6 - 1);
        if ( v11 == 92 || v11 == 47 )
          goto LABEL_71;
      }
    }
    if ( *Source == 123 )
    {
      Sourcea = Source + 1;
      for ( i = Sourcea; *i; ++i )
      {
        if ( *i == 125 )
          break;
        if ( *i == 94 )
          ++i;
      }
      v13 = i - Sourcea;
      if ( v13 )
      {
        mbsnbcpy(Dest, Sourcea, v13);
        Source = &Sourcea[v13 + 1];
        if ( *(Source - 2) != 92 )
          Dest[v13++] = 92;
      }
      else
      {
        v13 = 2;
        mbsnbcpy(Dest, ::Source, 2u);
        Source = Sourcea + 1;
      }
      v14 = mbsrchr(String, 0x5Cu);
      v15 = mbsrchr(String, 0x2Fu);
      if ( v15 <= v14 )
        v15 = v14;
      if ( v15 )
      {
        strcpy((char *)&Dest[v13], (const char *)v15 + 1);
        v16 = a3 - (const char *)v15 - 1 + v13;
      }
      else
      {
        strcpy((char *)&Dest[v13], (const char *)String);
        v16 = (int)&a3[v13 - (_DWORD)String];
      }
    }
    else
    {
      if ( *v4 )
      {
        for ( j = mbsrchr(String, 0x2Eu); *j != 58; --j )
        {
          if ( *j == 92 )
            break;
          if ( *j == 47 )
            break;
          if ( j <= String )
            break;
        }
        v18 = *j;
        if ( *j == 58 || v18 == 92 || v18 == 47 )
          ++j;
      }
      else
      {
        j = String;
      }
      v19 = 0;
      if ( j != String && *String == 34 )
      {
        v19 = 1;
        *Dest = 34;
      }
      v16 = v19 + a3 - (const char *)j;
      mbsnbcpy(&Dest[v19], j, a3 - (const char *)j);
    }
    v20 = v27 - Source;
    if ( v16 + v27 - Source > 257 )
      sub_403220(0, 0x434u);
    mbsnbcpy(&Dest[v16], Source, v20);
    if ( *Dest == 34 )
    {
      v21 = &Dest[v20++];
      v21[v16] = 34;
    }
    Dest[v20 + v16] = 0;
    v22 = sub_40AEC0((char *)Dest, 128, (int)dword_413828, 1);
    if ( v22 )
      break;
    if ( sub_40CBF0((const char *)Dest, &a4) )
      return v30;
LABEL_71:
    v30 = (_DWORD *)*v30;
    if ( !v30 )
      return 0;
  }
  sub_404CC0(&a4, v22[3]);
  return v30;
}
// 40A280: conditional instruction was optimized away because esi.4==0
// 413828: using guessed type _DWORD dword_413828[128];

//----- (0040A2A0) --------------------------------------------------------
void __stdcall sub_40A2A0(void *Block, int a2)
{
  void *v2; // ebx
  void *v3; // esi
  void *v4; // [esp-4h] [ebp-14h]

  v2 = Block;
  v3 = Block;
  while ( v2 )
  {
    if ( a2 )
    {
      if ( (byte_4133D4 & 1) != 0 )
        sub_403220(0, 0xFA5u, *((_DWORD *)v2 + 2));
    }
    free(*((void **)v2 + 2));
    sub_402C40(*((_DWORD **)v2 + 3));
    sub_402C40(*((_DWORD **)v2 + 4));
    v2 = *(void **)v2;
    v4 = v3;
    v3 = v2;
    free(v4);
  }
}
// 4133D4: using guessed type char byte_4133D4;

//----- (0040A310) --------------------------------------------------------
int __stdcall sub_40A310(const unsigned __int8 **Block, int a2)
{
  int v2; // edi
  unsigned __int8 *i; // ebx

  v2 = a2;
  if ( !a2 )
    return 0;
  while ( mbsicmp(*(const unsigned __int8 **)(v2 + 8), Block[2]) )
  {
    v2 = *(_DWORD *)v2;
    if ( !v2 )
      return 0;
  }
  free((void *)Block[2]);
  for ( i = (unsigned __int8 *)Block[3]; i; i = (unsigned __int8 *)Block[3] )
  {
    Block[3] = *(const unsigned __int8 **)i;
    free(*((void **)i + 1));
    sub_40ADA0(i);
  }
  free(Block);
  return 1;
}

//----- (0040A390) --------------------------------------------------------
_BYTE *__stdcall sub_40A390(_BYTE *a1)
{
  _BYTE *result; // eax
  _BYTE *v2; // ecx

  result = a1;
  if ( *a1 == 123 )
  {
    do
    {
      v2 = result++;
      if ( *v2 == 94 )
        ++result;
    }
    while ( *result != 125 );
    ++result;
  }
  return result;
}

//----- (0040A3C0) --------------------------------------------------------
void sub_40A3C0()
{
  void *v0; // eax
  _BYTE *v1; // edi
  size_t v2; // esi
  const unsigned __int8 *v3; // ebx
  unsigned __int8 v4; // al
  int v5; // ebx
  _DWORD *v6; // eax
  int **j; // ebp
  int i; // [esp+10h] [ebp-10h] BYREF
  void *Block; // [esp+14h] [ebp-Ch]
  unsigned __int8 *Str1; // [esp+18h] [ebp-8h]
  int v11; // [esp+1Ch] [ebp-4h]

  v0 = (void *)dword_413A34;
  dword_413A34 = 0;
  Block = v0;
  v11 = dword_413A2C;
  for ( i = 0; v11; v11 = *(_DWORD *)v11 )
  {
    Str1 = *(unsigned __int8 **)(v11 + 4);
    v1 = Block;
    v2 = strlen((const char *)Str1);
    if ( Block )
    {
      do
      {
        v3 = sub_40A390(*((_BYTE **)v1 + 2));
        if ( !mbsnbicmp(Str1, v3, v2) && ((v4 = v3[v2], v4 == 46) || v4 == 123) )
        {
          v5 = (int)v1;
          v6 = (_DWORD *)*((_DWORD *)v1 + 1);
          if ( v6 )
            *v6 = *(_DWORD *)v1;
          else
            Block = *(void **)v1;
          if ( *(_DWORD *)v1 )
            *(_DWORD *)(*(_DWORD *)v1 + 4) = *((_DWORD *)v1 + 1);
          v1 = *(_BYTE **)v1;
          *(_DWORD *)v5 = 0;
          if ( !sub_40A310((const unsigned __int8 **)v5, dword_413A34) )
          {
            for ( j = *(int ***)(v5 + 12); j; j = (int **)*j )
              sub_40B110((unsigned __int8 *)j[1], (int **)&i, 0, 0, 0, 0, 0);
            *(_DWORD *)(v5 + 16) = i;
            i = 0;
            sub_40AE30(&dword_413A34, v5);
          }
        }
        else
        {
          v1 = *(_BYTE **)v1;
        }
      }
      while ( v1 );
    }
  }
  if ( Block )
    sub_40A2A0(Block, 1);
}
// 413A2C: using guessed type int dword_413A2C;

//----- (0040A500) --------------------------------------------------------
_DWORD *__stdcall sub_40A500(
        int a1,
        unsigned __int8 *Str2,
        unsigned int a3,
        int ***a4,
        int ***a5,
        _DWORD *a6,
        unsigned int *a7,
        _DWORD *a8)
{
  void *v8; // esp
  unsigned __int8 *v9; // eax
  int **v10; // ebx
  _DWORD *v11; // ebx
  char v12; // al
  unsigned int v13; // ecx
  int v15; // [esp+0h] [ebp-18h] BYREF
  int *v16; // [esp+Ch] [ebp-Ch] BYREF
  _DWORD *v17; // [esp+10h] [ebp-8h]
  unsigned int v18; // [esp+14h] [ebp-4h] BYREF

  v8 = alloca(dword_413EE0);
  v16 = &v15;
  v9 = mbsrchr(*(const unsigned __int8 **)(a1 + 4), 0x2Eu);
  if ( !v9 )
    return 0;
  v17 = sub_409EF0(Str2, *(unsigned __int8 **)(a1 + 4), (const char *)v9, (int)v16);
  if ( !v17 )
    return 0;
  v18 = sub_404CA0(&v16);
  *a8 = Str2;
  v10 = *a5;
  if ( *a5 )
  {
    do
    {
      if ( !mbsicmp((const unsigned __int8 *)v10[1], Str2) )
        break;
      v10 = (int **)*v10;
    }
    while ( v10 );
    if ( v10 )
      *(_BYTE *)(a1 + 8) &= ~1u;
  }
  *a6 += sub_402080(Str2, *(_BYTE *)(a1 + 8), &v18, 0);
  if ( (*(_BYTE *)(a1 + 8) & 0x10) != 0 || a3 < v18 || dword_4133B8 && a3 == v18 )
  {
    if ( !v10 )
    {
      v11 = sub_40AD20();
      v11[1] = sub_40ADD0((const char *)Str2);
      sub_40AE30(a4, (int)v11);
      if ( !*a5 )
        *a5 = *a4;
    }
    v12 = *(_BYTE *)(a1 + 8);
    if ( (v12 & 1) != 0 && (v12 & 0x10) == 0 )
      sub_403370(3u, Str2, *(_DWORD *)(a1 + 4));
  }
  v13 = *a7;
  if ( *a7 <= v18 )
    v13 = v18;
  *a7 = v13;
  return v17;
}
// 4133B8: using guessed type int dword_4133B8;
// 413EE0: using guessed type int dword_413EE0;

//----- (0040A630) --------------------------------------------------------
int sub_40A630()
{
  signed int i; // ebx
  int result; // eax

  for ( i = 0; i <= 127; ++i )
  {
    result = ismbcalnum(i);
    if ( result )
    {
      result = (unsigned __int8)i;
      byte_4149C0[(unsigned __int8)i] |= 1u;
    }
  }
  return result;
}

//----- (0040A660) --------------------------------------------------------
char *__stdcall sub_40A660(int a1)
{
  FILE *v1; // esi
  int v2; // eax
  char *result; // eax

  v1 = dword_414AC0;
  if ( dword_414AC0 )
  {
    if ( dword_414AC0 != (FILE *)-1 )
      goto LABEL_5;
    return byte_413060;
  }
  else
  {
    if ( dword_414AC4 )
    {
      dword_414AC0 = fopen(dword_414AC4, Mode);
      if ( dword_414AC0 )
      {
        sub_40CF7B((_onexit_t)Func);
        v1 = dword_414AC0;
LABEL_5:
        v2 = sub_40AA70(a1);
        fseek(v1, v2, 0);
        return sub_40A6F0(a1, Buffer, 1024);
      }
    }
    result = byte_413060;
    dword_414AC0 = (FILE *)-1;
  }
  return result;
}

//----- (0040A6F0) --------------------------------------------------------
char *__stdcall sub_40A6F0(int a1, char *Buffer, int MaxCount)
{
  int v3; // ebp
  int v5; // [esp+10h] [ebp-8h] BYREF
  char *v6; // [esp+14h] [ebp-4h]

  while ( 1 )
  {
    v3 = ftell(dword_414AC0);
    if ( !fgets(Buffer, MaxCount, dword_414AC0) )
      return byte_413060;
    v6 = sub_40A820(Buffer, &v5);
    if ( a1 == v5 )
      break;
    if ( v5 % 1000 == 999 )
    {
      if ( a1 == v5 )
        break;
      if ( a1 / -1000 == v5 / -1000 )
        return sub_40A7A0(v6);
    }
  }
  sub_40AA20(v3, a1);
  return sub_40A7A0(v6);
}

//----- (0040A7A0) --------------------------------------------------------
char *__stdcall sub_40A7A0(char *a1)
{
  char *v2; // eax
  char *v3; // ebx
  char *v4; // ebp
  char v5; // al
  char v6; // al
  char v7; // al
  char *result; // eax

  do
    v2 = a1++;
  while ( *v2 != 34 );
  v3 = a1;
  v4 = a1;
  if ( *a1 != 34 )
  {
    while ( (_p__mbctype()[(unsigned __int8)*a1 + 1] & 4) == 0 )
    {
      if ( *a1 == 92 )
      {
        v6 = *++a1;
        switch ( v6 )
        {
          case 'n':
            *a1 = 10;
            break;
          case 't':
            *a1 = 9;
            break;
          case '"':
            *a1 = 34;
            break;
          default:
            *v3 = 92;
            goto LABEL_13;
        }
      }
LABEL_14:
      v7 = *a1++;
      *v3++ = v7;
      if ( *a1 == 34 )
        goto LABEL_15;
    }
    v5 = *a1++;
    *v3 = v5;
LABEL_13:
    ++v3;
    goto LABEL_14;
  }
LABEL_15:
  result = v4;
  *v3 = 0;
  return result;
}

//----- (0040A820) --------------------------------------------------------
_BYTE *__stdcall sub_40A820(_BYTE *a1, int *a2)
{
  int v2; // ebx
  _BYTE *i; // edi
  int v4; // eax

  v2 = 0;
  for ( i = a1; *i; v2 = (char)*i++ + 10 * v2 - 48 )
  {
    if ( *(int *)_p___mb_cur_max() <= 1 )
      v4 = (*_p__pctype())[(char)*i] & 4;
    else
      v4 = isctype((char)*i, 4);
    if ( !v4 )
      break;
  }
  *a2 = v2;
  return i;
}
// 41525C: using guessed type int _p___mb_cur_max(void);

//----- (0040A890) --------------------------------------------------------
int __stdcall sub_40A890(char *FileName, char *FullPath, int a3)
{
  FILE *v4; // eax
  char Drive[4]; // [esp+Ch] [ebp-408h] BYREF
  char Filename[256]; // [esp+10h] [ebp-404h] BYREF
  char Ext[256]; // [esp+110h] [ebp-304h] BYREF
  char Dir[256]; // [esp+210h] [ebp-204h] BYREF
  char Buffer[260]; // [esp+310h] [ebp-104h] BYREF

  if ( a3 )
  {
    splitpath(FullPath, Drive, Dir, 0, 0);
    splitpath(FileName, 0, 0, Filename, Ext);
    makepath(Buffer, Drive, Dir, Filename, Ext);
    if ( !access(Buffer, 0) || (makepath(Buffer, 0, 0, Filename, Ext), !access(Buffer, 0)) )
    {
      dword_414AC4 = strdup(Buffer);
      return 0;
    }
    v4 = _p__iob();
    fprintf(v4 + 2, "WARNING:  missing %s; displaying error numbers without messages.\n", FileName);
  }
  else if ( !access(FileName, 0) )
  {
    dword_414AC4 = strdup(FileName);
    return 0;
  }
  return 1;
}
// 40A890: using guessed type char Drive[4];

//----- (0040A9F0) --------------------------------------------------------
void __cdecl Func()
{
  if ( dword_414AC0 )
    fclose(dword_414AC0);
  if ( dword_414AC4 )
    free(dword_414AC4);
}

//----- (0040AA20) --------------------------------------------------------
int __stdcall sub_40AA20(int a1, int a2)
{
  int result; // eax
  int *v3; // edx
  int v4; // ecx

  result = 0;
  v3 = dword_414AC8;
  do
  {
    if ( !*v3 )
      break;
    if ( a2 == *v3 )
      return result;
    v3 += 2;
    ++result;
  }
  while ( v3 < (int *)aWarningMissing );
  if ( result < 20 )
  {
    dword_414AC8[2 * result] = a2;
    v4 = 2 * result;
    result = a1;
    dword_414ACC[v4] = a1;
  }
  return result;
}
// 414AC8: using guessed type int dword_414AC8[];
// 414ACC: using guessed type int dword_414ACC[39];

//----- (0040AA70) --------------------------------------------------------
int __stdcall sub_40AA70(int a1)
{
  int v1; // ecx
  int v2; // ebx
  int v3; // edi
  int v4; // eax

  v1 = 0;
  v2 = -1;
  v3 = 0x7FFF;
  do
  {
    v4 = dword_414AC8[2 * v1];
    if ( !v4 )
      break;
    if ( a1 == v4 )
    {
      v2 = v1;
      break;
    }
    if ( a1 > v4 && v3 > a1 - v4 && v4 / -1000 == a1 / -1000 )
    {
      v3 = a1 - v4;
      v2 = v1;
    }
    ++v1;
  }
  while ( v1 < 20 );
  if ( v2 < 0 )
    return 0;
  else
    return dword_414ACC[2 * v2];
}
// 414AC8: using guessed type int dword_414AC8[];
// 414ACC: using guessed type int dword_414ACC[39];

//----- (0040AAF0) --------------------------------------------------------
bool sub_40AAF0()
{
  HMODULE ModuleHandleA; // eax

  ModuleHandleA = GetModuleHandleA(ModuleName);
  return ModuleHandleA && GetProcAddress(ModuleHandleA, ProcName) != 0;
}

//----- (0040AB20) --------------------------------------------------------
bool sub_40AB20()
{
  signed int Version; // eax

  Version = GetVersion();
  return Version < 0 && (unsigned __int8)Version >= 4u;
}

//----- (0040AB40) --------------------------------------------------------
int __stdcall sub_40AB40(char *FullPath, _DWORD *a2)
{
  HFILE v2; // esi
  LONG v3; // eax
  int v4; // eax
  HFILE v6; // [esp-4h] [ebp-1A4h]
  char Buffer[2]; // [esp+12h] [ebp-18Eh] BYREF
  LONG lOffset; // [esp+14h] [ebp-18Ch] BYREF
  struct _OFSTRUCT ReOpenBuff; // [esp+18h] [ebp-188h] BYREF
  char Ext[256]; // [esp+A0h] [ebp-100h] BYREF

  splitpath(FullPath, 0, 0, 0, Ext);
  if ( !strnicmp(Ext, ::Ext, 3u) )
    goto LABEL_14;
  v2 = OpenFile(FullPath, &ReOpenBuff, 0x40u);
  if ( v2 != -1 )
  {
    lread(v2, Buffer, 2u);
    if ( memicmp(Buffer, aMz, 2u) || llseek(v2, 60, 0) != 60 )
      goto LABEL_9;
    if ( lread(v2, &lOffset, 4u) == 4 )
    {
      v3 = llseek(v2, lOffset, 0);
      if ( v3 != lOffset )
      {
LABEL_9:
        lclose(v2);
        *a2 = 2;
        return 0;
      }
      lread(v2, Buffer, 4u);
      v4 = memicmp(Buffer, aPe, 2u);
      v6 = v2;
      if ( !v4 )
      {
        lclose(v2);
        *a2 = 0;
        return 1;
      }
    }
    else
    {
      v6 = v2;
    }
    lclose(v6);
LABEL_14:
    *a2 = 1;
    return 0;
  }
  *a2 = 3;
  return 0;
}

//----- (0040ACC0) --------------------------------------------------------
void *__stdcall sub_40ACC0(size_t Size)
{
  void *v1; // esi

  v1 = malloc(Size);
  if ( !v1 )
    sub_403220(dword_413424, 0x41Bu);
  return v1;
}

//----- (0040ACF0) --------------------------------------------------------
void *__stdcall sub_40ACF0(size_t a1)
{
  void *v1; // edx

  v1 = sub_40ACC0(a1);
  memset(v1, 0, a1);
  return v1;
}

//----- (0040AD20) --------------------------------------------------------
_DWORD *sub_40AD20()
{
  _DWORD *result; // eax

  if ( dword_40EE28 )
  {
    result = (_DWORD *)dword_40EE28;
    dword_40EE28 = *(_DWORD *)dword_40EE28;
  }
  else
  {
    if ( (unsigned int)dword_414BDC < 8 )
    {
      dword_414BE0 = (int)malloc(0x8000u);
      if ( !dword_414BE0 )
        sub_403220(dword_413424, 0x41Bu);
      dword_414BDC = 0x8000;
    }
    dword_414BDC -= 8;
    result = (_DWORD *)dword_414BE0;
    dword_414BE0 += 8;
  }
  *result = 0;
  result[1] = 0;
  return result;
}
// 40EE28: using guessed type int dword_40EE28;
// 414BDC: using guessed type int dword_414BDC;
// 414BE0: using guessed type int dword_414BE0;

//----- (0040ADA0) --------------------------------------------------------
_DWORD *__stdcall sub_40ADA0(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  if ( dword_40EE28 )
    *a1 = dword_40EE28;
  else
    *a1 = 0;
  dword_40EE28 = (int)a1;
  return result;
}
// 40EE28: using guessed type int dword_40EE28;

//----- (0040ADD0) --------------------------------------------------------
char *__stdcall sub_40ADD0(const char *a1)
{
  size_t v1; // ebx
  char *result; // eax

  v1 = strlen(a1) + 1;
  result = (char *)sub_40ACC0(v1);
  qmemcpy(result, a1, v1);
  return result;
}

//----- (0040AE10) --------------------------------------------------------
_DWORD *__stdcall sub_40AE10(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a1;
  *a2 = *a1;
  *a1 = a2;
  return result;
}

//----- (0040AE30) --------------------------------------------------------
_DWORD *__stdcall sub_40AE30(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  for ( result = a1; *result; result = (_DWORD *)*result )
    ;
  *result = a2;
  return result;
}

//----- (0040AE50) --------------------------------------------------------
int __stdcall sub_40AE50(char *a1, unsigned int a2, int a3)
{
  unsigned int v3; // edi
  _BYTE *v4; // esi
  unsigned int i; // eax
  unsigned int v6; // eax
  _BYTE *j; // esi

  if ( a3 )
  {
    v3 = 0;
    v4 = a1;
    for ( i = *a1; *v4; i = (char)*v4 )
    {
      if ( i == 47 )
        v6 = 92;
      else
        v6 = mbctoupper(i);
      v3 += v6;
      ++v4;
    }
  }
  else
  {
    v3 = 0;
    for ( j = a1; *j; ++j )
      v3 += (char)*j;
  }
  return v3 % a2;
}

//----- (0040AEC0) --------------------------------------------------------
int *__stdcall sub_40AEC0(char *Str1, int a2, int a3, int a4)
{
  int v4; // esi
  int v5; // eax
  int *result; // eax
  char *v7; // ebp
  int v8; // eax
  _DWORD *v9; // edi
  int v10; // eax
  _DWORD *v11; // edi
  char *v12; // ebp
  int v13; // eax
  _DWORD *v14; // esi
  int **v15; // esi

  v4 = 0;
  if ( !*Str1 )
    return 0;
  v5 = sub_40AE50(Str1, a2, a4);
  if ( a4 )
  {
    result = sub_40C8D0(Str1, a3, v5);
    if ( !result )
    {
      if ( mbsnbcmp((const unsigned __int8 *)Str1, Source, 2u)
        && mbsnbcmp((const unsigned __int8 *)Str1, &byte_414BE8, 2u) )
      {
        v7 = (char *)sub_40ACC0(strlen(Str1) + 3);
        strcpy(v7, ".\\");
        strcat(v7, Str1);
        v4 = 1;
      }
      else
      {
        v7 = Str1 + 2;
      }
      v8 = sub_40AE50(v7, a2, a4);
      v9 = sub_40C8D0(v7, a3, v8);
      if ( v9 )
      {
        if ( v4 )
          free(v7);
        return v9;
      }
      else
      {
        if ( Str1 - v7 != -2 )
          v7[1] = 47;
        v10 = sub_40AE50(v7, a2, a4);
        v11 = sub_40C8D0(v7, a3, v10);
        if ( v4 )
          free(v7);
        if ( v11 )
        {
          return v11;
        }
        else
        {
          if ( *Str1 == 34 )
          {
            v12 = sub_40CA30(Str1);
          }
          else
          {
            v12 = (char *)sub_40ACF0(strlen(Str1) + 3);
            *(_WORD *)v12 = word_414BE4;
            strcat(v12, Str1);
            strcat(v12, (const char *)&word_414BE4);
          }
          v13 = sub_40AE50(v12, a2, a4);
          v14 = sub_40C8D0(v12, a3, v13);
          free(v12);
          return v14;
        }
      }
    }
    return result;
  }
  v15 = *(int ***)(a3 + 4 * v5);
  if ( !v15 )
    return 0;
  while ( mbscmp((const unsigned __int8 *)v15[1], (const unsigned __int8 *)Str1) )
  {
    v15 = (int **)*v15;
    if ( !v15 )
      return 0;
  }
  return ((_BYTE)v15[3] & 0x10) == 0 ? (int *)v15 : 0;
}
// 414BE4: using guessed type __int16 word_414BE4;

//----- (0040B110) --------------------------------------------------------
int __stdcall sub_40B110(unsigned __int8 *Ptr, int **a2, int *a3, unsigned __int8 *Str1, int a5, int a6, char a7)
{
  BOOL v7; // edi
  int *v8; // ecx
  unsigned __int8 *i; // ebx
  unsigned __int8 v10; // al
  unsigned __int8 *v11; // eax
  unsigned __int8 *v12; // ebx
  unsigned __int8 *v13; // eax
  signed __int8 v14; // al
  unsigned __int8 v15; // al
  int *v16; // esi
  unsigned int v17; // ebp
  _DWORD *v18; // eax
  int v19; // ecx
  int **v20; // eax
  int v21; // ecx
  int v23; // [esp+10h] [ebp-110h] BYREF
  int v24[2]; // [esp+14h] [ebp-10Ch] BYREF
  unsigned __int8 Str2[260]; // [esp+1Ch] [ebp-104h] BYREF

  v7 = 0;
  if ( a2 )
  {
    if ( a3 )
    {
      v23 = *a3;
    }
    else
    {
      v8 = *a2;
      v23 = (int)v8;
      if ( v8 && *v8 )
      {
        do
          v23 = *(_DWORD *)v23;
        while ( *(_DWORD *)v23 );
      }
    }
  }
  else
  {
    v23 = 0;
  }
  for ( i = Ptr; *i; i = v12 + 1 )
  {
    do
    {
      v10 = *i;
      if ( *i == 36 )
        break;
      if ( v10 == 34 )
        v7 = !v7;
      if ( !v7 && v10 == 94 )
        v7 = *++i == 34;
      i = mbsinc(i);
    }
    while ( *i );
    if ( !*i )
      break;
    if ( !i[1] )
    {
      if ( (a7 & 4) != 0 )
      {
        if ( a3 )
          *a3 = v23;
        return 0;
      }
      sub_403220(dword_413424, 0x3EAu);
    }
    v11 = mbsinc(i);
    v12 = v11;
    if ( !v7 && *v11 == 94 )
    {
      v13 = mbsinc(v11);
      v12 = v13;
      if ( (byte_4149C0[*v13] & 1) == 0 )
      {
        if ( (a7 & 4) != 0 )
        {
          if ( a3 )
            *a3 = v23;
          return 0;
        }
        sub_403220(dword_413424, 0x3E9u, (char)*v13);
      }
    }
    v14 = *v12;
    if ( *v12 == 36 )
    {
      v12 = sub_40B5D0(v12);
    }
    else if ( v14 == 40 )
    {
      v12 = (unsigned __int8 *)sub_40B520((char *)v12 + 1, Str2);
      if ( !mbschr(asc_414BCC, (char)Str2[0]) )
        goto LABEL_36;
    }
    else if ( !mbschr(asc_414BCC, v14) )
    {
      if ( (byte_4149C0[*v12] & 1) == 0 )
      {
        if ( (a7 & 4) != 0 )
        {
          if ( a3 )
            *a3 = v23;
          return 0;
        }
        sub_403220(dword_413424, 0x3EAu);
      }
      v15 = *v12;
      Str2[1] = 0;
      Str2[0] = v15;
LABEL_36:
      if ( a2 )
      {
        v16 = sub_40AD20();
      }
      else
      {
        v24[0] = 0;
        v16 = v24;
        v24[1] = (int)sub_40ADD0(" ");
      }
      v17 = sub_407B70(Str2);
      if ( v17 )
      {
        if ( !Str1 || mbscmp(Str1, Str2) )
        {
          if ( (*(_BYTE *)(v17 + 12) & 1) != 0 )
          {
            if ( (a7 & 4) != 0 )
            {
              if ( a3 )
                *a3 = v23;
              return 0;
            }
            sub_403220(dword_413424, 0x42Eu, Str2);
          }
          else
          {
            v16[1] = *(_DWORD *)(*(_DWORD *)(v17 + 8) + 4);
          }
        }
        else
        {
          v18 = *(_DWORD **)(v17 + 8);
          v19 = a5;
          if ( a6 == a5 )
          {
LABEL_45:
            if ( !v18 )
              goto LABEL_47;
            v16[1] = v18[1];
          }
          else
          {
            while ( v18 )
            {
              v18 = (_DWORD *)*v18;
              if ( a6 == --v19 )
                goto LABEL_45;
            }
LABEL_47:
            v16[1] = (int)sub_40ADD0(byte_413060);
          }
        }
      }
      if ( a2 )
      {
        if ( !v17 || (*(_BYTE *)(v17 + 12) & 0x10) != 0 )
          v16[1] = (int)sub_40ADD0(byte_413060);
        *v16 = 0;
        if ( v23 )
          v20 = (int **)v23;
        else
          v20 = a2;
        *v20 = v16;
        v23 = (int)v16;
      }
      if ( v17 && mbschr((const unsigned __int8 *)v16[1], 0x24u) )
      {
        *(_BYTE *)(v17 + 12) |= 1u;
        if ( Str1 && mbscmp(Str1, Str2) )
          v21 = a5;
        else
          v21 = a6;
        sub_40B110((unsigned __int8 *)v16[1], (int)a2, (int)&v23, Str2, a5 + 1, v21, a7);
        *(_BYTE *)(v17 + 12) &= ~1u;
      }
    }
  }
  if ( a3 )
    *a3 = v23;
  return 1;
}

//----- (0040B520) --------------------------------------------------------
char *__stdcall sub_40B520(char *a1, _BYTE *a2)
{
  char *v2; // esi
  _BYTE *i; // edi
  char v4; // al
  unsigned __int8 v5; // al
  char v6; // al

  v2 = a1;
  for ( i = a2; *v2; *i++ = v6 )
  {
    v4 = *v2;
    if ( *v2 == 41 || v4 == 58 )
      break;
    if ( v4 == 94 )
    {
      v5 = *++v2;
      if ( (byte_4149C0[v5] & 1) == 0 )
        sub_403220(dword_413424, 0x3E9u, (char)v5);
    }
    v6 = *v2++;
  }
  if ( *v2 != 41 )
  {
    do
    {
      if ( *v2 == 94 )
        ++v2;
      if ( !*v2 )
        break;
      ++v2;
    }
    while ( *v2 != 41 );
    if ( *v2 != 41 )
      sub_403220(dword_413424, 0x3E8u);
  }
  *i = 0;
  if ( i - a2 > 257 )
    sub_403220(dword_413424, 0x434u);
  return v2;
}

//----- (0040B5D0) --------------------------------------------------------
_BYTE *__stdcall sub_40B5D0(_BYTE *a1)
{
  _BYTE *result; // eax
  char v2; // dl
  char v3; // cl
  char v4; // al
  char v5; // al

  result = a1 + 1;
  v2 = a1[1];
  if ( v2 != 94 )
  {
    if ( v2 == 40 )
    {
      v3 = a1[2];
      if ( v3 == 94 )
        return a1 + 2;
      if ( v3 != 64 )
        return a1 + 2;
      v4 = a1[3];
      if ( v4 == 94 )
      {
        sub_403220(dword_413424, 0x3E9u, (char)a1[4]);
      }
      else
      {
        if ( v4 == 41 )
          return a1 + 3;
        if ( mbschr(aDfbr_0, v4) )
        {
          v5 = a1[4];
          if ( v5 == 94 )
          {
            sub_403220(dword_413424, 0x3E9u, (char)a1[5]);
            return a1;
          }
          if ( v5 == 41 )
            return a1 + 4;
        }
      }
    }
    return a1;
  }
  return result;
}
// 40B67A: conditional instruction was optimized away because dl.1==28

//----- (0040B690) --------------------------------------------------------
char *__stdcall sub_40B690(unsigned __int8 *Str)
{
  char *v1; // esi
  _DWORD *v2; // edi
  int i; // [esp+8h] [ebp-4h] BYREF

  i = 0;
  v1 = (char *)Str;
  if ( mbschr(Str, 0x24u) )
  {
    sub_40B110(Str, (int **)&i, 0, 0, 0, 0, 0);
    v2 = (_DWORD *)i;
    v1 = sub_40B700((char *)Str, (int)&i);
    for ( i = (int)v2; v2; i = (int)v2 )
    {
      v2 = (_DWORD *)*v2;
      sub_40ADA0((_DWORD *)i);
    }
  }
  return v1;
}

//----- (0040B700) --------------------------------------------------------
char *__stdcall sub_40B700(char *a1, int a2)
{
  BOOL v2; // ebx
  int v3; // ebp
  int v4; // esi
  _BYTE *v5; // edi
  _BYTE *v6; // eax
  char *v7; // edi
  char v8; // al
  char v9; // al
  _BYTE *v10; // edi
  bool v11; // zf
  _DWORD *v12; // eax
  unsigned __int8 *v13; // edi
  char *v14; // ebx
  char *v16; // [esp+10h] [ebp-410h] BYREF
  void **v17; // [esp+14h] [ebp-40Ch] BYREF
  char *v18; // [esp+18h] [ebp-408h] BYREF
  size_t v19; // [esp+1Ch] [ebp-404h] BYREF
  char v20[1024]; // [esp+20h] [ebp-400h] BYREF
  void *retaddr; // [esp+420h] [ebp+0h] BYREF

  v19 = 1024;
  v2 = 0;
  v3 = 0;
  v18 = v20;
  v17 = &retaddr;
  v16 = v20;
  if ( *a1 )
  {
    v4 = a2;
    do
    {
      for ( ; *a1; *v16++ = *a1++ )
      {
        if ( *a1 == 36 )
          break;
        if ( v17 == (void **)v16 )
          sub_40BB00((const void **)&v18, &v16, &v17, &v19, v20);
        if ( *a1 == 34 )
          v2 = !v2;
        if ( !v2 && *a1 == 94 )
        {
          *v16++ = 94;
          v2 = *++a1 == 34;
        }
      }
      if ( v17 == (void **)v16 )
        sub_40BB00((const void **)&v18, &v16, &v17, &v19, v20);
      if ( !*a1 )
        break;
      v5 = a1 + 1;
      if ( a1[1] == 40 && mbschr(asc_414BCC, a1[2]) )
      {
        sub_40BB90((const void **)&v18, (const unsigned __int8 **)&a1, &v16, &v17, &v19, 3, v20);
      }
      else
      {
        v6 = v5;
        v7 = v5 + 1;
        if ( *v6 != 36 )
        {
          if ( mbschr(asc_414BCC, a1[1]) )
          {
            sub_40BB90((const void **)&v18, (const unsigned __int8 **)&a1, &v16, &v17, &v19, 1, v20);
          }
          else
          {
            if ( !*(_DWORD *)v4 )
              sub_403220(dword_413424, 0x410u);
            v11 = mbschr(*(const unsigned __int8 **)(*(_DWORD *)v4 + 4), 0x24u) == 0;
            v12 = *(_DWORD **)v4;
            if ( v11 )
            {
              v13 = (unsigned __int8 *)v12[1];
              *(_DWORD *)v4 = *v12;
            }
            else
            {
              v3 = 1;
              *(_DWORD *)v4 = *v12;
              v13 = (unsigned __int8 *)sub_40B700(v12[1], v4);
            }
            sub_40C060((const void **)&v18, (const unsigned __int8 **)&a1, &v16, &v17, v13, &v19, v20);
            if ( v3 )
            {
              v3 = 0;
              free(v13);
            }
          }
          continue;
        }
        v8 = *v7;
        if ( *v7 != 94 )
        {
          if ( v8 == 64 )
          {
            sub_40BB90((const void **)&v18, (const unsigned __int8 **)&a1, &v16, &v17, &v19, 2, v20);
            continue;
          }
          if ( v8 == 40 )
            ++v7;
          v9 = v7[1];
          v10 = v7 + 1;
          if ( (v9 == 70 || v9 == 68 || v9 == 66 || v9 == 82) && v10[1] == 41 )
          {
            sub_40BB90((const void **)&v18, (const unsigned __int8 **)&a1, &v16, &v17, &v19, 4, v20);
            continue;
          }
        }
        sub_40BB90((const void **)&v18, (const unsigned __int8 **)&a1, &v16, &v17, &v19, 5, v20);
      }
    }
    while ( *a1 );
  }
  if ( v17 == (void **)v16 )
    sub_40BB00((const void **)&v18, &v16, &v17, &v19, v20);
  *v16++ = 0;
  v14 = (char *)sub_40ACC0(v16 - v18);
  if ( !v14 )
    sub_403220(dword_413424, 0x419u);
  qmemcpy(v14, v18, v16 - v18);
  return v14;
}

//----- (0040BB00) --------------------------------------------------------
_DWORD *__stdcall sub_40BB00(const void **a1, _DWORD *a2, _DWORD *a3, size_t *a4, const void *a5)
{
  void *v5; // eax
  size_t v6; // esi
  void *v7; // eax
  _DWORD *result; // eax

  if ( *a1 == a5 )
  {
    v5 = sub_40ACC0(*a4);
    qmemcpy(v5, *a1, *a4);
    *a1 = v5;
  }
  v6 = *a4 + 1024;
  v7 = realloc((void *)*a1, v6);
  *a1 = v7;
  if ( !v7 )
    sub_403220(dword_413424, 0x419u);
  *a2 = (char *)*a1 + *a4;
  result = a3;
  *a4 = v6;
  *a3 = (char *)*a1 + v6;
  return result;
}

//----- (0040BB90) --------------------------------------------------------
void __stdcall sub_40BB90(
        const void **a1,
        const unsigned __int8 **a2,
        _DWORD *a3,
        _DWORD *a4,
        size_t *a5,
        int a6,
        const void *a7)
{
  int v7; // esi
  int v8; // edi
  const unsigned __int8 **v9; // ebp
  const unsigned __int8 *v10; // ecx
  unsigned __int8 *i; // esi
  unsigned __int8 v12; // bl
  void *v13; // esi
  const unsigned __int8 *v14; // ebx
  char v15; // al
  unsigned __int8 *v16; // eax
  void *Block; // [esp+10h] [ebp-118h] BYREF
  void *v18; // [esp+14h] [ebp-114h] BYREF
  char *v19; // [esp+18h] [ebp-110h] BYREF
  int v20; // [esp+1Ch] [ebp-10Ch]
  size_t v21; // [esp+20h] [ebp-108h] BYREF
  unsigned __int8 Str[257]; // [esp+24h] [ebp-104h] BYREF
  char v23; // [esp+125h] [ebp-3h] BYREF

  v7 = 0;
  v8 = 1;
  Block = 0;
  v20 = 0;
  v21 = 0;
  switch ( a6 )
  {
    case 1:
      goto LABEL_3;
    case 2:
      goto LABEL_5;
    case 3:
      v20 = 1;
      v8 = 2;
LABEL_3:
      v9 = a2;
      v10 = &(*a2)[v8];
      switch ( *v10 )
      {
        case '*':
          if ( v10[1] == 42 )
          {
            v7 = 1;
            Block = (void *)dword_413A98;
            v8 += 2;
          }
          else
          {
            ++v8;
            v21 = 1;
            Block = (void *)dword_413A8C;
          }
          break;
        case '<':
          ++v8;
          Block = (void *)dword_413A88;
          break;
        case '?':
          v7 = 1;
          ++v8;
          Block = (void *)dword_413A94;
          break;
        case '@':
          Block = dword_413A90;
          goto LABEL_37;
        default:
LABEL_37:
          ++v8;
          break;
      }
      goto LABEL_6;
    case 4:
      v20 = 1;
      v8 = 4;
LABEL_5:
      v9 = a2;
      Block = (void *)dword_413A84;
LABEL_6:
      if ( !Block )
      {
        for ( i = (unsigned __int8 *)*v9; *i; ++i )
        {
          if ( *i == 32 )
            break;
          if ( *i == 9 )
            break;
        }
        v12 = *i;
        *i = 0;
        sub_403220(dword_413424, 0xFA6u, *v9);
        *i = v12;
        v7 = 0;
        Block = sub_40ADD0(byte_413060);
      }
      if ( v7 )
      {
        v13 = Block;
        v21 = 1024;
        v19 = (char *)sub_40ACF0(0x400u);
        v18 = v19 + 1024;
        for ( Block = v19; v13; v13 = *(void **)v13 )
        {
          v14 = (const unsigned __int8 *)*((_DWORD *)v13 + 1);
          if ( v20 )
            v14 = sub_40BF30((*v9)[v8], Str, *((const char **)v13 + 1));
          for ( ; *v14; Block = (char *)Block + 1 )
          {
            if ( Block == v18 )
              sub_40BB00((const void **)&v19, &Block, &v18, &v21, 0);
            v15 = *v14++;
            *(_BYTE *)Block = v15;
          }
          if ( Block == v18 )
            sub_40BB00((const void **)&v19, &Block, &v18, &v21, 0);
          *(_BYTE *)Block = 0;
          if ( *(_DWORD *)v13 )
          {
            *(_BYTE *)Block = 32;
            Block = (char *)Block + 1;
            if ( Block == v18 )
              sub_40BB00((const void **)&v19, &Block, &v18, &v21, 0);
            *(_BYTE *)Block = 0;
          }
        }
        v16 = (unsigned __int8 *)v19;
        goto LABEL_42;
      }
      if ( v21 )
        Block = (void *)sub_40BF30(82, Str, (const char *)Block);
      if ( v20 )
      {
        v16 = (unsigned __int8 *)sub_40BF30((*v9)[v8], Str, (const char *)Block);
LABEL_42:
        Block = v16;
      }
      sub_40C060(a1, v9, a3, a4, (unsigned __int8 *)Block, a5, a7);
      if ( Block != dword_413A90
        && (void *)dword_413A84 != Block
        && (void *)dword_413A88 != Block
        && (Block < Str || Block >= &v23) )
      {
        free(Block);
      }
      return;
    case 5:
      if ( *a4 == *a3 )
        sub_40BB00(a1, a3, a4, a5, a7);
      *(_BYTE *)(*a3)++ = 36;
      *a2 += 2;
      return;
    default:
      return;
  }
}
// 413A84: using guessed type int dword_413A84;
// 413A88: using guessed type int dword_413A88;
// 413A8C: using guessed type int dword_413A8C;
// 413A94: using guessed type int dword_413A94;
// 413A98: using guessed type int dword_413A98;

//----- (0040BF30) --------------------------------------------------------
const unsigned __int8 *__stdcall sub_40BF30(char a1, unsigned __int8 *Str, const char *a3)
{
  unsigned __int8 *v3; // edx
  unsigned __int8 *v4; // ebp
  const unsigned __int8 *v5; // ebx
  BOOL v6; // esi
  unsigned __int8 *v7; // ecx
  unsigned __int8 v8; // al
  unsigned __int8 *v9; // eax

  v3 = 0;
  v4 = 0;
  v5 = (const unsigned __int8 *)strcpy((char *)Str, a3);
  v6 = *Str == 34;
  v7 = &Str[strlen((const char *)Str) - 1];
  if ( v7 >= Str )
  {
    while ( 1 )
    {
      v8 = *v7;
      if ( *v7 == 92 || v8 == 47 )
        break;
      if ( v8 == 46 && !v4 )
        v4 = v7;
      if ( --v7 < Str )
        goto LABEL_10;
    }
    v3 = v7;
  }
LABEL_10:
  switch ( a1 )
  {
    case 'B':
      if ( v4 )
        *v4 = 0;
      goto LABEL_13;
    case 'D':
      if ( v3 )
      {
        if ( Str[1] == 58 && Str - v3 == -2 )
          ++v3;
        *v3 = 0;
      }
      else if ( Str[1] == 58 )
      {
        Str[2] = 0;
      }
      else
      {
        *(_WORD *)Str = word_413FE0;
      }
      break;
    case 'F':
LABEL_13:
      if ( v3 )
      {
        v5 = v3 + 1;
      }
      else if ( Str[1] == 58 )
      {
        v5 = Str + 2;
      }
      break;
    case 'R':
      if ( v4 )
        *v4 = 0;
      break;
    default:
      break;
  }
  if ( v6 )
  {
    v9 = mbschr(v5, 0);
    *v9 = 34;
    v9[1] = 0;
  }
  return v5;
}
// 413FE0: using guessed type __int16 word_413FE0;

//----- (0040C060) --------------------------------------------------------
void __stdcall sub_40C060(
        const void **a1,
        const unsigned __int8 **a2,
        _DWORD *a3,
        _DWORD *a4,
        unsigned __int8 *a5,
        size_t *a6,
        const void *a7)
{
  const unsigned __int8 *v7; // eax
  const unsigned __int8 *v8; // eax
  unsigned __int8 v9; // dl
  unsigned __int8 *i; // ebx
  char v11; // al
  unsigned __int8 v12; // cl
  const unsigned __int8 *v13; // eax
  const unsigned __int8 *v14; // eax
  unsigned __int8 *v15; // [esp+10h] [ebp-4h] BYREF

  v7 = *a2 + 1;
  *a2 = v7;
  if ( *v7 == 94 )
    *a2 = v7 + 1;
  v15 = mbschr(*a2, 0x3Au);
  v8 = *a2;
  v9 = **a2;
  if ( v9 )
  {
    do
    {
      if ( *v8 == 41 )
        break;
      if ( *v8 == 94 )
        ++v8;
      ++v8;
    }
    while ( *v8 );
  }
  if ( v9 == 40 && v15 && v15 < v8 )
  {
    sub_40C170(a1, &v15, a3, a4, a5, a6, a7);
    *a2 = v15;
  }
  else
  {
    for ( i = a5; *i; ++*a3 )
    {
      if ( *a4 == *a3 )
        sub_40BB00(a1, a3, a4, a6, a7);
      v11 = *i++;
      *(_BYTE *)*a3 = v11;
    }
    if ( **a2 == 36 )
      ++*a2;
    v12 = **a2;
    if ( v12 == 40 )
    {
      do
      {
        v14 = *a2 + 1;
        *a2 = v14;
      }
      while ( *v14 != 41 );
    }
    else if ( v12 == 42 )
    {
      v13 = *a2 + 1;
      if ( *v13 == 42 )
        *a2 = v13;
    }
    ++*a2;
  }
}

//----- (0040C170) --------------------------------------------------------
void __stdcall sub_40C170(
        const void **a1,
        _DWORD *a2,
        _DWORD *a3,
        _DWORD *a4,
        unsigned __int8 *Str1,
        size_t *a6,
        const void *a7)
{
  _BYTE *v7; // esi
  _BYTE *i; // ebx
  unsigned __int8 *v9; // ecx
  unsigned __int8 *j; // ebp
  unsigned __int8 v11; // al
  char *v12; // ebp
  char *v13; // eax
  char v14; // cl
  const unsigned __int8 *v15; // ebp
  char *k; // ebx
  char v17; // al
  char v18; // al
  unsigned __int8 *Str2; // [esp+10h] [ebp-Ch]
  char *Block; // [esp+14h] [ebp-8h]
  unsigned int MaxCount; // [esp+18h] [ebp-4h]

  v7 = (_BYTE *)(*a2 + 1);
  for ( *a2 = v7; *v7; ++v7 )
  {
    if ( *v7 == 61 )
      break;
    if ( *v7 == 94 )
      ++v7;
  }
  if ( *v7 != 61 )
    sub_403220(dword_4133F4, 0x3EBu);
  if ( (_BYTE *)*a2 == v7 )
    sub_403220(dword_4133F4, 0x3EDu);
  for ( i = v7; *i; ++i )
  {
    if ( *i == 41 )
      break;
    if ( *i == 94 )
      ++i;
  }
  if ( *i != 41 )
    sub_403220(dword_4133F4, 0x3E8u);
  v9 = (unsigned __int8 *)sub_40ACF0((size_t)&v7[-*a2 + 1]);
  Str2 = v9;
  for ( j = (unsigned __int8 *)*a2; *j != 61; ++v9 )
  {
    if ( *j == 94 )
      ++j;
    v11 = *j++;
    *v9 = v11;
  }
  *v9 = 0;
  v12 = (char *)(j + 1);
  MaxCount = strlen((const char *)Str2);
  v13 = (char *)sub_40ACF0(i - v7);
  for ( Block = v13; *v12 != 41; ++v13 )
  {
    if ( *v12 == 94 )
      ++v12;
    v14 = *v12++;
    *v13 = v14;
  }
  *v13 = 0;
  v15 = Str1;
  *a2 = i + 1;
  while ( *v15 )
  {
    if ( *Str2 != *v15 || mbsnbcmp(v15, Str2, MaxCount) )
    {
      if ( *a4 == *a3 )
        sub_40BB00(a1, a3, a4, a6, a7);
      v18 = *v15++;
      *(_BYTE *)(*a3)++ = v18;
    }
    else
    {
      for ( k = Block; *k; ++*a3 )
      {
        if ( *a4 == *a3 )
          sub_40BB00(a1, a3, a4, a6, a7);
        v17 = *k++;
        *(_BYTE *)*a3 = v17;
      }
      v15 += MaxCount;
    }
  }
  free(Str2);
  free(Block);
}

//----- (0040C340) --------------------------------------------------------
char *__stdcall sub_40C340(char *FullPath, char *Filename)
{
  char Drive[4]; // [esp+0h] [ebp-208h] BYREF
  char Dir[256]; // [esp+4h] [ebp-204h] BYREF
  char Buffer[260]; // [esp+104h] [ebp-104h] BYREF

  splitpath(FullPath, Drive, Dir, 0, 0);
  makepath(Buffer, Drive, Dir, Filename, 0);
  return sub_40ADD0(Buffer);
}
// 40C340: using guessed type char Drive[4];

//----- (0040C3A0) --------------------------------------------------------
int __stdcall sub_40C3A0(_BYTE *a1)
{
  _BYTE *v1; // edx
  int v2; // esi
  _BYTE *v3; // edi
  _BYTE *i; // eax
  _BYTE *v5; // edi
  _BYTE *v6; // edi
  const unsigned __int8 *v7; // edi
  unsigned __int8 *v9; // eax
  const unsigned __int8 *v10; // edi

  v1 = a1;
  v2 = 0;
  if ( *a1 == 123 )
  {
    v1 = a1 + 1;
    if ( a1[1] )
    {
      do
      {
        if ( *v1 == 125 )
          break;
        if ( *v1 == 94 )
          ++v1;
        ++v1;
      }
      while ( *v1 );
      if ( *v1 )
        ++v1;
    }
  }
  if ( *v1 != 46 )
    return v2;
  v3 = v1;
  do
  {
    if ( *v3 == 123 )
      break;
    if ( *v3 == 94 )
      ++v3;
    ++v3;
  }
  while ( *v3 );
  for ( i = v1; v3 > v1; ++v1 )
  {
    if ( *v1 == 92 )
      break;
    if ( *v1 == 47 )
      break;
  }
  if ( !*v3 || v3 != v1 )
  {
    v9 = mbspbrk(i + 1, &byte_414BF0);
    if ( v9 )
    {
      if ( *v9 == 46 )
      {
        v10 = v9 + 1;
        if ( !mbschr(v9 + 1, 0x2Fu) && !mbschr(v10, 0x5Cu) )
        {
          if ( mbschr(v10, 0x2Eu) )
            goto LABEL_31;
          return 1;
        }
      }
    }
    return v2;
  }
  v5 = v3 + 1;
  if ( !*v5 )
    return v2;
  do
  {
    if ( *v5 == 125 )
      break;
    if ( *v5 == 94 )
      ++v5;
    ++v5;
  }
  while ( *v5 );
  if ( !*v5 )
    return v2;
  v6 = v5 + 1;
  if ( *v6 != 46 )
    return v2;
  v7 = v6 + 1;
  if ( mbschr(v7, 0x2Fu) || mbschr(v7, 0x5Cu) )
    return v2;
  if ( mbschr(v7, 0x2Eu) )
  {
LABEL_31:
    sub_403220(dword_413424, 0x444u);
    return 0;
  }
  return 1;
}

//----- (0040C510) --------------------------------------------------------
int __stdcall sub_40C510(char *a1, int a2, char *a3, char *FullPath)
{
  char *v4; // ebx
  char *v5; // esi
  char *v6; // ebp
  char v7; // al
  int v8; // eax
  char *v9; // ebx
  char *i; // ecx
  char v11; // al
  char *v12; // ecx
  int v13; // edi
  int v14; // edx
  int v15; // eax
  char v16; // al
  char *j; // ecx
  char v18; // al
  int result; // eax
  int v20; // [esp+10h] [ebp-10Ch]
  int v21; // [esp+14h] [ebp-108h]
  char Ext[4]; // [esp+18h] [ebp-104h] BYREF
  char Drive[256]; // [esp+1Ch] [ebp-100h] BYREF

  v4 = a1;
  v5 = a3;
  v6 = &a1[a2];
  v7 = *a3;
  if ( *a3 )
  {
    while ( v6 > v4 )
    {
      if ( v7 == 37 )
      {
        v8 = *++v5;
        switch ( v8 )
        {
          case '%':
            *v4++ = 37;
            break;
          case 's':
            for ( i = FullPath; *i; *v4++ = v11 )
            {
              if ( v6 <= v4 )
                break;
              v11 = *i++;
            }
            break;
          case '|':
            v12 = v5 - 1;
            v13 = 0;
            v20 = 0;
            v21 = 0;
            *(_DWORD *)Ext = 0;
            v14 = 0;
            Drive[0] = 0;
            while ( 1 )
            {
              v15 = *++v5;
              switch ( v15 )
              {
                case 'F':
                  if ( *(v5 - 1) == 124 )
                  {
                    v13 = 1;
                    *(_DWORD *)Ext = 1;
                    v21 = 1;
                    v20 = 1;
                  }
                  break;
                case 'd':
                  v13 = 1;
                  break;
                case 'e':
                  v20 = 1;
                  break;
                case 'f':
                  v21 = 1;
                  break;
                case 'p':
                  *(_DWORD *)Ext = 1;
                  break;
                default:
                  v14 = 1;
                  break;
              }
              if ( v14 )
                break;
              if ( *v5 == 70 )
              {
                if ( !FullPath )
                  sub_403220(0, 0x449u);
                if ( v13 )
                  sub_40C7D0(FullPath, Drive);
                if ( *(_DWORD *)Ext )
                  sub_40C890(FullPath, &Ext[strlen(Drive) + 4]);
                if ( v21 )
                  sub_40C850(FullPath, &Ext[strlen(Drive) + 4]);
                if ( v20 )
                  sub_40C810(FullPath, &Ext[strlen(Drive) + 4]);
                for ( j = Drive; *j; *v4++ = v18 )
                {
                  if ( v6 <= v4 )
                    break;
                  v18 = *j++;
                }
                goto LABEL_44;
              }
            }
            for ( ; v12 <= v5; *v4++ = v16 )
            {
              if ( v6 <= v4 )
                break;
              v16 = *v12++;
            }
            break;
          default:
            *v4 = 37;
            v9 = v4 + 1;
            if ( v6 == v9 )
              return 1;
            *v9 = *v5;
            v4 = v9 + 1;
            break;
        }
      }
      else
      {
        *v4++ = v7;
      }
LABEL_44:
      v7 = *++v5;
      if ( !v7 )
        goto LABEL_45;
    }
  }
  else
  {
LABEL_45:
    if ( v6 > v4 )
    {
      result = 0;
      *v4 = 0;
      return result;
    }
  }
  return 1;
}
// 40C638: conditional instruction was optimized away because edx.4==0

//----- (0040C790) --------------------------------------------------------
int __stdcall sub_40C790(char *a1, char *ArgList, char *a3)
{
  int result; // eax

  result = sub_40C510(a1, 2048, ArgList, a3);
  if ( result )
    return sub_403220(0, 0x447u, ArgList);
  return result;
}
// 40C790: using guessed type char *ArgList;

//----- (0040C7D0) --------------------------------------------------------
BOOL __stdcall sub_40C7D0(char *FullPath, char *Drive)
{
  splitpath(FullPath, Drive, 0, 0, 0);
  return strlen(Drive) != 0;
}

//----- (0040C810) --------------------------------------------------------
BOOL __stdcall sub_40C810(char *FullPath, char *Ext)
{
  splitpath(FullPath, 0, 0, 0, Ext);
  return strlen(Ext) != 0;
}

//----- (0040C850) --------------------------------------------------------
BOOL __stdcall sub_40C850(char *FullPath, char *Filename)
{
  splitpath(FullPath, 0, 0, Filename, 0);
  return strlen(Filename) != 0;
}

//----- (0040C890) --------------------------------------------------------
BOOL __stdcall sub_40C890(char *FullPath, char *Dir)
{
  splitpath(FullPath, 0, Dir, 0, 0);
  return strlen(Dir) != 0;
}

//----- (0040C8D0) --------------------------------------------------------
_DWORD *__stdcall sub_40C8D0(char *a1, int a2, int a3)
{
  char *v3; // esi
  char *v4; // edi
  char v5; // al
  char v6; // bl
  unsigned int v8; // [esp+10h] [ebp-8h]
  _DWORD *v9; // [esp+14h] [ebp-4h]

  v9 = *(_DWORD **)(a2 + 4 * a3);
  if ( !v9 )
    return 0;
  while ( 1 )
  {
    v3 = a1;
    v4 = (char *)v9[1];
    if ( !*a1 )
      goto LABEL_18;
    do
    {
      v5 = *v4;
      if ( !*v4 )
        break;
      v6 = *v3;
      if ( *v3 == 92 || v6 == 47 )
      {
        if ( v5 != 92 && v5 != 47 )
          break;
      }
      else
      {
        v8 = mbctoupper(v5);
        if ( v8 != mbctoupper(v6) )
          break;
      }
      ++v3;
      ++v4;
    }
    while ( *v3 );
    if ( !*v3 )
    {
LABEL_18:
      if ( !*v4 )
        return v9;
    }
    v9 = (_DWORD *)*v9;
    if ( !v9 )
      return 0;
  }
}

//----- (0040C980) --------------------------------------------------------
int __stdcall sub_40C980(const char *a1, const char *a2)
{
  unsigned __int8 *v2; // ebx
  void *v3; // esp
  const char *v4; // esi
  void *v5; // esp
  unsigned __int8 *i; // ecx
  unsigned __int8 v7; // al
  _BYTE *j; // ecx
  char v9; // al
  unsigned __int8 *v11; // [esp-8h] [ebp-18h]
  const unsigned __int8 *v12; // [esp-4h] [ebp-14h]
  _BYTE v13[12]; // [esp+0h] [ebp-10h] BYREF
  unsigned __int8 *Str1; // [esp+Ch] [ebp-4h]

  v2 = (unsigned __int8 *)a1;
  v3 = alloca(strlen(a1) + 1);
  Str1 = v13;
  v4 = a2;
  v5 = alloca(strlen(a2) + 1);
  if ( *a1 == 34 )
    v2 = (unsigned __int8 *)(a1 + 1);
  for ( i = Str1; *v2; ++i )
  {
    v7 = *v2++;
    *i = v7;
  }
  if ( *(i - 1) == 34 )
    --i;
  *i = 0;
  if ( *a2 == 34 )
    v4 = a2 + 1;
  for ( j = v13; *v4; ++j )
  {
    v9 = *v4++;
    *j = v9;
  }
  if ( *(j - 1) == 34 )
    --j;
  v12 = v13;
  v11 = Str1;
  *j = 0;
  return mbsicmp(v11, v12);
}

//----- (0040CA30) --------------------------------------------------------
_BYTE *__stdcall sub_40CA30(const char *a1)
{
  const char *v1; // esi
  _BYTE *result; // eax
  _BYTE *i; // ecx
  char v4; // dl

  v1 = a1;
  result = sub_40ACC0(strlen(a1) + 1);
  if ( *a1 == 34 )
    v1 = a1 + 1;
  for ( i = result; *v1; ++i )
  {
    v4 = *v1++;
    *i = v4;
  }
  if ( *(i - 1) == 34 )
    --i;
  *i = 0;
  return result;
}

//----- (0040CA80) --------------------------------------------------------
FILE *__stdcall sub_40CA80(unsigned __int8 *String, char *Mode)
{
  if ( *String == 34 )
  {
    *mbsrchr(String, 0x22u) = 0;
    strcpy((char *)String, (const char *)String + 1);
  }
  return fsopen((const char *)String, Mode, 32);
}

//----- (0040CAE0) --------------------------------------------------------
void __stdcall sub_40CAE0(_BYTE *a1, unsigned int a2)
{
  _BYTE *v2; // ebx
  int v3; // eax

  v2 = a1;
  if ( *a1 )
  {
    while ( 1 )
    {
      v3 = 2 - ((_p__mbctype()[(unsigned __int8)*v2 + 1] & 4) == 0);
      if ( v3 + v2 - a1 > a2 )
        break;
      v2 += v3;
      if ( !*v2 )
        return;
    }
    *v2 = 0;
  }
}

//----- (0040CB30) --------------------------------------------------------
_DWORD *__stdcall sub_40CB30(char *FullPath)
{
  void *v1; // esp
  char *v2; // edi
  char *v4; // eax
  char *v5; // ebx
  _DWORD *v6; // edi
  int v7; // [esp+0h] [ebp-18h] BYREF
  intptr_t FindHandle; // [esp+Ch] [ebp-Ch] BYREF
  _DWORD *v9; // [esp+10h] [ebp-8h] BYREF
  int v10; // [esp+14h] [ebp-4h] BYREF

  v1 = alloca(dword_413EE0);
  v10 = (int)&v7;
  v2 = (char *)sub_40CD20((unsigned __int8 *)FullPath, &v10, &FindHandle);
  if ( !v2 )
    return 0;
  v9 = sub_40AD20();
  v4 = sub_40C340(FullPath, v2);
  v9[1] = v4;
  while ( 1 )
  {
    sub_404C90(&v10);
    v5 = (char *)sub_40CE00(&v10, FindHandle);
    if ( !v5 )
      break;
    v6 = sub_40AD20();
    v6[1] = sub_40C340(FullPath, v5);
    sub_40AE10(&v9, v6);
  }
  return v9;
}
// 413EE0: using guessed type int dword_413EE0;

//----- (0040CBD0) --------------------------------------------------------
int __stdcall sub_40CBD0(int Drive)
{
  return chdrive(Drive);
}

//----- (0040CBF0) --------------------------------------------------------
int __stdcall sub_40CBF0(const char *a1, _DWORD *a2)
{
  _BYTE *v2; // edx
  unsigned int v3; // kr04_4
  intptr_t v4; // eax

  v2 = a1;
  v3 = strlen(a1) + 1;
  if ( *a1 == 34 && a1[v3 - 2] == 34 )
    v2 = sub_40CA30(a1);
  v4 = findfirst(v2, *a2);
  if ( v4 == -1 )
    return 0;
  findclose(v4);
  return sub_404C90(a2);
}
// 4152E8: using guessed type int __cdecl findfirst(_DWORD, _DWORD);

//----- (0040CC50) --------------------------------------------------------
void __stdcall sub_40CC50(char *FullPath)
{
  int v1; // esi
  char Drive[4]; // [esp+Ch] [ebp-304h] BYREF
  char Filename[256]; // [esp+10h] [ebp-300h] BYREF
  char Ext[256]; // [esp+110h] [ebp-200h] BYREF
  char Dir[256]; // [esp+210h] [ebp-100h] BYREF

  v1 = 0;
  splitpath(FullPath, Drive, Dir, Filename, Ext);
  if ( strlen(Filename) > dword_413ED8 )
  {
    v1 = 1;
    sub_40CAE0(Filename, dword_413ED8);
  }
  if ( strlen(Ext) > dword_413ED4 )
  {
    v1 = 1;
    sub_40CAE0(Ext, dword_413ED4);
  }
  if ( v1 )
    makepath(FullPath, Drive, Dir, Filename, Ext);
}
// 413ED4: using guessed type int dword_413ED4;
// 413ED8: using guessed type int dword_413ED8;
// 40CC50: using guessed type char Drive[4];

//----- (0040CD20) --------------------------------------------------------
int __stdcall sub_40CD20(unsigned __int8 *String, _DWORD *a2, intptr_t *a3)
{
  char *v3; // esi
  unsigned __int8 *v4; // eax
  BOOL v5; // ebx
  unsigned int v6; // kr04_4
  char *i; // eax
  char v8; // cl
  int v9; // eax
  char v11[260]; // [esp+10h] [ebp-104h] BYREF

  v3 = (char *)String;
  v4 = mbspbrk(String, asc_414BF4);
  v5 = v4 != 0;
  if ( v4 )
  {
    v6 = strlen((const char *)String) + 1;
    if ( *String == 34 && String[v6 - 2] == 34 )
      v3 = sub_40CA30((const char *)String);
    for ( i = v11; *v3; ++i )
    {
      if ( *v3 == 94 )
        ++v3;
      v8 = *v3++;
      *i = v8;
    }
    v3 = v11;
    *i = 0;
  }
  sub_40CC50(v3);
  v9 = findfirst(v3, *a2);
  *a3 = v9;
  if ( v9 == -1 )
    return 0;
  if ( !v5 || !mbschr((const unsigned __int8 *)v3, 0x2Au) && !mbschr((const unsigned __int8 *)v3, 0x3Fu) )
    findclose(*a3);
  return *a2 + 20;
}
// 4152E8: using guessed type int __cdecl findfirst(_DWORD, _DWORD);

//----- (0040CE00) --------------------------------------------------------
int __stdcall sub_40CE00(_DWORD *a1, intptr_t FindHandle)
{
  if ( !findnext(FindHandle, *a1) )
    return sub_404C90(a1);
  findclose(FindHandle);
  return 0;
}
// 4152EC: using guessed type int __cdecl findnext(_DWORD, _DWORD);

//----- (0040CE40) --------------------------------------------------------
char *sub_40CE40()
{
  size_t v0; // kr08_4
  char *v1; // edx
  char DstBuf[260]; // [esp+8h] [ebp-104h] BYREF

  v0 = strlen(getcwd(DstBuf, 257)) + 1;
  v1 = (char *)sub_40ACC0(v0);
  strcpy(v1, DstBuf);
  return v1;
}

//----- (0040CEA0) --------------------------------------------------------
__time32_t __stdcall sub_40CEA0(__time32_t *Time)
{
  return time(Time);
}

// nfuncs=195 queued=182 decompiled=182 lumina nreq=0 worse=0 better=0
// ALL OK, 182 function(s) have been successfully decompiled
