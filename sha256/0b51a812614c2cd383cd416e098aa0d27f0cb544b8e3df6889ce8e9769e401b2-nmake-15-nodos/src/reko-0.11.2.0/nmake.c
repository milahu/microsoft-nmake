// tmp3zoxja9l_text.c
// Generated by decompiling tmp3zoxja9l
// using Reko decompiler version 0.11.2.0.

#include "tmp3zoxja9l.h"

// 00401000: void fn00401000(Register Eq_2 ecx, Stack Eq_2 dwArgF4, Stack Eq_2 dwArgF8, Stack Eq_2 dwArgFC)
// Called from:
//      fn00408AE0
void fn00401000(Eq_2 ecx, Eq_2 dwArgF4, Eq_2 dwArgF8, Eq_2 dwArgFC)
{
	word32 ecx_53;
	word32 ebx_54;
	word32 ebp_55;
	word32 esi_56;
	word32 edi_57;
	fn0040B110(ecx, dwArgF4, dwArgF8, dwArgFC, out ecx_53, out ebx_54, out ebp_55, out esi_56, out edi_57);
	word32 ecx_58;
	word32 edx_59;
	g_t413A3C = fn0040ADD0(4274848, out ecx_58, out edx_59);
}

// 00401030: Register word32 fn00401030(Stack Eq_2 dwArgEC, Stack Eq_2 dwArgF0, Stack Eq_2 dwArgF4, Register out (ptr32 (ptr32 byte)) ebpOut)
// Called from:
//      fn00407D90
//      fn00408AE0
word32 fn00401030(Eq_2 dwArgEC, Eq_2 dwArgF0, Eq_2 dwArgF4, byte & ebpOut)
{
	Eq_2 tLoc04;
	byte ** ebp;
	word32 ebx;
	if (g_t413A3C != 0x00)
	{
		g_b413A48 |= 0x20;
		fn00401170();
		g_t413A3C.u0 = 0x00;
	}
	if ((g_b413A48 & 0x20) != 0x00)
	{
		word32 ecx_300;
		if (fn0040C3A0(4274848, out ecx_300) != 0x00)
		{
			if ((g_b413A48 & 0x10) != 0x00)
			{
				word32 ecx_303;
				word32 edx_304;
				fn00403220(g_t413424, 0x0444, out ecx_303, out edx_304);
			}
			word32 edx_302;
			word32 ecx_301;
			fn00403220(g_t413424, 0x043D, out ecx_301, out edx_302);
		}
	}
	Eq_2 ecx_128;
	Eq_2 eax_73 = fn0040AD20(out ecx_128);
	if ((g_b413A48 & 0x40) != 0x00)
	{
		*((word32) eax_73 + 4) = g_t4133FC;
		g_t4133FC.u0 = 0x00;
	}
	else
	{
		word32 edx_305;
		*((word32) eax_73 + 4) = fn0040ADD0(4274848, out ecx_128, out edx_305);
	}
	tLoc04 = eax_73;
	if ((g_b413A48 & 0x10) == 0x00 || (g_b413A48 & 0x20) != 0x00)
	{
		word32 esi_307;
		word32 edi_308;
		word32 ecx_306;
		fn0040B110(ecx_128, dwArgEC, dwArgF0, dwArgF4, out ecx_306, out ebx, out ebp, out esi_307, out edi_308);
		if ((g_b413A48 & 0x20) != 0x00)
		{
			Eq_2 esi_144 = g_t413A28;
			fn004013D0(&tLoc04);
			fn004013D0(&tLoc04);
			g_t413A28 = esi_144;
			while (esi_144 != 0x00)
			{
				esi_144 = *esi_144;
				fn0040ADA0(g_t413A28);
				g_t413A28 = esi_144;
			}
		}
	}
	fn0040AE30(4274744, tLoc04);
	ebpOut = ebp;
	return ebx;
}

// 00401170: void fn00401170()
// Called from:
//      fn00401030
//      fn00401230
void fn00401170()
{
	g_t413A44 = g_t4133D0;
	word32 ecx_167;
	Eq_2 eax_9 = fn0040AD20(out ecx_167);
	*((word32) eax_9 + 4) = g_t413A3C;
	Eq_2 esi_22 = g_t413A28;
	g_t413A38 = eax_9;
	fn004013D0(4274744);
	fn004013D0(4274744);
	g_t413A28 = esi_22;
	while (esi_22 != 0x00)
	{
		esi_22 = *esi_22;
		fn0040ADA0(g_t413A28);
		g_t413A28 = esi_22;
	}
	if (g_t413A38 == 0x00)
	{
		if ((g_b413A48 & 0x20) == 0x00)
		{
			word32 ecx_169;
			word32 edx_170;
			fn00403220(g_t4133F4, 0x043B, out ecx_169, out edx_170);
		}
		if (g_t413A38 == 0x00)
			return;
	}
	word32 ecx_168;
	if (fn0040C3A0(*((word32) g_t413A38 + 4), out ecx_168) != 0x00)
		g_b413A48 |= 0x10;
}

// 00401230: void fn00401230()
// Called from:
//      fn00407D90
//      fn00408AE0
void fn00401230()
{
	if (g_t413A3C != 0x00)
	{
		fn00401170();
		g_t413A3C.u0 = 0x00;
	}
	else
		g_b413A48 &= 223;
	if (g_b413AA1 != 0x00)
		g_t413A44 |= 0x20;
	if (g_t413A38 == 0x00)
	{
		word32 ecx_164;
		word32 edx_165;
		fn00403220(g_t413424, 0x040D, out ecx_164, out edx_165);
	}
	if ((g_b413A48 & 0x10) != 0x00)
	{
		if ((g_t413A44 & 0x20) != 0x00)
		{
			word32 edx_167;
			word32 ecx_166;
			fn00403220(g_t413424, 0x0440, out ecx_166, out edx_167);
		}
		Eq_2 eax_104 = g_t413A38;
		fn00401BC0(eax_104, eax_104);
		fn0040ADA0(g_t413A38);
	}
	else
	{
		Eq_2 eax_49 = g_t413A38;
		if (*eax_49 == 0x00 && fn00401310(*((word32) eax_49 + 4)) != 0x00)
		{
			free(*((word32) g_t413A38 + 4));
			fn0040ADA0(g_t413A38);
		}
		else
			g_t411B10 = g_t413A38;
	}
	g_t413A38.u0 = 0x00;
	g_b413A48 |= 0x80;
}

// 00401310: Register word32 fn00401310(Stack Eq_2 dwArg04)
// Called from:
//      fn00401230
//      fn00401710
word32 fn00401310(Eq_2 dwArg04)
{
	word32 esi_102 = 0x00;
	if (mbsicmp(dwArg04, 0x00413EC0) == 0x00)
	{
		byte al_30 = g_b413A48;
		esp_22->t0004.u0 = 0x01;
		esp_22->t0000.u0 = 115;
		g_b413A48 = al_30 | 0x02;
		fn004086D0(esp_22->t0000, esp_22->t0004);
		esi_102 = 0x01;
	}
	if (mbsicmp(dwArg04, 0x00413EB8) != 0x00)
	{
		if (mbscmp(dwArg04, 4275880) != 0x00)
		{
			if (mbscmp(dwArg04, 4275912) == 0x00)
			{
				g_b413A48 |= 0x08;
				esi_102 = 0x01;
			}
			return esi_102;
		}
		else
		{
			g_b413A48 |= 0x01;
			return 0x01;
		}
	}
	else
	{
		g_b413A48 |= 0x04;
		fn004086D0(0x69, 0x01);
		return 0x01;
	}
}

// 004013D0: void fn004013D0(Stack Eq_2 dwArg08)
// Called from:
//      fn00401030
//      fn00401170
void fn004013D0(Eq_2 dwArg08)
{
	ptr32 fp;
	Eq_2 ebx_145 = 0x00;
	struct Eq_484 * esp_18 = fp - 0x20;
	Eq_2 edi_122 = *dwArg08;
	while (edi_122 != 0x00)
	{
		union Eq_2 * ebp_25 = (word32) edi_122 + 4;
		if (mbspbrk(*ebp_25, esp_18->dw0024) == 0x00)
		{
			ebx_145 = edi_122;
			edi_122 = *edi_122;
			goto l00401538;
		}
		if (*esp_37->ptr002C == 0x24)
		{
			Eq_2 eax_84 = esp_37->t0034;
			Eq_2 ecx_85 = *ebp_25;
			esp_37->t0004 = eax_84;
			esp_37->t0000 = ecx_85;
			word32 edx_391;
			fn0040B700(esp_37->t0000, esp_37->t0004, out edx_391);
			Eq_2 ecx_97 = *ebp_25;
			esp_37->t0020 = eax_84;
			esp_37->t0004 = ecx_97;
			free(esp_37->t0004);
			goto l00401470;
		}
		esp_37->t0004 = *ebp_25;
		Eq_2 ecx_54;
		if (fn0040C3A0(esp_37->t0004, out ecx_54) == 0x00)
		{
			esp_37->t0004 = *ebp_25;
			Eq_2 eax_66 = fn0040CB30(ecx_54, esp_37->t0004);
			esp_37->t0018 = eax_66;
			if (eax_66 == 0x00)
				goto l00401534;
			esp_37->t0024 = *ebp_25;
l00401470:
			Eq_2 eax_105 = *edi_122;
			if (ebx_145 != 0x00)
			{
				esp_37->t0004 = edi_122;
				*ebx_145 = eax_105;
				fn0040ADA0(esp_37->t0004);
				edi_122 = *ebx_145;
			}
			else
			{
				esp_37->t0004 = edi_122;
				*dwArg08 = eax_105;
				fn0040ADA0(esp_37->t0004);
				edi_122 = *dwArg08;
			}
			if (*esp_37->ptr002C == 0x24)
			{
				esp_37->t001C = esp_37->t0020;
				esp_37->t0004 = &esp_37->t001C;
				Eq_2 eax_186 = fn00401550(esp_37->t0004);
				Eq_2 ebp_194 = eax_186;
				if (eax_186 != 0x00)
				{
					do
					{
						word32 ecx_392;
						esp_37->t0018 = fn0040AD20(out ecx_392);
						esp_37->t0004 = ebp_194;
						word32 ecx_393;
						word32 edx_394;
						*((word32) esp_37->t0018 + 4) = fn0040ADD0(esp_37->t0004, out ecx_393, out edx_394);
						esp_37->t0004 = esp_37->t0018;
						esp_37->t0000 = dwArg08;
						fn0040AE10(esp_37->t0000, esp_37->t0004);
						if (ebx_145 == 0x00)
							ebx_145 = esp_37->t0018;
						esp_37->t0004 = &esp_37->t001C;
						Eq_2 eax_239 = fn00401550(esp_37->t0004);
						ebp_194 = eax_239;
					} while (eax_239 != 0x00);
				}
				esp_37->t0004 = esp_37->t0020;
				free(esp_37->t0004);
			}
			else
			{
				if (esp_37->t0018 != 0x00)
				{
					if (ebx_145 == 0x00)
					{
						ebx_145 = esp_37->t0018;
						while (*ebx_145 != 0x00)
							ebx_145 = *ebx_145;
					}
					esp_37->t0004 = *dwArg08;
					esp_37->t0000 = &esp_37->t0018;
					fn0040AE30(esp_37->t0000, esp_37->t0004);
					*dwArg08 = esp_37->t0018;
				}
				esp_37->t0004 = esp_37->t0024;
				free(esp_37->t0004);
			}
		}
		else
		{
l00401534:
			ebx_145 = edi_122;
			edi_122 = *edi_122;
		}
l00401538:
		esp_18 = (struct Eq_484 *) ((char *) &esp_37->t0004 + 4);
	}
}

// 00401550: Register Eq_2 fn00401550(Stack Eq_2 dwArg04)
// Called from:
//      fn004013D0
Eq_2 fn00401550(Eq_2 dwArg04)
{
	Eq_2 edx_10 = *dwArg04;
	while (true)
	{
		byte al_12 = *edx_10;
		if (al_12 != 0x20 && al_12 != 0x09)
			break;
		edx_10 = (word32) edx_10 + 1;
	}
	byte bl_18 = *edx_10;
	if (bl_18 == 0x00)
		return 0x00;
	Eq_2 edx_27;
	if (bl_18 == 0x22)
	{
		edx_27 = (word32) edx_10 + 1;
		if (*edx_27 != 0x00)
		{
			while (*edx_27 != 0x22)
			{
				edx_27 = (word32) edx_27 + 1;
				if (*edx_27 == 0x00)
					break;
			}
		}
	}
	else
	{
		edx_27 = edx_10;
		edx_27 = edx_10;
		if (bl_18 != 0x00)
		{
			do
			{
				byte bl_29 = *edx_27;
				if (bl_29 == 0x20 || bl_29 == 0x09)
					break;
				edx_27 = (word32) edx_27 + 1;
			} while (*edx_27 != 0x00);
		}
	}
	byte bl_49 = *edx_27;
	if (bl_49 != 0x20 && bl_49 != 0x09)
	{
		if (bl_49 == 0x22)
		{
			*((word32) edx_27 + 1) = 0x00;
			*dwArg04 = (word32) edx_27 + 2;
			return edx_10;
		}
		if (bl_49 == 0x00)
		{
			*dwArg04 = edx_27;
			return edx_10;
		}
	}
	else
		*edx_27 = 0x00;
	*dwArg04 = (word32) edx_27 + 1;
	return edx_10;
}

// 004015E0: void fn004015E0()
// Called from:
//      fn00407D90
//      fn00408AE0
void fn004015E0()
{
	if ((g_b413A48 & 0x80) != 0x00)
		g_b413A48 &= 0x7F;
	if ((g_b413A48 & 0x10) != 0x00)
	{
		if (g_t413A38 != 0x00)
		{
			word32 ecx_170;
			word32 edx_171;
			fn00403220(g_t413424, 0x043E, out ecx_170, out edx_171);
		}
	}
	else
	{
		byte cl_17 = g_b413A48;
		if ((cl_17 & 0x02) == 0x00 && (g_b413A48 & 0x04) == 0x00)
		{
			if ((g_b413A48 & 0x01) != 0x00)
			{
				if (g_t413A38 == 0x00)
					fn00401CC0();
				else
					fn00401D00(4274732, g_t413A38);
			}
			else if ((g_b413A48 & 0x08) != 0x00)
			{
				if (g_t413A38 != 0x00)
					fn00401D00(0x00413A30, g_t413A38);
			}
			else
			{
				fn0040ACF0(0x00, 0x18);
				g_t413A40.u0 = 0x00;
				*g_t413A40 = g_t413A38;
				*((word32) g_t413A40 + 4) = g_t413A28;
			}
		}
		else if (g_t413A38 != 0x00)
		{
			word32 edx_173;
			word32 ecx_172;
			fn00403220(g_t413424, 0x0442, out ecx_172, out edx_173);
		}
	}
	g_b413A48 |= 0x40;
	g_t413A38.u0 = 0x00;
	g_t413A28.u0 = 0x00;
}

// 00401710: Register Eq_2 fn00401710()
// Called from:
//      fn00407D90
//      fn00408AE0
Eq_2 fn00401710()
{
	word24 ecx_24_8;
	Eq_2 ecx_129;
	word32 esi_140 = 0x01;
	word32 edi_124 = 0x01;
	if ((g_b413A48 & 0x10) != 0x00)
	{
		ecx_129 = g_t413A34;
		*((word32) ecx_129 + 0x0C) = g_t413A38;
	}
	else
	{
		byte cl_22 = g_b413A48;
		if ((cl_22 & 0x02) == 0x00 && (g_b413A48 & 0x0D) == 0x00)
		{
			*((word32) g_t413A40 + 8) = g_t413A38;
			*((word32) g_t413A40 + 0x0C) = g_t413A28;
			ecx_129 = g_t413A40;
			*((word32) ecx_129 + 16) = g_t413A44;
			Eq_2 ebx_174 = g_t411B10;
			while (ebx_174 != 0x00)
			{
				if (fn00401310(*((word32) ebx_174 + 4)) != 0x00)
				{
					word32 edx_278;
					word32 ecx_277;
					fn00403220(g_t413424, 0x0445, out ecx_277, out edx_278);
				}
				Eq_2 eax_121 = *((word32) ebx_174 + 4);
				ecx_129 = fn00401BF0(eax_121, eax_121, edi_124, &g_t413A40);
				if (g_t4133DC == 0x00)
				{
					g_t4133DC = ebx_174;
					esi_140 = 0x00;
				}
				g_t411B10 = *ebx_174;
				if (esi_140 != 0x00)
					ecx_129 = fn0040ADA0(ebx_174);
				if (edi_124 != 0x00)
					edi_124 = 0x00;
				ebx_174 = g_t411B10;
			}
		}
		else
		{
			ecx_129 = SEQ(ecx_24_8, cl_22 & 0x02);
			if (g_t413A38 != 0x00)
			{
				word32 edx_279;
				fn00403220(g_t413424, 0x0441, out ecx_129, out edx_279);
			}
		}
	}
	g_t411B10.u0 = 0x00;
	g_t413A38.u0 = 0x00;
	g_t413A28.u0 = 0x00;
	g_t413A40.u0 = 0x00;
	g_b413A48 = 0x00;
	return ecx_129;
}

// 00401870: void fn00401870()
// Called from:
//      fn00408AE0
void fn00401870()
{
	void (* esi_163)(Eq_2);
	if (mbschr(g_t413A3C, 0x24) != 0x00)
	{
		Eq_2 esi_26 = g_t413A28;
		esp_15->t0004.u0 = 4274728;
		Eq_2 eax_29 = g_t413A3C;
		esp_15->t0000 = eax_29;
		word32 edx_235;
		fn0040B700(esp_15->t0000, esp_15->t0004, out edx_235);
		if (*eax_29 == 0x00)
		{
			esp_15->t0004.u0 = 1004;
			esp_15->t0000 = g_t413424;
			word32 ecx_236;
			word32 edx_237;
			fn00403220(esp_15->t0000, esp_15->t0004, out ecx_236, out edx_237);
		}
		g_t413A28 = esi_26;
		while (esi_26 != 0x00)
		{
			esi_26 = *esi_26;
			esp_15->t0004 = g_t413A28;
			fn0040ADA0(esp_15->t0004);
			g_t413A28 = esi_26;
		}
		esp_15->t0004 = g_t413A3C;
		free(esp_15->t0004);
		g_t413A3C = eax_29;
		esi_163 = free;
	}
	else
		esi_163 = free;
	Eq_2 ecx_107 = g_t413A3C;
	if (*ecx_107 != 0x00)
	{
		while ((g_a4149C0[(uint32) *ecx_107] & 0x01) != 0x00)
		{
			ecx_107 = (word32) ecx_107 + 1;
			if (*ecx_107 == 0x00)
				break;
		}
	}
	byte al_112 = *ecx_107;
	if (al_112 != 0x00)
	{
		esp_15->t0004 = (int32) al_112;
		Eq_2 ecx_122 = g_t413424;
		esp_15->t0000.u0 = 1001;
		esp_15->tFFFFFFFC = ecx_122;
		word32 ecx_239;
		word32 edx_240;
		fn00403220(esp_15->tFFFFFFFC, esp_15->t0000, out ecx_239, out edx_240);
	}
	esp_15->t0004.u0 = 0x00;
	esp_15->t0000 = g_t4133FC;
	Eq_2 ecx_142 = g_t413A3C;
	g_dw4133B4 = 0x01;
	esp_15->tFFFFFFFC = ecx_142;
	word32 ecx_238;
	if (fn004019F0(ecx_142, esp_15->tFFFFFFFC, esp_15->t0000, esp_15->t0004, esp_15->t00C0, esp_15->t00C4, esp_15->t00C8, esp_15->t00D4, esp_15->t00D8, esp_15->t00DC, out ecx_238) == 0x00)
	{
		Eq_2 eax_157 = g_t413A3C;
		esp_15->t0004 = eax_157;
		union Eq_2 * esp_175;
		esi_163();
		Eq_2 eax_183 = g_t4133FC;
		*esp_175 = (union Eq_2 *) eax_183;
		esi_163();
	}
	g_t4133FC.u0 = 0x00;
	g_t413A3C.u0 = 0x00;
}

// 00401980: Register word32 fn00401980(Register Eq_2 ecx, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 bArg0C, Stack Eq_2 dwArgB0, Stack Eq_2 dwArgB4, Stack Eq_2 dwArgB8, Stack Eq_2 dwArgC4, Stack Eq_2 dwArgC8, Stack Eq_2 dwArgCC, Register out Eq_2 ecxOut)
// Called from:
//      fn00407D90
//      fn00407F70
//      fn00408270
//      fn00408320
word32 fn00401980(Eq_2 ecx, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 bArg0C, Eq_2 dwArgB0, Eq_2 dwArgB4, Eq_2 dwArgB8, Eq_2 dwArgC4, Eq_2 dwArgC8, Eq_2 dwArgCC, union Eq_2 & ecxOut)
{
	word32 ebx;
	word24 ebx_24_8_63 = SLICE(ebx, word24, 8);
	Eq_2 eax_11 = dwArg04;
	if (*dwArg04 != 0x00)
	{
		do
		{
			ecx = (uint32) *eax_11;
			if ((*((word32) ecx + 4278720) & 0x01) == 0x00)
				break;
			eax_11 = (word32) eax_11 + 1;
		} while (*eax_11 != 0x00);
	}
	word32 ebx_61 = SEQ(ebx_24_8_63, bArg0C);
	if (*eax_11 != 0x00)
	{
		ebx_61 = SEQ(ebx_24_8_63, bArg0C);
		if ((bArg0C & 0x04) != 0x00)
		{
			ecxOut = ecx;
			return 0x00;
		}
		word32 edx_169;
		fn00403220(g_t413424, 1001, out ecx, out edx_169);
	}
	Eq_2 ecx_79;
	word32 eax_78 = fn004019F0(ecx, dwArg04, dwArg08, (byte) ebx_61, dwArgB0, dwArgB4, dwArgB8, dwArgC4, dwArgC8, dwArgCC, out ecx_79);
	ecxOut = ecx_79;
	return eax_78;
}

// 004019F0: Register word32 fn004019F0(Register Eq_2 ecx, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 bArg0C, Stack Eq_2 dwArgC8, Stack Eq_2 dwArgCC, Stack Eq_2 dwArgD0, Stack Eq_2 dwArgDC, Stack Eq_2 dwArgE0, Stack Eq_2 dwArgE4, Register out Eq_2 ecxOut)
// Called from:
//      fn00401870
//      fn00401980
word32 fn004019F0(Eq_2 ecx, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 bArg0C, Eq_2 dwArgC8, Eq_2 dwArgCC, Eq_2 dwArgD0, Eq_2 dwArgDC, Eq_2 dwArgE0, Eq_2 dwArgE4, union Eq_2 & ecxOut)
{
	Eq_2 ebp_119;
	Eq_2 ebx_122;
	word32 dwLoc04_359 = 0x00;
	word32 dwLoc08_360 = 0x01;
	if ((bArg0C & 0x02) != 0x00)
	{
		ebp_119 = dwArg08;
		if (*dwArg08 != 0x00)
		{
			ebx_122 = dwArg04;
			word32 ebx_530;
			if (fn00401E00(dwArg04, fn0040B690(ecx, dwArg08, dwArgC8, dwArgCC, dwArgD0, out ebx_530, out ebp_119)) == ~0x00)
			{
				word32 ecx_531;
				word32 edx_532;
				fn00403220(g_t413424, 1055, out ecx_531, out edx_532);
			}
		}
		else
			ebx_122 = dwArg04;
	}
	else if (g_dw4133B4 != 0x00)
	{
		ebx_122 = dwArg04;
		if ((g_b4133D4 & 0x04) == 0x00)
		{
			if (getenv(dwArg04) != 0x00)
			{
				Eq_2 ecx_42;
				Eq_2 eax_41 = fn00407B70(dwArg04, out ecx_42);
				if (eax_41 != 0x00)
				{
					Eq_2 al_52 = *((word32) eax_41 + 0x0C);
					if ((al_52 & 0x02) != 0x00 || (g_b4133D4 & 0x04) != 0x00 && (al_52 & 0x04) != 0x00)
					{
						ecxOut = ecx_42;
						return 0x00;
					}
				}
				if (fn00401E00(ebx_122, fn0040B690(ecx_42, dwArg08, dwArgC8, dwArgCC, dwArgD0, out ebx_122, out ebp_119)) == ~0x00)
				{
					word32 ecx_533;
					word32 edx_534;
					fn00403220(g_t413424, 1055, out ecx_533, out edx_534);
				}
			}
			else
				ebp_119 = dwArg08;
		}
		else
			ebp_119 = dwArg08;
	}
	else
	{
		ebx_122 = dwArg04;
		ebp_119 = dwArg08;
	}
	g_dw4133B4 = 0x00;
	Eq_2 ecx_171;
	Eq_2 eax_170 = fn00407B70(ebx_122, out ecx_171);
	Eq_2 esi_178 = eax_170;
	if (eax_170 != 0x00)
	{
		Eq_2 al_182 = *((word32) eax_170 + 0x0C);
		if ((al_182 & 0x02) != 0x00 || (g_b4133D4 & 0x04) != 0x00 && (al_182 & 0x04) != 0x00)
		{
			ecxOut = ecx_171;
			return 0x00;
		}
	}
	word32 ecx_535;
	Eq_2 eax_192 = fn0040AD20(out ecx_535);
	*((word32) eax_192 + 4) = ebp_119;
	if (eax_170 == 0x00)
	{
		fn0040ACF0(eax_192, 0x10);
		*((word32) eax_192 + 4) = ebx_122;
		esi_178 = eax_192;
	}
	else
		dwLoc04_359 = 0x01;
	Eq_2 al_223 = *((word32) esi_178 + 0x0C);
	*((word32) esi_178 + 0x0C) = al_223 & ~0x10;
	*((word32) esi_178 + 0x0C) = bArg0C | al_223 & ~0x10;
	fn0040AE10((word32) esi_178 + 8, eax_192);
	if (dwLoc04_359 == 0x00)
		fn00407BF0(esi_178);
	Eq_2 ecx_269;
	if (mbschr(ebp_119, 0x24) != 0x00)
	{
		*((word32) esi_178 + 0x0C) |= 0x01;
		word32 ebp_537;
		word32 edi_538;
		word32 ebx_536;
		word32 eax_298 = fn0040B110(ecx_269, dwArgDC, dwArgE0, dwArgE4, out ecx_269, out ebx_536, out ebp_537, out esi_178, out edi_538);
		*((word32) esi_178 + 0x0C) &= ~0x01;
		dwLoc08_360 = eax_298;
	}
	if (dwLoc08_360 != 0x00)
	{
		ecxOut = ecx_269;
		return 0x01;
	}
	else
	{
		((word32) esi_178 + 8)->u0 = 0x00;
		*((word32) esi_178 + 0x0C) &= 0x10;
		ecxOut = ecx_269;
		return 0x00;
	}
}

// 00401BC0: void fn00401BC0(Register Eq_2 eax, Stack Eq_2 dwArg04)
// Called from:
//      fn00401230
void fn00401BC0(Eq_2 eax, Eq_2 dwArg04)
{
	fn0040ACF0(eax, 0x14);
	*((word32) eax + 8) = *((word32) dwArg04 + 4);
	fn0040AE10(4274740, eax);
	Eq_2 eax_29 = *eax;
	if (eax_29 != 0x00)
		*((word32) eax_29 + 4) = eax;
}

// 00401BF0: Register word32 fn00401BF0(Register Eq_2 eax, Stack Eq_2 dwArg04, Stack word32 dwArg08, Stack (ptr32 Eq_2) dwArg0C)
// Called from:
//      fn00401710
word32 fn00401BF0(Eq_2 eax, Eq_2 dwArg04, word32 dwArg08, union Eq_2 * dwArg0C)
{
	if (*dwArg0C == 0x00)
	{
		fn0040ACF0(eax, 0x18);
		*dwArg0C = (union Eq_2 *) eax;
	}
	Eq_2 edi_42;
	if (dwArg08 != 0x00)
	{
		fn0040ACF0(eax, 0x08);
		*((word32) eax + 4) = *dwArg0C;
		edi_42 = eax;
	}
	else
	{
		Eq_2 eax_32 = *dwArg0C;
		fn00401ED0(eax_32, eax_32);
		edi_42 = eax_32;
	}
	Eq_2 eax_67 = fn0040AEC0(dwArg04, 0x80, 4274216, 0x01);
	if (eax_67 == 0x00)
	{
		*edi_42 = 0x00;
		fn0040ACF0(eax_67, 0x14);
		*((word32) eax_67 + 4) = dwArg04;
		*((word32) eax_67 + 16) = edi_42;
		*((word32) eax_67 + 8) = g_t413A44;
		return fn0040AE10(fn0040AE50(dwArg04, 0x80, 0x01) * 0x04 + 4274216, eax_67);
	}
	else
	{
		if (((*((word32) eax_67 + 8) ^ g_t413A44) & 0x20) != 0x00)
		{
			word32 ecx_224;
			word32 edx_225;
			fn00403220(g_t413424, 0x043F, out ecx_224, out edx_225);
		}
		word32 ecx_151 = fn0040AE30((word32) eax_67 + 16, edi_42);
		free(dwArg04);
		return ecx_151;
	}
}

// 00401CC0: void fn00401CC0()
// Called from:
//      fn004015E0
void fn00401CC0()
{
	Eq_2 edi_13 = g_t413A2C;
	while (edi_13 != 0x00)
	{
		g_t413A2C = *g_t413A2C;
		free(*((word32) edi_13 + 4));
		fn0040ADA0(edi_13);
		edi_13 = g_t413A2C;
	}
}

// 00401D00: void fn00401D00(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn004015E0
void fn00401D00(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 edi_17 = dwArg08;
	if (dwArg08 != 0x00)
	{
		do
		{
			struct Eq_1921 * esp_173;
			if (mbschr(*((word32) edi_17 + 4), 0x24) == 0x00)
			{
				struct Eq_1892 * eax_174 = esp_33->ptr0024;
				esp_33->t0004 = edi_17;
				esp_33->t0000 = dwArg04;
				esp_33->ptr0024 = eax_174->ptr0000;
				*edi_17 = 0x00;
				fn0040AE30(esp_33->t0000, esp_33->t0004);
				esp_173 = (struct Eq_1921 *) ((char *) &esp_33->t0004 + 4);
			}
			else
			{
				Eq_2 ebx_42 = g_t413A28;
				esp_33->t0004.u0 = 4274728;
				Eq_2 eax_45 = *((word32) edi_17 + 4);
				esp_33->t0000 = eax_45;
				word32 edx_274;
				fn0040B700(esp_33->t0000, esp_33->t0004, out edx_274);
				esp_33->t0018 = eax_45;
				if (g_t413A28 != ebx_42)
				{
					do
					{
						Eq_2 ebp_60 = *ebx_42;
						esp_33->t0004 = ebx_42;
						fn0040ADA0(esp_33->t0004);
						ebx_42 = ebp_60;
					} while (g_t413A28 != ebp_60);
				}
				Eq_2 eax_90 = mbstok(esp_33->t0018, 0x00413008);
				struct Eq_1945 * esp_108 = esp_89 + 0x08;
				Eq_2 ebp_110 = eax_90;
				if (eax_90 != 0x00)
				{
					do
					{
						word32 ecx_275;
						Eq_2 eax_100 = fn0040AD20(out ecx_275);
						struct Eq_2016 * esp_109 = esp_108 - 4;
						esp_109->t0000 = ebp_110;
						word32 ecx_276;
						word32 edx_277;
						Eq_2 eax_112 = fn0040ADD0(esp_109->t0000, out ecx_276, out edx_277);
						esp_109->t0000 = eax_100;
						*((word32) eax_100 + 4) = eax_112;
						esp_109->tFFFFFFFC = dwArg04;
						fn0040AE30(esp_109->tFFFFFFFC, esp_109->t0000);
						Eq_2 eax_140 = mbstok(0x00, 0x00413008);
						esp_108 = esp_139 + 0x08;
						ebp_110 = eax_140;
					} while (eax_140 != 0x00);
				}
				struct Eq_1966 * esp_153 = esp_108 - 4;
				esp_153->t0000 = esp_108->t0010;
				free(esp_153->t0000);
				esp_153->t0000 = *((word32) edi_17 + 4);
				free(esp_153->t0000);
				struct Eq_1991 * ecx_163 = esp_153->ptr0020->ptr0000;
				esp_153->t0000 = edi_17;
				esp_153->ptr0020 = ecx_163;
				fn0040ADA0(esp_153->t0000);
				esp_173 = (struct Eq_1921 *) ((char *) &esp_153->t0000 + 4);
			}
			edi_17 = esp_173->t001C;
		} while (edi_17 != 0x00);
	}
}

// 00401E00: Register int32 fn00401E00(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn004019F0
int32 fn00401E00(Eq_2 dwArg04, Eq_2 dwArg08)
{
	word32 ecx_21 = ~0x00;
	Eq_2 edi_20 = dwArg04;
	while (ecx_21 != 0x00)
	{
		edi_20 = (word32) edi_428 + 1;
		--ecx_21;
		edi_428 = edi_20;
		if (*edi_428 != 0x00)
			break;
	}
	word32 ecx_36 = ~ecx_21;
	Eq_2 edi_37 = dwArg08;
	word32 ecx_39 = ~0x00;
	while (ecx_39 != 0x00)
	{
		edi_37 = (word32) edi_429 + 1;
		--ecx_39;
		edi_429 = edi_37;
		if (*edi_429 != 0x00)
			break;
	}
	fn0040ACC0(~ecx_39 - 1 + (ecx_36 - 1) + 0x02);
	Eq_2 edi_430 = dwArg04;
	word32 ecx_77 = ~0x00;
	while (ecx_77 != 0x00)
	{
		edi_430 = (word32) edi_430 + 1;
		--ecx_77;
		if (*edi_430 != 0x00)
			break;
	}
	uint32 ecx_89 = ~ecx_77;
	uint32 ecx_264;
	struct Eq_2113 * esi_249 = edi_430 - ecx_89;
	struct Eq_2115 * edi_252 = null;
	for (ecx_264 = ecx_89 >> 0x02; ecx_264 != 0x00; --ecx_264)
	{
		edi_252->dw0000 = esi_249->dw0000;
		esi_249 += 4;
		edi_252 += 4;
	}
	ui32 ecx_102;
	for (ecx_102 = ecx_89 & 0x03; ecx_102 != 0x00; --ecx_102)
	{
		edi_252->dw0000 = esi_249->dw0000;
		++esi_249;
		++edi_252;
	}
	byte * edi_106 = &g_b41300C;
	word32 ecx_107 = ~0x00;
	while (ecx_107 != 0x00)
	{
		++edi_106;
		--ecx_107;
		if (*edi_106 != 0x00)
			break;
	}
	uint32 ecx_119 = ~ecx_107;
	struct Eq_2165 * esi_123 = edi_106 - ecx_119;
	word32 ecx_124 = ~0x00;
	byte * edi_128 = null;
	while (ecx_124 != 0x00)
	{
		++edi_128;
		--ecx_124;
		if (*edi_128 != 0x00)
			break;
	}
	struct Eq_2182 * edi_140 = edi_128 - 0x01;
	uint32 ecx_144;
	for (ecx_144 = ecx_119 >> 0x02; ecx_144 != 0x00; --ecx_144)
	{
		edi_140->dw0000 = esi_123->dw0000;
		esi_123 += 4;
		edi_140 += 4;
	}
	ui32 ecx_149;
	for (ecx_149 = ecx_119 & 0x03; ecx_149 != 0x00; --ecx_149)
	{
		edi_140->dw0000 = esi_123->dw0000;
		++esi_123;
		++edi_140;
	}
	Eq_2 edi_154 = dwArg08;
	word32 ecx_155 = ~0x00;
	while (ecx_155 != 0x00)
	{
		edi_154 = (word32) edi_154 + 1;
		--ecx_155;
		if (*edi_154 != 0x00)
			break;
	}
	uint32 ecx_167 = ~ecx_155;
	struct Eq_2235 * esi_171 = edi_154 - ecx_167;
	word32 ecx_172 = ~0x00;
	byte * edi_176 = null;
	while (ecx_172 != 0x00)
	{
		++edi_176;
		--ecx_172;
		if (*edi_176 != 0x00)
			break;
	}
	struct Eq_2252 * edi_188 = edi_176 - 0x01;
	uint32 ecx_192;
	for (ecx_192 = ecx_167 >> 0x02; ecx_192 != 0x00; --ecx_192)
	{
		edi_188->dw0000 = esi_171->dw0000;
		esi_171 += 4;
		edi_188 += 4;
	}
	ui32 ecx_201;
	for (ecx_201 = ecx_167 & 0x03; ecx_201 != 0x00; --ecx_201)
	{
		edi_188->dw0000 = esi_171->dw0000;
		++esi_171;
		++edi_188;
	}
	return _putenv(0x00);
}

// 00401ED0: void fn00401ED0(Register Eq_2 eax, Stack Eq_2 dwArg04)
// Called from:
//      fn00401BF0
void fn00401ED0(Eq_2 eax, Eq_2 dwArg04)
{
	fn0040ACF0(eax, 0x08);
	fn0040ACF0(eax, 0x18);
	*eax = *dwArg04;
	*((word32) eax + 4) = *((word32) dwArg04 + 4);
	*((word32) eax + 8) = *((word32) dwArg04 + 8);
	*((word32) eax + 0x0C) = *((word32) dwArg04 + 0x0C);
	*((word32) eax + 16) = *((word32) dwArg04 + 16);
	*((word32) eax + 20) = *((word32) dwArg04 + 20);
	*((word32) eax + 4) = eax;
}

// 00401F10: void fn00401F10()
// Called from:
//      fn00407F70
void fn00401F10()
{
	ptr32 fp;
	ptr32 tLoc08;
	Eq_2 dwLoc10;
	Eq_2 esi_18 = g_t4133DC;
	while (esi_18 != 0x00)
	{
		word24 ecx_24_8_52 = SLICE(ecx_37, word24, 8);
		if (mbspbrk(*((word32) g_t4133DC + 4), 0x00413000) != 0x00)
		{
			fn0040CEB4((word32) g_t413EE0 + 3 & ~0x03, ecx_37, esp_35->t0004);
			tLoc08 = (char *) &esp_35->t0004 + 4;
			esp_35->t0004 = fp - 16;
			Eq_2 edx_108 = g_t4133DC;
			esp_35->t0000 = &tLoc08;
			esp_35->tFFFFFFFC = *((word32) edx_108 + 4);
			if (fn0040CD20(esp_35->tFFFFFFFC) == 0x00)
			{
				esp_35->t0004 = *((word32) g_t4133DC + 4);
				esp_35->t0000.u0 = 0x042D;
				esp_35->tFFFFFFFC.u0 = 0x00;
				word32 ecx_345;
				word32 edx_346;
				fn00403220(esp_35->tFFFFFFFC, esp_35->t0000, out ecx_345, out edx_346);
			}
			else
			{
				do
				{
					esp_35->t0004 = &tLoc08;
					esp_35->t0004 = fn00404C90(esp_35->t0004);
					esp_35->t0000 = *((word32) g_t4133DC + 4);
					Eq_2 eax_142 = fn0040C340(esp_35->t0000, esp_35->t0004);
					esp_35->t0004 = &tLoc08;
					word32 ecx_155;
					fn00404CA0(esp_35->t0004, out ecx_155);
					esp_35->t0004.u0 = 0x00;
					Eq_2 cl_163 = g_t4133D0;
					esp_35->t0000 = fp - 0x0C;
					esp_35->tFFFFFFFC = SEQ(SLICE(ecx_155, word24, 8), cl_163);
					esp_35->tFFFFFFF8 = eax_142;
					int32 eax_174 = fn00402080(esp_35->tFFFFFFF8, esp_35->tFFFFFFFC);
					esp_35->t0004 = eax_142;
					free(esp_35->t0004);
					if (eax_174 < 0x00 && (g_b4133D4 & 0x08) != 0x00)
					{
						esp_35->t0004 = esi_18;
						fn00402C40(esp_35->t0004);
						return;
					}
					esp_35->t0004 = dwLoc10;
					esp_35->t0000 = &tLoc08;
				} while (fn0040CE00(esp_35->t0000, esp_35->t0004) != 0x00);
			}
		}
		else
		{
			esp_35->t0004.u0 = 0x00;
			esp_35->t0000 = fp - 0x0C;
			esp_35->tFFFFFFFC = SEQ(ecx_24_8_52, g_t4133D0);
			esp_35->tFFFFFFF8 = *((word32) g_t4133DC + 4);
			if (fn00402080(esp_35->tFFFFFFF8, esp_35->tFFFFFFFC) < 0x00 && (g_b4133D4 & 0x08) != 0x00)
			{
				esp_35->t0004 = esi_18;
				fn00402C40(esp_35->t0004);
				return;
			}
		}
		Eq_2 eax_249 = *esi_18;
		esp_35->t0004 = esi_18;
		g_t4133DC = eax_249;
		fn0040ADA0(esp_35->t0004);
		esi_18 = g_t4133DC;
	}
}

// 00402080: Register word32 fn00402080(Stack Eq_2 dwArg04, Stack Eq_2 bArg08)
// Called from:
//      fn00401F10
//      fn004020E0
//      fn0040A500
word32 fn00402080(Eq_2 dwArg04, Eq_2 bArg08)
{
	Eq_2 dwArg10;
	union Eq_2 * dwArg0C;
	++g_dw413010;
	word32 edi_14 = 0x01;
	Eq_2 eax_26 = fn0040AEC0(dwArg04, 0x80, 4274216, 0x01);
	if (eax_26 == 0x00)
	{
		fn00402C70(eax_26, dwArg04, bArg08);
		edi_14 = 0x00;
	}
	word32 eax_74 = fn004020E0(dwArg10, eax_26, bArg08, dwArg0C, edi_14, dwArg10);
	--g_dw413010;
	return eax_74;
}

// 004020E0: Register Eq_2668 fn004020E0(Register Eq_2 ecx, Stack Eq_2 dwArg04, Stack Eq_2 bArg08, Stack (ptr32 Eq_2) dwArg0C, Stack word32 dwArg10, Stack Eq_2 dwArg14)
// Called from:
//      fn00402080
Eq_2668 fn004020E0(Eq_2 ecx, Eq_2 dwArg04, Eq_2 bArg08, union Eq_2 * dwArg0C, word32 dwArg10, Eq_2 dwArg14)
{
	ptr32 fp;
	time_t tLoc34;
	Eq_2 tLoc24;
	Eq_2 tLoc20;
	Eq_2 tLoc1C;
	Eq_2 dwLoc08;
	Eq_2 dwLoc14;
	Eq_2668 eax_1315;
	Eq_2 ecx_11 = fn0040CEB4(0x0148, ecx, dwLoc08);
	Eq_2668 dwLoc28_1407 = 0x00;
	if (dwArg04 == 0x00)
	{
		*dwArg0C = (union Eq_2 *) 0x00;
		eax_1315.u0 = 0x00;
		return eax_1315;
	}
	if ((*((word32) dwArg04 + 9) & 0x01) != 0x00)
	{
		dwLoc14 = *((word32) dwArg04 + 4);
		tLoc1C.u0 = 0x00;
		word32 edx_2236;
		fn00403220(tLoc1C, 1071, out ecx_11, out edx_2236);
	}
	if ((*((word32) dwArg04 + 9) & 0x02) != 0x00)
	{
		if ((bArg08 & 0x01) != 0x00)
		{
			Eq_2 eax_1349 = *((word32) dwArg04 + 0x0C);
			tLoc1C = g_dw413010 * 0x02;
			fn00408D10(eax_1349);
		}
		*dwArg0C = (union Eq_2 *) *((word32) dwArg04 + 0x0C);
		eax_1315 = 0x00 - (word32) ((*((word32) dwArg04 + 9) & 0x04) < 0x01) + 0x01;
		return eax_1315;
	}
	fn0040CEB4((word32) g_t413EE0 + 3 & ~0x03, ecx_11, dwLoc14);
	tLoc20 = fp - 16;
	tLoc24.u0 = 0x00;
	tLoc1C.u0 = 0x00;
	tLoc34 = (Eq_2670) 0x00;
	Eq_2 eax_76 = *((word32) dwArg04 + 4);
	*((word32) dwArg04 + 9) |= 0x01;
	g_t413A90 = eax_76;
	g_t413A8C = eax_76;
	Eq_2 edx_85 = *((word32) dwArg04 + 16);
	Eq_2 dwLoc48_1414 = 0x00;
	Eq_2 dwLoc40_1415 = 0x00;
	Eq_2 dwLoc08_1416 = 0x00;
	Eq_2 dwLoc38_1418 = 0x00;
	word32 * dwLoc44_1419 = null;
	Eq_2 dwLoc30_1420 = edx_85;
	if (edx_85 != 0x00 && (*((word32) (*((word32) edx_85 + 4)) + 16) & 0x20) != 0x00)
	{
		tLoc1C = *((word32) dwArg04 + 4);
		dwLoc14 = fp - 44;
		if (fn0040CD20(tLoc1C) != 0x00)
		{
			dwLoc14 = &tLoc20;
			word32 ecx_2237;
			dwLoc08_1416 = fn00404CA0(dwLoc14, out ecx_2237);
		}
	}
	ptr32 esp_143 = fp - 16;
	if (edx_85 != 0x00)
	{
		do
		{
			Eq_2 ecx_132 = *((word32) dwLoc30_1420 + 4);
			Eq_2 esi_128 = 0x00;
			dwLoc14 = ecx_132;
			Eq_2 ecx_136 = *((word32) ecx_132 + 20);
			if (ecx_136 != 0x00)
			{
				Eq_2 eax_739 = dwLoc08_1416;
				if (dwLoc08_1416 <= ecx_136)
					eax_739 = ecx_136;
				dwLoc08_1416 = eax_739;
				goto l0040250F;
			}
			struct Eq_2882 * esp_144 = esp_143 - 4;
			esp_144->t0000 = *((word32) dwArg04 + 4);
			esp_144->tFFFFFFFC = ecx_132;
			word32 edx_152;
			Eq_2 eax_150 = fn00402870(esp_144->tFFFFFFFC, out edx_152);
			dwLoc44_1419 = (word32) ecx_132 + 20;
			word24 edx_24_8_177 = SLICE(edx_152, word24, 8);
			ptr32 esp_157 = (char *) &esp_144->t0000 + 4;
			Eq_2 ebx_159 = eax_150;
			if (eax_150 != 0x00)
			{
				do
				{
					Eq_2 eax_165 = *((word32) ebx_159 + 8);
					struct Eq_2931 * esp_167 = esp_157 - 4;
					esp_167->dw0000 = 0x00;
					Eq_2 dl_173 = *((word32) ecx_132 + 16);
					esp_167->ptrFFFFFFFC = fp - 16;
					esp_167->dwFFFFFFF8 = SEQ(edx_24_8_177, dl_173);
					esp_167->tFFFFFFF4 = *((word32) ebx_159 + 4);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					Eq_2 stackArg8 = <invalid>;
					int32 eax_187 = fn00402080(stackArg4, stackArg8);
					dwLoc28_1407 = (word32) dwLoc28_1407.u1 + eax_187;
					if (g_dw4133A4 != 0x00 && eax_187 != 0x00)
					{
						esp_167->tFFFFFFF0.u0 = 0x01;
						Eq_2 eax_201 = *((word32) ebx_159 + 4);
						esp_167->tFFFFFFEC.u0 = 4274216;
						esp_167->tFFFFFFE8.u0 = 0x80;
						esp_167->tFFFFFFE4 = eax_201;
						if ((*((word32) fn0040AEC0(esp_167->tFFFFFFE4, esp_167->tFFFFFFE8, esp_167->tFFFFFFEC, esp_167->tFFFFFFF0) + 9) & 0x08) == 0x00)
						{
							g_dw4133B0 = 0x00;
							esp_167->tFFFFFFF0 = *((word32) ebx_159 + 4);
							esp_167->tFFFFFFEC.u0 = 0x0FAA;
							esp_167->tFFFFFFE8.u0 = 0x00;
							word32 ecx_2240;
							word32 edx_2241;
							fn00403220(esp_167->tFFFFFFE8, esp_167->tFFFFFFEC, out ecx_2240, out edx_2241);
						}
						*((word32) dwArg04 + 9) |= 0x08;
					}
					if (esi_128 <= eax_165)
						esi_128 = eax_165;
					if (dwLoc08_1416 == 0x00 && (*((word32) ecx_132 + 16) & 0x20) == 0x00)
					{
						esp_167->tFFFFFFF0 = fp - 44;
						Eq_2 edx_268 = *((word32) dwArg04 + 4);
						esp_167->tFFFFFFEC = &tLoc20;
						esp_167->tFFFFFFE8 = edx_268;
						if (fn0040CD20(esp_167->tFFFFFFE8) != 0x00)
						{
							esp_167->tFFFFFFF0 = &tLoc20;
							word32 ecx_2251;
							Eq_2 eax_287 = fn00404CA0(esp_167->tFFFFFFF0, out ecx_2251);
							*((word32) dwArg04 + 0x0C) = eax_287;
							dwLoc08_1416 = eax_287;
						}
					}
					if ((*((word32) dwArg04 + 8) & 0x10) != 0x00 || (eax_165 > dwLoc08_1416 || g_dw4133B8 != 0x00 && eax_165 == dwLoc08_1416))
					{
						word32 ecx_2256;
						Eq_2 eax_309 = fn0040AD20(out ecx_2256);
						esp_167->tFFFFFFF0 = *((word32) ebx_159 + 4);
						word32 ecx_2257;
						word32 edx_2258;
						Eq_2 eax_328 = fn0040ADD0(esp_167->tFFFFFFF0, out ecx_2257, out edx_2258);
						esp_167->tFFFFFFF0 = eax_309;
						*((word32) eax_309 + 4) = eax_328;
						esp_167->tFFFFFFEC = &tLoc24;
						fn0040AE30(esp_167->tFFFFFFEC, esp_167->tFFFFFFF0);
					}
					word32 ecx_2259;
					Eq_2 eax_350 = fn0040AD20(out ecx_2259);
					esp_167->tFFFFFFF0 = *((word32) ebx_159 + 4);
					word32 ecx_2260;
					Eq_2 eax_364 = fn0040ADD0(esp_167->tFFFFFFF0, out ecx_2260, out edx_152);
					esp_167->tFFFFFFF0 = eax_350;
					*((word32) eax_350 + 4) = eax_364;
					esp_167->tFFFFFFEC = &tLoc1C;
					fn0040AE30(esp_167->tFFFFFFEC, esp_167->tFFFFFFF0);
					edx_24_8_177 = SLICE(edx_152, word24, 8);
					esp_157 = esp_167 - 0x0C;
					ebx_159 = *ebx_159;
				} while (ebx_159 != 0x00);
			}
			word24 edx_24_8_543 = SLICE(edx_152, word24, 8);
			Eq_2 ebx_392 = eax_150;
			if (eax_150 != 0x00)
			{
				do
				{
					union Eq_2 * esp_400 = esp_157 - 4;
					*esp_400 = (union Eq_2 *) *((word32) ebx_392 + 4);
					free(*esp_400);
					Eq_2 eax_403 = *ebx_392;
					*esp_400 = (union Eq_2 *) ebx_392;
					free(*esp_400);
					ebx_392 = eax_403;
				} while (eax_403 != 0x00);
			}
			if ((*((word32) ecx_132 + 16) & 0x20) != 0x00)
			{
				if (*((word32) ecx_132 + 8) == 0x00)
					goto l004024FE;
				g_t413A94 = tLoc24;
				Eq_2 eax_470 = tLoc1C;
				Eq_2 ecx_472 = *((word32) dwArg04 + 4);
				g_t413A90 = ecx_472;
				g_t413A8C = ecx_472;
				g_t413A84.u0 = 0x00;
				g_t413A88.u0 = 0x00;
				g_t413A98 = eax_470;
				if ((g_dw4133A4 != 0x00 && (*((word32) dwArg04 + 9) & 0x08) == 0x00 || dwLoc28_1407 == 0x00) && esi_128 > dwLoc08_1416 || (g_dw4133B8 != 0x00 && esi_128 == dwLoc08_1416 || (dwLoc08_1416 == 0x00 && esi_128 == 0x00 || *ecx_132 == 0x00)))
				{
					byte bl_515 = g_b414008;
					g_b414008 = 0x01;
					if (dwArg14 == 0x00)
					{
						if (tLoc1C != 0x00)
							dwArg14 = *((byte) tLoc1C.u0 + 4);
						else
							dwArg14.u0 = 0x00;
					}
					struct Eq_3964 * esp_535 = esp_157 - 4;
					esp_535->t0000 = dwArg14;
					esp_535->tFFFFFFFC = SEQ(edx_24_8_543, *((word32) ecx_132 + 16));
					esp_535->tFFFFFFF8 = *((word32) ecx_132 + 0x0C);
					esp_535->tFFFFFFF4 = *((word32) ecx_132 + 8);
					Eq_2 eax_566 = *((word32) dwArg04 + 4);
					esp_535->tFFFFFFF0 = eax_566;
					dwLoc28_1407.u0 = (bool) dwLoc28_1407.u0 + fn004036C0(SLICE(eax_566, word24, 8), esp_535->tFFFFFFF0, esp_535->tFFFFFFF4, esp_535->tFFFFFFFC);
					if ((*((word32) dwArg04 + 8) & 0x04) == 0x00)
					{
						esp_535->t0000 = fp - 44;
						Eq_2 edx_587 = *((word32) dwArg04 + 4);
						esp_535->tFFFFFFFC = &tLoc20;
						esp_535->tFFFFFFF8 = edx_587;
						if (fn0040CD20(esp_535->tFFFFFFF8) == 0x00)
							goto l00402457;
						esp_535->t0000 = &tLoc20;
						word32 ecx_2261;
						tLoc34 = (Eq_2670) fn00404CA0(esp_535->t0000, out ecx_2261);
					}
					else
					{
l00402457:
						if (dwLoc38_1418 != 0x00)
							tLoc34 = (Eq_2670) dwLoc38_1418;
						else
						{
							union Eq_2 * esp_609 = esp_157 - 4;
							*esp_609 = (union Eq_2 *) &tLoc34;
							fn0040CEA0(*esp_609);
						}
					}
					*((word32) ecx_132 + 20) = tLoc34;
					Eq_2 edx_636 = tLoc24;
					union Eq_2 * esp_638 = esp_157 - 4;
					*esp_638 = (union Eq_2 *) tLoc1C;
					if (tLoc1C != edx_636)
					{
						fn00402C40(*esp_638);
						*esp_638 = (union Eq_2 *) tLoc24;
					}
					fn00402C40(*esp_638);
					tLoc24.u0 = 0x00;
					tLoc1C.u0 = 0x00;
					g_b414008 = bl_515;
				}
				if (g_dw4133A4 != 0x00 && (*((word32) dwArg04 + 9) & 0x08) != 0x00)
				{
					struct Eq_4103 * esp_681 = esp_157 - 4;
					esp_681->t0000 = *((word32) dwArg04 + 4);
					esp_681->tFFFFFFFC.u0 = 4011;
					esp_681->tFFFFFFF8.u0 = 0x00;
					word32 ecx_2262;
					word32 edx_2263;
					fn00403220(esp_681->tFFFFFFF8, esp_681->tFFFFFFFC, out ecx_2262, out edx_2263);
				}
			}
			else
			{
				if (*((word32) ecx_132 + 8) != 0x00)
				{
					if (dwLoc40_1415 != 0x00)
					{
						struct Eq_4205 * esp_434 = esp_157 - 4;
						esp_434->t0000 = *((word32) dwArg04 + 4);
						esp_434->tFFFFFFFC.u0 = 4004;
						esp_434->tFFFFFFF8.u0 = 0x00;
						word32 ecx_2264;
						word32 edx_2265;
						fn00403220(esp_434->tFFFFFFF8, esp_434->tFFFFFFFC, out ecx_2264, out edx_2265);
					}
					else
						dwLoc40_1415 = ecx_132;
				}
				Eq_2 eax_451 = dwLoc38_1418;
				if (dwLoc38_1418 <= esi_128)
					eax_451 = esi_128;
				dwLoc38_1418 = eax_451;
			}
l004024FE:
			esp_143 = esp_157;
			if ((*((word32) ecx_132 + 16) & 0x20) != 0x00 && *dwLoc30_1420 == 0x00)
			{
				byte al_716;
				byte al_709 = *((word32) dwArg04 + 9);
				*((word32) dwArg04 + 9) = al_709 & ~0x01;
				byte al_712 = al_709 & ~0x01 | 0x02;
				*((word32) dwArg04 + 9) = al_712;
				if (dwLoc28_1407 > 0x00)
					al_716 = al_712 | 0x04;
				else
					al_716 = al_712 & ~0x04;
				Eq_2 ecx_724 = tLoc34;
				*((word32) dwArg04 + 9) = al_716;
				if (ecx_724 <= dwLoc08_1416)
					ecx_724 = dwLoc08_1416;
				*((word32) dwArg04 + 0x0C) = ecx_724;
				*dwArg0C = (union Eq_2 *) ecx_724;
				goto l00402853;
			}
l0040250F:
			Eq_2 ecx_749 = *dwLoc30_1420;
			dwLoc30_1420 = ecx_749;
		} while (ecx_749 != 0x00);
	}
	g_t413A84.u0 = 0x00;
	g_t413A88.u0 = 0x00;
	Eq_2 esi_760 = *dwArg0C;
	if (esi_760 == 0x00)
	{
		Eq_2 ecx_767 = *((word32) dwArg04 + 0x0C);
		if (ecx_767 != 0x00)
			esi_760 = ecx_767;
		else
		{
			struct Eq_3062 * esp_780 = esp_143 - 4;
			esp_780->t0000 = fp - 44;
			Eq_2 edx_782 = *((word32) dwArg04 + 4);
			esp_780->ptrFFFFFFFC = &tLoc20;
			esp_780->tFFFFFFF8 = edx_782;
			if (fn0040CD20(esp_780->tFFFFFFF8) != 0x00)
			{
				esp_780->t0000 = &tLoc20;
				word32 ecx_2242;
				esi_760 = fn00404CA0(esp_780->t0000, out ecx_2242);
			}
		}
	}
	if ((*((word32) dwArg04 + 8) & 0x01) != 0x00)
	{
		struct Eq_3160 * esp_816 = esp_143 - 4;
		esp_816->t0000 = esi_760;
		esp_816->tFFFFFFFC = *((word32) dwArg04 + 4);
		esp_816->dwFFFFFFF8 = g_dw413010 * 0x02;
		fn00408D10(esp_816->t0000);
	}
	struct Eq_3099 * esp_840 = esp_143 - 4;
	esp_840->t0000 = fp + 20;
	esp_840->tFFFFFFFC = fp - 56;
	esp_840->tFFFFFFF8 = fp - 40;
	esp_840->tFFFFFFF4 = &tLoc1C;
	esp_840->tFFFFFFF0 = &tLoc24;
	esp_840->tFFFFFFEC = esi_760;
	esp_840->ptrFFFFFFE8 = fp - 332;
	esp_840->tFFFFFFE4 = dwArg04;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	Eq_2 stackArg8 = <invalid>;
	Eq_2 stackArg12 = <invalid>;
	Eq_2 stackArg16 = <invalid>;
	Eq_2 stackArg20 = <invalid>;
	Eq_2 stackArg24 = <invalid>;
	Eq_2 stackArg28 = <invalid>;
	Eq_2 stackArg32 = <invalid>;
	struct Eq_3144 * eax_896 = fn0040A500(&tLoc24, stackArg4, stackArg8, stackArg12, stackArg16, stackArg20, stackArg24, stackArg28, stackArg32);
	if (eax_896 != null && dwLoc40_1415 == 0x00)
	{
		g_t413A88 = fp - 332;
		dwLoc48_1414 = eax_896->t000C;
	}
	Eq_2 edx_915 = tLoc24;
	Eq_2 ecx_913 = *((word32) dwArg04 + 4);
	g_t413A90 = ecx_913;
	g_t413A8C = ecx_913;
	Eq_2 ecx_918 = tLoc1C;
	g_t413A94 = edx_915;
	g_t413A98 = ecx_918;
	word24 edx_24_8_1036 = SLICE(edx_915, word24, 8);
	if ((g_dw4133A4 != 0x00 && (*((word32) dwArg04 + 9) & 0x08) == 0x00 || dwLoc28_1407 == 0x00) && ((dwLoc38_1418 > esi_760 || g_dw4133B8 != 0x00 && dwLoc38_1418 == esi_760) || (esi_760 == 0x00 && dwLoc38_1418 == 0x00 || (*((word32) dwArg04 + 8) & 0x10) != 0x00)))
	{
		byte cl_991 = g_b414008;
		g_b414008 = 0x01;
		if (dwLoc40_1415 != 0x00)
		{
			if (dwArg14 == 0x00)
			{
				if (tLoc1C != 0x00)
					dwArg14 = *((byte) tLoc1C.u0 + 4);
				else
					dwArg14.u0 = 0x00;
			}
			esp_840->t0000 = dwArg14;
			esp_840->tFFFFFFFC = SEQ(edx_24_8_1036, *((word32) dwLoc40_1415 + 16));
			esp_840->tFFFFFFF8 = *((word32) dwLoc40_1415 + 0x0C);
			esp_840->tFFFFFFF4 = *((word32) dwLoc40_1415 + 8);
			Eq_2 eax_1124 = *((word32) dwArg04 + 4);
			esp_840->tFFFFFFF0 = eax_1124;
			dwLoc28_1407 = (word32) dwLoc28_1407 + fn004036C0(SLICE(eax_1124, word24, 8), esp_840->tFFFFFFF0, esp_840->tFFFFFFF4, esp_840->tFFFFFFFC);
		}
		else if (dwLoc48_1414 != 0x00)
		{
			Eq_2 dl_1064 = *((word32) dwArg04 + 8);
			esp_840->t0000 = dwArg14;
			Eq_2 eax_1073 = eax_896->t0010;
			esp_840->tFFFFFFFC = SEQ(edx_24_8_1036, dl_1064);
			esp_840->tFFFFFFF8 = eax_1073;
			Eq_2 edx_1080 = *((word32) dwArg04 + 4);
			esp_840->tFFFFFFF4 = dwLoc48_1414;
			esp_840->tFFFFFFF0 = edx_1080;
			dwLoc28_1407 = (word32) dwLoc28_1407 + fn004036C0(SLICE(eax_1073, word24, 8), esp_840->tFFFFFFF0, esp_840->tFFFFFFF4, esp_840->tFFFFFFFC);
		}
		else if ((g_b4133D4 & 0x10) != 0x00)
		{
			esp_840->t0000 = dwArg14;
			esp_840->tFFFFFFFC = SEQ(edx_24_8_1036, *((word32) dwLoc14 + 16));
			esp_840->tFFFFFFF8 = *((word32) dwLoc14 + 0x0C);
			esp_840->tFFFFFFF4 = *((word32) dwLoc14 + 8);
			Eq_2 eax_1048 = *((word32) dwArg04 + 4);
			esp_840->tFFFFFFF0 = eax_1048;
			dwLoc28_1407 = (word32) dwLoc28_1407 + fn004036C0(SLICE(eax_1048, word24, 8), esp_840->tFFFFFFF0, esp_840->tFFFFFFF4, esp_840->tFFFFFFFC);
		}
		else if (dwArg10 == 0x00 && esi_760 == 0x00)
		{
			if (g_dw4133A4 != 0x00)
				dwLoc28_1407.u0 = 0x01;
			else
			{
				esp_840->t0000 = *((word32) dwArg04 + 4);
				esp_840->tFFFFFFFC.u0 = 0x0431;
				esp_840->tFFFFFFF8.u0 = 0x00;
				word32 edx_2253;
				word32 ecx_2252;
				fn00403220(esp_840->tFFFFFFF8, esp_840->tFFFFFFFC, out ecx_2252, out edx_2253);
			}
		}
		g_b414008 = cl_991;
		if (dwLoc40_1415 == 0x00 && (dwLoc48_1414 == 0x00 && g_t413A98 != 0x00))
			tLoc34 = (Eq_2670) dwLoc38_1418;
		else
		{
			esp_840->t0000 = &tLoc34;
			fn0040CEA0(esp_840->t0000);
			tLoc34 = (Eq_2670) ((word32) tLoc34 + 2);
		}
		if (dwLoc44_1419 != null && dwLoc40_1415 != 0x00)
			*dwLoc44_1419 = (word32) tLoc34;
	}
	else if ((g_b4133D4 & 0x08) == 0x00 && (g_dw413010 == 0x01 && (*((word32) dwArg04 + 9) & 0x08) == 0x00))
	{
		esp_840->t0000 = *((word32) dwArg04 + 4);
		esp_840->tFFFFFFFC.u0 = 0x02;
		fn00403370();
	}
	if (g_dw4133A4 != 0x00 && dwLoc28_1407 != 0x00)
	{
		g_dw4133B0 = 0x00;
		if ((*((word32) dwArg04 + 9) & 0x08) != 0x00)
		{
			esp_840->t0000 = *((word32) dwArg04 + 4);
			esp_840->tFFFFFFFC.u0 = 4011;
		}
		else
		{
			if (g_dw413010 != 0x01)
				goto l004027D2;
			esp_840->t0000 = *((word32) dwArg04 + 4);
			esp_840->tFFFFFFFC.u0 = 0x0FAA;
		}
		esp_840->tFFFFFFF8.u0 = 0x00;
		word32 ecx_2254;
		word32 edx_2255;
		fn00403220(esp_840->tFFFFFFF8, esp_840->tFFFFFFFC, out ecx_2254, out edx_2255);
	}
l004027D2:
	if ((g_b4133D4 & 0x08) != 0x00 && g_dw413010 == 0x01)
	{
		Eq_2 eax_1316 = tLoc24;
		esp_840->t0000 = tLoc1C;
		if (tLoc1C != eax_1316)
		{
			fn00402C40(esp_840->t0000);
			esp_840->t0000 = tLoc24;
		}
		fn00402C40(esp_840->t0000);
		eax_1315 = SLICE(cond(g_dw413A50 - 0x01), bool, 1) + ~0x00;
	}
	else
	{
		byte al_1236;
		byte al_1226 = *((word32) dwArg04 + 9);
		*((word32) dwArg04 + 9) = al_1226 & ~0x01;
		byte al_1229 = al_1226 & ~0x01 | 0x02;
		*((word32) dwArg04 + 9) = al_1229;
		if (dwLoc28_1407 > 0x00)
			al_1236 = al_1229 | 0x04;
		else
			al_1236 = al_1229 & ~0x04;
		*((word32) dwArg04 + 9) = al_1236;
		Eq_2 eax_1246 = tLoc34;
		if (eax_1246 <= esi_760)
			eax_1246 = esi_760;
		Eq_2 ecx_1262 = tLoc24;
		*((word32) dwArg04 + 0x0C) = eax_1246;
		*dwArg0C = (union Eq_2 *) eax_1246;
		esp_840->t0000 = tLoc1C;
		if (tLoc1C != ecx_1262)
		{
			fn00402C40(esp_840->t0000);
			esp_840->t0000 = tLoc24;
		}
		fn00402C40(esp_840->t0000);
l00402853:
		eax_1315 = dwLoc28_1407;
	}
	return eax_1315;
}

// 00402870: Register word32 fn00402870(Stack Eq_2 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn004020E0
word32 fn00402870(Eq_2 dwArg04, ptr32 & edxOut)
{
	ptr32 fp;
	Eq_2 eax_7 = g_t413EE0;
	fn0040ACF0(eax_7, eax_7);
	struct Eq_4260 * esp_29 = fp - 0x38;
	ptr32 edx_113 = *dwArg04;
	if (edx_113 != 0x00)
	{
		do
		{
			Eq_2 ecx_42 = *((word32) esp_29[0x0A] + 4);
			Eq_2 eax_43 = ecx_42;
			if (*ecx_42 != 0x00)
			{
				do
				{
					byte dl_48 = *eax_43;
					if (dl_48 == 0x24)
						break;
					if (dl_48 == 0x5E)
						eax_43 = (word32) eax_43 + 1;
					eax_43 = (word32) eax_43 + 1;
				} while (*eax_43 != 0x00);
				if (*eax_43 == 0x00)
					goto l004028EE;
				Eq_2 eax_73 = esp_29[16];
				struct Eq_4314 * edx_75 = esp_29[0x0A];
				struct Eq_4318 * esp_76 = esp_29 - 4;
				esp_76->t0000 = esp_29 + 0x0D;
				g_t413A84 = eax_73;
				Eq_2 eax_79 = edx_75->t0004;
				esp_76->tFFFFFFFC = eax_79;
				word32 edx_665;
				fn0040B700(esp_76->tFFFFFFFC, esp_76->t0000, out edx_665);
				esp_76->t0030 = eax_79;
			}
			else
			{
l004028EE:
				esp_29[11] = (struct Eq_4260) ecx_42;
			}
			struct Eq_4348 * esp_93 = esp_29 - 4;
			esp_93->t0000 = esp_29[11];
			word32 ecx_666;
			word32 edx_667;
			Eq_2 eax_95 = fn0040ADD0(esp_93->t0000, out ecx_666, out edx_667);
			esp_93->t0034 = eax_95;
			esp_93->t0028 = eax_95;
			esp_93->t0000 = (char *) &esp_93->t0000 + 32;
			esp_93->ptrFFFFFFFC = (word32 *) &esp_93->t0028;
			struct Eq_4383 * esp_118 = (char *) &esp_93->t0000 + 4;
			if (fn00402B20(esp_93->ptrFFFFFFFC, esp_93->t0000, out edx_113) != 0x00)
			{
				do
				{
					Eq_2 esi_128 = esp_118[7];
					byte al_129 = *esp_118[7];
					if (al_129 == 0x7B)
					{
						if (al_129 != 0x00)
						{
							do
							{
								byte al_139 = *esi_128;
								if (al_139 == 0x7D)
									break;
								if (al_139 == 0x5E)
									esi_128 = (word32) esi_128 + 1;
								esi_128 = (word32) esi_128 + 1;
							} while (*esi_128 != 0x00);
						}
						if (*esi_128 != 0x00)
						{
							*esi_128 = 0x00;
							esp_118[7] = (struct Eq_4383) ((word32) esp_118[7] + 1);
							esi_128 = (word32) esi_128 + 1;
						}
					}
					else
						esp_118[7] = (struct Eq_4383) 0x00;
					struct Eq_4595 * esp_169 = esp_118 - 4;
					esp_169->t0000.u0 = 0x00;
					esp_169->dw0024 = 0x00;
					esp_169->ptrFFFFFFFC = (struct Eq_10420 **) (esp_118 + 4);
					fn00404CC0(esp_169->ptrFFFFFFFC, esp_169->t0000);
					esp_169->t0000 = esi_128;
					word32 edx_671;
					word32 ecx_670;
					Eq_2 eax_191 = fn0040ADD0(esp_169->t0000, out ecx_670, out edx_671);
					Eq_2 ebp_199 = eax_191;
					Eq_2 eax_215 = mbspbrk(esi_128, 0x00413000);
					ptr32 esp_220 = (char *) &esp_214->t0004 + 4;
					if (eax_215 != 0x00 || esp_214->t0024 != 0x00)
					{
						Eq_2 ecx_229 = esp_214->t0018;
						Eq_2 edx_230 = esp_214->t0024;
						esp_214->t0004 = (char *) &esp_214->t0018 + 4;
						esp_214->t0000 = ecx_229;
						esp_214->tFFFFFFFC = esi_128;
						esp_214->tFFFFFFF8 = edx_230;
						eax_215 = fn00405930(esp_214->tFFFFFFF8, esp_214->tFFFFFFFC);
						esp_220 = (char *) &esp_214->t0004 + 4;
						if (eax_215 != 0x00)
						{
							esp_214->t0004 = eax_191;
							esp_214->dw0028 = 0x01;
							free(esp_214->t0004);
							esp_214->t0004 = &esp_214->t0018;
							esp_214->t0004 = fn00404C90(esp_214->t0004);
							esp_214->t0000 = eax_215;
							eax_215 = fn0040C340(esp_214->t0000, esp_214->t0004);
							esi_128 = eax_215;
							esp_220 = (char *) &esp_214->t0004 + 4;
							ebp_199 = eax_215;
						}
					}
					do
					{
						struct Eq_4526 * esp_282 = esp_220 - 4;
						esp_282->t0000.u0 = 0x0C;
						fn0040ACF0(eax_215, esp_282->t0000);
						esp_282->t0000 = ebp_199;
						word32 ecx_668;
						word32 edx_669;
						*((word32) eax_215 + 4) = fn0040ADD0(esp_282->t0000, out ecx_668, out edx_669);
						if (g_dw4133A8 != 0x00)
						{
							esp_282->t0000 = (char *) &esp_282->t0000 + 24;
							esp_282->ptrFFFFFFFC = (char *) &esp_282->t0000 + 20;
							esp_282->tFFFFFFF8 = ebp_199;
							if (fn0040CD20(esp_282->tFFFFFFF8) != 0x00)
								goto l004029F5;
							((word32) eax_215 + 8)->u0 = 0x00;
						}
						else
						{
l004029F5:
							union Eq_2 * esp_329 = esp_220 - 4;
							*esp_329 = (union Eq_2 *) (esp_220 + 16);
							word32 ecx_672;
							*((word32) eax_215 + 8) = fn00404CA0(*esp_329, out ecx_672);
						}
						struct Eq_4698 * esp_343 = esp_220 - 4;
						esp_343->t0000 = eax_215;
						esp_343->tFFFFFFFC = esp_220 + 24;
						if (g_dw4133A8 != 0x00)
							fn00402AE0(esp_343->tFFFFFFFC, esp_343->t0000);
						else
							fn0040AE30(esp_343->tFFFFFFFC, esp_343->t0000);
						struct Eq_4732 * esp_368 = esp_220 - 4;
						esp_368->t0000 = ebp_199;
						free(esp_368->t0000);
						esp_220 = (char *) &esp_368->t0000 + 4;
						if (esp_368->dw0024 == 0x00)
							break;
						esp_220 = (char *) &esp_390->t0004 + 4;
						if (mbspbrk(esi_128, 0x00413000) == 0x00)
							break;
						esp_390->t0004 = esp_390->t001C;
						esp_390->t0000 = (char *) &esp_390->t0004 + 20;
						esp_220 = (char *) &esp_390->t0004 + 4;
						if (fn0040CE00(esp_390->t0000, esp_390->t0004) == 0x00)
							break;
						esp_390->t0004 = (char *) &esp_390->t0004 + 20;
						esp_390->t0004 = fn00404C90(esp_390->t0004);
						esp_390->t0000 = esi_128;
						eax_215 = fn0040C340(esp_390->t0000, esp_390->t0004);
						esp_220 = (char *) &esp_390->t0004 + 4;
						ebp_199 = eax_215;
					} while (eax_215 != 0x00);
					struct Eq_4750 * esp_443 = esp_220 - 4;
					esp_443->t0000 = esp_220 + 28;
					esp_443->ptrFFFFFFFC = esp_220 + 36;
					esp_118 = (struct Eq_4383 *) ((char *) &esp_443->t0000 + 4);
				} while (fn00402B20(esp_443->ptrFFFFFFFC, esp_443->t0000, out edx_113) != 0x00);
			}
			Eq_2 eax_461 = esp_118[11];
			if (*((word32) esp_118[0x0A] + 4) != eax_461)
			{
				union Eq_2 * esp_464 = esp_118 - 4;
				*esp_464 = (union Eq_2 *) eax_461;
				free(*esp_464);
			}
			struct Eq_4442 * esp_471 = esp_118 - 4;
			esp_471->t0000 = esp_118[0x0C];
			free(esp_471->t0000);
			struct Eq_4456 * eax_475 = esp_471->ptr002C->ptr0000;
			esp_471->ptr002C = eax_475;
			esp_29 = (struct Eq_4260 *) ((char *) &esp_471->t0000 + 4);
		} while (eax_475 != null);
	}
	free(eax_7);
	edxOut = edx_113;
	return 0x00;
}

// 00402AE0: void fn00402AE0(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00402870
void fn00402AE0(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 edx_13 = *dwArg04;
	Eq_2 eax_12 = *((word32) dwArg08 + 8);
	Eq_2 ecx_14 = edx_13;
	if (edx_13 != 0x00)
	{
		while (*((word32) ecx_14 + 8) >= eax_12)
		{
			edx_13 = ecx_14;
			ecx_14 = *ecx_14;
			if (ecx_14 == 0x00)
				break;
		}
	}
	if (edx_13 != ecx_14)
	{
		*edx_13 = dwArg08;
		*dwArg08 = ecx_14;
	}
	else
		*dwArg04 = dwArg08;
}

// 00402B20: Register word32 fn00402B20(Stack (ptr32 word32) dwArg04, Stack Eq_2 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn00402870
word32 fn00402B20(word32 * dwArg04, Eq_2 dwArg08, ptr32 & edxOut)
{
	ptr32 edx;
	byte * edi_101 = *dwArg04;
	while (*edi_101 != 0x00)
	{
		byte al_16 = *edi_101;
		if (al_16 != 0x20 && al_16 != 0x09)
			break;
		++edi_101;
	}
	*dwArg08 = edi_101;
	if (*edi_101 != 0x00)
	{
		*dwArg08 = edi_101;
		byte al_36 = *edi_101;
		if (al_36 == 0x22)
		{
			do
			{
				if (*edi_101 == 0x00)
					goto l00402C0E;
				++edi_101;
			} while (*edi_101 != 0x22);
			if (*edi_101 == 0x00)
			{
l00402C0E:
				word32 ecx_395;
				fn00403220(0x00, 0x040E, out ecx_395, out edx);
			}
			byte * edi_65 = edi_101 + 1;
			if (*edi_65 != 0x00)
			{
				*edi_65 = 0x00;
				++edi_65;
			}
			*dwArg04 = edi_65;
			edxOut = edx;
			return 0x01;
		}
		else
		{
			if (al_36 == 0x7B)
			{
				if (al_36 != 0x00)
				{
					do
					{
						byte al_95 = *edi_101;
						if (al_95 != 0x22)
						{
							++edi_101;
							if (*edi_101 == 0x7D)
								break;
						}
						else if (al_95 != 0x00)
						{
							while (*edi_101 != 0x22)
							{
								++edi_101;
								if (*edi_101 == 0x00)
									break;
							}
						}
					} while (*edi_101 != 0x00);
				}
				if (*edi_101 == 0x00)
				{
					word32 ecx_396;
					fn00403220(0x00, 0x0423, out ecx_396, out edx);
				}
				++edi_101;
				if (*edi_101 == 0x22)
				{
					do
					{
						if (*edi_101 == 0x00)
							goto l00402BAF;
						++edi_101;
					} while (*edi_101 != 0x22);
					if (*edi_101 == 0x00)
					{
l00402BAF:
						word32 ecx_397;
						fn00403220(0x00, 0x040E, out ecx_397, out edx);
					}
					byte * edi_209 = edi_101 + 1;
					if (*edi_209 != 0x00)
					{
						*edi_209 = 0x00;
						++edi_209;
					}
					*dwArg04 = edi_209;
					edxOut = edx;
					return 0x01;
				}
			}
			if (*edi_101 != 0x00)
			{
				do
				{
					byte al_147 = *edi_101;
					if (al_147 == 0x20 || al_147 == 0x09)
						break;
					++edi_101;
				} while (*edi_101 != 0x00);
				if (*edi_101 != 0x00)
				{
					*edi_101 = 0x00;
					++edi_101;
				}
			}
			*dwArg04 = edi_101;
			edxOut = edx;
			return 0x01;
		}
	}
	else
	{
		edxOut = edx;
		return 0x00;
	}
}

// 00402C40: void fn00402C40(Stack Eq_2 dwArg04)
// Called from:
//      fn00401F10
//      fn004020E0
//      fn00408190
//      fn0040A2A0
void fn00402C40(Eq_2 dwArg04)
{
	Eq_2 edi_13 = dwArg04;
	Eq_2 ebx_14 = dwArg04;
	if (dwArg04 != 0x00)
	{
		do
		{
			edi_13 = *edi_13;
			free(*((word32) ebx_14 + 4));
			fn0040ADA0(ebx_14);
			ebx_14 = edi_13;
		} while (edi_13 != 0x00);
	}
}

// 00402C70: void fn00402C70(Register Eq_2 eax, Stack Eq_2 dwArg04, Stack Eq_2 bArg08)
// Called from:
//      fn00402080
void fn00402C70(Eq_2 eax, Eq_2 dwArg04, Eq_2 bArg08)
{
	fn0040ACF0(eax, 0x14);
	word32 ecx_80;
	word32 edx_81;
	*((word32) eax + 4) = fn0040ADD0(dwArg04, out ecx_80, out edx_81);
	*((word32) eax + 8) = bArg08;
	*((word32) eax + 9) = 0x00;
	((word32) eax + 0x0C)->u0 = 0x00;
	((word32) eax + 16)->u0 = 0x00;
	fn0040AE10(fn0040AE50(dwArg04, 0x80, 0x01) * 0x04 + 4274216, eax);
}

// 00402CC0: void fn00402CC0(Stack Eq_2 dwArg04)
// Called from:
//      fn00408320
void fn00402CC0(Eq_2 dwArg04)
{
	ptr32 fp;
	struct Eq_72 * tLoc10;
	Eq_2 tLoc0C;
	ui32 tLoc08;
	tLoc08 = 0x00;
	Eq_2 eax_25 = fn0040CA80(dwArg04);
	g_t4133D8 = eax_25;
	if (eax_25 == 0x00)
	{
		word32 ecx_528;
		word32 edx_529;
		fn00403220(0x00, 0x041C, out ecx_528, out edx_529);
	}
	while (fgets(g_a413AA0, 0x0400, g_t4133D8) != null)
	{
		byte * edi_71 = g_a413AA0;
		word32 ecx_72 = ~0x00;
		while (ecx_72 != 0x00)
		{
			edi_71 = edi_534 + 1;
			--ecx_72;
			edi_534 = edi_71;
			if (*edi_534 != 0x00)
				break;
		}
		byte * ecx_116;
		struct Eq_5195 * ecx_84 = ~ecx_72;
		tLoc10 = ecx_84 - 0x01;
		if (ecx_84 == (struct Eq_5195 *) 0x0400)
		{
			ecx_116 = &ecx_84->b413A9E;
			if (ecx_84->b413A9E == 0x0A)
				goto l00402D56;
			goto l00402D72;
		}
l00402D56:
		struct Eq_72 * ecx_97 = tLoc10;
		ecx_116 = &ecx_97->b413A9F;
		if (ecx_97->b413A9F == 0x0A && tLoc10->b413A9E == 0x5C)
		{
l00402D72:
			struct Eq_72 * eax_112 = tLoc10;
			if (eax_112->b413A9E == 0x5C)
			{
				*ecx_116 = 0x00;
				--tLoc10;
				eax_112->b413A9E = 0x20;
			}
			word32 ecx_530;
			word32 edx_531;
			tLoc0C = fn0040ADD0(4274848, out ecx_530, out edx_531);
			fn00402E60(&tLoc0C, &tLoc10);
		}
		else
			tLoc0C.u0 = 4274848;
		fn00402F60(tLoc0C, &tLoc08, fp - 0x04);
		if (tLoc0C != 4274848)
			free(tLoc0C);
	}
	if (fclose(g_t4133D8) == ~0x00)
	{
		word32 ecx_532;
		word32 edx_533;
		fn00403220(0x00, 0x0424, out ecx_532, out edx_533);
	}
	fn00408320(tLoc08, null);
	ui32 dwLoc08_458 = tLoc08 - 0x01;
	if (tLoc08 != 0x00)
	{
		do
		{
			Eq_2 eax_299 = null[dwLoc08_535];
			if (eax_299 != 0x00)
				free(eax_299);
			dwLoc08_458 = dwLoc08_535 - 0x01;
			dwLoc08_535 = dwLoc08_458;
		} while (dwLoc08_535 != 0x00);
	}
	free(0x00);
}

// 00402E60: void fn00402E60(Stack (ptr32 Eq_2) dwArg04, Stack (ptr32 (ptr32 Eq_72)) dwArg08)
// Called from:
//      fn00402CC0
//      fn00402F60
void fn00402E60(union Eq_2 * dwArg04, struct Eq_72 ** dwArg08)
{
	if (*((char *) *dwArg04 + (*dwArg08 - 1)) != 0x0A)
	{
		while (fgets(g_a413AA0, 0x0400, g_t4133D8) != null)
		{
			byte * edi_37 = g_a413AA0;
			word32 ecx_38 = ~0x00;
			while (ecx_38 != 0x00)
			{
				edi_37 = edi_300 + 1;
				--ecx_38;
				edi_300 = edi_37;
				if (*edi_300 != 0x00)
					break;
			}
			struct Eq_5392 * ecx_50 = ~ecx_38;
			if (ecx_50->b413A9D == 0x5C && ecx_50->b413A9E == 0x0A)
			{
				ecx_50->b413A9E = 0x00;
				ecx_50->b413A9D = 0x20;
			}
			struct Eq_72 * edx_64 = *dwArg08;
			byte * edi_65 = g_a413AA0;
			word32 ecx_66 = ~0x00;
			while (ecx_66 != 0x00)
			{
				edi_65 = edi_301 + 1;
				--ecx_66;
				edi_301 = edi_65;
				if (*edi_301 != 0x00)
					break;
			}
			struct Eq_72 * eax_85 = edx_64 + (~ecx_66 - 1) / 4274848;
			*dwArg08 = (struct Eq_72 **) eax_85;
			Eq_2 eax_103 = realloc(*dwArg04, (char *) eax_85 + 1);
			*dwArg04 = (union Eq_2 *) eax_103;
			if (eax_103 == 0x00)
			{
				word32 ecx_298;
				word32 edx_299;
				fn00403220(g_t4133F4, 0x0419, out ecx_298, out edx_299);
			}
			byte * edi_123 = g_a413AA0;
			word32 ecx_124 = ~0x00;
			while (ecx_124 != 0x00)
			{
				++edi_123;
				--ecx_124;
				if (*edi_123 != 0x00)
					break;
			}
			uint32 ecx_136 = ~ecx_124;
			uint32 ecx_140;
			struct Eq_5486 * esi_141 = edi_123 - ecx_136;
			word32 edi_150 = Mem197[dwArg04 + 0x00:word32] + edx_64;
			for (ecx_140 = ecx_136 >> 0x02; ecx_140 != 0x00; --ecx_140)
			{
				edi_150->dw0000 = esi_141->dw0000;
				esi_141 += 4;
				edi_150 += 4;
			}
			ui32 ecx_155;
			for (ecx_155 = ecx_136 & 0x03; ecx_155 != 0x00; --ecx_155)
			{
				edi_150->dw0000 = esi_141->dw0000;
				++esi_141;
				++edi_150;
			}
			if (*((char *) *dwArg04 + (*dwArg08 - 1)) == 0x0A)
				return;
		}
	}
}

// 00402F60: void fn00402F60(Stack Eq_2 dwArg04, Stack (ptr32 word32) dwArg08, Stack (ptr32 Eq_2) dwArg0C)
// Called from:
//      fn00402CC0
//      fn00402F60
void fn00402F60(Eq_2 dwArg04, word32 * dwArg08, union Eq_2 * dwArg0C)
{
	ptr32 fp;
	word32 ebx_14 = 0x00;
	Eq_2 eax_26 = mbschr(dwArg04, 0x22);
	if (eax_26 != 0x00)
	{
		Eq_2 dwLoc08_479;
		if (dwArg04 != eax_26 && *((word32) eax_26 - 1) == 0x3D)
		{
			*eax_26 = 0x20;
			Eq_2 edi_113 = eax_26 - 0x01;
			bool v24_410 = dwArg04 == eax_26 - 0x01;
			if (dwArg04 < eax_26 - 0x01)
			{
				do
				{
					byte al_72 = *edi_113;
					if (al_72 == 0x20 || (al_72 == 0x09 || al_72 == 0x0A))
						break;
					--edi_113;
				} while (dwArg04 < edi_113);
				v24_410 = dwArg04 == edi_113;
			}
			if (!v24_410)
			{
				*edi_113 = 0x00;
				fn00403120(dwArg04);
				edi_113 = (word32) edi_113 + 1;
			}
			dwLoc08_479 = edi_113;
		}
		else
		{
			*eax_26 = 0x00;
			fn00403120(dwArg04);
			dwLoc08_479 = (word32) eax_26 + 1;
		}
		Eq_2 edi_118 = dwLoc08_479;
		word32 ecx_119 = ~0x00;
		Eq_2 ebp_122 = dwLoc08_479;
		while (ecx_119 != 0x00)
		{
			edi_118 = (word32) edi_654 + 1;
			--ecx_119;
			edi_654 = edi_118;
			if (*edi_654 != 0x00)
				break;
		}
		word32 dwLoc04_493 = ~ecx_119 - 0x01;
		if (*dwLoc08_479 != 0x00)
		{
			do
			{
				byte al_143 = *ebp_122;
				if (al_143 == 0x22)
				{
					byte * edi_199 = (word32) ebp_122 + 1;
					if (*edi_199 != 0x22)
					{
						*ebp_122 = 0x00;
						fn004031B0(dwLoc08_479, *dwArg08, dwArg0C);
						++*dwArg08;
						ebp_122 = (word32) ebp_122 + 1;
						fn00402F60((word32) ebp_122 + 1, dwArg08, dwArg0C);
						break;
					}
					word32 ecx_244 = ~0x00;
					while (ecx_244 != 0x00)
					{
						++edi_199;
						--ecx_244;
						if (*edi_199 != 0x00)
							break;
					}
					uint32 ecx_256 = ~ecx_244;
					uint32 ecx_260;
					struct Eq_5678 * esi_262 = edi_199 - ecx_256;
					Eq_2 edi_265 = ebp_122;
					for (ecx_260 = ecx_256 >> 0x02; ecx_260 != 0x00; --ecx_260)
					{
						*edi_265 = esi_262->dw0000;
						esi_262 += 4;
						edi_265 = (word32) edi_265 + 4;
					}
					ui32 ecx_269;
					for (ecx_269 = ecx_256 & 0x03; ecx_269 != 0x00; --ecx_269)
					{
						*edi_265 = esi_262->dw0000;
						++esi_262;
						edi_265 = (word32) edi_265 + 1;
					}
				}
				else if (al_143 == 0x5C)
				{
					byte al_148 = *((word32) ebp_122 - 1);
					if ((al_148 == 0x20 || al_148 == 0x09) && *((word32) ebp_122 + 1) == 0x0A)
					{
						*ebp_122 = 0x00;
						word32 v20_160 = dwLoc04_493 - 0x02;
						dwLoc04_493 = v20_160;
						if (ebx_14 == 0x00)
						{
							ebx_14 = 0x01;
							word32 edx_651;
							word32 ecx_650;
							dwLoc08_479 = fn0040ADD0(dwLoc08_479, out ecx_650, out edx_651);
						}
						fn00402E60(fp - 0x08, fp - 0x04);
						ebp_122 = (word32) dwLoc08_479 + v20_160;
					}
				}
				ebp_122 = (word32) ebp_122 + 1;
			} while (*ebp_122 != 0x00);
		}
		if ((word32) dwLoc08_479 + dwLoc04_493 == ebp_122)
		{
			word32 ecx_652;
			word32 edx_653;
			fn00403220(0x00, 0x03EE, out ecx_652, out edx_653);
		}
		if (ebx_14 != 0x00)
			free(dwLoc08_479);
	}
	else
		fn00403120(dwArg04);
}

// 00403120: void fn00403120(Stack Eq_2 dwArg04)
// Called from:
//      fn00402F60
void fn00403120(Eq_2 dwArg04)
{
	ptr32 fp;
	struct Eq_5788 * eax_19 = mbschr(dwArg04, 0x5C);
	if (eax_19 != null)
	{
		byte cl_27 = eax_19->bFFFFFFFF;
		if ((cl_27 == 0x20 || cl_27 == 0x09) && eax_19->b0001 == 0x0A)
			eax_19->b0000 = 0x00;
	}
	Eq_2 eax_118 = mbstok(dwArg04, 4272152);
	ptr32 esp_123 = (char *) esp_50 + 8;
	if (eax_118 == 0x00)
		return;
	ui32 * esi_59 = esp_50->ptr001C;
	union Eq_2 * edi_60 = esp_50->ptr0020;
	do
	{
		if (*eax_118 == 0x40)
		{
			struct Eq_5831 * esp_68 = esp_123 - 4;
			esp_68->dw0000 = (word32) eax_118 + 1;
			esp_68->tFFFFFFFC.u0 = 4001;
			esp_68->tFFFFFFF8.u0 = 0x00;
			word32 edx_190;
			word32 ecx_189;
			fn00403220(esp_68->tFFFFFFF8, esp_68->tFFFFFFFC, out ecx_189, out edx_190);
			return;
		}
		struct Eq_5859 * esp_91 = esp_123 - 4;
		esp_91->ptr0000 = edi_60;
		esp_91->dwFFFFFFFC = *esi_59;
		esp_91->tFFFFFFF8 = eax_118;
		fn004031B0(esp_91->tFFFFFFF8, esp_91->dwFFFFFFFC, esp_91->ptr0000);
		++*esi_59;
		eax_118 = mbstok(0x00, 4272152);
		esp_123 = fp - 0x0C;
	} while (eax_118 != 0x00);
}

// 004031B0: void fn004031B0(Stack Eq_2 dwArg04, Stack ui32 dwArg08, Stack (ptr32 Eq_2) dwArg0C)
// Called from:
//      fn00402F60
//      fn00403120
void fn004031B0(Eq_2 dwArg04, ui32 dwArg08, union Eq_2 * dwArg0C)
{
	Eq_2 eax_11 = *dwArg0C;
	if (eax_11 == 0x00)
	{
		fn0040ACF0(eax_11, 0x20);
		*dwArg0C = (union Eq_2 *) eax_11;
	}
	else if ((dwArg08 & 0x07) == 0x00)
	{
		Eq_2 eax_24 = realloc(eax_11, dwArg08 * 0x04 + 0x20);
		*dwArg0C = (union Eq_2 *) eax_24;
		if (eax_24 == 0x00)
		{
			word32 ecx_92;
			word32 edx_93;
			fn00403220(0x00, 1051, out ecx_92, out edx_93);
		}
	}
	word32 edx_91;
	word32 ecx_90;
	*((char *) *dwArg0C + dwArg08 * 0x04) = (union Eq_2 *) fn0040ADD0(dwArg04, out ecx_90, out edx_91);
}

// 00403220: Register uint32 fn00403220(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out (ptr32 Eq_105) ecxOut, Register out Eq_106 edxOut)
// Called from:
//      fn00401030
//      fn00401170
//      fn00401230
//      fn004015E0
//      fn00401710
//      fn00401870
//      fn00401980
//      fn004019F0
//      fn00401BF0
//      fn00401F10
//      fn004020E0
//      fn00402B20
//      fn00402CC0
//      fn00402E60
//      fn00402F60
//      fn00403120
//      fn004031B0
//      fn004036C0
//      fn00403AF0
//      fn004043A0
//      fn00404680
//      fn00404830
//      fn004048B0
//      fn00404DE0
//      fn00404F80
//      fn004050B0
//      fn004051E0
//      fn00405530
//      fn00405710
//      fn00405860
//      fn00405A20
//      fn00405C20
//      fn00405E60
//      fn00406020
//      fn004065D0
//      fn00406A80
//      fn00407070
//      fn00407550
//      fn004075C0
//      fn00407680
//      fn00407F70
//      fn00408190
//      fn00408320
//      fn004085F0
//      fn004086D0
//      fn00408AE0
//      fn00409620
//      fn00409690
//      fn00409730
//      fn00409800
//      fn00409AE0
//      fn00409B70
//      fn00409BE0
//      fn00409D70
//      fn00409DE0
//      fn00409E80
//      fn00409EF0
//      fn0040A2A0
//      fn0040ACC0
//      fn0040AD20
//      fn0040B110
//      fn0040B520
//      fn0040B5D0
//      fn0040B700
//      fn0040BB00
//      fn0040BB90
//      fn0040C170
//      fn0040C3A0
//      fn0040C510
//      fn0040C790
uint32 fn00403220(Eq_2 dwArg04, Eq_2 dwArg08, struct Eq_105 & ecxOut, union Eq_106 & edxOut)
{
	Eq_106 edx_234;
	uint32 eax_233;
	struct Eq_105 * ecx_21;
	int32 esi_108 = 0x02;
	if ((g_b4133D4 & 0x20) != 0x00)
	{
		uint64 edx_eax_24 = (uint64) dwArg08;
		ecx_21 = (struct Eq_105 *) 1000;
		edx_234.u0 = (uint32) (edx_eax_24 % 1000);
		eax_233 = (uint32) (edx_eax_24 /u 1000);
		if (eax_233 == 0x04)
			goto l0040335C;
	}
	int32 (* ebx_139)(FILE *, char *, word32);
	<anonymous> * edi_136;
	struct Eq_5968 * esp_105;
	fn00403420();
	if (dwArg04 != 0x00)
	{
		esp_71->ptrFFFFFFFC = _p__iob(0x00413040, g_t4133F8, dwArg04) + 0x40;
		fprintf(esp_71->ptrFFFFFFFC, esp_71->ptr0000, 0x00);
		edi_136 = _p__iob;
		ebx_139 = fprintf;
		esp_105 = (struct Eq_5968 *) ((char *) &esp_71->ptr0000 + 0x0C);
	}
	else
	{
		esp_50->ptrFFFFFFFC = _p__iob(0x00413030, 0x00413038) + 0x40;
		fprintf(esp_50->ptrFFFFFFFC, esp_50->ptr0000, 0x00);
		edi_136 = _p__iob;
		ebx_139 = fprintf;
		esp_105 = (struct Eq_5968 *) ((char *) &esp_50->ptr0000 + 8);
	}
	uint32 eax_92 = (uint32) ((uint64) esp_105->dw0018 /u 1000);
	if (eax_92 == 0x01)
	{
		struct Eq_6047 * esp_96 = esp_105 - 4;
		esp_96->dw0000 = 0x14;
		fn00403370();
		esp_105 = (struct Eq_5968 *) (&esp_96->dw0000 + 1);
		if (esp_96->dw001C == 1051)
			esi_108 = 0x04;
		goto l004032E4;
	}
	word32 * esp_111;
	if (eax_92 != 0x02)
	{
		if (eax_92 != 0x04)
			goto l004032E4;
		esp_111 = esp_105 - 4;
		*esp_111 = 22;
	}
	else
	{
		esp_111 = esp_105 - 4;
		*esp_111 = 0x15;
	}
	fn00403370();
	esp_105 = (struct Eq_5968 *) (esp_111 + 1);
l004032E4:
	word32 eax_130 = esp_105->dw0018;
	struct Eq_6084 * esp_131 = esp_105 - 4;
	esp_131->dw0000 = eax_130;
	esp_131->dwFFFFFFFC = 0x00413024;
	struct Eq_6094 * esp_149;
	word32 eax_151;
	edi_136();
	esp_149->dwFFFFFFFC = eax_151 + 0x40;
	struct Eq_6101 * esp_159;
	ebx_139();
	byte * ecx_166 = esp_159->ptr0024;
	esp_159->ptr0008 = (char *) &esp_159->ptr0024 + 4;
	esp_159->ptr0004 = ecx_166;
	esp_159->ptr0004 = fn00403410(esp_159->ptr0004);
	word32 eax_185;
	edi_136();
	MSVCRT20.dll!vfprintf(eax_185 + 0x40);
	word32 eax_203;
	edi_136();
	MSVCRT20.dll!putc(0x0A, eax_203 + 0x40);
	word32 eax_223;
	edi_136();
	eax_233 = MSVCRT20.dll!fflush(eax_223 + 0x40);
	if (eax_92 == 0x01)
	{
		*esp_231 = 0x0041301C;
		struct Eq_6149 * esp_252;
		word32 eax_254;
		edi_136();
		esp_252->dwFFFFFFFC = eax_254 + 0x40;
		struct Eq_6156 * esp_262;
		ebx_139();
		fn00408A20();
		esp_262->dw0004 = esi_108;
		exit(esp_262->dw0004);
	}
l0040335C:
	ecxOut = ecx_21;
	edxOut = edx_234;
	return eax_233;
}

// 00403370: void fn00403370()
// Called from:
//      fn004020E0
//      fn00403220
//      fn00403420
//      fn00403490
//      fn00404C10
//      fn00404DE0
//      fn00408D10
//      fn00408D80
//      fn00409000
//      fn004090A0
//      fn00409170
//      fn0040A500
void fn00403370()
{
	word32 edi_18 = _p__iob() + 32;
	if ((g_b4133D4 & 0x20) == 0x00)
	{
		fn00403420();
		struct Eq_6188 * esp_20 = esp_11;
		if (esp_11->ptr000C >= (byte *) 0x14 && esp_11->ptr000C <= (byte *) 0x19)
			edi_18 = _p__iob() + 64;
		<anonymous> * esi_39;
		if (esp_20->ptr000C == (byte *) 0x18)
		{
			MSVCRT20.dll!putc(0x0A, edi_18);
			esi_39 = MSVCRT20.dll!putc;
			esp_20 = esp_47 + 0x08;
		}
		else
			esi_39 = MSVCRT20.dll!putc;
		byte * ecx_57 = esp_20->ptr000C;
		struct Eq_6224 * esp_58 = esp_20 - 4;
		esp_58->ptr0000 = (char *) &esp_20->ptr000C + 4;
		esp_58->ptrFFFFFFFC = ecx_57;
		MSVCRT20.dll!vfprintf(edi_18, fn00403410(esp_58->ptrFFFFFFFC));
		if ((esp_77->dw0018 < 0x0A || esp_77->dw0018 > 0x17) && esp_77->dw0018 != 0x78)
		{
			esp_77->dw0008 = edi_18;
			esp_77->dw0004 = 0x0A;
			esi_39();
		}
		MSVCRT20.dll!fflush(edi_18);
	}
}

// 00403400: void fn00403400()
// Called from:
//      fn00403420
//      fn004036C0
//      fn00407C30
void fn00403400()
{
}

// 00403410: Register word32 fn00403410(Stack (ptr32 byte) dwArg04)
// Called from:
//      fn00403220
//      fn00403370
//      fn00403490
word32 fn00403410(byte * dwArg04)
{
	return fn0040A660(dwArg04);
}

// 00403420: void fn00403420()
// Called from:
//      fn00403220
//      fn00403370
//      fn00407F70
void fn00403420()
{
	if (g_dw4133CC == 0x00)
	{
		g_dw4133CC = 0x01;
		fn00403400();
		fn00403400();
		fn00403370();
		fn00403370();
		MSVCRT20.dll!fflush(_p__iob() + 0x40);
	}
}

// 00403490: void fn00403490()
// Called from:
//      fn00408320
void fn00403490()
{
	ptr32 fp;
	up32 esi_14;
	up32 ebp_18 = 0x00;
	for (esi_14 = 100; esi_14 < 0x67; ++esi_14)
		fn00403370();
	byte * ebx_189 = (byte *) 0x67;
	do
	{
		if (ebx_189 == (byte *) 111)
			++ebx_189;
		if (ebx_189 == (byte *) 0x77)
			++ebx_189;
		if (ebx_189 == (byte *) 0x78)
			break;
		if (ebp_18 == 0x00)
		{
			byte * edi_144 = fn00403410(ebx_189);
			word32 ecx_145 = ~0x00;
			while (ecx_145 != 0x00)
			{
				++edi_144;
				--ecx_145;
				if (*edi_144 != 0x00)
					break;
			}
			uint32 ecx_157 = ~ecx_145;
			uint32 ecx_161;
			struct Eq_6338 * esi_163 = edi_144 - ecx_157;
			struct Eq_6340 * edi_166 = fp - 0xA0;
			for (ecx_161 = ecx_157 >> 0x02; ecx_161 != 0x00; --ecx_161)
			{
				edi_166->dw0000 = esi_163->dw0000;
				esi_163 += 4;
				edi_166 += 4;
			}
			ui32 ecx_170;
			for (ecx_170 = ecx_157 & 0x03; ecx_170 != 0x00; --ecx_170)
			{
				edi_166->dw0000 = esi_163->dw0000;
				++esi_163;
				++edi_166;
			}
		}
		else
		{
			byte * edi_359 = fn00403410(ebx_189);
			word32 ecx_73 = ~0x00;
			while (ecx_73 != 0x00)
			{
				++edi_359;
				--ecx_73;
				if (*edi_359 != 0x00)
					break;
			}
			uint32 ecx_85 = ~ecx_73;
			uint32 ecx_135;
			struct Eq_6380 * esi_120 = edi_359 - ecx_85;
			struct Eq_6382 * edi_123 = fp - 0x50;
			for (ecx_135 = ecx_85 >> 0x02; ecx_135 != 0x00; --ecx_135)
			{
				edi_123->dw0000 = esi_120->dw0000;
				esi_120 += 4;
				edi_123 += 4;
			}
			ui32 ecx_101;
			for (ecx_101 = ecx_85 & 0x03; ecx_101 != 0x00; --ecx_101)
			{
				edi_123->dw0000 = esi_120->dw0000;
				++esi_120;
				++edi_123;
			}
			fn00403370();
		}
		++ebx_189;
		ebp_18 = (word32) (ebp_18 < 0x01);
	} while (ebx_189 < (byte *) 0x78);
	if (ebp_18 != 0x00)
		fn00403370();
	fn00403370();
}

// 00403580: void fn00403580(Stack (ptr32 word32) dwArg04, Stack (ptr32 Eq_6453) dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      fn00403AF0
void fn00403580(word32 * dwArg04, struct Eq_6453 * dwArg08, Eq_2 dwArg0C)
{
	word32 ebx_13 = 0x01;
	Eq_2 edi_14 = dwArg0C;
	Eq_2 esi_177 = dwArg0C;
	if (*dwArg0C != 0x00)
	{
		do
			edi_14 = (word32) edi_14 + 1;
		while (*edi_14 != 0x00);
	}
	*dwArg04 = 0x00;
	struct Eq_6453 * ebp_251 = dwArg08;
	while (edi_14 > esi_177)
	{
		struct Eq_6480 * esp_121 = esp_44 + 0x08;
		Eq_2 esi_50 = (word32) esi_177 + mbsspn(esi_177, 0x00413008);
		if (edi_14 <= esi_50)
			break;
		Eq_2 esi_101;
		ebp_251->dw0000 = (word32) esi_50;
		++ebp_251;
		if (*esi_50 == 0x22)
		{
			esi_177 = (word32) esi_50 + 1;
			if (edi_14 <= (word32) esi_50 + 1)
				goto l0040369B;
			do
			{
				byte al_182 = *esi_177;
				if (al_182 == 0x5C)
					esi_177 = (word32) esi_177 + 1;
				else if (al_182 == 0x22)
					break;
				esi_177 = (word32) esi_177 + 1;
			} while (edi_14 > esi_177);
			if (edi_14 <= esi_177)
				goto l0040369B;
			esp_121 = esp_217 + 0x08;
			esi_101 = mbspbrk((word32) esi_177 + 1, 0x00413008);
			goto l00403691;
		}
		Eq_2 eax_63 = mbspbrk(esi_50, 4272864);
		esp_121 = esp_61 + 0x08;
		esi_101 = eax_63;
		if (eax_63 != 0x00)
		{
			while (edi_14 > esi_101 && (*esi_101 == 0x2F && ebx_13 == 0x00))
			{
				Eq_2 eax_93 = mbspbrk((word32) esi_101 + 1, 4272864);
				esp_121 = esp_91 + 0x08;
				esi_101 = eax_93;
				if (eax_93 == 0x00)
					break;
			}
			if (esi_101 != 0x00 && *esi_101 == 0x22)
			{
				Eq_2 esi_108 = (word32) esi_101 + 1;
				if (edi_14 > esi_108)
				{
					while (*esi_108 != 0x22)
					{
						esi_108 = (word32) esi_108 + 1;
						if (edi_14 <= esi_108)
							break;
					}
				}
				esp_121 = esp_138 + 0x08;
				esi_101 = mbspbrk(esi_108, 0x00413008);
			}
		}
		if (ebx_13 != 0x00)
		{
			ebx_13 = 0x00;
			if (esi_101 == 0x00)
				goto l00403695;
			if (*esi_101 == 0x2F)
			{
				*esi_101 = 0x00;
				union Eq_2 * esp_165 = esp_121 - 4;
				*esp_165 = ebp_251->dwFFFFFFFC;
				word32 edx_418;
				word32 ecx_417;
				ebp_251->dwFFFFFFFC = (word32) fn0040ADD0(*esp_165, out ecx_417, out edx_418);
				--esi_101;
				*((word32) esi_101 + 1) = 0x2F;
				esp_121 = (struct Eq_6480 *) ((char *) esp_165 + 4);
			}
		}
l00403691:
		if (esi_101 == 0x00)
		{
l00403695:
			esi_101 = edi_14;
		}
		*esi_101 = 0x00;
		esi_177 = (word32) esi_101 + 1;
l0040369B:
		up32 * ecx_245 = esp_121->ptr0014;
		up32 eax_246 = *ecx_245;
		*ecx_245 = eax_246 + 0x01;
		if (eax_246 >= 0x7E)
			break;
	}
	ebp_251->dw0000 = 0x00;
}

// 004036C0: Register word32 fn004036C0(Register ui24 eax_24_8, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 bArg10)
// Called from:
//      fn004020E0
word32 fn004036C0(ui24 eax_24_8, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 bArg10)
{
	ptr32 fp;
	++g_dw413A50;
	if ((g_b4133D4 & 0x08) != 0x00)
		return;
	fn00403400();
	ptr32 esp_31 = fp - 0x28;
	if ((g_b4133D4 & 0x10) == 0x00)
	{
		Eq_2 edi_35 = dwArg08;
		if (dwArg08 != 0x00)
		{
			do
			{
				struct Eq_7304 * esp_43 = esp_31 - 4;
				esp_43->ptr0000 = esp_31 + 52;
				Eq_2 edx_46 = *((word32) edi_35 + 4);
				esp_43->ptrFFFFFFFC = esp_31 + 28;
				esp_43->tFFFFFFF8 = edx_46;
				word32 edx_53;
				word32 eax_51 = fn00406020(esp_43->tFFFFFFF8, out edx_53);
				byte * ecx_59 = esp_43->ptr0020;
				esp_43->dw0028 = eax_51;
				esp_43->b0017 = 0x00;
				g_t413A4C.u0 = 0x00;
				esp_43->ptr0018 = ecx_59;
				word24 edx_24_8_284 = SLICE(edx_53, word24, 8);
				struct Eq_6731 * esp_110 = &esp_43->ptr0000 + 1;
				byte bl_126 = *ecx_59;
				if (bl_126 != 0x00)
				{
					do
					{
						byte al_70 = *ecx_59;
						if (al_70 == 0x5E || al_70 == 0x24)
							++ecx_59;
						++ecx_59;
					} while (*ecx_59 != 0x00);
				}
				while (bl_126 == 33 || (bl_126 == 0x2D || (bl_126 == 0x40 || (bl_126 == 0x5E || (bl_126 == 0x20 || bl_126 == 0x09)))))
				{
					Eq_6717 eax_98 = (int32) bl_126;
					if (eax_98 <= 0x5E)
					{
						switch (eax_98)
						{
						case 33:
							esp_110->b0013 |= 0x04;
							break;
						case 0x22:
						case 0x23:
						case 0x24:
						case 0x25:
						case 0x26:
						case 0x27:
						case 0x28:
						case 0x29:
						case 0x2A:
						case 0x2B:
						case 44:
						case 0x2E:
						case 0x2F:
						case 0x30:
						case 0x31:
						case 0x32:
						case 0x33:
						case 0x34:
						case 0x35:
						case 0x36:
						case 55:
						case 0x38:
						case 0x39:
						case 0x3A:
						case 0x3B:
						case 0x3C:
						case 0x3D:
						case 0x3E:
						case 0x3F:
						case 0x41:
						case 66:
						case 0x43:
						case 0x44:
						case 0x45:
						case 0x46:
						case 0x47:
						case 0x48:
						case 0x49:
						case 0x4A:
						case 0x4B:
						case 0x4C:
						case 77:
						case 0x4E:
						case 0x4F:
						case 0x50:
						case 0x51:
						case 0x52:
						case 0x53:
						case 0x54:
						case 0x55:
						case 0x56:
						case 0x57:
						case 88:
						case 0x59:
						case 0x5A:
						case 0x5B:
						case 0x5C:
						case 0x5D:
							break;
						case 0x2D:
							edx_24_8_284 = SLICE(edx_159, word24, 8);
							esp_110 = (struct Eq_6731 *) ((char *) &esp_156->t0000 + 4);
							if (ismbcdigit((int32) *esp_110[5], esp_110->b0013 | 0x02, (word32) esp_110[5] + 1) != 0x00)
							{
								Eq_2 ebp_167 = esp_156->t0018;
								esp_156->t0000.u0 = 0x0A;
								Eq_2 ecx_171 = esp_156->t0018;
								esp_156->tFFFFFFFC = &esp_156->t0018;
								esp_156->tFFFFFFF8 = ecx_171;
								g_t413A4C = strtol(esp_156->tFFFFFFF8, esp_156->tFFFFFFFC, esp_156->t0000);
								if (*_errno() == 0x22)
								{
									Eq_2 eax_182 = esp_156->t0018;
									esp_156->t0000 = ebp_167;
									esp_156->tFFFFFFFC.u0 = 0x0436;
									*eax_182 = 0x00;
									esp_156->tFFFFFFF8 = g_t4133F4;
									word32 ecx_978;
									word32 edx_979;
									fn00403220(esp_156->tFFFFFFF8, esp_156->tFFFFFFFC, out ecx_978, out edx_979);
								}
								edx_24_8_284 = SLICE(edx_214, word24, 8);
								esp_110 = esp_211 + 0x04;
								if (ismbcspace((int32) *esp_156->t0018) == 0x00)
									goto l00403858;
								do
								{
									edx_24_8_284 = SLICE(edx_243, word24, 8);
									esp_110 = (struct Eq_6731 *) ((char *) esp_240 + 4);
									esp_984 = esp_110;
								} while (ismbcspace((int32) *esp_984[5], (word32) esp_984[5] + 1) != 0x00);
								--esp_240->dw0018;
							}
							else
							{
								g_t413A4C.u0 = 0xFF;
l00403858:
								esp_110[5] = (struct Eq_6731) (esp_110[5] - 0x01);
							}
							break;
						case 0x40:
							if ((g_t4133D0 & 0x04) == 0x00)
								esp_110->b0013 |= 0x01;
							break;
						case 0x5E:
							up32 eax_118;
							esp_110[5] = (struct Eq_6731) ((word32) esp_110[5] + 1);
							byte al_114 = *esp_110[5];
							if (al_114 != 0x20)
							{
								eax_118 = 0x00;
								if (al_114 == 0x09)
									goto l00403885;
							}
							else
							{
l00403885:
								eax_118 = 0x01;
							}
							bl_126 = (0x00 - (byte) (eax_118 < 0x01) & 0x3E) + 0x20;
							break;
						}
					}
					if (bl_126 == 0x5E)
						break;
					esp_110[5] = (struct Eq_6731) ((word32) esp_110[5] + 1);
					bl_126 = (byte) *esp_110[5];
				}
				if ((esp_110->b0013 & 0x04) != 0x00)
				{
					union Eq_2 * eax_274 = esp_110 + 6;
					Eq_2 ecx_275 = esp_110[0x0F];
					byte dl_276 = esp_110->b0013;
					struct Eq_6993 * esp_277 = esp_110 - 4;
					esp_277->ptr0000 = eax_274;
					byte al_279 = esp_277->b003C;
					esp_277->tFFFFFFFC = ecx_275;
					Eq_2 ecx_282 = esp_277->t0038;
					esp_277->tFFFFFFF8 = SEQ(edx_24_8_284, dl_276);
					Eq_2 edx_296 = esp_277->t0018;
					esp_277->tFFFFFFF4 = SEQ(SLICE(eax_274, word24, 8), al_279);
					esp_277->tFFFFFFF0 = ecx_282;
					esp_277->tFFFFFFEC = edx_296;
					if (fn004048B0(esp_277->tFFFFFFEC, esp_277->tFFFFFFF0, esp_277->tFFFFFFF4, esp_277->tFFFFFFF8, esp_277->tFFFFFFFC, esp_277->ptr0000) == 0x00)
						goto l00403951;
					Eq_2 ebx_525 = esp_277->t0018;
					if (mbschr(esp_277->t0018, 0x24) != 0x00)
					{
						Eq_2 ecx_547 = esp_536->t001C;
						esp_536->t0004 = (char *) &esp_536->t0020 + 28;
						esp_536->t0000 = ecx_547;
						word32 edx_980;
						fn0040B700(esp_536->t0000, esp_536->t0004, out edx_980);
						esp_536->t001C = (char *) &esp_536->t0020 + 28;
					}
					if (ebx_525 != esp_536->t001C)
					{
						esp_536->t0004 = esp_536->t001C;
						free(esp_536->t0004);
					}
					esp_31 = (char *) &esp_536->t0004 + 4;
					if ((esp_536->b0040 & 0x02) == 0x00 && (g_dw4133A4 != 0x00 && (esp_536->t0020 != 0x00 && esp_536->t0020 > g_t413A4C)))
						break;
					goto l00403A63;
				}
l00403951:
				struct Eq_6731 * esp_316 = esp_110;
				byte * ebp_319 = esp_110[5];
				if (esp_110[9] == 0x00)
				{
					esp_316 = (struct Eq_6731 *) ((char *) &esp_354->t0004 + 4);
					if (mbschr(esp_110[5], 0x24) != 0x00)
					{
						Eq_2 ecx_365 = esp_354->t001C;
						esp_354->t0004 = (char *) &esp_354->t001C + 32;
						esp_354->t0000 = ecx_365;
						word32 edx_981;
						fn0040B700(esp_354->t0000, esp_354->t0004, out edx_981);
						esp_354->t001C = (char *) &esp_354->t001C + 32;
						esp_316 = (struct Eq_6731 *) ((char *) &esp_354->t0004 + 4);
					}
				}
				Eq_2 ecx_403;
				Eq_2 ecx_381 = esp_316[5];
				struct Eq_7126 * esp_382 = esp_316 - 4;
				esp_382->t0000 = esp_316[0x0F];
				esp_382->tFFFFFFFC = ecx_381;
				esp_382->tFFFFFFF8.u0 = 0x00411250;
				fn0040C790(esp_382->tFFFFFFF8, esp_382->tFFFFFFFC, esp_382->t0000);
				byte al_396 = esp_382->b003C;
				if ((al_396 & 0x04) != 0x00)
				{
					ecx_403.u0 = 0x00;
					if ((esp_382->b0017 & 0x08) != 0x00)
						goto l004039AB;
				}
				else
				{
l004039AB:
					ecx_403.u0 = 0x01;
				}
				Eq_2 edx_421;
				if ((al_396 & 0x04) == 0x00 && ((esp_382->b003C & 0x08) != 0x00 || (esp_382->b0017 & 0x01) != 0x00))
					edx_421.u0 = 0x00;
				else
					edx_421.u0 = 0x01;
				esp_382->t0000 = &esp_382->t0024;
				esp_382->tFFFFFFFC = SEQ(SLICE(&esp_382->t0024, word24, 8), esp_382->b0017) & 0x02;
				esp_382->tFFFFFFF8 = ecx_403;
				esp_382->tFFFFFFF4 = edx_421;
				esp_382->tFFFFFFF0.u0 = 0x00411250;
				Eq_2 eax_450 = fn00403AF0(ecx_403, esp_382->tFFFFFFF0, esp_382->tFFFFFFF8);
				byte bl_458 = esp_382->b003C;
				esp_382->t001C = eax_450;
				if ((bl_458 & 0x02) == 0x00 && (eax_450 != 0x00 && (esp_382->t001C > g_t413A4C && g_dw4133A4 == 0x00)))
				{
					Eq_2 ecx_473 = esp_382->t0024;
					esp_382->t0000 = esp_382->t001C;
					esp_382->tFFFFFFFC = ecx_473;
					esp_382->tFFFFFFF8.u0 = 1077;
					esp_382->tFFFFFFF4.u0 = 0x00;
					word32 ecx_982;
					word32 edx_983;
					fn00403220(esp_382->tFFFFFFF4, esp_382->tFFFFFFF8, out ecx_982, out edx_983);
				}
				if (ebp_319 != esp_316[5])
				{
					union Eq_2 * esp_503 = esp_316 - 4;
					*esp_503 = (union Eq_2 *) esp_316[5];
					free(*esp_503);
				}
				struct Eq_7408 * esp_510 = esp_316 - 4;
				esp_510->t0000 = esp_316[7];
				free(esp_510->t0000);
				esp_31 = (char *) &esp_510->t0000 + 4;
				if ((bl_458 & 0x02) == 0x00 && (g_dw4133A4 != 0x00 && (esp_510->t001C != 0x00 && esp_510->t001C > g_t413A4C)))
					break;
l00403A63:
				edi_35 = *edi_35;
			} while (edi_35 != 0x00);
		}
		if ((bArg10 & 0x02) != 0x00 || g_dw4133A4 == 0x00)
			return;
		return;
	}
	else
	{
		fn00404C10(dwArg04, SEQ(eax_24_8, bArg10) & 0x04);
		return;
	}
}

// 00403AF0: Register word32 fn00403AF0(Register Eq_2 ecx, Stack Eq_2 dwArg04, Stack Eq_2 dwArg0C)
// Called from:
//      fn004036C0
//      fn004048B0
//      fn00409A90
word32 fn00403AF0(Eq_2 ecx, Eq_2 dwArg04, Eq_2 dwArg0C)
{
	ptr32 fp;
	g_t413A54.u0 = 0x00;
	struct Eq_7461 * esp_112 = fp - 0x0230;
	word32 ebp_20 = 0x00;
	if (g_dw413A58 == 0x00)
		g_dw413A58 = fn00404830(ecx);
	int32 eax_36 = (int32) *dwArg04;
	if (eax_36 == 0x2D)
	{
		esp_112 = (struct Eq_7461 *) ((char *) &esp_52->t0000 + 4);
		if (ismbcdigit((int32) *((word32) dwArg04 + 1)) != 0x00)
		{
			Eq_2 esi_63 = esp_52->t0238;
			esp_52->t0000.u0 = 0x0A;
			Eq_2 ecx_67 = esp_52->t0238;
			esp_52->tFFFFFFFC = &esp_52->t0238;
			esp_52->tFFFFFFF8 = ecx_67;
			g_t413A4C = strtol(esp_52->tFFFFFFF8, esp_52->tFFFFFFFC, esp_52->t0000);
			if (*_errno() == 0x22)
			{
				Eq_2 eax_78 = esp_52->t0238;
				esp_52->t0000 = esi_63;
				esp_52->tFFFFFFFC.u0 = 0x0436;
				esp_52->tFFFFFFF8.u0 = 0x00;
				*eax_78 = 0x00;
				word32 ecx_1390;
				word32 edx_1391;
				fn00403220(esp_52->tFFFFFFF8, esp_52->tFFFFFFFC, out ecx_1390, out edx_1391);
			}
			esp_112 = esp_106 + 0x04;
			if (ismbcspace((int32) *esp_52->t0238) != 0x00)
			{
				do
				{
					esp_112 = esp_130 + 0x04;
					esp_1405 = esp_112;
				} while (ismbcspace((int32) *esp_1405->ptr0234, esp_1405->ptr0234 + 1) != 0x00);
			}
		}
		else
			g_t413A4C.u0 = 0xFF;
	}
	word32 eax_1025;
	if (*esp_112->ptr0234 == 0x00)
	{
l00404166:
		eax_1025 = 0x00;
		return eax_1025;
	}
	byte * edi_152 = esp_112->ptr0234;
	word32 ecx_153 = ~0x00;
	while (ecx_153 != 0x00)
	{
		edi_152 = edi_1406 + 1;
		--ecx_153;
		edi_1406 = edi_152;
		if (*edi_1406 != 0x00)
			break;
	}
	if (~ecx_153 < 0x0801)
	{
		byte * edi_1407 = esp_112->ptr0234;
		word32 ecx_189 = ~0x00;
		while (ecx_189 != 0x00)
		{
			++edi_1407;
			--ecx_189;
			if (*edi_1407 != 0x00)
				break;
		}
		uint32 ecx_201 = ~ecx_189;
		uint32 ecx_1075;
		struct Eq_7659 * esi_1065 = edi_1407 - ecx_201;
		struct Eq_7661 * edi_1066 = (char *) &g_t0400 + 0x0040DD08;
		for (ecx_1075 = ecx_201 >> 0x02; ecx_1075 != 0x00; --ecx_1075)
		{
			edi_1066->dw0000 = esi_1065->dw0000;
			esi_1065 += 4;
			edi_1066 += 4;
		}
		ui32 ecx_1067;
		for (ecx_1067 = ecx_201 & 0x03; ecx_1067 != 0x00; --ecx_1067)
		{
			edi_1066->dw0000 = esi_1065->dw0000;
			++esi_1065;
			++edi_1066;
		}
	}
	else
	{
		struct Eq_7619 * esp_173 = esp_112 - 4;
		esp_173->ptr0000 = esp_112->ptr0234;
		esp_173->tFFFFFFFC.u0 = 0x0447;
		esp_173->tFFFFFFF8.u0 = 0x00;
		word32 ecx_1392;
		word32 edx_1393;
		fn00403220(esp_173->tFFFFFFF8, esp_173->tFFFFFFFC, out ecx_1392, out edx_1393);
	}
	struct Eq_7461 * esp_216 = esp_112;
	if (esp_112->dw0238 != 0x00)
	{
		struct Eq_7716 * esp_222 = esp_112 - 4;
		printf(esp_222->tFFFFFFFC, esp_222->ptr0000);
		MSVCRT20.dll!fflush(_p__iob(0x00413350, 0x0040E108) + 0x20);
		esp_216 = esp_263 + 0x04;
	}
	word32 ebx_301;
	if (g_b41400C != 0x00 || g_b414010 != 0x00)
	{
		if ((g_t4133D0 & 0x04) == 0x00)
		{
			struct Eq_7775 * esp_284 = esp_216 - 4;
			esp_284->ptr0000 = (char *) esp_216 + 24;
			esp_284->ptrFFFFFFFC = (char *) esp_216 + 28;
			esp_284->tFFFFFFF8.u0 = 0x0040E108;
			if (fn004043A0(esp_284->tFFFFFFF8) != 0x00)
				goto l00403CE7;
		}
		ebx_301 = 0x00;
l00403CF0:
		struct Eq_7801 * esp_308 = esp_216 - 4;
		esp_308->t0000.u0 = 0x0040E108;
		word32 edx_1395;
		word32 ecx_1394;
		Eq_2 eax_310 = fn0040ADD0(esp_308->t0000, out ecx_1394, out edx_1395);
		esp_308->t0000 = eax_310;
		esp_308->ptrFFFFFFFC = (struct Eq_6453 *) &esp_308->dw0028;
		esp_308->ptrFFFFFFF8 = (word32 *) ((char *) &esp_308->t0000 + 24);
		g_t413A5C = eax_310;
		fn00403580(esp_308->ptrFFFFFFF8, esp_308->ptrFFFFFFFC, esp_308->t0000);
		struct Eq_7845 * esp_334 = (char *) &esp_308->t0000 + 4;
		if (esp_308->dw0028 != 0x00 && g_t413FF8 != 0x00)
		{
			esp_334 = (struct Eq_7845 *) ((char *) esp_366 + 8);
			if (mbsicmp(esp_308->dw0028, g_t413FF8) == 0x00)
				esp_366->dw002C = *__p__pgmptr();
		}
		if (esp_334->dw0014 != 0x00)
		{
			struct Eq_7884 * esp_1012;
			g_t413A54 = mbsnbcpy(4272376, esp_334->dw0024, 0x0100);
			int32 edx_406 = esp_396->dw0020;
			esp_396->t0008 = &esp_396->dw001C;
			esp_396->ptr0004 = (struct Eq_7906 *) &esp_396->t0030;
			esp_396->dw0000 = edx_406;
			if (esp_396->dw0248 == 0x00)
			{
				esp_1012 = (struct Eq_7884 *) ((char *) &esp_396->t0008 + 4);
				if (fn00404680(esp_396->dw0000, esp_396->ptr0004, esp_396->t0008) != 0x00)
				{
					if (esp_396->dw001C != 0x00)
					{
						union Eq_2 * esi_1030 = esp_396->ptr0250;
						if (esi_1030 != null)
						{
							esp_396->t0008 = esp_396->t0030;
							word32 ecx_1396;
							word32 edx_1397;
							*esi_1030 = (union Eq_2 *) fn0040ADD0(esp_396->t0008, out ecx_1396, out edx_1397);
							esp_1012 = (struct Eq_7884 *) ((char *) &esp_396->t0008 + 4);
						}
					}
					goto l00404160;
				}
				goto l00404166;
			}
			struct Eq_7918 * esp_422 = (char *) &esp_396->t0008 + 4;
			if (fn00404680(esp_396->dw0000, esp_396->ptr0004, esp_396->t0008) != 0x00)
			{
				ebx_301 = 0x00;
				goto l00403F53;
			}
			if (ebx_301 != 0x00)
				goto l00403F53;
			*_errno() = 0x00;
			int32 esi_429 = 0x00;
			int32 ebp_433 = 0x23;
			int32 edi_434 = 0x11;
			do
			{
				int32 eax_450 = mbsicmp(esp_422->t0024, g_a413068[edi_434 * 0x04]);
				esp_422 = (struct Eq_7918 *) ((char *) &esp_449->t0004 + 4);
				if (eax_450 == 0x00)
				{
					ebx_301 = 0x01;
					break;
				}
				if (eax_450 < 0x00)
					ebp_433 = edi_434;
				else
					esi_429 = edi_434;
				int64 edx_eax_466 = (int64) (esi_429 + ebp_433);
				edi_434 = (word32) edx_eax_466 - SLICE(edx_eax_466, word32, 32) >> 0x01;
			} while (ebp_433 - esi_429 > 0x01);
			ebp_20 = 0x01;
			if (ebx_301 != 0x00)
			{
l00403F53:
				<anonymous> * edi_645;
				<anonymous> * esi_646;
				if (esp_422->dw001C != ~0x00)
				{
					esi_646 = dup2;
					if (dup2(esp_660->dw001C, _p__iob()->dw0010) == ~0x00)
					{
						esp_673->t0004.u0 = 0x0411;
						esp_673->t0000.u0 = 0x00;
						word32 ecx_1398;
						word32 edx_1399;
						fn00403220(esp_673->t0000, esp_673->t0004, out ecx_1398, out edx_1399);
					}
					close(esp_673->dw0024);
					edi_645 = close;
					esp_422 = esp_706 + 0x04;
				}
				else
				{
					edi_645 = close;
					esi_646 = dup2;
				}
				if (esp_422->dw0018 != ~0x00)
				{
					word32 eax_730 = _p__iob()->dw0030;
					word32 ecx_731 = esp_724->dw0018;
					esp_724->dwFFFFFFFC = eax_730;
					esp_724->dwFFFFFFF8 = ecx_731;
					struct Eq_8248 * esp_736;
					word32 eax_737;
					word32 edx_739;
					word32 ecx_738;
					esi_646();
					if (eax_737 == ~0x00)
					{
						esp_736->t0004.u0 = 0x0411;
						esp_736->t0000.u0 = 0x00;
						word32 edx_1400;
						fn00403220(esp_736->t0000, esp_736->t0004, out ecx_738, out edx_1400);
					}
					Eq_2 eax_760 = esp_736->t0020;
					esp_736->t0004 = eax_760;
					word32 esp_769;
					word32 edx_772;
					edi_645();
					esp_422 = esp_769 + 0x04;
				}
				if (ebx_301 != 0x00)
				{
					if (g_b414014 != 0x00)
					{
						struct Eq_8414 * esp_888 = esp_422 - 4;
						esp_888->t0000.u0 = 0x00413314;
						printf(esp_888->t0000);
						*_errno() = 0x01;
						esp_888->dw0014 = ~0x00;
						esp_422 = (struct Eq_7918 *) ((char *) &esp_888->t0000 + 4);
					}
					else
					{
						byte * edi_1408 = esp_422->ptr0234;
						word32 ecx_786 = ~0x00;
						while (ecx_786 != 0x00)
						{
							++edi_1408;
							--ecx_786;
							if (*edi_1408 != 0x00)
								break;
						}
						uint32 ecx_798 = ~ecx_786;
						uint32 ecx_802;
						struct Eq_8444 * esi_804 = edi_1408 - ecx_798;
						struct Eq_8446 * edi_805 = (char *) &g_t0400 + 0x0040DD08;
						for (ecx_802 = ecx_798 >> 0x02; ecx_802 != 0x00; --ecx_802)
						{
							edi_805->dw0000 = esi_804->dw0000;
							esi_804 += 4;
							edi_805 += 4;
						}
						ui32 ecx_809;
						for (ecx_809 = ecx_798 & 0x03; ecx_809 != 0x00; --ecx_809)
						{
							edi_805->dw0000 = esi_804->dw0000;
							++esi_804;
							++edi_805;
						}
						int32 eax_860;
						if (ebp_20 != 0x00)
						{
							char ** esp_867 = esp_422 - 4;
							*esp_867 = (char **) ((char *) &g_t0400 + 0x0040DD08);
							eax_860 = system(*esp_867);
							esp_422 = (struct Eq_7918 *) ((char *) esp_867 + 4);
						}
						else
						{
							int32 eax_819 = esp_422->dw0014;
							if (eax_819 >= 0x00)
							{
								struct Eq_8648 * ecx_823 = (char *) &esp_422->t002C + eax_819 * 0x04;
								do
								{
									ecx_823 -= 0x04;
									ecx_823[1] = (struct Eq_8648) ecx_823->dwFFFFFFF8;
								} while (ecx_823 >= &esp_422->t002C);
							}
							eax_860 = spawnvp(0x00, esp_422->t0024, &esp_422->t0024, g_dw413A58, 0x00413310);
							esp_422 = esp_859 + 0x0C;
						}
						esp_422->dw0010 = eax_860;
					}
				}
				if (esp_422->dw0010 == 0xC000004B)
				{
					esp_919->ptrFFFFFFFC = _p__iob(4272872) + 0x40;
					fprintf(esp_919->ptrFFFFFFFC, esp_919->ptr0000, 0x00);
					esp_919->dw0014 = 0x00;
					esp_422 = (struct Eq_7918 *) ((char *) &esp_919->ptr0000 + 4);
				}
				if (esp_422->dw0010 == ~0x00)
				{
					if (esp_422->dw0240 != 0x00)
						esp_422->dw0010 = 0x00;
					else
					{
						word32 eax_940 = *_errno();
						if (eax_940 != 0x00)
						{
							if (eax_940 != 0x02)
							{
								if (eax_940 != 0x0C)
								{
									struct Eq_8593 * esp_965 = esp_422 - 4;
									esp_965->ptr0000 = null;
									esp_965->ptr0000 = _strerror(esp_965->ptr0000);
									esp_965->dwFFFFFFFC = 0x0415;
								}
								else
								{
									Eq_2 eax_953 = esp_422->t002C;
									if (ebx_301 == 0x00)
										eax_953 = esp_422->t0024;
									struct Eq_8665 * esp_960 = esp_422 - 4;
									esp_960->t0000 = eax_953;
									esp_960->dwFFFFFFFC = 0x043A;
								}
							}
							else
							{
								struct Eq_8572 * esp_947 = esp_422 - 4;
								esp_947->t0000 = esp_422->t0024;
								esp_947->dwFFFFFFFC = 1081;
							}
							struct Eq_8614 * esp_974 = esp_422 - 8;
							esp_974->tFFFFFFFC.u0 = 0x00;
							word32 ecx_1401;
							word32 edx_1402;
							fn00403220(esp_974->tFFFFFFFC, esp_974->t0000, out ecx_1401, out edx_1402);
						}
					}
				}
				if (esp_422->dw0010 != 0x00)
				{
					union Eq_2 * esi_991 = esp_422->ptr0244;
					if (esi_991 != null)
					{
						union Eq_2 * esp_996 = esp_422 - 4;
						*esp_996 = (union Eq_2 *) esp_422->t0024;
						word32 edx_1404;
						word32 ecx_1403;
						*esi_991 = (union Eq_2 *) fn0040ADD0(*esp_996, out ecx_1403, out edx_1404);
					}
				}
				union Eq_2 * esp_1010 = esp_422 - 4;
				*esp_1010 = (union Eq_2 *) g_t413A5C;
				free(*esp_1010);
				esp_1012 = (struct Eq_7884 *) ((char *) esp_1010 + 4);
l00404160:
				eax_1025 = esp_1012->dw0010;
				return eax_1025;
			}
			else
			{
				esp_449->t0004.u0 = 0x00;
				Eq_2 eax_486 = g_t413A54;
				esp_449->t0000.u0 = 0x0040E008;
				esp_449->ptrFFFFFFFC = (char *) &g_t0400 + 0x0040E508;
				esp_449->ptrFFFFFFF8 = (char *) &g_t0400 + 0x0040DC00;
				esp_449->tFFFFFFF4 = eax_486;
				_splitpath(esp_449->tFFFFFFF4, esp_449->ptrFFFFFFF8, esp_449->ptrFFFFFFFC, esp_449->t0000, esp_449->t0004);
				Eq_2 ecx_496 = g_t413A54;
				esp_449->t0004.u0 = 0x00;
				esp_449->t0000.u0 = 0x0040E008;
				esp_449->ptrFFFFFFFC = (char *) &g_t0400 + 0x0040E508;
				esp_449->ptrFFFFFFF8 = (char *) &g_t0400 + 0x0040DC00;
				esp_449->tFFFFFFF4 = ecx_496;
				_makepath(esp_449->tFFFFFFF4, esp_449->ptrFFFFFFF8, esp_449->ptrFFFFFFFC, esp_449->t0000, esp_449->t0004);
				Eq_2 ecx_509 = g_t413A54;
				esp_449->t0004.u0 = 0x00411050;
				esp_449->t0000 = ecx_509;
				struct Eq_8197 * eax_514 = fn00405BC0(esp_449->t0000, esp_449->t0004);
				esp_422 = (struct Eq_7918 *) ((char *) &esp_449->t0004 + 4);
				if (eax_514 == null)
				{
					*_errno() = 0x02;
					esp_449->dw0018 = ~0x00;
					goto l00403F53;
				}
				if (eax_514->b0001 != 0x62)
				{
					esp_422 = (struct Eq_7918 *) ((char *) esp_534 + 8);
					if (mbsicmp(eax_514, 0x00413348) != 0x00)
					{
						struct Eq_8294 * esi_545 = esp_534->ptr002C;
						while (esi_545->b0000 != 0x00)
						{
							++esi_545;
							esi_545->bFFFFFFFF = (byte) mbctoupper((int32) esi_545->b0000);
							esp_422 = esp_562 + 0x04;
						}
						Eq_2 esi_576 = esp_422->t0024;
						esp_422->t0024.u0 = 0x00411050;
						if (g_b414014 != 0x00)
						{
							struct Eq_8352 * esp_580 = esp_422 - 4;
							esp_580->t0000 = &esp_422->dw001C + 1;
							esp_580->tFFFFFFFC.u0 = 0x00411050;
							if (fn0040AB40(esp_580->tFFFFFFFC, esp_580->t0000) == 0x00)
							{
								esp_580->t0000.u0 = 0x00413314;
								printf(esp_580->t0000);
								*_errno() = 0x01;
								esp_580->dw0014 = ~0x00;
								esp_422 = (struct Eq_7918 *) ((char *) &esp_580->t0000 + 4);
								goto l00403F53;
							}
						}
						esp_613->dw001C = spawnvp(0x00, 0x00411050, &esp_422->t0024);
						esp_613->t0030 = esi_576;
						esp_422 = (struct Eq_7918 *) ((char *) esp_613 + 0x0C);
						goto l00403F53;
					}
				}
				ebx_301 = 0x01;
				goto l00403F53;
			}
		}
		goto l00404166;
	}
	else
	{
l00403CE7:
		ebx_301 = 0x01;
		goto l00403CF0;
	}
}

// 00404180: Register ptr32 fn00404180(Register Eq_2 ecx)
// Called from:
//      fn00404680
ptr32 fn00404180(Eq_2 ecx)
{
	ptr32 fp;
	Eq_2 dwLoc04;
	fn0040CEB4(0x1108, ecx, dwLoc04);
	struct Eq_8727 * ebx_17 = fp + 0x090B;
	struct Eq_8730 * ebp_136 = (char *) &g_t0400 + 0x0040DD0B;
	while (true)
	{
		byte al_31 = ebp_136->b0000;
		if (al_31 != 0x20 && al_31 != 0x09)
			break;
		ebx_17->b0000 = al_31;
		++ebx_17;
		++ebp_136;
	}
	struct Eq_8742 * esp_114 = fp - 0x1118;
	if (mbschr(ebp_136, 0x3D) == 0x00)
		return 4272224;
	struct Eq_8727 * ebx_262;
	ebx_262 = ebx_17;
	ebx_262 = ebx_17;
	while (ebp_136->b0000 != 0x3D)
	{
		++ebp_136;
		++ebx_262;
		ebx_262->bFFFFFFFF = (byte) mbctoupper((int32) ebp_136->bFFFFFFFF);
		esp_114 = esp_73 + 0x04;
	}
	while (ebp_136->b0000 != 0x00)
	{
		byte al_90 = ebp_136->b0000;
		if (al_90 == 0x25)
		{
			struct Eq_8813 * esi_109 = esp_114 + 5;
			byte * ebp_100 = ebp_136 + 1;
			while (*ebp_100 != 0x25)
			{
				byte al_105 = *ebp_100;
				if (al_105 == 0x00)
					break;
				++esi_109;
				esi_109->bFFFFFFFF = (byte) mbctoupper((int32) al_105);
				++ebp_100;
				esp_114 = esp_121 + 0x04;
			}
			esi_109->b0000 = 0x00;
			ebp_136 = (struct Eq_8730 *) (ebp_100 + 1);
			if (*ebp_100 == 0x00)
			{
				ebx_262->b0000 = 0x00;
				byte * edi_295 = esp_114 + 5;
				word32 ecx_296 = ~0x00;
				while (ecx_296 != 0x00)
				{
					++edi_295;
					--ecx_296;
					if (*edi_295 != 0x00)
						break;
				}
				uint32 ecx_310 = ~ecx_296;
				struct Eq_8894 * esi_314 = edi_295 - ecx_310;
				word32 ecx_315 = ~0x00;
				byte * edi_318 = esp_114 + 582;
				while (ecx_315 != 0x00)
				{
					++edi_318;
					--ecx_315;
					if (*edi_318 != 0x00)
						break;
				}
				struct Eq_8912 * edi_330 = edi_318 - 0x01;
				uint32 ecx_334;
				for (ecx_334 = ecx_310 >> 0x02; ecx_334 != 0x00; --ecx_334)
				{
					edi_330->dw0000 = esi_314->dw0000;
					esi_314 += 4;
					edi_330 += 4;
				}
				ui32 ecx_339;
				for (ecx_339 = ecx_310 & 0x03; ecx_339 != 0x00; --ecx_339)
				{
					edi_330->dw0000 = esi_314->dw0000;
					++esi_314;
					++edi_330;
				}
				byte * edi_344 = esp_114 + 5;
				word32 ecx_345 = ~0x00;
				while (ecx_345 != 0x00)
				{
					edi_344 = edi_856 + 1;
					--ecx_345;
					edi_856 = edi_344;
					if (*edi_856 != 0x00)
						break;
				}
				ebx_262 += ~ecx_345 - 1;
			}
			else
			{
				esp_114[70] = (struct Eq_8742) 0x00;
				union Eq_2 * esp_142 = esp_114 - 4;
				*esp_142 = (union Eq_2 *) (esp_114 + 5);
				Eq_2 eax_144 = getenv(*esp_142);
				esp_114 = (struct Eq_8742 *) ((char *) esp_142 + 4);
				if (eax_144 != 0x00)
				{
					Eq_2 edi_149 = eax_144;
					word32 ecx_150 = ~0x00;
					while (ecx_150 != 0x00)
					{
						edi_149 = (word32) edi_149 + 1;
						--ecx_150;
						if (*edi_149 != 0x00)
							break;
					}
					uint32 ecx_162 = ~ecx_150;
					struct Eq_9066 * esi_166 = edi_149 - ecx_162;
					word32 ecx_167 = ~0x00;
					byte * edi_170 = (char *) esp_142 + 0x011C;
					while (ecx_167 != 0x00)
					{
						++edi_170;
						--ecx_167;
						if (*edi_170 != 0x00)
							break;
					}
					struct Eq_9084 * edi_182 = edi_170 - 0x01;
					uint32 ecx_186;
					for (ecx_186 = ecx_162 >> 0x02; ecx_186 != 0x00; --ecx_186)
					{
						edi_182->dw0000 = esi_166->dw0000;
						esi_166 += 4;
						edi_182 += 4;
					}
					ui32 ecx_191;
					for (ecx_191 = ecx_162 & 0x03; ecx_191 != 0x00; --ecx_191)
					{
						edi_182->dw0000 = esi_166->dw0000;
						++esi_166;
						++edi_182;
					}
					ebx_262->b0000 = 0x00;
					byte * edi_196 = (char *) esp_142 + 0x011C;
					word32 ecx_197 = ~0x00;
					while (ecx_197 != 0x00)
					{
						++edi_196;
						--ecx_197;
						if (*edi_196 != 0x00)
							break;
					}
					uint32 ecx_211 = ~ecx_197;
					struct Eq_9143 * esi_215 = edi_196 - ecx_211;
					word32 ecx_216 = ~0x00;
					byte * edi_219 = (char *) esp_142 + 2332;
					while (ecx_216 != 0x00)
					{
						++edi_219;
						--ecx_216;
						if (*edi_219 != 0x00)
							break;
					}
					struct Eq_9161 * edi_231 = edi_219 - 0x01;
					uint32 ecx_235;
					for (ecx_235 = ecx_211 >> 0x02; ecx_235 != 0x00; --ecx_235)
					{
						edi_231->dw0000 = esi_215->dw0000;
						esi_215 += 4;
						edi_231 += 4;
					}
					ui32 ecx_240;
					for (ecx_240 = ecx_211 & 0x03; ecx_240 != 0x00; --ecx_240)
					{
						edi_231->dw0000 = esi_215->dw0000;
						++esi_215;
						++edi_231;
					}
					byte * edi_245 = (char *) esp_142 + 0x011C;
					word32 ecx_246 = ~0x00;
					while (ecx_246 != 0x00)
					{
						edi_245 = edi_853 + 1;
						--ecx_246;
						edi_853 = edi_245;
						if (*edi_853 != 0x00)
							break;
					}
					ebx_262 += ~ecx_246 - 1;
				}
			}
		}
		else
		{
			ebx_262->b0000 = al_90;
			++ebp_136;
			++ebx_262;
		}
	}
	ebx_262->b0000 = 0x00;
	byte * edi_392 = fp - 0x0800;
	word32 ecx_393 = ~0x00;
	while (ecx_393 != 0x00)
	{
		++edi_392;
		--ecx_393;
		if (*edi_392 != 0x00)
			break;
	}
	uint32 ecx_409 = ~ecx_393;
	uint32 ecx_413;
	struct Eq_8951 * esi_415 = edi_392 - ecx_409;
	struct Eq_8953 * edi_416 = (char *) &g_t0400 + 0x0040DD08;
	for (ecx_413 = ecx_409 >> 0x02; ecx_413 != 0x00; --ecx_413)
	{
		edi_416->dw0000 = esi_415->dw0000;
		esi_415 += 4;
		edi_416 += 4;
	}
	ui32 ecx_420;
	for (ecx_420 = ecx_409 & 0x03; ecx_420 != 0x00; --ecx_420)
	{
		edi_416->dw0000 = esi_415->dw0000;
		++esi_415;
		++edi_416;
	}
	ebx_17->b0000 = 0x00;
	byte * edi_427 = fp - 0x0800;
	word32 ecx_433 = ~0x00;
	while (ecx_433 != 0x00)
	{
		edi_427 = edi_858 + 1;
		--ecx_433;
		edi_858 = edi_427;
		if (*edi_858 != 0x00)
			return ~ecx_433 + 0x0040E107;
	}
	return ~ecx_433 + 0x0040E107;
}

// 004043A0: Register word32 fn004043A0(Stack Eq_2 dwArg04)
// Called from:
//      fn00403AF0
word32 fn004043A0(Eq_2 dwArg04)
{
	word32 ebx_14 = 0x00;
	word32 ecx_18 = ~0x00;
	Eq_2 ebp_171 = dwArg04;
	Eq_2 edi_22 = dwArg04;
	while (ecx_18 != 0x00)
	{
		edi_22 = (word32) edi_638 + 1;
		--ecx_18;
		edi_638 = edi_22;
		if (*edi_638 != 0x00)
			break;
	}
	word32 esi_37 = 0x01;
	if (~ecx_18 < 0x7D)
		esi_37 = 0x00;
	do
	{
		struct Eq_9254 * eax_55 = mbspbrk(ebp_171, 4272988);
		struct Eq_9259 * esp_129 = (char *) &esp_53->t0004 + 4;
		if (eax_55 == null)
			break;
		Eq_9268 eax_63 = (int32) eax_55->b0000;
		if (eax_63 <= 0x7C)
		{
			switch (eax_63)
			{
			case 0x22:
				word32 eax_230 = mbschr(&eax_55->b0001, 0x22);
				esp_129 = esp_228 + 0x08;
				if (eax_230 != 0x00)
				{
					ebp_171 = eax_230 + 1;
					goto l00404510;
				}
				break;
			case 0x23:
			case 0x24:
			case 0x25:
			case 0x26:
			case 0x27:
			case 0x28:
			case 0x29:
			case 0x2A:
			case 0x2B:
			case 44:
			case 0x2D:
			case 0x2E:
			case 0x2F:
			case 0x30:
			case 0x31:
			case 0x32:
			case 0x33:
			case 0x34:
			case 0x35:
			case 0x36:
			case 55:
			case 0x38:
			case 0x39:
			case 0x3A:
			case 0x3B:
			case 0x3D:
			case 0x3F:
			case 0x40:
			case 0x41:
			case 66:
			case 0x43:
			case 0x44:
			case 0x45:
			case 0x46:
			case 0x47:
			case 0x48:
			case 0x49:
			case 0x4A:
			case 0x4B:
			case 0x4C:
			case 77:
			case 0x4E:
			case 0x4F:
			case 0x50:
			case 0x51:
			case 0x52:
			case 0x53:
			case 0x54:
			case 0x55:
			case 0x56:
			case 0x57:
			case 88:
			case 0x59:
			case 0x5A:
			case 0x5B:
			case 0x5C:
			case 0x5D:
			case 0x5E:
			case 0x5F:
			case 0x60:
			case 0x61:
			case 0x62:
			case 99:
			case 100:
			case 101:
			case 0x66:
			case 0x67:
			case 0x68:
			case 0x69:
			case 0x6A:
			case 0x6B:
			case 0x6C:
			case 0x6D:
			case 110:
			case 111:
			case 0x70:
			case 113:
			case 114:
			case 115:
			case 116:
			case 117:
			case 118:
			case 0x77:
			case 0x78:
			case 121:
			case 122:
			case 0x7B:
				goto l00404406;
			case 0x3C:
				if (esp_53->dw0024 == 0x00 && esi_37 != 0x00)
				{
					if (esp_53->t0018 == 0x00)
					{
						esp_53->t0004 = ebp_171;
						word32 ecx_636;
						word32 edx_637;
						esp_53->t0018 = fn0040ADD0(esp_53->t0004, out ecx_636, out edx_637);
					}
					eax_55->b0000 = 0x20;
					word32 eax_186 = dup(_p__iob(0x01)->dw0010);
					*esp_184->ptr002C = eax_186;
					ebp_171 = &eax_55->b0001;
					esp_129 = (struct Eq_9259 *) (&esp_184->dw0000 + 1);
					if (eax_186 != ~0x00)
					{
						esp_184->dw0000 = 0x04;
						esp_184->ptrFFFFFFFC = &eax_55->b0001;
						esp_129 = (struct Eq_9259 *) (&esp_184->dw0000 + 1);
						if (fn00404AF0(esp_184->ptrFFFFFFFC) != 0x00)
							goto l00404510;
					}
				}
				break;
			case 0x3E:
				if (esp_53->dw0020 == 0x00 && esi_37 != 0x00)
				{
					if (esp_53->t0018 == 0x00)
					{
						esp_53->t0004 = ebp_171;
						word32 ecx_634;
						word32 edx_635;
						esp_53->t0018 = fn0040ADD0(esp_53->t0004, out ecx_634, out edx_635);
					}
					eax_55->b0000 = 0x20;
					esp_53->dw0020 = 0x01;
					byte * edi_100 = &eax_55->b0001;
					ebp_171 = &eax_55->b0001;
					if (eax_55->b0001 == 0x3E)
					{
						eax_55->b0001 = 0x20;
						esp_53->dw001C = 0x03;
						edi_100 = (byte *) (&eax_55->b0001 + 1);
					}
					else
						esp_53->dw001C = 0x02;
					word32 eax_124 = dup(_p__iob()->dw0030);
					*esp_122->ptr0030 = eax_124;
					esp_129 = (struct Eq_9259 *) (&esp_122->dw0000 + 1);
					if (eax_124 != ~0x00)
					{
						esp_122->dw0000 = esp_122->dw0018;
						esp_122->ptrFFFFFFFC = edi_100;
						esp_129 = (struct Eq_9259 *) (&esp_122->dw0000 + 1);
						if (fn00404AF0(esp_122->ptrFFFFFFFC) != 0x00)
							goto l00404510;
					}
				}
				break;
			case 0x7C:
				break;
			}
			ebx_14 = 0x01;
		}
		else
		{
l00404406:
			esp_53->t0004.u0 = 0x0411;
			esp_53->t0000.u0 = 0x00;
			word32 ecx_628;
			word32 edx_629;
			fn00403220(esp_53->t0000, esp_53->t0004, out ecx_628, out edx_629);
			esp_129 = (struct Eq_9259 *) ((char *) &esp_53->t0004 + 4);
		}
l00404510:
	} while (ebx_14 == 0x00);
	if (ebx_14 != 0x00)
	{
		if (esp_129->t0010 != 0x00)
		{
			Eq_2 edi_257 = esp_129->t0010;
			word32 ecx_258 = ~0x00;
			while (ecx_258 != 0x00)
			{
				edi_257 = (word32) edi_257 + 1;
				--ecx_258;
				if (*edi_257 != 0x00)
					break;
			}
			uint32 ecx_270 = ~ecx_258;
			uint32 ecx_274;
			struct Eq_9344 * esi_276 = edi_257 - ecx_270;
			Eq_2 edi_283 = ebp_171;
			for (ecx_274 = ecx_270 >> 0x02; ecx_274 != 0x00; --ecx_274)
			{
				*edi_283 = esi_276->dw0000;
				esi_276 += 4;
				edi_283 = (word32) edi_283 + 4;
			}
			ui32 ecx_287;
			for (ecx_287 = ecx_270 & 0x03; ecx_287 != 0x00; --ecx_287)
			{
				*edi_283 = esi_276->dw0000;
				++esi_276;
				edi_283 = (word32) edi_283 + 1;
			}
			union Eq_2 * esp_294 = esp_129 - 4;
			*esp_294 = (union Eq_2 *) esp_129->t0010;
			free(*esp_294);
		}
		struct Eq_9259 * esp_298 = esp_129;
		if (esp_129->dw001C != 0x00)
		{
			word32 esi_303 = *esp_129->ptr0028;
			if (esi_303 != ~0x00)
			{
				if (dup2(esi_303, _p__iob()->dw0030) == ~0x00)
				{
					esp_333->t0004.u0 = 0x0411;
					esp_333->t0000.u0 = 0x00;
					word32 ecx_630;
					word32 edx_631;
					fn00403220(esp_333->t0000, esp_333->t0004, out ecx_630, out edx_631);
				}
				close(*esp_333->ptr0030);
				*esp_366->ptr002C = ~0x00;
				esp_298 = (struct Eq_9259 *) ((char *) esp_366 + 4);
			}
		}
		if (esp_298->dw0018 != 0x00)
		{
			word32 esi_381 = *esp_298->ptr002C;
			if (esi_381 != ~0x00)
			{
				if (dup2(esi_381, _p__iob()->dw0030) == ~0x00)
				{
					esp_399->t0004.u0 = 0x0411;
					esp_399->t0000.u0 = 0x00;
					word32 edx_633;
					word32 ecx_632;
					fn00403220(esp_399->t0000, esp_399->t0004, out ecx_632, out edx_633);
				}
				close(*esp_399->ptr0034);
				*esp_432->ptr0030 = ~0x00;
			}
		}
	}
	return ebx_14;
}

// 00404680: Register word32 fn00404680(Stack int32 dwArg04, Stack (ptr32 Eq_7906) dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      fn00403AF0
word32 fn00404680(int32 dwArg04, struct Eq_7906 * dwArg08, Eq_2 dwArg0C)
{
	struct Eq_9688 * ebx_18 = dwArg08->dw0000;
	Eq_2 esi_19 = dwArg08[1];
	if (ismbcalpha((int32) ebx_18->b0000) == 0x00 || (ebx_18->b0001 != 0x3A || ebx_18->b0002 != 0x00))
	{
		if (mbsicmp(ebx_18, 4272984) == 0x00)
		{
			if (dwArg04 == 0x01)
				return 0x00;
			Eq_2 eax_230 = fn00404180(ecx_48);
			if (*eax_230 == 0x00)
				return 0x00;
			word32 ecx_492;
			word32 edx_493;
			int32 eax_255 = _putenv(fn0040ADD0(eax_230, out ecx_492, out edx_493));
			*dwArg0C = eax_255;
			if (eax_255 == ~0x00)
			{
				word32 edx_495;
				word32 ecx_494;
				fn00403220(g_t413424, 1055, out ecx_494, out edx_495);
			}
		}
		else
		{
			Eq_2 ebx_118;
			if (mbsnbicmp(ebx_18, 4273004, 0x02) == 0x00)
				ebx_118 = &ebx_18->b0002;
			else
			{
				if (mbsnbicmp(ebx_18, 0x00413364, 0x05) != 0x00)
					return 0x00;
				ebx_118 = &ebx_18->b0002 + 3;
			}
			fn00404BB0(dwArg04, dwArg08);
			if (dwArg04 > 0x02)
				return 0x00;
			Eq_2 dwLoc14_433;
			byte al_119 = *ebx_118;
			if (al_119 == 0x00 && esi_19 != 0x00)
			{
				int32 eax_173;
				if (*_p___mb_cur_max() > 0x01)
				{
					int32 eax_176 = (int32) *esi_19;
					esp_154->dwFFFFFFFC = 0x0103;
					esp_154->dwFFFFFFF8 = eax_176;
					eax_173 = _isctype(esp_154->dwFFFFFFF8, esp_154->dwFFFFFFFC);
				}
				else
				{
					uint16 ecx_168[] = *_p__pctype();
					int32 eax_169 = (int32) *esi_19;
					eax_173 = SEQ(SLICE(eax_169, word16, 16), ecx_168[eax_169]) & 0x0103;
				}
				if (eax_173 != 0x00 && (*((word32) esi_19 + 1) == 0x3A && *((word32) esi_19 + 2) == 0x00))
					return 0x00;
				dwLoc14_433 = esi_19;
			}
			else
			{
				if (al_119 != 0x2E && (al_119 != 0x5C && al_119 != 0x2F))
					return 0x00;
				dwLoc14_433 = ebx_118;
			}
			*dwArg0C = _chdir(dwLoc14_433);
		}
		if (*dwArg0C != 0x00)
			*dwArg0C = 0x01;
		return 0x01;
	}
	else
	{
		fn0040CBD0(mbctoupper((int32) ebx_18->b0000) - 0x40);
		*dwArg0C = 0x00;
		return 0x01;
	}
}

// 00404830: Register Eq_2 fn00404830(Register Eq_2 ecx)
// Called from:
//      fn00403AF0
Eq_2 fn00404830(Eq_2 ecx)
{
	Eq_2 dwLoc14;
	fn0040CEB4((word32) g_t413EE0 + 3 & ~0x03, ecx, dwLoc14);
	Eq_2 eax_119 = getenv(0x00413378);
	if (eax_119 == 0x00)
	{
		Eq_2 eax_38 = getenv(4272724);
		if (eax_38 == 0x00)
			eax_38.u0 = 4272224;
		Eq_2 eax_57 = fn00405930(eax_38, 0x00413370);
		if (eax_57 == 0x00)
		{
			word32 ecx_141;
			word32 edx_142;
			fn00403220(0x00, 0x0420, out ecx_141, out edx_142);
		}
		eax_119 = eax_57;
	}
	return eax_119;
}

// 004048B0: Register word32 fn004048B0(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_7019 bArg0C, Stack Eq_7010 bArg10, Stack Eq_2 dwArg14, Stack (ptr32 Eq_2) dwArg18)
// Called from:
//      fn004036C0
word32 fn004048B0(Eq_2 dwArg04, Eq_2 dwArg08, Eq_7019 bArg0C, Eq_7010 bArg10, Eq_2 dwArg14, union Eq_2 * dwArg18)
{
	ptr32 fp;
	Eq_2 ebx_115 = 0x00;
	Eq_2 esi_106 = dwArg04;
	struct Eq_9943 * esp_112 = fp - 0x24;
	if (*dwArg04 != 0x00)
	{
		do
		{
			word32 ecx_24 = 0x00;
			if (*esi_106 == 0x24)
			{
				Eq_2 eax_29 = (word32) esi_106 + 1;
				if (*eax_29 == 0x28)
				{
					esi_106 = eax_29;
					ecx_24 = 0x01;
				}
				Eq_2 edi_35 = (word32) esi_106 + 1;
				byte al_37 = *edi_35;
				if (al_37 == 0x3F)
				{
					if (ecx_24 == 0x00)
					{
l00404911:
						esp_112->b0013 = 0x3F;
						ebx_115 = g_t413A94;
						break;
					}
					esp_112 = esp_90 + 0x08;
					if (mbschr(0x00413380, (int32) *((word32) esi_106 + 2)) != 0x00 && *((word32) esi_106 + 3) == 0x29 || *((word32) esi_106 + 2) == 0x29)
						goto l00404911;
					goto l0040494D;
				}
				esi_106 = edi_35;
				if (al_37 != 0x2A || *((word32) edi_35 + 1) != 0x2A)
					goto l0040494D;
				if (ecx_24 == 0x00)
				{
l00404959:
					esp_112->b0013 = 0x2A;
					ebx_115 = g_t413A98;
					break;
				}
				esp_112 = esp_62 + 0x08;
				if (mbschr(0x00413380, (int32) *((word32) edi_35 + 2)) != 0x00 && *((word32) edi_35 + 3) == 0x29 || *((word32) edi_35 + 2) == 0x29)
					goto l00404959;
			}
l0040494D:
			esi_106 = (word32) esi_106 + 1;
		} while (*esi_106 != 0x00);
	}
	if (*esi_106 == 0x00)
		return 0x00;
	ebx_132 = ebx_115;
	do
	{
		Eq_2 ebx_132;
		if (ebx_132 == 0x00)
			break;
		Eq_2 eax_142;
		g_t413A28 = dwArg08;
		if (false)
			eax_142 = g_t413A98;
		else
			eax_142 = g_t413A94;
		Eq_2 ecx_184;
		ebx_132 = *eax_142;
		eax_142->u0 = 0x00;
		word32 edx_672;
		fn0040B700(dwArg04, 4274728, out edx_672);
		fn0040C790(0x00411250, dwArg04, dwArg14);
		if ((bArg0C & 0x04) != 0x00)
		{
			ecx_184.u0 = 0x00;
			if ((bArg10 & 0x08) != 0x00)
				goto l004049E6;
		}
		else
		{
l004049E6:
			ecx_184.u0 = 0x01;
		}
		if ((bArg0C & 0x04) == 0x00 && ((bArg0C & 0x08) != 0x00 || (bArg10 & 0x01) != 0x00))
			;
		*dwArg18 = (union Eq_2 *) fn00403AF0(ecx_184, 0x00411250, ecx_184);
		if ((bArg0C & 0x02) == 0x00)
		{
			Eq_2 eax_253 = *dwArg18;
			if (eax_253 != 0x00 && (g_t413A4C < eax_253 && g_dw4133A4 == 0x00))
			{
				word32 ecx_673;
				word32 edx_674;
				fn00403220(0x00, 1077, out ecx_673, out edx_674);
			}
		}
		if (false)
		{
			*g_t413A98 = ebx_132;
			g_t413A98 = *g_t413A98;
		}
		else
		{
			*g_t413A94 = ebx_132;
			g_t413A94 = *g_t413A94;
		}
		free(dwArg04);
		if ((bArg0C & 0x02) != 0x00 || g_dw4133A4 == 0x00)
			continue;
		Eq_2 eax_316 = *dwArg18;
	} while (eax_316 == 0x00 || g_t413A4C >= eax_316);
	if (false)
		g_t413A98 = ebx_115;
	else
		g_t413A94 = ebx_115;
	return 0x01;
}

// 00404AF0: Register word32 fn00404AF0(Stack (ptr32 byte) dwArg04)
// Called from:
//      fn004043A0
word32 fn00404AF0(byte * dwArg04)
{
	byte * edi_115 = dwArg04;
	while (true)
	{
		byte al_22 = *edi_115;
		if (al_22 != 0x20 && al_22 != 0x09)
			break;
		++edi_115;
	}
	byte * eax_37 = mbspbrk(edi_115, 4273044);
	if (eax_37 != null)
	{
		esp_36->b001B = *eax_37;
		*eax_37 = 0x00;
	}
	ptr32 ebx_53;
	word32 eax_61;
	word32 ebp_50 = esp_36->dw0024;
	if (ebp_50 == 0x04)
	{
		ebx_53 = 0x00413390;
		eax_61 = _p__iob();
	}
	else
	{
		ebx_53 = 0x0041338C;
		eax_61 = _p__iob() + 0x20;
		if (ebp_50 != 0x02)
			ebx_53 = 0x00413388;
	}
	struct Eq_10234 * eax_84 = MSVCRT20.dll!freopen(edi_115, ebx_53, eax_61);
	word32 ebx_90 = 0x00 - (word32) (eax_84 < (struct Eq_10234 *) 0x01);
	if (ebx_90 != 0x01 && ebp_50 == 0x03)
		lseek(eax_84->dw0010, 0x00, 0x02);
	while (*edi_115 != 0x00)
	{
		*edi_115 = 0x20;
		++edi_115;
	}
	if (eax_37 != null)
		*eax_37 = 0x00;
	return ebx_90 + 0x01;
}

// 00404BB0: void fn00404BB0(Stack int32 dwArg04, Stack (ptr32 Eq_7906) dwArg08)
// Called from:
//      fn00404680
void fn00404BB0(int32 dwArg04, struct Eq_7906 * dwArg08)
{
	word32 esi_15 = dwArg04 - 0x01;
	if (dwArg04 != 0x00)
	{
		struct Eq_7906 * edx_19 = dwArg08;
		do
		{
			byte * edi_22 = edx_19->dw0000;
			byte * eax_23 = edi_22;
			if (*edi_22 != 0x00)
			{
				do
				{
					byte bl_28 = *eax_23;
					if (bl_28 != 0x5C && bl_28 != 0x5E)
					{
						if (bl_28 == 0x22)
						{
							++eax_23;
							goto l00404BF6;
						}
						*edi_22 = bl_28;
					}
					else
					{
						byte * ecx_34 = eax_23 + 1;
						if (*ecx_34 == 0x22)
						{
							*edi_22 = bl_28;
							eax_23 = ecx_34;
							++edi_22;
						}
						*edi_22 = *eax_23;
					}
					++eax_23;
					++edi_22;
l00404BF6:
				} while (*eax_23 != 0x00);
			}
			*edi_22 = 0x00;
			++edx_19;
			esi_15 = esi_160 - 0x01;
			esi_160 = esi_15;
		} while (esi_160 != 0x00);
	}
}

// 00404C10: void fn00404C10(Stack Eq_2 dwArg04, Stack ui32 dwArg08)
// Called from:
//      fn004036C0
void fn00404C10(Eq_2 dwArg04, ui32 dwArg08)
{
	ptr32 fp;
	fn00403370();
	if (dwArg08 == 0x00)
	{
		Eq_2 eax_28 = fn0040CA80(dwArg04);
		if (eax_28 != 0x00)
		{
			word32 esi_38 = *((word32) eax_28 + 16);
			if (read(esi_38, fp - 0x01, 0x01) > 0x00)
			{
				lseek(esi_38, 0x00, 0x00);
				write(esi_38, esp_61 + 19, 0x01);
			}
			close(esi_38);
		}
	}
}

// 00404C90: Register word32 fn00404C90(Stack Eq_2 dwArg04)
// Called from:
//      fn00401F10
//      fn00402870
//      fn00408D80
//      fn0040CB30
//      fn0040CBF0
//      fn0040CE00
word32 fn00404C90(Eq_2 dwArg04)
{
	return (word32) *dwArg04 + 20;
}

// 00404CA0: Register word32 fn00404CA0(Stack Eq_2 dwArg04, Register out ptr32 ecxOut)
// Called from:
//      fn00401F10
//      fn004020E0
//      fn00402870
//      fn0040A500
word32 fn00404CA0(Eq_2 dwArg04, ptr32 & ecxOut)
{
	word32 eax_10;
	struct Eq_10396 * ecx_6 = *dwArg04;
	if ((ecx_6->b0000 & 0x10) != 0x00)
	{
		eax_10 = ecx_6->dw0004;
		if (eax_10 == ~0x00)
		{
			word32 eax_14 = ecx_6->dw000C;
			ecxOut = <invalid>;
			return eax_14;
		}
	}
	else
		eax_10 = ecx_6->dw000C;
	ecxOut = <invalid>;
	return eax_10;
}

// 00404CC0: void fn00404CC0(Stack (ptr32 (ptr32 Eq_10420)) dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00402870
//      fn00409EF0
void fn00404CC0(struct Eq_10420 ** dwArg04, Eq_2 dwArg08)
{
	struct Eq_10420 * ecx_6 = *dwArg04;
	if ((ecx_6->b0000 & 0x10) == 0x00)
		ecx_6->t000C = dwArg08;
	else
		ecx_6->t0004 = dwArg08;
}

// 00404CF0: Register Eq_2 fn00404CF0(Stack Eq_2 dwArg04, Register out Eq_2 ecxOut)
// Called from:
//      fn00404DE0
//      fn00404F80
//      fn00405710
//      fn00406880
//      fn00406940
//      fn004069D0
Eq_2 fn00404CF0(Eq_2 dwArg04, union Eq_2 & ecxOut)
{
	Eq_2 ecx;
	Eq_2 ebx_17;
	if (g_t413A80 == ~0x00)
	{
		Eq_2 eax_26 = MSVCRT20.dll!getc(dwArg04);
		ebx_17 = eax_26;
		ecx = (uint32) (byte) eax_26;
		if (((word32) ecx + 1 + _p__mbctype() & 0x04) != 0x00)
		{
			ecx = eax_26 << 0x08 | MSVCRT20.dll!getc(dwArg04);
			g_t413A80 = ecx;
			if (ecx == 33088)
			{
				ecxOut = ecx;
				return 0x20;
			}
		}
	}
	else
	{
		ebx_17.u0 = 0x20;
		if (g_t413A80 != 33088)
			ebx_17 = g_t413A80;
		g_t413A80.u0 = ~0x00;
	}
	ecxOut = ecx;
	return ebx_17;
}

// 00404D70: Register Eq_2 fn00404D70(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00404DE0
//      fn00404F80
//      fn00406490
//      fn00406500
//      fn004065D0
//      fn00406880
//      fn00406940
//      fn004069D0
//      fn00406A80
//      fn00407070
//      fn00407680
Eq_2 fn00404D70(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 eax_7 = g_t413A80;
	if (eax_7 != ~0x00)
	{
		MSVCRT20.dll!ungetc(eax_7 & 0xFF, dwArg08);
		Eq_2 eax_34 = MSVCRT20.dll!ungetc(esp_22->dw0014, dwArg08);
		g_t413A80.u0 = ~0x00;
		return eax_34;
	}
	else
	{
		if ((dwArg04 & ~0xFF) == 0x00)
			return MSVCRT20.dll!ungetc(dwArg04, dwArg08);
		g_t413A80 = dwArg04;
		return dwArg04;
	}
}

// 00404DE0: Register Eq_2 fn00404DE0(Register out ptr32 ecxOut)
// Called from:
//      fn00406490
//      fn00406500
//      fn004065D0
//      fn00406880
//      fn00406940
//      fn004069D0
//      fn00406A80
//      fn00407070
//      fn00407680
Eq_2 fn00404DE0(ptr32 & ecxOut)
{
	ptr32 fp;
	Eq_2 ecx;
	ptr32 ecx_25;
	Eq_2 eax_24 = fn00404CF0(g_t4133D8, out ecx_25);
	ptr32 esp_30 = fp - 0x14;
	while (g_t413A78 != 0x00 || g_dw4133F0 != 0x00 && eax_24 == 33)
	{
		Eq_2 esi_59;
		g_dw4133F0 = 0x00;
		if (g_t413A78 == 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg208 = <invalid>;
			Eq_2 stackArg212 = <invalid>;
			Eq_2 stackArg216 = <invalid>;
			esi_59 = fn00404F80(stackArg208, stackArg212, stackArg216);
		}
		else
		{
			struct Eq_10544 * esp_48 = esp_30 - 4;
			esp_48->t0000 = g_t4133D8;
			esp_48->tFFFFFFFC = eax_24;
			fn00404D70(esp_48->tFFFFFFFC, esp_48->t0000);
			esi_59 = g_t413A78;
			g_t413A78.u0 = 0x00;
		}
		ptr32 esp_137;
		struct Eq_10579 * esp_77 = esp_30 - 4;
		esp_77->t0000 = esp_30 + 19;
		esp_77->tFFFFFFFC = esi_59;
		Eq_2 eax_82 = fn004050B0(esp_77->tFFFFFFFC, esp_77->t0000);
		word24 eax_24_8_143 = SLICE(eax_82, word24, 8);
		Eq_2 edi_120 = eax_82;
		if (esp_77->b0017 == 0x09)
		{
			if (g_t413408 != 0x00)
			{
				esp_77->t0000 = esi_59;
				Eq_2 eax_247 = g_t4133F4;
				esp_77->tFFFFFFFC.u0 = 0x0409;
				esp_77->tFFFFFFF8 = eax_247;
				word32 edx_412;
				word32 ecx_411;
				fn00403220(esp_77->tFFFFFFF8, esp_77->tFFFFFFFC, out ecx_411, out edx_412);
			}
			union Eq_2 * esp_262 = esp_30 - 4;
			*esp_262 = (union Eq_2 *) eax_82;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			esp_137 = (char *) esp_262 + 4;
			word32 ebp_410;
			if ((byte) fn00407680(ecx, stackArg4, out ecx_25, out ebp_410) == 0x12)
			{
				eax_24.u0 = 0x20;
				break;
			}
		}
		else if (esp_77->b0017 == 0x0A)
		{
			esp_77->t0000 = eax_82;
			fn004051E0(esp_77->t0000);
			esp_137 = (char *) &esp_77->t0000 + 4;
		}
		else if (esp_77->b0017 == 11)
		{
			esp_77->t0000 = eax_82;
			Eq_2 eax_219 = g_t4133F4;
			esp_77->tFFFFFFFC.u0 = 1050;
			esp_77->tFFFFFFF8 = eax_219;
			word32 ecx_413;
			word32 edx_414;
			fn00403220(esp_77->tFFFFFFF8, esp_77->tFFFFFFFC, out ecx_413, out edx_414);
			esp_137 = (char *) &esp_77->t0000 + 4;
		}
		else if (esp_77->b0017 != 0x0C)
		{
			if (esp_77->b0017 == 0x0D)
			{
				Eq_2 eax_160 = mbstok(eax_82, 0x00413008);
				if (mbstok(0x00, 0x00413008) != 0x00)
				{
					esp_172->t0004 = eax_160;
					Eq_2 eax_184 = g_t4133F4;
					esp_172->t0000.u0 = 0x0409;
					esp_172->tFFFFFFFC = eax_184;
					word32 edx_419;
					word32 ecx_418;
					fn00403220(esp_172->tFFFFFFFC, esp_172->t0000, out ecx_418, out edx_419);
				}
				esp_172->t0004 = eax_160;
				word32 ecx_417;
				Eq_2 eax_202 = fn00407B70(esp_172->t0004, out ecx_417);
				esp_137 = (char *) &esp_172->t0004 + 4;
				if (eax_202 != 0x00)
					*((word32) eax_202 + 0x0C) |= 0x10;
			}
			else
			{
				esp_77->t0000 = SEQ(eax_24_8_143, esp_77->b0017);
				esp_77->tFFFFFFFC = eax_82;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_2 stackArg8 = <invalid>;
				fn00405530(stackArg4, stackArg8);
				esp_137 = (char *) &esp_77->t0000 + 4;
			}
		}
		else
		{
			if (mbsnbicmp(eax_82, 0x00413F04, 0x02) == 0x00)
			{
				esp_108->t0008.u0 = 0x00413F00;
				printf(esp_108->t0008);
				edi_120 = (word32) eax_82 + 2;
			}
			esp_108->t0008 = edi_120;
			esp_108->dw0004 = 0x0D;
			fn00403370();
			esp_137 = (char *) &esp_108->t0008 + 4;
		}
		g_dw4133F0 = 0x01;
		if (g_t413A74 != esi_59)
		{
			union Eq_2 * esp_286 = esp_137 - 4;
			*esp_286 = (union Eq_2 *) esi_59;
			free(*esp_286);
		}
		Eq_2 eax_291 = g_t4133D8;
		g_t4133F4 = (word32) g_t4133F4 + 1;
		union Eq_2 * esp_296 = esp_137 - 4;
		*esp_296 = (union Eq_2 *) eax_291;
		eax_24 = fn00404CF0(*esp_296, out ecx_25);
		esp_30 = (char *) esp_296 + 4;
	}
	ecxOut = ecx_25;
	return eax_24;
}

// 00404F80: Register Eq_2 fn00404F80(Stack Eq_2 dwArgD0, Stack Eq_2 dwArgD4, Stack Eq_2 dwArgD8)
// Called from:
//      fn00404DE0
//      fn00405710
Eq_2 fn00404F80(Eq_2 dwArgD0, Eq_2 dwArgD4, Eq_2 dwArgD8)
{
	Eq_10873 esi_13 = 0x00;
	Eq_2 eax_22 = fn00406880(0x01);
	if (eax_22 == 0x0A || eax_22 == ~0x00)
	{
		word32 edx_353;
		word32 ecx_352;
		fn00403220(g_t4133F4, 1018, out ecx_352, out edx_353);
	}
	fn00404D70(eax_22, g_t4133D8);
	while (true)
	{
		word32 ecx_358;
		Eq_2 ecx_113;
		Eq_2 eax_88 = fn004069D0(fn00404CF0(g_t4133D8, out ecx_358), 0x01, out ecx_113);
		Eq_2 ebx_120 = eax_88;
		byte bl_238 = (byte) eax_88;
		if (eax_88 == 0x23 || (eax_88 == 0x0A || eax_88 == ~0x00))
			break;
		if ((word32) esi_13 + 2 > g_t413A7C)
		{
			g_t413A7C = (word32) g_t413A7C + 0x0400;
			Eq_10911 eax_192 = g_t413A7C;
			if (g_t413A74 == 0x00)
			{
				fn0040ACF0((word32) eax_192 + 1, (word32) eax_192 + 1);
				g_t413A74 = (word32) eax_192 + 1;
			}
			else
			{
				Eq_2 eax_201 = realloc(g_t413A74, (word32) eax_192 + 1);
				g_t413A74 = eax_201;
				if (eax_201 == 0x00)
				{
					word32 edx_357;
					word32 ecx_356;
					fn00403220(g_t4133F4, 0x0419, out ecx_356, out edx_357);
				}
			}
		}
		esi_13 = (word32) esi_13 + 1;
		*((word32) esi_13 + (g_t413A74 - 1)) = bl_238;
	}
	Mem106[Mem81[0x00413A74<p32>:word32] + esi_13:byte] = 0x00;
	if (eax_88 == 0x23)
	{
		Eq_2 eax_112 = fn00404CF0(g_t4133D8, out ecx_113);
		ebx_120 = eax_112;
		if (eax_112 != 0x0A)
		{
			do
			{
				if (ebx_120 == ~0x00)
					goto l00405089;
				Eq_2 eax_130 = fn00404CF0(g_t4133D8, out ecx_113);
				ebx_120 = eax_130;
			} while (eax_130 != 0x0A);
		}
	}
	if (ebx_120 == ~0x00)
	{
l00405089:
		fn00404D70(ebx_120, g_t4133D8);
	}
	word32 ebp_355;
	word32 ebx_354;
	return fn0040B690(ecx_113, g_t413A74, dwArgD0, dwArgD4, dwArgD8, out ebx_354, out ebp_355);
}

// 004050B0: Register Eq_2 fn004050B0(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00404DE0
//      fn00405710
Eq_2 fn004050B0(Eq_2 dwArg04, Eq_2 dwArg08)
{
	*dwArg08 = 0x00;
	Eq_2 dwLoc04_254 = dwArg04;
	if (*dwArg04 != 0x00)
	{
		do
		{
			byte al_26 = *dwLoc04_254;
			if (al_26 == 0x20 || al_26 == 0x09)
				break;
			Eq_2 v11_31 = (word32) dwLoc04_254 + 1;
			dwLoc04_254 = v11_31;
		} while (*v11_31 != 0x00);
	}
	ui32 ebx_42 = dwLoc04_254 - dwArg04;
	if (*dwLoc04_254 != 0x00)
	{
		do
		{
			byte al_48 = *dwLoc04_254;
			if (al_48 != 0x20 && al_48 != 0x09)
				break;
			Eq_2 v13_55 = (word32) dwLoc04_254 + 1;
			dwLoc04_254 = v13_55;
		} while (*v13_55 != 0x00);
	}
	if (mbsnbicmp(dwArg04, 4276012, 0x07) == 0x00 && ebx_42 == 0x07)
		*dwArg08 = 0x09;
	else if (mbsnbicmp(dwArg04, 4276000, 11) == 0x00 && ebx_42 == 11)
		*dwArg08 = 0x0A;
	else if (mbsnbicmp(dwArg04, 4275992, 0x05) == 0x00 && ebx_42 == 0x05)
		*dwArg08 = 11;
	else if (mbsnbicmp(dwArg04, 0x00413F10, 0x07) == 0x00 && ebx_42 == 0x07)
		*dwArg08 = 0x0C;
	else if (mbsnbicmp(dwArg04, 0x00413F08, 0x05) == 0x00 && ebx_42 == 0x05)
		*dwArg08 = 0x0D;
	else
	{
		esp_176->ptr0008 = (union Eq_2 *) ((char *) &esp_176->ptr0008 + 20);
		esp_176->dw0004 = ebx_42;
		esp_176->t0000 = dwArg04;
		*dwArg08 = fn00405360(esp_176->t0000, esp_176->dw0004, esp_176->ptr0008);
	}
	if (*dwArg08 == 0x00)
	{
		word32 ecx_366;
		word32 edx_367;
		fn00403220(g_t4133F4, 1017, out ecx_366, out edx_367);
	}
	return dwLoc04_254;
}

// 004051E0: void fn004051E0(Stack Eq_2 dwArg04)
// Called from:
//      fn00404DE0
void fn004051E0(Eq_2 dwArg04)
{
	ptr32 fp;
	Eq_2 ebx_10 = dwArg04;
	ptr32 esp_101 = fp - 0x0C;
	if (*dwArg04 != 0x00)
	{
		do
		{
			byte al_20 = *ebx_10;
			int32 ecx_21 = (int32) al_20;
			if (ecx_21 != 0x2B)
			{
				if (ecx_21 == 0x2D)
					goto l004052C4;
				if (al_20 != 0x20 && al_20 != 0x09)
				{
					struct Eq_11205 * esp_271 = esp_101 - 4;
					esp_271->t0000.u0 = 0x0400;
					esp_271->tFFFFFFFC = g_t4133F4;
					word32 ecx_472;
					word32 edx_473;
					fn00403220(esp_271->tFFFFFFFC, esp_271->t0000, out ecx_472, out edx_473);
					esp_101 = (char *) &esp_271->t0000 + 4;
				}
			}
			else
			{
				ebx_10 = (word32) ebx_10 + 1;
				if (*ebx_10 != 0x00)
				{
					do
					{
						byte al_29 = *ebx_10;
						if (al_29 == 0x2D)
							break;
						word32 eax_53 = mbschr(0x00413F44, mbctoupper((int32) al_29) & 0xFFFF);
						word24 eax_24_8_122 = SLICE(eax_53, word24, 8);
						word32 esp_57 = (char *) &esp_52->t0004 + 4;
						if (eax_53 != 0x00)
						{
							esp_52->t0004.u0 = 0x01;
							esp_52->t0000 = SEQ(eax_24_8_122, *ebx_10);
							fn004086D0(esp_52->t0000, esp_52->t0004);
							esp_101 = (char *) &esp_52->t0004 + 4;
							goto l004052B5;
						}
						if (g_t413408 != 0x00)
						{
							word32 eax_80 = mbschr(0x00413F34, mbctoupper((int32) *ebx_10) & 0xFFFF);
							word24 eax_24_8_107 = SLICE(eax_80, word24, 8);
							esp_57 = (char *) &esp_79->t0004 + 4;
							if (eax_80 == 0x00)
								goto l004052A2;
							esp_79->t0004.u0 = 0x01;
							esp_79->t0000 = SEQ(eax_24_8_107, *ebx_10);
							fn004086D0(esp_79->t0000, esp_79->t0004);
							esp_101 = (char *) &esp_79->t0004 + 4;
						}
						else
						{
l004052A2:
							struct Eq_11423 * esp_89 = esp_57 - 4;
							esp_89->t0000.u0 = 0x0400;
							esp_89->tFFFFFFFC = g_t4133F4;
							word32 ecx_476;
							word32 edx_477;
							fn00403220(esp_89->tFFFFFFFC, esp_89->t0000, out ecx_476, out edx_477);
							esp_101 = (char *) &esp_89->t0000 + 4;
						}
l004052B5:
						ebx_10 = (word32) ebx_10 + 1;
					} while (*ebx_10 != 0x00);
					if (*ebx_10 == 0x00)
						return;
l004052C4:
					ebx_10 = (word32) ebx_10 + 1;
					if (*ebx_10 == 0x00)
						return;
					do
					{
						byte al_152 = *ebx_10;
						if (al_152 == 0x2B)
							break;
						word32 eax_177 = mbschr(0x00413F44, mbctoupper((int32) al_152) & 0xFFFF);
						word24 eax_24_8_249 = SLICE(eax_177, word24, 8);
						word32 esp_182 = (char *) &esp_176->t0004 + 4;
						if (eax_177 != 0x00)
						{
							esp_176->t0004.u0 = 0x00;
							esp_176->t0000 = SEQ(eax_24_8_249, *ebx_10);
							fn004086D0(esp_176->t0000, esp_176->t0004);
							esp_101 = (char *) &esp_176->t0004 + 4;
							goto l00405342;
						}
						if (g_t413408 != 0x00)
						{
							word32 eax_206 = mbschr(0x00413F34, mbctoupper((int32) *ebx_10) & 0xFFFF);
							word24 eax_24_8_234 = SLICE(eax_206, word24, 8);
							esp_182 = (char *) &esp_205->t0004 + 4;
							if (eax_206 == 0x00)
								goto l0040532F;
							esp_205->t0004.u0 = 0x00;
							esp_205->t0000 = SEQ(eax_24_8_234, *ebx_10);
							fn004086D0(esp_205->t0000, esp_205->t0004);
							esp_101 = (char *) &esp_205->t0004 + 4;
						}
						else
						{
l0040532F:
							struct Eq_11301 * esp_216 = esp_182 - 4;
							esp_216->t0000.u0 = 0x0400;
							esp_216->tFFFFFFFC = g_t4133F4;
							word32 ecx_474;
							word32 edx_475;
							fn00403220(esp_216->tFFFFFFFC, esp_216->t0000, out ecx_474, out edx_475);
							esp_101 = (char *) &esp_216->t0000 + 4;
						}
l00405342:
						ebx_10 = (word32) ebx_10 + 1;
					} while (*ebx_10 != 0x00);
				}
			}
			if (*ebx_10 == 0x00)
				return;
			ebx_10 = (word32) ebx_10 + 1;
		} while (*ebx_10 != 0x00);
	}
}

// 00405360: Register byte fn00405360(Stack Eq_2 dwArg04, Stack ui32 dwArg08, Stack (ptr32 Eq_2) dwArg0C)
// Called from:
//      fn004050B0
byte fn00405360(Eq_2 dwArg04, ui32 dwArg08, union Eq_2 * dwArg0C)
{
	word32 eax_30 = mbsnbicmp(dwArg04, 4272744, 0x02);
	if (eax_30 == 0x00 && dwArg08 == 0x02)
		return 0x01;
	word32 eax_55 = mbsnbicmp(dwArg04, 0x00413F84, 0x05);
	if (eax_55 == 0x00 && dwArg08 == 0x05)
		return 0x06;
	word32 eax_79 = mbsnbicmp(dwArg04, 4276092, 0x06);
	if (eax_79 == 0x00 && dwArg08 == 0x06)
		return 0x07;
	word32 eax_24_8_bl_701;
	word32 eax_103 = mbsnbicmp(dwArg04, 0x00413F74, 0x04);
	if (eax_103 != 0x00 || dwArg08 != 0x04)
	{
		word32 eax_127 = mbsnbicmp(dwArg04, 4276076, 0x06);
		if (eax_127 == 0x00 && dwArg08 == 0x06)
			return 0x03;
		word32 eax_151 = mbsnbicmp(dwArg04, 4276064, 0x09);
		if (eax_151 == 0x00 && dwArg08 == 0x09)
			return 0x04;
		word32 eax_175 = mbsnbicmp(dwArg04, 0x00413F54, 0x0A);
		if (eax_175 == 0x00 && dwArg08 == 0x0A)
			return 0x05;
		word32 eax_199 = mbsnbicmp(dwArg04, 4276044, 0x05);
		word24 eax_24_8_505 = SLICE(eax_199, word24, 8);
		eax_24_8_bl_701 = SEQ(eax_24_8_505, 0x00);
		if (eax_199 == 0x00)
		{
			eax_24_8_bl_701 = SEQ(eax_24_8_505, 0x00);
			if (dwArg08 == 0x05)
				eax_24_8_bl_701 = SEQ(eax_24_8_505, 0x08);
		}
		return (byte) eax_24_8_bl_701;
	}
	else
	{
		Eq_2 ecx_242 = *dwArg0C;
		byte al_243 = *ecx_242;
		if (al_243 == 0x00)
			return 0x02;
		Eq_2 ecx_251;
		ecx_251 = ecx_242;
		ecx_251 = ecx_242;
		if (al_243 != 0x00)
		{
			do
			{
				byte al_253 = *ecx_251;
				if (al_253 == 0x20 || al_253 == 0x09)
					break;
				ecx_251 = (word32) ecx_251 + 1;
			} while (*ecx_251 != 0x00);
		}
		int32 ebp_265 = ecx_251 - ecx_242;
		while (*ecx_251 != 0x00)
		{
			byte al_271 = *ecx_251;
			if (al_271 != 0x20 && al_271 != 0x09)
				break;
			ecx_251 = (word32) ecx_251 + 1;
		}
		*dwArg0C = (union Eq_2 *) ecx_251;
		word32 eax_321 = mbsnbicmp(ecx_242, 4272744, 0x02);
		if (eax_321 == 0x00 && ebp_265 == 0x02)
			return 0x03;
		word32 eax_345 = mbsnbicmp(ecx_242, 0x00413F84, 0x05);
		if (eax_345 == 0x00 && ebp_265 == 0x05)
			return 0x04;
		word32 eax_369 = mbsnbicmp(ecx_242, 4276092, 0x06);
		word24 eax_24_8_502 = SLICE(eax_369, word24, 8);
		eax_24_8_bl_701 = SEQ(eax_24_8_502, 0x00);
		if (eax_369 != 0x00)
			return (byte) eax_24_8_bl_701;
		eax_24_8_bl_701 = SEQ(eax_24_8_502, 0x00);
		if (ebp_265 != 0x06)
			return (byte) eax_24_8_bl_701;
		return 0x05;
	}
}

// 00405530: void fn00405530(Stack Eq_2 dwArg04, Stack Eq_2 bArg08)
// Called from:
//      fn00404DE0
void fn00405530(Eq_2 dwArg04, Eq_2 bArg08)
{
	uint32 eax_11 = (uint32) bArg08;
	if (eax_11 > 0x08)
		return;
	switch (eax_11)
	{
	case 0x01:
	case 0x06:
	case 0x07:
		struct Eq_11664 * eax_233 = g_ptr413A70;
		if (eax_233 == (struct Eq_11664 *) 0x0F)
		{
			word32 ecx_466;
			word32 edx_467;
			fn00403220(g_t4133F4, 1019, out ecx_466, out edx_467);
			eax_233 = g_ptr413A70;
		}
		eax_233->b413A61 = 0x01;
		struct Eq_11664 * eax_254 = (char *) eax_233 + 1;
		g_ptr413A70 = eax_254;
		if (eax_254 == null || (eax_254->b413A5F & 0x02) != 0x00)
		{
			if (fn00409E80(dwArg04, bArg08) == 0x00)
			{
				fn00405710();
				return;
			}
			else
			{
				struct Eq_11664 * eax_294 = g_ptr413A70;
				eax_294->b413A60 |= 0x02;
				return;
			}
		}
		else
		{
			eax_254->b413A60 = 0x05;
			fn00405710();
			return;
		}
	case 0x02:
		struct Eq_11664 * eax_154 = g_ptr413A70;
		if (eax_154 < null || (eax_154->b413A60 & 0x09) == 0x00)
		{
			word32 ecx_460;
			word32 edx_461;
			fn00403220(g_t4133F4, 1021, out ecx_460, out edx_461);
			eax_154 = g_ptr413A70;
		}
		byte * eax_179 = &eax_154->b413A60;
		byte cl_181 = *eax_179;
		*eax_179 = cl_181 & ~0x01;
		byte cl_184 = cl_181 & ~0x01 & ~0x08;
		*eax_179 = cl_184;
		if ((cl_184 & 0x04) == 0x00)
		{
			byte cl_192;
			if ((cl_184 & 0x02) != 0x00)
				cl_192 = cl_184 & ~0x02;
			else
				cl_192 = cl_184 | 0x02;
			*eax_179 = cl_192;
			if ((*eax_179 & 0x02) != 0x00)
				return;
			fn00405710();
			return;
		}
		else
		{
			fn00405710();
			return;
		}
	case 0x03:
	case 0x04:
	case 0x05:
		struct Eq_11664 * eax_55 = g_ptr413A70;
		if (eax_55 < null || (eax_55->b413A60 & 0x09) == 0x00)
		{
			word32 ecx_464;
			word32 edx_465;
			fn00403220(g_t4133F4, 1021, out ecx_464, out edx_465);
			eax_55 = g_ptr413A70;
		}
		byte * eax_81 = &eax_55->b413A60;
		byte cl_83 = *eax_81;
		*eax_81 = cl_83 & ~0x01;
		byte cl_86 = cl_83 & ~0x01 | 0x08;
		*eax_81 = cl_86;
		if ((cl_86 & 0x04) == 0x00)
		{
			if ((cl_86 & 0x02) != 0x00)
			{
				*eax_81 = cl_86 | 0x04;
				*eax_81 = (cl_86 | 0x04) & ~0x02;
				fn00405710();
				return;
			}
			if (fn00409E80(dwArg04, bArg08) == 0x00)
			{
				fn00405710();
				return;
			}
			else
			{
				struct Eq_11664 * eax_125 = g_ptr413A70;
				eax_125->b413A60 |= 0x02;
				return;
			}
		}
		else
		{
			fn00405710();
			return;
		}
	case 0x08:
		struct Eq_11664 * eax_16 = g_ptr413A70;
		if (eax_16 < null)
		{
			word32 ecx_462;
			word32 edx_463;
			fn00403220(g_t4133F4, 1021, out ecx_462, out edx_463);
			eax_16 = g_ptr413A70;
		}
		struct Eq_11664 * eax_36 = eax_16 - 0x01;
		g_ptr413A70 = eax_36;
		if (eax_36 >= null && (eax_36->b413A60 & 0x02) == 0x00)
			fn00405710();
		return;
	}
}

// 00405710: void fn00405710()
// Called from:
//      fn00405530
void fn00405710()
{
	ptr32 fp;
	cu8 bLoc01;
	Eq_2 ecx_18 = g_t4133D8;
l00405726:
	word32 ecx_341;
	Eq_2 eax_102 = fn00404CF0(ecx_18, out ecx_341);
	Eq_2 edx_100 = g_t4133D8;
	if (eax_102 == 33)
	{
l004057DE:
		if (eax_102 != 33)
		{
			if (eax_102 == ~0x00)
			{
				word32 ecx_339;
				word32 edx_340;
				fn00403220(g_t4133F4, 1020, out ecx_339, out edx_340);
			}
			return;
		}
		goto l004057E3;
	}
l0040573B:
	if (eax_102 == ~0x00)
		goto l004057DE;
	g_t4133F4 = (word32) g_t4133F4 + 1;
	while (true)
	{
		if (eax_102 == 0x5C)
		{
			word32 ecx_331;
			eax_102 = fn004069D0(eax_102, 0x01, out ecx_331);
			word32 ecx_55 = g_dw4133F0;
			edx_100 = g_t4133D8;
			if (eax_102 == 33 && ecx_55 != 0x00)
				goto l00405793;
			g_dw4133F0 = 0x00;
		}
		if (eax_102 == 0x23)
			goto l00405798;
		if (eax_102 == 0x0A || eax_102 == ~0x00)
			break;
		word32 ecx_336;
		eax_102 = fn00404CF0(edx_100, out ecx_336);
		edx_100 = g_t4133D8;
	}
l00405793:
	if (eax_102 != 0x23)
		goto l004057BF;
l00405798:
	word32 ecx_335;
	eax_102 = fn00404CF0(edx_100, out ecx_335);
	edx_100 = g_t4133D8;
	while (eax_102 != 0x0A)
	{
		if (eax_102 == ~0x00)
			goto l004057DE;
		word32 ecx_337;
		eax_102 = fn00404CF0(edx_100, out ecx_337);
		edx_100 = g_t4133D8;
	}
l004057BF:
	if (eax_102 == ~0x00)
		goto l004057DE;
	if (eax_102 == 33)
	{
l004057E3:
		if (g_t413A78 != 0x00 && g_t413A78 != g_t413A74)
			free(g_t413A78);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg208 = <invalid>;
		Eq_2 stackArg212 = <invalid>;
		Eq_2 stackArg216 = <invalid>;
		Eq_2 eax_213 = fn00404F80(stackArg208, stackArg212, stackArg216);
		g_t413A78 = eax_213;
		fn004050B0(eax_213, fp - 0x01);
		Eq_2 eax_230 = g_t4133F4;
		ecx_18 = g_t4133D8;
		if (bLoc01 <= 0x08)
			return;
		g_t4133F4 = (word32) eax_230 + 1;
		goto l00405726;
	}
	word32 ecx_338;
	eax_102 = fn00404CF0(edx_100, out ecx_338);
	edx_100 = g_t4133D8;
	if (eax_102 == 33)
		goto l004057DE;
	goto l0040573B;
}

// 00405860: Register word32 fn00405860(Register Eq_2 ecx, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      fn00407F70
word32 fn00405860(Eq_2 ecx, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 dwLoc10;
	fn0040CEB4((word32) g_t413EE0 + 3 & ~0x03, ecx, dwLoc10);
	Eq_2 eax_41 = fn00405930(getenv(dwArg04), dwArg08);
	if (eax_41 == 0x00)
		return 0x00;
	Eq_2 eax_57 = fn0040CA80(eax_41);
	g_t4133D8 = eax_57;
	if (eax_57 == 0x00)
	{
		word32 ecx_200;
		word32 edx_201;
		fn00403220(0x00, 0x041D, out ecx_200, out edx_201);
	}
	free(eax_41);
	if (fn00405A20(dwArg0C) != 0x00)
		return 0x01;
	if (fclose(g_t4133D8) == ~0x00)
	{
		word32 ecx_202;
		word32 edx_203;
		fn00403220(0x00, 0x0424, out ecx_202, out edx_203);
	}
	return 0x00;
}

// 00405930: Register Eq_2 fn00405930(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00402870
//      fn00404830
//      fn00405860
//      fn00407680
Eq_2 fn00405930(Eq_2 dwArg04, Eq_2 dwArg08)
{
	if (fn0040CD20(dwArg08) == 0x00)
	{
		Eq_2 ebx_224 = dwArg04;
		if (dwArg04 == 0x00)
			return 0x00;
l0040596E:
		struct Eq_12118 * ebp_192 = g_a413AA0;
		do
		{
			byte al_44 = *ebx_224;
			if (al_44 != 0x00)
			{
				ebp_192->b0000 = al_44;
				ebx_224 = (word32) ebx_224 + 1;
				if (al_44 != 0x3B)
				{
					++ebp_192;
					continue;
				}
			}
			if (ebp_192 != g_a413AA0)
			{
				byte al_57 = ebp_192->bFFFFFFFF;
				if (al_57 != 0x5C && al_57 != 0x2F)
				{
					ebp_192->b0000 = 0x5C;
					++ebp_192;
				}
				ebp_192->b0000 = 0x00;
				if (mbspbrk(4274848, 0x00413000) != 0x00)
					goto l0040596E;
				Eq_2 edi_101 = dwArg08;
				word32 ecx_105 = ~0x00;
				while (ecx_105 != 0x00)
				{
					edi_101 = (word32) edi_101 + 1;
					--ecx_105;
					if (*edi_101 != 0x00)
						break;
				}
				uint32 ecx_108 = ~ecx_105;
				uint32 ecx_112;
				struct Eq_12177 * esi_114 = edi_101 - ecx_108;
				struct Eq_12118 * edi_117 = ebp_192;
				for (ecx_112 = ecx_108 >> 0x02; ecx_112 != 0x00; --ecx_112)
				{
					edi_117->b0000 = (byte) esi_114->dw0000;
					esi_114 += 4;
					edi_117 += 4;
				}
				ui32 ecx_121;
				for (ecx_121 = ecx_108 & 0x03; ecx_121 != 0x00; --ecx_121)
				{
					edi_117->b0000 = (byte) esi_114->dw0000;
					++esi_114;
					++edi_117;
				}
				if (fn0040CD20(4274848) == 0x00)
					goto l0040596E;
				word32 ecx_345;
				word32 edx_346;
				return fn0040ADD0(4274848, out ecx_345, out edx_346);
			}
		} while (*ebx_224 != 0x00);
		return 0x00;
	}
	else
	{
		word32 ecx_343;
		word32 edx_344;
		return fn0040ADD0(dwArg08, out ecx_343, out edx_344);
	}
}

// 00405A20: Register word32 fn00405A20(Stack Eq_2 dwArg04)
// Called from:
//      fn00405860
word32 fn00405A20(Eq_2 dwArg04)
{
	ptr32 fp;
	Eq_2 eax_7 = g_t4133D8;
	g_t4133F4.u0 = 0x00;
	ptr32 esp_138 = fp - 0x10;
	if (fgets(g_a413AA0, 0x0400, eax_7) != null)
	{
		do
		{
			if (g_a413AA0[0] == 0x5B)
			{
				byte * eax_47 = mbstok(4274849, 4272152);
				word32 ebp_102 = 0x00;
				esp_138 = esp_46 + 0x08;
				byte * edx_139 = eax_47;
				if (eax_47 != null)
				{
					while (ebp_102 == 0x00)
					{
						byte * edi_61 = edx_139;
						word32 ecx_62 = ~0x00;
						while (ecx_62 != 0x00)
						{
							edi_61 = edi_291 + 1;
							--ecx_62;
							edi_291 = edi_61;
							if (*edi_291 != 0x00)
								break;
						}
						byte * eax_77 = edx_139 + (~ecx_62 - 2);
						if (*eax_77 == 0x5D)
						{
							*eax_77 = 0x00;
							ebp_102 = 0x01;
						}
						if (mbsicmp(edx_139, dwArg04) == 0x00)
							return 0x01;
						byte * eax_133 = mbstok(0x00, 4272152);
						esp_138 = esp_132 + 0x08;
						edx_139 = eax_133;
						if (eax_133 == null)
							break;
					}
				}
			}
			Eq_2 eax_145 = g_t4133D8;
			g_t4133F4 = (word32) g_t4133F4 + 1;
			struct Eq_12269 * esp_149 = esp_138 - 4;
			esp_149->t0000 = eax_145;
			esp_149->dwFFFFFFFC = 0x0400;
			esp_149->ptrFFFFFFF8 = (struct Eq_5168 *) g_a413AA0;
			esp_138 = (char *) &esp_149->t0000 + 4;
		} while (fgets(esp_149->ptrFFFFFFF8, esp_149->dwFFFFFFFC, esp_149->t0000) != null);
	}
	if ((*((word32) g_t4133D8 + 0x0C) & 0x10) == 0x00)
	{
		g_t413424 = g_t4133F4;
		word32 ecx_289;
		word32 edx_290;
		fn00403220(0x00, 0x041D, out ecx_289, out edx_290);
	}
	return 0x00;
}

// 00405B20: Register word32 fn00405B20(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 char) dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      fn00405BC0
word32 fn00405B20(Eq_2 dwArg04, Eq_2 dwArg08, char * dwArg0C, Eq_2 dwArg10)
{
	char bLoc0104;
	_makepath(&bLoc0104, null, null, dwArg04, dwArg08);
	_searchenv(&bLoc0104, dwArg0C, dwArg10);
	if (*dwArg10 != 0x00 && mbspbrk(dwArg04, 0x00413F8C) != 0x00)
	{
		byte * edi_177 = esp_45 + 0x14;
		word32 ecx_55 = ~0x00;
		while (ecx_55 != 0x00)
		{
			++edi_177;
			--ecx_55;
			if (*edi_177 != 0x00)
				break;
		}
		uint32 ecx_67 = ~ecx_55;
		uint32 ecx_125;
		struct Eq_12421 * esi_115 = edi_177 - ecx_67;
		Eq_2 edi_116 = dwArg10;
		for (ecx_125 = ecx_67 >> 0x02; ecx_125 != 0x00; --ecx_125)
		{
			*edi_116 = esi_115->dw0000;
			esi_115 += 4;
			edi_116 = (word32) edi_116 + 4;
		}
		ui32 ecx_117;
		for (ecx_117 = ecx_67 & 0x03; ecx_117 != 0x00; --ecx_117)
		{
			*edi_116 = esi_115->dw0000;
			++esi_115;
			edi_116 = (word32) edi_116 + 1;
		}
	}
	return mbsrchr(dwArg10, 0x2E);
}

// 00405BC0: Register Eq_12466 fn00405BC0(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00403AF0
Eq_12466 fn00405BC0(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_12466 eax_20 = fn00405B20(dwArg04, 0x00413FA0, &g_b413254, dwArg08);
	if (eax_20 == 0x00)
	{
		eax_20 = fn00405B20(dwArg04, 4276120, &g_b413254, dwArg08);
		if (eax_20 == 0x00)
		{
			Eq_12466 eax_56 = fn00405B20(dwArg04, 4276112, &g_b413254, dwArg08);
			eax_20 = SLICE(cond(eax_56 - 0x01), bool, 1) + ~0x00 & eax_56;
		}
	}
	return eax_20;
}

// 00405C20: Register Eq_2 fn00405C20(Stack Eq_2 dwArg04)
// Called from:
//      fn00406A80
Eq_2 fn00405C20(Eq_2 dwArg04)
{
	ptr32 fp;
	byte bLoc03FD;
	Eq_2 esi_110 = 0x00;
	Eq_2 dwLoc0400_400 = SEQ(bLoc03FD, g_b413FAE, g_w413FAC);
	if (fn00406490(fp - 1022, 1022) == 0x00)
	{
		if ((*((word32) g_t4133D8 + 0x0C) & 0x10) != 0x00)
		{
			word32 ecx_473;
			word32 edx_474;
			fn00403220(g_t4133F4, 0x0409, out ecx_473, out edx_474);
		}
		word32 edx_472;
		word32 ecx_471;
		fn00403220(g_t4133F4, 0x041D, out ecx_471, out edx_472);
	}
	Eq_2 ebx_101;
	fn00405EF0();
	struct Eq_12519 * esp_148 = fp - 0x0418;
	if (g_ptr413404 != null)
	{
		Eq_2 edi_114 = dwLoc0400_400;
		ebx_101 = dwArg04;
		do
		{
			while (true)
			{
				esp_148[4] = (struct Eq_12519) (esp_148 + 6);
				do
				{
					byte * eax_100 = esp_148[4];
					union Eq_2 * ecx_103 = esp_148[265];
					esp_148[4] = (struct Eq_12519) ((word32) esp_148[4] + 1);
					ebx_101 = (word32) ebx_101 + 1;
					byte al_106 = *eax_100;
					*((word32) ebx_101 - 1) = al_106;
					Eq_2 eax_161 = SEQ(SLICE(eax_100, word24, 8), al_106);
					if (*ecx_103 == ebx_101)
					{
						if (esi_110 == 0x00)
						{
							struct Eq_12568 * esp_157 = esp_148 - 4;
							esp_157->t0000.u0 = 0x0800;
							fn0040ACF0(eax_161, esp_157->t0000);
							mbsnbcpy(eax_161, *esp_157->ptr0424, 0x0400);
							*esp_181->ptr0430 = (word32) eax_161 + 0x0800;
							edi_114.u0 = 0x0800;
							ebx_101 = (word32) eax_161 + 0x0400;
							esi_110 = eax_161;
							esp_148 = (struct Eq_12519 *) ((char *) esp_181 + 0x0C);
							goto l00405D58;
						}
						Eq_2 ebp_115 = (word32) edi_114 + 0x0400;
						if (edi_114 <= ebp_115)
						{
							struct Eq_12635 * esp_118 = esp_148 - 4;
							esp_118->t0000 = ebp_115;
							esp_118->tFFFFFFFC = esi_110;
							Eq_2 eax_122 = realloc(esp_118->tFFFFFFFC, esp_118->t0000);
							esi_110 = eax_122;
							if (eax_122 == 0x00)
								goto l00405D35;
						}
						else
						{
l00405D35:
							struct Eq_12611 * esp_129 = esp_148 - 4;
							esp_129->t0000.u0 = 0x0419;
							esp_129->tFFFFFFFC = g_t4133F4;
							word32 edx_476;
							word32 ecx_475;
							fn00403220(esp_129->tFFFFFFFC, esp_129->t0000, out ecx_475, out edx_476);
						}
						Mem156[Mem149[esp_148 + 0x0424:word32] + 0x00:word32] = ebp_115 + esi_110;
						ebx_101 = edi_114 + esi_110;
						edi_114 = ebp_115;
l00405D58:
						*esp_148[264] = (struct Eq_12519) esi_110;
					}
				} while (*esp_148[4] != 0x00);
				if (esp_148[5] != 0x00 && (esp_148[6] == 0x3C && esp_148->b0019 == 0x3C))
					break;
				struct Eq_12699 * esp_291 = esp_148 - 4;
				esp_291->dw0000 = 0x0400;
				esp_291->dw0018 = 0x01;
				esp_291->tFFFFFFFC = esp_148 + 6;
				esp_148 = (struct Eq_12519 *) (&esp_291->dw0000 + 1);
				if (fn00406490(esp_291->tFFFFFFFC, esp_291->dw0000) == 0x00)
				{
					if ((*((word32) g_t4133D8 + 0x0C) & 0x10) != 0x00)
					{
						esp_291->dw0000 = 4276136;
						Eq_2 eax_313 = g_t4133F4;
						esp_291->tFFFFFFFC.u0 = 0x0409;
						esp_291->tFFFFFFF8 = eax_313;
						word32 edx_480;
						word32 ecx_479;
						fn00403220(esp_291->tFFFFFFF8, esp_291->tFFFFFFFC, out ecx_479, out edx_480);
					}
					struct Eq_12758 * esp_328 = esp_148 - 4;
					esp_328->t0000.u0 = 0x041D;
					esp_328->tFFFFFFFC = g_t4133F4;
					word32 ecx_477;
					word32 edx_478;
					fn00403220(esp_328->tFFFFFFFC, esp_328->t0000, out ecx_477, out edx_478);
					esp_148 = (struct Eq_12519 *) ((char *) &esp_328->t0000 + 4);
				}
			}
			if (g_ptr413404->ptr0000 != null)
			{
				struct Eq_12820 * esp_212 = esp_148 - 4;
				esp_212->dw0000 = 0x0400;
				esp_212->tFFFFFFFC = esp_148 + 6;
				if (fn00406490(esp_212->tFFFFFFFC, esp_212->dw0000) == 0x00)
				{
					if ((*((word32) g_t4133D8 + 0x0C) & 0x10) != 0x00)
					{
						esp_212->dw0000 = 4276136;
						Eq_2 eax_233 = g_t4133F4;
						esp_212->tFFFFFFFC.u0 = 0x0409;
						esp_212->tFFFFFFF8 = eax_233;
						word32 edx_484;
						word32 ecx_483;
						fn00403220(esp_212->tFFFFFFF8, esp_212->tFFFFFFFC, out ecx_483, out edx_484);
					}
					struct Eq_12851 * esp_248 = esp_148 - 4;
					esp_248->t0000.u0 = 0x041D;
					esp_248->tFFFFFFFC = g_t4133F4;
					word32 ecx_481;
					word32 edx_482;
					fn00403220(esp_248->tFFFFFFFC, esp_248->t0000, out ecx_481, out edx_482);
				}
			}
			struct Eq_12523 * ecx_264 = g_ptr413404->ptr0000;
			g_ptr413404 = ecx_264;
		} while (ecx_264 != null);
	}
	else
		ebx_101 = dwArg04;
	*ebx_101 = 0x00;
	return ebx_101;
}

// 00405E60: void fn00405E60(Stack Eq_2 dwArg04)
// Called from:
//      fn00405EF0
void fn00405E60(Eq_2 dwArg04)
{
	Eq_2 esi_19 = dwArg04;
	while (true)
	{
		struct Eq_12907 * eax_31 = mbschr(esi_19, 0x0A);
		if (eax_31 == null || eax_31->bFFFFFFFF != 0x5E)
			break;
		esi_19 = eax_31 + 0x01;
		if (fgets(eax_31 + 0x01, dwArg04 - (eax_31 + 0x01) + 0x0400, Mem25[0x004133D8<p32>:word32]) == 0x00)
		{
			if ((*((word32) g_t4133D8 + 0x0C) & 0x10) != 0x00)
			{
				word32 edx_171;
				word32 ecx_170;
				fn00403220(g_t4133F4, 0x0409, out ecx_170, out edx_171);
			}
			word32 ecx_168;
			word32 edx_169;
			fn00403220(g_t4133F4, 0x041D, out ecx_168, out edx_169);
		}
		g_t4133F4 = (word32) g_t4133F4 + 1;
	}
}

// 00405EF0: void fn00405EF0()
// Called from:
//      fn00405C20
void fn00405EF0()
{
	Eq_2 tArg04;
	fn00405E60(tArg04);
	Eq_2 eax_26 = fn00405F60(&tArg04);
	Eq_2 edi_33 = eax_26;
	while (eax_26 != 0x00)
	{
		fn0040ACF0(eax_26, 0x0C);
		word32 ecx_124;
		word32 edx_125;
		*((word32) eax_26 + 4) = fn0040ADD0(edi_33, out ecx_124, out edx_125);
		fn00405F40(0x00413404, eax_26);
		eax_26 = fn00405F60(&tArg04);
		edi_33 = eax_26;
	}
}

// 00405F40: void fn00405F40(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00405EF0
void fn00405F40(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 eax_10 = dwArg04;
	if (*dwArg04 != 0x00)
	{
		do
			eax_10 = *eax_10;
		while (*eax_10 != 0x00);
	}
	*eax_10 = dwArg08;
}

// 00405F60: Register ptr32 fn00405F60(Stack Eq_2 dwArg04)
// Called from:
//      fn00405EF0
//      fn00406020
ptr32 fn00405F60(Eq_2 dwArg04)
{
	byte * edi_110 = &g_b410F40;
	Eq_2 eax_18 = *dwArg04;
	word32 ebp_19 = 0x00;
	do
	{
		struct Eq_13032 * eax_35 = mbschr(eax_18, 0x3C);
		if (eax_35 == null)
			return 0x00;
		eax_18 = &eax_35->b0001;
		if (eax_35->b0001 == 0x3C)
			ebp_19 = 0x01;
	} while (ebp_19 == 0x00);
	Eq_2 eax_100 = &eax_35->b0002;
	if (eax_35->b0002 != 0x00)
	{
		do
		{
			byte dl_70 = *eax_100;
			if (dl_70 == 0x20 || (dl_70 == 0x3E || (dl_70 == 0x3C || (dl_70 == 0x5E || (dl_70 == 44 || (dl_70 == 0x09 || dl_70 == 0x0A))))))
				break;
			if (dl_70 == 0x24)
			{
				Eq_2 ecx_87 = (word32) eax_100 + 1;
				if (*ecx_87 != 0x28)
					goto l00405FF8;
				*edi_110 = 0x24;
				++edi_110;
				*edi_110 = 0x28;
				eax_100 = ecx_87;
				if (*ecx_87 != 0x0A)
				{
					do
					{
						byte cl_106 = *eax_100;
						if (cl_106 == 0x29)
							break;
						*edi_110 = cl_106;
						eax_100 = (word32) eax_100 + 1;
						++edi_110;
					} while (*eax_100 != 0x0A);
				}
				if (*eax_100 == 0x0A)
					break;
			}
			else
			{
l00405FF8:
				*edi_110 = dl_70;
				++edi_110;
				eax_100 = (word32) eax_100 + 1;
			}
		} while (*eax_100 != 0x00);
	}
	*edi_110 = 0x00;
	*dwArg04 = eax_100;
	return 0x00410F40;
}

// 00406020: Register word32 fn00406020(Stack Eq_2 dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn004036C0
word32 fn00406020(Eq_2 dwArg04, ptr32 & edxOut)
{
	word32 eax_123;
	ptr32 edx_37;
	Eq_2 eax_24 = mbschr(dwArg04, 0x0A);
	esp_23->t0024 = eax_24;
	if (eax_24 != 0x00)
	{
		Eq_2 edi_48 = esp_23->t013C;
		*eax_24 = 0x00;
		esp_23->t0004 = edi_48;
		esp_23->t0000 = dwArg04;
		word32 edx_632;
		fn0040B700(esp_23->t0000, esp_23->t0004, out edx_632);
		union Eq_2 * esi_61 = esp_23->ptr0138;
		*esi_61 = (union Eq_2 *) eax_24;
		Eq_2 eax_63 = esp_23->t0024;
		esp_23->t0024 = (word32) esp_23->t0024 + 1;
		*eax_63 = 0x0A;
		if (*esi_61 == dwArg04)
		{
			esp_23->t0004 = dwArg04;
			word32 edx_634;
			word32 ecx_633;
			*esi_61 = (union Eq_2 *) fn0040ADD0(esp_23->t0004, out ecx_633, out edx_634);
		}
		Eq_2 eax_82 = *esi_61;
		esp_23->t0004 = edi_48;
		Eq_2 ecx_87 = esp_23->t0024;
		esp_23->t0020 = eax_82;
		esp_23->t0000 = ecx_87;
		word32 edx_92;
		fn0040B700(esp_23->t0000, esp_23->t0004, out edx_92);
		esp_23->t0028 = eax_82;
		esp_23->t0018 = eax_82;
		word24 edx_24_8_529 = SLICE(edx_92, word24, 8);
		ptr32 esp_100 = (char *) &esp_23->t0004 + 4;
		while (true)
		{
			struct Eq_13275 * esp_102 = esp_100 - 4;
			esp_102->t0000 = esp_100 + 24;
			Eq_2 eax_105 = fn00405F60(esp_102->t0000);
			edx_37 = SEQ(edx_24_8_529, dl_104);
			if (eax_105 == 0x00)
				break;
			Eq_2 ebx_163;
			struct Eq_13284 * esp_178;
			esp_102->dw0018 = 0x00;
			esp_102->t0000 = eax_105;
			word32 ecx_635;
			word32 edx_636;
			Eq_2 eax_141 = fn0040ADD0(esp_102->t0000, out ecx_635, out edx_636);
			Eq_2 ebp_150 = eax_141;
			if (*eax_141 == 0x00)
			{
				esp_102->t0000.u0 = 0x00413FC0;
				Eq_2 eax_197 = getenv(esp_102->t0000);
				ptr32 esp_198 = (char *) &esp_102->t0000 + 4;
				if (eax_197 != 0x00 && *eax_197 != 0x00)
				{
					mbsnbcpy(&esp_102->b0028, eax_197, 0x0101);
					esp_198 = esp_216 + 0x0C;
				}
				else
					esp_102->b0028 = 0x00;
				struct Eq_13357 * esp_226 = esp_198 - 4;
				esp_226->t0000 = esp_198 + 36;
				Eq_2 eax_228 = fn00407450(esp_226->t0000);
				ebx_163 = eax_228;
				if (eax_228 == 0x00)
				{
					Eq_2 ecx_241 = g_t4133F4;
					esp_226->t0000 = (char *) &esp_226->t0000 + 40;
					esp_226->tFFFFFFFC.u0 = 0x041E;
					esp_226->tFFFFFFF8 = ecx_241;
					word32 edx_640;
					word32 ecx_639;
					fn00403220(esp_226->tFFFFFFF8, esp_226->tFFFFFFFC, out ecx_639, out edx_640);
				}
				struct Eq_13387 * esp_259 = esp_198 - 4;
				esp_259->t0000 = esp_198 + 36;
				esp_259->ptrFFFFFFFC = esi_61;
				fn004062A0(esp_259->ptrFFFFFFFC, esp_259->t0000);
				esp_259->t0000 = eax_141;
				free(esp_259->t0000);
				esp_259->t0000 = (char *) &esp_259->t0000 + 40;
				esp_178 = (struct Eq_13284 *) ((char *) &esp_259->t0000 + 4);
				word32 ecx_637;
				word32 edx_638;
				ebp_150 = fn0040ADD0(esp_259->t0000, out ecx_637, out edx_638);
			}
			else
			{
				esp_102->t0000.u0 = 0x0041338C;
				esp_102->tFFFFFFFC = eax_141;
				Eq_2 eax_156 = fn0040CA80(esp_102->tFFFFFFFC);
				ebx_163 = eax_156;
				if (eax_156 == 0x00)
				{
					esp_102->t0000 = eax_141;
					Eq_2 eax_181 = g_t4133F4;
					esp_102->tFFFFFFFC.u0 = 0x041E;
					esp_102->tFFFFFFF8 = eax_181;
					word32 ecx_641;
					word32 edx_642;
					fn00403220(esp_102->tFFFFFFF8, esp_102->tFFFFFFFC, out ecx_641, out edx_642);
					esp_178 = (struct Eq_13284 *) ((char *) &esp_102->t0000 + 4);
				}
				else
				{
					esp_102->t0000 = *esi_61;
					fn00406430(esp_102->t0000);
					esp_178 = (struct Eq_13284 *) ((char *) &esp_102->t0000 + 4);
				}
			}
			int32 edi_350;
			esp_178->t0018 = *esi_61;
			struct Eq_13467 * esp_299 = esp_178 - 4;
			esp_299->ptr0000 = (struct Eq_14068 **) ((char *) esp_178 + 16);
			esp_299->tFFFFFFFC = ebx_163;
			fn004063B0(esp_299->tFFFFFFFC, esp_299->ptr0000);
			word32 eax_326 = mbschr(esp_299->dw0014, 0x0A);
			edx_24_8_529 = SLICE(edx_329, word24, 8);
			struct Eq_13499 * esp_331 = (char *) esp_325 + 8;
			if (eax_326 != 0x00)
				edi_350 = eax_326 - esp_325->ptr0018;
			else
			{
				byte * edi_336 = esp_325->ptr0018;
				word32 ecx_337 = ~0x00;
				while (ecx_337 != 0x00)
				{
					edi_336 = edi_646 + 1;
					--ecx_337;
					edi_646 = edi_336;
					if (*edi_646 != 0x00)
						break;
				}
				edi_350 = ~ecx_337 - 1;
			}
			if (edi_350 > 0x03)
			{
				edx_24_8_529 = SLICE(edx_384, word24, 8);
				esp_331 = (struct Eq_13499 *) ((char *) esp_380 + 0x0C);
				if (mbsnbicmp(esp_325->ptr0018, 4276152, 0x04) != 0x00)
					goto l004061D3;
				esp_380->dw001C += 0x04;
				esp_380->dw0020 = 0x01;
				goto l0040620F;
			}
l004061D3:
			if (edi_350 > 0x05)
			{
				edx_24_8_529 = SLICE(edx_410, word24, 8);
				esp_331 = (struct Eq_13499 *) ((char *) esp_406 + 0x0C);
				if (mbsnbicmp(esp_331->ptr0010, 4276144, 0x06) != 0x00)
					goto l004061F8;
				esp_406->dw001C += 0x06;
			}
			else
			{
l004061F8:
				if (edi_350 != 0x00)
				{
					struct Eq_13710 * esp_421 = esp_331 - 4;
					esp_421->t0000.u0 = 0x0446;
					esp_421->tFFFFFFFC = g_t4133F4;
					word32 edx_428;
					word32 ecx_645;
					fn00403220(esp_421->tFFFFFFFC, esp_421->t0000, out ecx_645, out edx_428);
					edx_24_8_529 = SLICE(edx_428, word24, 8);
					esp_331 = (struct Eq_13499 *) ((char *) &esp_421->t0000 + 4);
				}
			}
l0040620F:
			if (*esp_331->ptr0010 == 0x0A)
				++esp_331->ptr0010;
			struct Eq_13611 * esp_452 = esp_331 - 4;
			esp_452->t0000 = ebx_163;
			fclose(esp_452->t0000);
			if (esp_452->dw0018 == 0x00)
			{
				word32 ecx_643;
				Eq_2 eax_461 = fn0040AD20(out ecx_643);
				esp_452->t0000 = ebp_150;
				word32 edx_476;
				word32 ecx_644;
				Eq_2 eax_474 = fn0040ADD0(esp_452->t0000, out ecx_644, out edx_476);
				esp_452->t0000 = eax_461;
				*((word32) eax_461 + 4) = eax_474;
				esp_452->tFFFFFFFC.u0 = 0x004133BC;
				fn0040AE30(esp_452->tFFFFFFFC, esp_452->t0000);
				edx_24_8_529 = SLICE(edx_476, word24, 8);
			}
			union Eq_2 * esp_495 = esp_331 - 4;
			*esp_495 = (union Eq_2 *) ebp_150;
			free(*esp_495);
			esp_100 = (char *) esp_495 + 4;
		}
		if (esp_102->t0024 != esp_102->t0020)
		{
			esp_102->t0000 = esp_102->t0024;
			free(esp_102->t0000);
		}
		eax_123 = 0x01;
	}
	else
	{
		esp_23->t0004 = dwArg04;
		word32 ecx_631;
		*esp_23->ptr0138 = (union Eq_2 *) fn0040ADD0(esp_23->t0004, out ecx_631, out edx_37);
		eax_123 = 0x00;
	}
	edxOut = edx_37;
	return eax_123;
}

// 004062A0: void fn004062A0(Stack (ptr32 Eq_2) dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00406020
void fn004062A0(union Eq_2 * dwArg04, Eq_2 dwArg08)
{
	ptr32 fp;
	Eq_2 dwLoc1C;
	word32 ecx_19 = ~0x00;
	Eq_2 edi_22 = *dwArg04;
	while (ecx_19 != 0x00)
	{
		edi_22 = (word32) edi_532 + 1;
		--ecx_19;
		edi_532 = edi_22;
		if (*edi_532 != 0x00)
			break;
	}
	word32 ecx_32 = ~ecx_19;
	Eq_2 edi_36 = dwArg08;
	word32 ecx_40 = ~0x00;
	while (ecx_40 != 0x00)
	{
		edi_36 = (word32) edi_533 + 1;
		--ecx_40;
		edi_533 = edi_36;
		if (*edi_533 != 0x00)
			break;
	}
	Eq_2 ecx_50 = ~ecx_40;
	fn0040CEB4(ecx_50 - 2 + (ecx_32 - 1) + 0x03 & ~0x03, ecx_50, dwLoc1C);
	Eq_2 edx_309 = *dwArg04;
	byte * esi_310 = fp - 0x18;
	while (true)
	{
		while (true)
		{
			byte al_81 = *edx_309;
			if (al_81 == 0x3C)
				break;
			*esi_310 = al_81;
			edx_309 = (word32) edx_309 + 1;
			++esi_310;
		}
		if (*((word32) edx_309 + 1) == 0x3C)
			break;
		*esi_310 = 0x3C;
		edx_309 = (word32) edx_309 + 1;
		++esi_310;
	}
	*esi_310 = 0x00;
	Eq_2 edi_104 = dwArg08;
	word32 ecx_100 = ~0x00;
	while (ecx_100 != 0x00)
	{
		edi_104 = (word32) edi_104 + 1;
		--ecx_100;
		if (*edi_104 != 0x00)
			break;
	}
	uint32 ecx_103 = ~ecx_100;
	struct Eq_13845 * esi_109 = edi_104 - ecx_103;
	word32 ecx_110 = ~0x00;
	byte * edi_111 = fp - 0x18;
	while (ecx_110 != 0x00)
	{
		++edi_111;
		--ecx_110;
		if (*edi_111 != 0x00)
			break;
	}
	struct Eq_13862 * edi_123 = edi_111 - 0x01;
	uint32 ecx_128;
	for (ecx_128 = ecx_103 >> 0x02; ecx_128 != 0x00; --ecx_128)
	{
		edi_123->dw0000 = esi_109->dw0000;
		esi_109 += 4;
		edi_123 += 4;
	}
	ui32 ecx_134;
	for (ecx_134 = ecx_103 & 0x03; ecx_134 != 0x00; --ecx_134)
	{
		edi_123->dw0000 = esi_109->dw0000;
		++esi_109;
		++edi_123;
	}
	byte * edi_139 = (word32) edx_309 + 2;
	word32 ecx_140 = ~0x00;
	while (ecx_140 != 0x00)
	{
		++edi_139;
		--ecx_140;
		if (*edi_139 != 0x00)
			break;
	}
	uint32 ecx_152 = ~ecx_140;
	struct Eq_13917 * esi_156 = edi_139 - ecx_152;
	word32 ecx_157 = ~0x00;
	byte * edi_162 = fp - 0x18;
	while (ecx_157 != 0x00)
	{
		++edi_162;
		--ecx_157;
		if (*edi_162 != 0x00)
			break;
	}
	struct Eq_13934 * edi_174 = edi_162 - 0x01;
	uint32 ecx_178;
	for (ecx_178 = ecx_152 >> 0x02; ecx_178 != 0x00; --ecx_178)
	{
		edi_174->dw0000 = esi_156->dw0000;
		esi_156 += 4;
		edi_174 += 4;
	}
	ui32 ecx_183;
	for (ecx_183 = ecx_152 & 0x03; ecx_183 != 0x00; --ecx_183)
	{
		edi_174->dw0000 = esi_156->dw0000;
		++esi_156;
		++edi_174;
	}
	byte * edi_189 = fp - 0x18;
	word32 ecx_190 = ~0x00;
	while (ecx_190 != 0x00)
	{
		edi_189 = edi_538 + 1;
		--ecx_190;
		edi_538 = edi_189;
		if (*edi_538 != 0x00)
			break;
	}
	*dwArg04 = (union Eq_2 *) realloc(*dwArg04, ~ecx_190);
	byte * edi_218 = fp - 0x18;
	word32 ecx_220 = ~0x00;
	while (ecx_220 != 0x00)
	{
		++edi_218;
		--ecx_220;
		if (*edi_218 != 0x00)
			break;
	}
	uint32 ecx_232 = ~ecx_220;
	uint32 ecx_236;
	struct Eq_14016 * esi_238 = edi_218 - ecx_232;
	Eq_2 edi_242 = *dwArg04;
	for (ecx_236 = ecx_232 >> 0x02; ecx_236 != 0x00; --ecx_236)
	{
		*edi_242 = esi_238->dw0000;
		esi_238 += 4;
		edi_242 = (word32) edi_242 + 4;
	}
	ui32 ecx_248;
	for (ecx_248 = ecx_232 & 0x03; ecx_248 != 0x00; --ecx_248)
	{
		*edi_242 = esi_238->dw0000;
		++esi_238;
		edi_242 = (word32) edi_242 + 1;
	}
}

// 004063B0: void fn004063B0(Stack Eq_2 dwArg04, Stack (ptr32 (ptr32 Eq_14068)) dwArg08)
// Called from:
//      fn00406020
void fn004063B0(Eq_2 dwArg04, struct Eq_14068 ** dwArg08)
{
	while (true)
	{
		struct Eq_14068 * eax_30 = mbschr(*dwArg08, 0x0A);
		if (eax_30 == null)
			break;
		if (mbsnbcmp(*dwArg08, 4276140, 0x02) == 0x00)
		{
			*dwArg08 = (struct Eq_14068 **) ((char *) *dwArg08 + 2);
			if (eax_30 == null)
				break;
			return;
		}
		struct Eq_14068 * ebp_100 = *dwArg08;
		while (ebp_100 <= eax_30)
		{
			esp_45->t0008 = dwArg04;
			++ebp_100;
			esp_45->dw0004 = (int32) ebp_100->bFFFFFFFF;
			fputc(esp_45->dw0004, esp_45->t0008);
		}
		*dwArg08 = (struct Eq_14068 **) ebp_100;
	}
	if (mbsnbcmp(*dwArg08, 4276140, 0x02) == 0x00)
		*dwArg08 = (struct Eq_14068 **) ((char *) *dwArg08 + 2);
}

// 00406430: void fn00406430(Stack Eq_2 dwArg04)
// Called from:
//      fn00406020
void fn00406430(Eq_2 dwArg04)
{
	struct Eq_14144 * eax_21 = mbschr(dwArg04, 0x3C);
	struct Eq_14144 * edx_27 = eax_21;
	if (eax_21[1] != 0x3C)
	{
		do
		{
			struct Eq_14144 * eax_44 = mbschr(edx_27 + 1, 0x3C);
			edx_27 = eax_44;
		} while (eax_44[1] != 0x3C);
	}
	byte * edi_158 = edx_27 + 2;
	word32 ecx_56 = ~0x00;
	while (ecx_56 != 0x00)
	{
		++edi_158;
		--ecx_56;
		if (*edi_158 != 0x00)
			break;
	}
	uint32 ecx_68 = ~ecx_56;
	uint32 ecx_107;
	struct Eq_14176 * esi_100 = edi_158 - ecx_68;
	struct Eq_14144 * edi_103 = edx_27;
	for (ecx_107 = ecx_68 >> 0x02; ecx_107 != 0x00; --ecx_107)
	{
		edi_103->dw0000 = esi_100->dw0000;
		esi_100 += 4;
		edi_103 += 4;
	}
	ui32 ecx_81;
	for (ecx_81 = ecx_68 & 0x03; ecx_81 != 0x00; --ecx_81)
	{
		edi_103->dw0000 = esi_100->dw0000;
		++esi_100;
		++edi_103;
	}
}

// 00406490: Register Eq_2 fn00406490(Stack Eq_2 dwArg04, Stack word32 dwArg08)
// Called from:
//      fn00405C20
Eq_2 fn00406490(Eq_2 dwArg04, word32 dwArg08)
{
	Eq_2 edi_14 = dwArg04;
	Eq_2 esi_16 = (word32) dwArg04 + dwArg08;
	while (true)
	{
		word32 ecx_129;
		Eq_2 eax_103 = fn00404DE0(out ecx_129);
		byte al_45 = (byte) eax_103;
		if (eax_103 == 0x00)
			break;
		if (eax_103 == ~0x00)
		{
			*edi_14 = 0x00;
			eax_103.u0 = 0x00;
			return eax_103;
		}
		*edi_14 = al_45;
		edi_14 = (word32) edi_14 + 1;
		if (esi_16 == edi_14)
		{
			*((word32) edi_14 - 1) = 0x00;
			fn00404D70(eax_103, g_t4133D8);
			return edi_14;
		}
		if (eax_103 == 0x0A)
		{
			g_t4133F4 = (word32) g_t4133F4 + 1;
			g_dw4133F0 = 0x01;
			*edi_14 = 0x00;
			return edi_14;
		}
		g_dw4133F0 = 0x00;
	}
	return eax_103;
}

// 00406500: Register word32 fn00406500(Stack word32 dwArg04, Stack Eq_14276 bArg08, Register out ptr32 ebpOut)
// Called from:
//      fn00408AE0
word32 fn00406500(word32 dwArg04, Eq_14276 bArg08, ptr32 & ebpOut)
{
	word32 ebx;
	ptr32 ebp;
	word24 ebx_24_8_27 = SLICE(ebx, word24, 8);
	if (g_dw4133C8 == 0x00)
	{
		word32 ebx_26 = SEQ(ebx_24_8_27, bArg08);
		if (bArg08 != 0x18)
		{
			ebx_26 = SEQ(ebx_24_8_27, bArg08);
			if (bArg08 != 0x19)
			{
				Eq_2 eax_47 = fn00406880(0x00);
				g_a413AA0[0] = (byte) eax_47;
				g_b413AA1 = 0x00;
				ptr32 ebp_66;
				word32 eax_63 = fn004065D0(eax_47, &g_b413AA1, dwArg04 + 4274848, out ebp_66);
				ebpOut = ebp_66;
				return eax_63;
			}
		}
		word32 eax_172 = SEQ(SLICE(fn00406A80((byte) ebx_26, 4274848), word24, 8), (byte) ebx_26);
		ebpOut = ebp;
		return eax_172;
	}
	g_dw4133C8 = 0x00;
	g_t4133F4 = (word32) g_t4133F4 + 1;
	word32 ecx_201;
	Eq_2 eax_80 = fn00404DE0(out ecx_201);
	word24 eax_24_8_175 = SLICE(eax_80, word24, 8);
	if (eax_80 != 0x20)
	{
		g_dw4133F0 = 0x01;
		if (eax_80 != 0x09)
		{
l00406548:
			if (g_dw4133F0 == 0x00)
			{
				ebpOut = ebp;
				return SEQ(eax_24_8_175, 0x12);
			}
			else if (eax_80 != ~0x00)
			{
				word32 eax_174 = SEQ(SLICE(fn00404D70(eax_80, g_t4133D8), word24, 8), 0x11);
				ebpOut = ebp;
				return eax_174;
			}
			else
			{
				ptr32 ebp_134;
				word32 eax_131 = fn004065D0(eax_80, g_a413AA0, dwArg04 + 4274848, out ebp_134);
				ebpOut = ebp_134;
				return eax_131;
			}
		}
	}
	g_dw4133F0 = 0x00;
	goto l00406548;
}

// 004065D0: Register word32 fn004065D0(Stack Eq_2 dwArg04, Stack (ptr32 Eq_14349) dwArg08, Stack (ptr32 Eq_14349) dwArg0C, Register out ptr32 ebpOut)
// Called from:
//      fn00406500
word32 fn004065D0(Eq_2 dwArg04, struct Eq_14349 * dwArg08, struct Eq_14349 * dwArg0C, ptr32 & ebpOut)
{
	ptr32 ebp;
	Eq_2 eax_20 = dwArg04;
l004065E3:
	struct Eq_14349 * esi_120;
	word24 eax_24_8_501 = SLICE(eax_20, word24, 8);
	up32 ecx_21 = (word32) eax_20 + 1;
	if (ecx_21 <= 0x5F)
	{
		switch (ecx_21)
		{
		case 0x00:
			Eq_2 eax_249 = g_t4133D8;
			word24 eax_24_8_519 = SLICE(eax_249, word24, 8);
			if ((*((word32) eax_249 + 0x0C) & 0x10) == 0x00)
			{
				word32 ecx_621;
				word32 edx_622;
				eax_24_8_519 = SLICE(fn00403220(g_t4133F4, 0x040E, out ecx_621, out edx_622), word24, 8);
			}
			if (g_dw413400 != 0x00)
			{
				fn00407550();
				goto l00406645;
			}
			if (g_ptr413A70 < null)
			{
				ebpOut = ebp;
				return SEQ(eax_24_8_519, 0x17);
			}
			else
			{
				word32 ecx_623;
				word32 edx_624;
				fn00403220(g_t4133F4, 1020, out ecx_623, out edx_624);
				goto l00406645;
			}
		case 0x01:
		case 0x02:
		case 0x03:
		case 0x04:
		case 0x05:
		case 0x06:
		case 0x07:
		case 0x08:
		case 0x09:
		case 0x0A:
		case 0x0C:
		case 0x0D:
		case 0x0E:
		case 0x0F:
		case 0x10:
		case 0x11:
		case 0x12:
		case 0x13:
		case 0x14:
		case 0x15:
		case 22:
		case 0x17:
		case 0x18:
		case 0x19:
		case 0x1A:
		case 0x1B:
		case 0x1C:
		case 0x1D:
		case 0x1E:
		case 0x1F:
		case 0x20:
		case 33:
		case 0x22:
		case 0x23:
		case 0x24:
		case 0x25:
		case 0x26:
		case 0x27:
		case 0x28:
		case 0x29:
		case 0x2A:
		case 0x2B:
		case 44:
		case 0x2D:
		case 0x2E:
		case 0x2F:
		case 0x30:
		case 0x31:
		case 0x32:
		case 0x33:
		case 0x34:
		case 0x35:
		case 0x36:
		case 55:
		case 0x38:
		case 0x39:
		case 0x3A:
		case 0x3D:
		case 0x3F:
		case 0x40:
		case 0x41:
		case 66:
		case 0x43:
		case 0x44:
		case 0x45:
		case 0x46:
		case 0x47:
		case 0x48:
		case 0x49:
		case 0x4A:
		case 0x4B:
		case 0x4C:
		case 77:
		case 0x4E:
		case 0x4F:
		case 0x50:
		case 0x51:
		case 0x52:
		case 0x53:
		case 0x54:
		case 0x55:
		case 0x56:
		case 0x57:
		case 88:
		case 0x59:
		case 0x5A:
		case 0x5B:
		case 0x5D:
		case 0x5E:
			goto l0040675E;
		case 11:
l00406645:
			g_t4133F4 = (word32) g_t4133F4 + 1;
			g_dw4133F0 = 0x01;
			word32 ecx_616;
			eax_20 = fn00404DE0(out ecx_616);
			if (eax_20 == 0x3B && g_t413408 != 0x00 || eax_20 == 0x23)
			{
				fn00406940(0x00);
				g_t4133F4 = (word32) g_t4133F4 + 1;
				g_dw4133F0 = 0x01;
				word32 ecx_620;
				eax_20 = fn00404DE0(out ecx_620);
			}
			word24 eax_24_8_505 = SLICE(eax_20, word24, 8);
			if (eax_20 != 0x20)
			{
				g_dw4133F0 = 0x01;
				if (eax_20 == 0x09)
					goto l0040668F;
			}
			else
			{
l0040668F:
				g_dw4133F0 = 0x00;
			}
			if (g_dw4133F0 == 0x00)
			{
				ebpOut = ebp;
				return SEQ(eax_24_8_505, 0x12);
			}
			else
			{
				if (eax_20 == ~0x00)
					goto l004065E3;
				word32 eax_504 = SEQ(SLICE(fn00404D70(eax_20, g_t4133D8), word24, 8), 0x11);
				ebpOut = ebp;
				return eax_504;
			}
		case 0x3B:
			g_dw4133F0 = 0x00;
			word32 ecx_617;
			Eq_2 eax_79 = fn00404DE0(out ecx_617);
			byte al_109 = (byte) eax_79;
			word24 eax_24_8_515 = SLICE(eax_79, word24, 8);
			if (eax_79 != 0x3A)
			{
				word32 eax_518 = SEQ(SLICE(fn00404D70(eax_79, g_t4133D8), word24, 8), 0x14);
				ebpOut = ebp;
				return eax_518;
			}
			else
			{
				dwArg08->b0000 = al_109;
				dwArg08[1] = (struct Eq_14349) 0x00;
				ebpOut = ebp;
				return SEQ(eax_24_8_515, 0x15);
			}
		case 0x3C:
			g_dw4133F0 = 0x00;
			ebpOut = ebp;
			return SEQ(eax_24_8_501, 0x13);
		case 0x3E:
			g_dw4133F0 = 0x00;
			ebpOut = ebp;
			return SEQ(eax_24_8_501, 22);
		case 0x5C:
			if (g_t413408 != 0x00 && g_dw4133F0 != 0x00)
			{
				ebpOut = ebp;
				return SEQ(eax_24_8_501, 0x17);
			}
			break;
		case 0x5F:
			break;
		}
		fn00404D70(eax_20, g_t4133D8);
		esi_120 = dwArg08 - 0x01;
	}
	else
	{
l0040675E:
		esi_120 = dwArg08;
	}
	word24 eax_24_8_509 = SLICE(fn00407070(esi_120, dwArg0C), word24, 8);
	if (g_dw4133F0 != 0x00)
	{
		word32 eax_156 = mbsicmp(4274848, 4276184);
		eax_24_8_509 = SLICE(eax_156, word24, 8);
		if (eax_156 == 0x00)
		{
			g_dw4133F0 = 0x00;
			Eq_2 eax_178 = fn00406880(0x00);
			if (eax_178 == 0x3A || eax_178 == 0x3D)
			{
				word32 eax_508 = SEQ(SLICE(fn00404D70(eax_178, g_t4133D8), word24, 8), 0x10);
				ebpOut = ebp;
				return eax_508;
			}
			else
			{
				if (g_t413408 != 0x00)
				{
					word32 ecx_618;
					word32 edx_619;
					fn00403220(g_t4133F4, 0x0409, out ecx_618, out edx_619);
				}
				ptr32 ebp_234;
				word32 eax_233 = fn004075C0(eax_178, out ebp_234);
				ebpOut = ebp_234;
				return eax_233;
			}
		}
	}
	g_dw4133F0 = 0x00;
	ebpOut = ebp;
	return SEQ(eax_24_8_509, 0x10);
}

// 00406880: Register Eq_2 fn00406880(Stack Eq_10878 bArg04)
// Called from:
//      fn00404F80
//      fn00406500
//      fn004065D0
//      fn00406A80
Eq_2 fn00406880(Eq_10878 bArg04)
{
	do
	{
		Eq_2 eax_111;
		if (bArg04 != 0x00)
		{
			word32 ecx_226;
			eax_111 = fn00404CF0(g_t4133D8, out ecx_226);
		}
		else
		{
			word32 ecx_225;
			eax_111 = fn00404DE0(out ecx_225);
		}
		if (eax_111 == 0x20 || (eax_111 == 0x09 || eax_111 == 0x5E))
		{
			if (eax_111 == 0x5E)
			{
				if (bArg04 != 0x00)
				{
					word32 ecx_228;
					eax_111 = fn00404CF0(g_t4133D8, out ecx_228);
				}
				else
				{
					word32 ecx_227;
					eax_111 = fn00404DE0(out ecx_227);
				}
				if (eax_111 != 0x20 && eax_111 != 0x09)
				{
					fn00404D70(eax_111, g_t4133D8);
					eax_111.u0 = 0x5E;
					break;
				}
			}
			g_dw4133F0 = 0x00;
		}
		if (eax_111 == 0x5C)
		{
			word32 ecx_229;
			eax_111 = fn004069D0(eax_111, bArg04, out ecx_229);
		}
	} while (eax_111 == 0x20 || eax_111 == 0x09);
	if (eax_111 == 0x3B && (g_dw4133F0 != 0x00 && g_t413408 != 0x00) || eax_111 == 0x23)
	{
		fn00406940(bArg04);
		g_dw4133F0 = 0x01;
		eax_111.u0 = 0x0A;
	}
	return eax_111;
}

// 00406940: void fn00406940(Stack Eq_10878 bArg04)
// Called from:
//      fn004065D0
//      fn00406880
//      fn004069D0
//      fn00406A80
void fn00406940(Eq_10878 bArg04)
{
	Eq_2 edx_117 = g_t4133D8;
	while (true)
	{
		g_dw4133F0 = 0x00;
		do
		{
			Eq_2 eax_20;
			if (bArg04 != 0x00)
			{
				word32 ecx_159;
				eax_20 = fn00404CF0(edx_117, out ecx_159);
			}
			else
			{
				word32 ecx_158;
				eax_20 = fn00404DE0(out ecx_158);
			}
			edx_117 = g_t4133D8;
			if (eax_20 == ~0x00)
				return;
		} while (eax_20 != 0x0A);
		if (eax_20 == ~0x00)
			break;
		Eq_2 eax_55;
		g_dw4133F0 = 0x01;
		if (bArg04 != 0x00)
		{
			word32 ecx_161;
			eax_55 = fn00404CF0(edx_117, out ecx_161);
		}
		else
		{
			word32 ecx_160;
			eax_55 = fn00404DE0(out ecx_160);
		}
		Eq_2 ecx_69 = g_t413408;
		edx_117 = g_t4133D8;
		if ((eax_55 != 0x3B || ecx_69 == 0x00) && eax_55 != 0x23)
		{
			fn00404D70(eax_55, edx_117);
			return;
		}
		g_t4133F4 = (word32) g_t4133F4 + 1;
	}
}

// 004069D0: Register Eq_2 fn004069D0(Stack Eq_2 dwArg04, Stack Eq_10878 bArg08, Register out Eq_2 ecxOut)
// Called from:
//      fn00404F80
//      fn00405710
//      fn00406880
Eq_2 fn004069D0(Eq_2 dwArg04, Eq_10878 bArg08, union Eq_2 & ecxOut)
{
	Eq_2 ecx;
	Eq_2 eax_151 = dwArg04;
	if (dwArg04 != 0x5C)
	{
l00406A6F:
		ecxOut = ecx;
		return eax_151;
	}
	else
	{
		do
		{
			Eq_2 eax_21;
			if (bArg08 != 0x00)
			{
				word32 ecx_206;
				eax_21 = fn00404CF0(g_t4133D8, out ecx_206);
			}
			else
			{
				word32 ecx_205;
				eax_21 = fn00404DE0(out ecx_205);
			}
			ecx = g_t4133D8;
			if (eax_21 != 0x0A)
			{
				fn00404D70(eax_21, ecx);
				eax_151.u0 = 0x5C;
				goto l00406A6F;
			}
			Eq_2 eax_117;
			g_dw4133F0 = 0x01;
			g_t4133F4 = (word32) g_t4133F4 + 1;
			if (bArg08 != 0x00)
			{
				word32 ecx_208;
				eax_117 = fn00404CF0(ecx, out ecx_208);
			}
			else
			{
				word32 ecx_207;
				eax_117 = fn00404DE0(out ecx_207);
			}
			Eq_2 ecx_118 = g_t413408;
			if (eax_117 == 0x3B && ecx_118 != 0x00 || eax_117 == 0x23)
			{
				fn00406940(bArg08);
				Eq_2 eax_109 = g_t4133D8;
				g_t4133F4 = (word32) g_t4133F4 + 1;
				if (bArg08 != 0x00)
					eax_117 = fn00404CF0(eax_109, out ecx_118);
				else
					eax_117 = fn00404DE0(out ecx_118);
			}
		} while (eax_117 == 0x5C);
		ecxOut = ecx_118;
		return eax_117;
	}
}

// 00406A80: Register Eq_2 fn00406A80(Stack byte bArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00406500
Eq_2 fn00406A80(byte bArg04, Eq_2 dwArg08)
{
	ptr32 fp;
	word32 ebx;
	word24 ebx_24_8_769 = SLICE(ebx, word24, 8);
	word32 ecx_1039;
	Eq_2 eax_21 = fn00404DE0(out ecx_1039);
	Eq_2 esi_13 = dwArg08;
	word24 eax_24_8_281 = SLICE(eax_21, word24, 8);
	if (bArg04 != 0x18)
	{
		if (eax_21 != 0x20 && eax_21 != 0x09)
		{
			if (eax_21 != 0x5E)
				goto l00406B00;
			word32 ecx_1040;
			Eq_2 eax_38 = fn00404DE0(out ecx_1040);
			if (eax_38 != 0x20 && eax_38 != 0x09)
			{
				eax_24_8_281 = SLICE(fn00404D70(eax_38, g_t4133D8), word24, 8);
				goto l00406B00;
			}
		}
		eax_24_8_281 = SLICE(fn00406880(0x00), word24, 8);
		goto l00406B00;
	}
	else
	{
l00406B00:
		struct Eq_14844 * esp_119 = fp - 0x20;
		Eq_2 edi_149 = 0x00;
		word32 ebx_212 = SEQ(ebx_24_8_769, 0x00);
l00406B08:
		Eq_14923 bl_235 = (byte) ebx_212;
		word24 ebx_24_8_640 = SLICE(ebx_212, word24, 8);
		if (esp_119[5] == 0x22)
		{
			up32 eax_86 = (word32) (esp_119[7] < 0x01);
			esp_119[7] = (struct Eq_14844) eax_86;
			eax_24_8_281 = SLICE(eax_86, word24, 8);
		}
		word32 ebp_236 = 0x01;
		if (esp_119[5] == 0x5E)
		{
			if (esp_119[7] == 0x00 && esp_119[9] == 0x19)
			{
				word32 ecx_1041;
				Eq_2 eax_121 = fn00404DE0(out ecx_1041);
				esp_119[5] = (struct Eq_14844) eax_121;
				eax_24_8_281 = SLICE(eax_121 - 0x0A, word24, 8);
				if (eax_121 <= 0x7D)
				{
					switch (eax_121)
					{
					case 0x0A:
					case 0x22:
					case 0x23:
					case 0x5C:
						goto l00406C14;
					case 11:
					case 0x0C:
					case 0x0D:
					case 0x0E:
					case 0x0F:
					case 0x10:
					case 0x11:
					case 0x12:
					case 0x13:
					case 0x14:
					case 0x15:
					case 22:
					case 0x17:
					case 0x18:
					case 0x19:
					case 0x1A:
					case 0x1B:
					case 0x1C:
					case 0x1D:
					case 0x1E:
					case 0x1F:
					case 0x20:
					case 0x25:
					case 0x26:
					case 0x27:
					case 0x2A:
					case 0x2B:
					case 44:
					case 0x2E:
					case 0x2F:
					case 0x30:
					case 0x31:
					case 0x32:
					case 0x33:
					case 0x34:
					case 0x35:
					case 0x36:
					case 55:
					case 0x38:
					case 0x39:
					case 0x3A:
					case 0x3B:
					case 0x3C:
					case 0x3D:
					case 0x3E:
					case 0x3F:
					case 0x41:
					case 66:
					case 0x43:
					case 0x44:
					case 0x45:
					case 0x46:
					case 0x47:
					case 0x48:
					case 0x49:
					case 0x4A:
					case 0x4B:
					case 0x4C:
					case 77:
					case 0x4E:
					case 0x4F:
					case 0x50:
					case 0x51:
					case 0x52:
					case 0x53:
					case 0x54:
					case 0x55:
					case 0x56:
					case 0x57:
					case 88:
					case 0x59:
					case 0x5A:
					case 0x5B:
					case 0x5D:
					case 0x5F:
					case 0x60:
					case 0x61:
					case 0x62:
					case 99:
					case 100:
					case 101:
					case 0x66:
					case 0x67:
					case 0x68:
					case 0x69:
					case 0x6A:
					case 0x6B:
					case 0x6C:
					case 0x6D:
					case 110:
					case 111:
					case 0x70:
					case 113:
					case 114:
					case 115:
					case 116:
					case 117:
					case 118:
					case 0x77:
					case 0x78:
					case 121:
					case 122:
					case 0x7C:
						break;
					case 33:
					case 0x24:
					case 0x28:
					case 0x29:
					case 0x2D:
					case 0x40:
					case 0x5E:
					case 0x7B:
					case 0x7D:
						*esi_13 = 0x5E;
						esi_13 = (word32) esi_13 + 1;
						if (esp_119[11] == esi_13)
						{
							word32 eax_187;
							if (g_t4133FC == 0x00)
							{
								struct Eq_14978 * esp_190 = esp_119 - 4;
								esp_190->t0000.u0 = 0x0800;
								fn0040ACF0(eax_121 - 0x0A, esp_190->t0000);
								g_t4133FC = eax_121 - 0x0A;
								mbsnbcpy(g_t4133FC, esp_190->dw001C, 0x0400);
								edi_149.u0 = 0x0800;
								esp_119 = esp_217 + 0x0C;
								esi_13 = (word32) g_t4133FC + 0x0400;
								eax_187 = (word32) g_t4133FC + 0x0800;
								goto l00406C07;
							}
							Eq_2 ebx_150 = (word32) edi_149 + 0x0400;
							ebx_24_8_640 = SLICE(ebx_150, word24, 8);
							if (edi_149 <= ebx_150)
							{
								struct Eq_15049 * esp_153 = esp_119 - 4;
								esp_153->t0000 = ebx_150;
								esp_153->tFFFFFFFC = g_t4133FC;
								Eq_2 eax_158 = realloc(esp_153->tFFFFFFFC, esp_153->t0000);
								g_t4133FC = eax_158;
								if (eax_158 == 0x00)
									goto l00406BE3;
							}
							else
							{
l00406BE3:
								struct Eq_15025 * esp_165 = esp_119 - 4;
								esp_165->t0000.u0 = 0x0419;
								esp_165->tFFFFFFFC = g_t4133F4;
								word32 ecx_1043;
								word32 edx_1044;
								fn00403220(esp_165->tFFFFFFFC, esp_165->t0000, out ecx_1043, out edx_1044);
							}
							esi_13 = Mem179[0x004133FC<p32>:word32] + edi_149;
							eax_187 = Mem179[0x004133FC<p32>:word32] + ebx_150;
							edi_149 = ebx_150;
l00406C07:
							esp_119[11] = (struct Eq_14844) eax_187;
							Eq_2 eax_233 = g_t4133FC;
							esp_119[6] = (struct Eq_14844) eax_233;
							eax_24_8_281 = SLICE(eax_233, word24, 8);
						}
l00406C14:
						bl_235.u0 = 0x00;
						ebp_236 = 0x00;
						break;
					}
				}
			}
			else if (esp_119[5] == 0x5E)
			{
				word32 ecx_1042;
				Eq_2 eax_102 = fn00404DE0(out ecx_1042);
				struct Eq_14941 * esp_110 = esp_119 - 4;
				esp_110->t0000 = g_t4133D8;
				esp_110->tFFFFFFFC = eax_102;
				eax_24_8_281 = SLICE(fn00404D70(esp_110->tFFFFFFFC, esp_110->t0000), word24, 8);
				esp_110->dw0018 = 0x5E;
				esp_119 = (struct Eq_14844 *) ((char *) &esp_110->t0000 + 4);
			}
		}
		if (ebp_236 != 0x00)
		{
			up32 eax_248 = esp_119[5];
			eax_24_8_281 = SLICE(eax_248 + 0x01, word24, 8);
			if (eax_248 <= 0x5C)
			{
				switch (eax_248)
				{
				case ~0x00:
				case 0x0A:
					bl_235.u0 = 0x06;
					break;
				case 0x00:
				case 0x01:
				case 0x02:
				case 0x03:
				case 0x04:
				case 0x05:
				case 0x06:
				case 0x07:
				case 0x08:
				case 11:
				case 0x0C:
				case 0x0D:
				case 0x0E:
				case 0x0F:
				case 0x10:
				case 0x11:
				case 0x12:
				case 0x13:
				case 0x14:
				case 0x15:
				case 22:
				case 0x17:
				case 0x18:
				case 0x19:
				case 0x1A:
				case 0x1B:
				case 0x1C:
				case 0x1D:
				case 0x1E:
				case 0x1F:
				case 33:
				case 0x22:
				case 0x25:
				case 0x26:
				case 0x27:
				case 0x2B:
				case 44:
				case 0x2D:
				case 0x2E:
				case 0x2F:
				case 0x30:
				case 0x31:
				case 0x32:
				case 0x33:
				case 0x34:
				case 0x35:
				case 0x36:
				case 55:
				case 0x38:
				case 0x39:
				case 0x3E:
				case 0x41:
				case 0x43:
				case 0x45:
				case 0x47:
				case 0x48:
				case 0x49:
				case 0x4A:
				case 0x4B:
				case 0x4C:
				case 77:
				case 0x4E:
				case 0x4F:
				case 0x50:
				case 0x51:
				case 0x53:
				case 0x54:
				case 0x55:
				case 0x56:
				case 0x57:
				case 88:
				case 0x59:
				case 0x5A:
				case 0x5B:
					goto l00406C58;
				case 0x09:
				case 0x20:
					bl_235.u0 = 0x05;
					break;
				case 0x23:
					bl_235.u0 = 0x01;
					break;
				case 0x24:
					bl_235.u0 = 0x07;
					break;
				case 0x28:
					bl_235.u0 = 0x08;
					break;
				case 0x29:
					bl_235.u0 = 0x09;
					break;
				case 0x2A:
					bl_235.u0 = 11;
					break;
				case 0x3A:
					bl_235.u0 = 0x04;
					break;
				case 0x3B:
					if (esp_119->b0013 == 0x00 && g_t413408 != 0x00)
						bl_235.u0 = 0x01;
					else
						bl_235.u0 = 0x00;
					break;
				case 0x3C:
				case 0x3F:
				case 0x40:
					bl_235.u0 = 0x0C;
					break;
				case 0x3D:
					bl_235.u0 = 0x02;
					break;
				case 66:
				case 0x44:
				case 0x46:
				case 0x52:
					bl_235.u0 = 0x0D;
					break;
				case 0x5C:
					bl_235.u0 = 0x03;
					break;
				}
			}
			else
			{
l00406C58:
				eax_24_8_281 = 0x00;
				bl_235 = SLICE(cond((g_a4149C0[(uint32) esp_119[5]] & 0x01) - 0x01), bool, 1) + ~0x00 & 0x0A;
			}
		}
		if (bl_235 == 0x0C && (esp_119[9] == 0x18 && esp_119[5] == 0x3C))
		{
			word32 ecx_1045;
			Eq_2 eax_338 = fn00404DE0(out ecx_1045);
			if (eax_338 == 0x3C)
			{
				struct Eq_15170 * esp_360 = esp_119 - 4;
				esp_360->ptr0000 = (word32 *) (esp_119 + 11);
				esp_360->ptrFFFFFFFC = (word32 *) (esp_119 + 6);
				esp_360->tFFFFFFF8 = esi_13;
				Eq_2 eax_378 = fn00405C20(esp_360->tFFFFFFF8);
				esp_360->dw0018 = 0x0A;
				bl_235.u0 = 0x06;
				esi_13 = eax_378;
			}
			else
			{
				struct Eq_15151 * esp_348 = esp_119 - 4;
				esp_348->t0000 = g_t4133D8;
				esp_348->tFFFFFFFC = eax_338;
				fn00404D70(esp_348->tFFFFFFFC, esp_348->t0000);
			}
		}
		else if (bl_235 == 0x01)
		{
			ebx_212 = SEQ(ebx_24_8_640, bl_235);
			if (esp_119->b0013 == 0x00)
			{
				esp_119[7] = (struct Eq_14844) 0x00;
				union Eq_10878 * esp_325 = esp_119 - 4;
				*esp_325 = 0x00;
				fn00406940(*esp_325);
				g_t4133F4 = (word32) g_t4133F4 + 1;
				esp_119 = (struct Eq_14844 *) ((char *) esp_325 + 4);
				goto l00406E8B;
			}
			ebx_212 = SEQ(ebx_24_8_640, bl_235);
			if (esp_119[9] == 0x19)
			{
				esp_119->b0013 = 0x40;
l00406D52:
				if (esp_119->b0013 == 0x40)
				{
					Eq_2 ecx_411 = esp_119[5];
					struct Eq_15262 * esp_412 = esp_119 - 4;
					esp_412->t0000 = g_t4133D8;
					esp_412->tFFFFFFFC = ecx_411;
					fn00404D70(esp_412->tFFFFFFFC, esp_412->t0000);
					if (esp_412->t001C < esi_13)
					{
						do
						{
							Eq_2 edi_429 = esi_13 - 1;
							if (ismbcspace((int32) *edi_429) == 0x00)
								break;
							esi_13 = edi_429;
						} while (esp_438->t001C < edi_429);
					}
					Eq_2 eax_459;
					*esi_13 = 0x00;
					if (g_t4133FC == 0x00)
					{
						word32 ecx_1049;
						word32 edx_1050;
						eax_459 = fn0040ADD0(dwArg08, out ecx_1049, out edx_1050);
						g_t4133FC = eax_459;
						return eax_459;
					}
					else
					{
						eax_459 = realloc(g_t4133FC, esi_13 - g_t4133FC + 0x01);
						if (eax_459 == 0x00)
							return eax_459;
						g_t4133FC = eax_459;
						return eax_459;
					}
				}
				if ((esp_119->b0013 & 0x20) != 0x00)
				{
					Eq_15297 eax_506 = esp_119[5];
					Eq_2 ecx_507 = g_t4133F4;
					struct Eq_15304 * esp_508 = esp_119 - 4;
					esp_508->t0000 = eax_506;
					esp_508->tFFFFFFFC = (SEQ(SLICE(eax_506, word24, 8), esp_508->b0017) & 223) + 1000;
					esp_508->tFFFFFFF8 = ecx_507;
					word32 edx_1048;
					word32 ecx_1047;
					eax_24_8_281 = SLICE(fn00403220(esp_508->tFFFFFFF8, esp_508->tFFFFFFFC, out ecx_1047, out edx_1048), word24, 8);
				}
				if (esp_119->b0013 == 0x00)
				{
					*((word32) esi_13 - 1) = 0x20;
					g_t4133F4 = (word32) g_t4133F4 + 1;
					g_dw4133F0 = 0x01;
					word32 ecx_1051;
					Eq_2 eax_706 = fn00404DE0(out ecx_1051);
					g_dw4133F0 = 0x00;
					if (eax_706 == 0x20 || eax_706 == 0x09)
					{
						esp_119->b0013 = 0x02;
						do
						{
							word32 ecx_1052;
							eax_706 = fn00404DE0(out ecx_1052);
						} while (eax_706 == 0x20 || eax_706 == 0x09);
					}
					struct Eq_15445 * esp_736 = esp_119 - 4;
					esp_736->t0000 = g_t4133D8;
					esp_736->tFFFFFFFC = eax_706;
					fn00404D70(esp_736->tFFFFFFFC, esp_736->t0000);
					esp_119 = (struct Eq_14844 *) ((char *) &esp_736->t0000 + 4);
l00406E8B:
					word32 ecx_1046;
					Eq_2 eax_747 = fn00404DE0(out ecx_1046);
					esp_119[5] = (struct Eq_14844) eax_747;
					eax_24_8_281 = SLICE(eax_747, word24, 8);
					goto l00406B08;
				}
				Eq_15401 al_533 = esp_119[5];
				*esi_13 = al_533;
				esi_13 = (word32) esi_13 + 1;
				Eq_2 eax_618 = SEQ(eax_24_8_281, al_533);
				if (esp_119[11] != esi_13)
					goto l00406E8B;
				word32 eax_593;
				if (g_t4133FC == 0x00)
				{
					struct Eq_15483 * esp_596 = esp_119 - 4;
					esp_596->t0000.u0 = 0x0800;
					fn0040ACF0(eax_618, esp_596->t0000);
					g_t4133FC = eax_618;
					mbsnbcpy(g_t4133FC, esp_596->dw001C, 0x0400);
					edi_149.u0 = 0x0800;
					esp_119 = esp_683 + 0x0C;
					esi_13 = (word32) g_t4133FC + 0x0400;
					eax_593 = (word32) g_t4133FC + 0x0800;
					goto l00406E87;
				}
				Eq_2 ebp_556 = (byte) edi_149.u0 + 0x0400;
				if (edi_149 <= ebp_556)
				{
					struct Eq_15545 * esp_559 = esp_119 - 4;
					esp_559->t0000 = ebp_556;
					esp_559->tFFFFFFFC = g_t4133FC;
					Eq_2 eax_564 = realloc(esp_559->tFFFFFFFC, esp_559->t0000);
					g_t4133FC = eax_564;
					if (eax_564 != 0x00)
					{
l00406E76:
						esi_13 = Mem585[0x004133FC<p32>:word32] + edi_149;
						eax_593 = Mem585[0x004133FC<p32>:word32] + ebp_556;
						edi_149 = ebp_556;
l00406E87:
						esp_119[11] = (struct Eq_14844) eax_593;
						goto l00406E8B;
					}
				}
				struct Eq_15521 * esp_571 = esp_119 - 4;
				esp_571->t0000.u0 = 0x0419;
				esp_571->tFFFFFFFC = g_t4133F4;
				word32 edx_1054;
				word32 ecx_1053;
				fn00403220(esp_571->tFFFFFFFC, esp_571->t0000, out ecx_1053, out edx_1054);
				goto l00406E76;
			}
		}
		esp_119->b0013 = (byte) *((word32) (uint32) bl_235 + ((uint32) esp_119->b0013 * 0x0E + 0x00414648));
		eax_24_8_281 = 0x00;
		ebx_212 = SEQ(ebx_24_8_640, bl_235);
		goto l00406D52;
	}
}

// 00407070: Register word32 fn00407070(Stack (ptr32 Eq_14349) dwArg04, Stack (ptr32 Eq_14349) dwArg08)
// Called from:
//      fn004065D0
word32 fn00407070(struct Eq_14349 * dwArg04, struct Eq_14349 * dwArg08)
{
	Eq_15576 bLoc12;
	uint8 bLoc11_326;
	word32 dwLoc10_319 = 0x00;
	up32 dwLoc08_321 = 0x00;
	struct Eq_14349 * esi_14 = dwArg04;
	int32 eax_17 = (int32) dwArg04->bFFFFFFFF;
	if (eax_17 != 0x22)
	{
		if (eax_17 != 0x24)
		{
			if (eax_17 != 0x7B)
				bLoc11_326 = 0x00;
			else
				bLoc11_326 = 0x08;
		}
		else
			bLoc11_326 = 0x02;
	}
	else
	{
		dwLoc08_321 = 0x01;
		bLoc11_326 = 0x10;
	}
	while (true)
	{
		word32 ecx_493;
		Eq_2 eax_30 = fn00404DE0(out ecx_493);
		Eq_2 ebx_38 = eax_30;
		word32 dwLoc0C_330 = 0x01;
		if (eax_30 == 0x5E)
		{
			word32 ecx_494;
			Eq_2 eax_42 = fn00404DE0(out ecx_494);
			ebx_38 = eax_42;
			if (eax_42 <= 0x7D)
			{
				switch (eax_42)
				{
				case 0x0A:
				case 0x23:
				case 0x5C:
					goto l004070F3;
				case 11:
				case 0x0C:
				case 0x0D:
				case 0x0E:
				case 0x0F:
				case 0x10:
				case 0x11:
				case 0x12:
				case 0x13:
				case 0x14:
				case 0x15:
				case 22:
				case 0x17:
				case 0x18:
				case 0x19:
				case 0x1A:
				case 0x1B:
				case 0x1C:
				case 0x1D:
				case 0x1E:
				case 0x1F:
				case 0x20:
				case 33:
				case 0x22:
				case 0x25:
				case 0x26:
				case 0x27:
				case 0x2A:
				case 0x2B:
				case 44:
				case 0x2D:
				case 0x2E:
				case 0x2F:
				case 0x30:
				case 0x31:
				case 0x32:
				case 0x33:
				case 0x34:
				case 0x35:
				case 0x36:
				case 55:
				case 0x38:
				case 0x39:
				case 0x3A:
				case 0x3B:
				case 0x3C:
				case 0x3D:
				case 0x3E:
				case 0x3F:
				case 0x40:
				case 0x41:
				case 66:
				case 0x43:
				case 0x44:
				case 0x45:
				case 0x46:
				case 0x47:
				case 0x48:
				case 0x49:
				case 0x4A:
				case 0x4B:
				case 0x4C:
				case 77:
				case 0x4E:
				case 0x4F:
				case 0x50:
				case 0x51:
				case 0x52:
				case 0x53:
				case 0x54:
				case 0x55:
				case 0x56:
				case 0x57:
				case 88:
				case 0x59:
				case 0x5A:
				case 0x5B:
				case 0x5D:
				case 0x5F:
				case 0x60:
				case 0x61:
				case 0x62:
				case 99:
				case 100:
				case 101:
				case 0x66:
				case 0x67:
				case 0x68:
				case 0x69:
				case 0x6A:
				case 0x6B:
				case 0x6C:
				case 0x6D:
				case 110:
				case 111:
				case 0x70:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 0x77:
				case 0x78:
				case 121:
				case 122:
				case 0x7C:
					break;
				case 0x24:
				case 0x28:
				case 0x29:
				case 0x5E:
				case 0x7B:
				case 0x7D:
					esi_14->b0000 = 0x5E;
					++esi_14;
l004070F3:
					bLoc12.u0 = 0x00;
					dwLoc0C_330 = 0x00;
					break;
				}
			}
		}
		byte bl_108 = (byte) ebx_38;
		if (dwLoc0C_330 != 0x00)
		{
			up32 eax_74 = (word32) ebx_38 + 1;
			if (eax_74 <= 0x7E)
			{
				switch (eax_74)
				{
				case 0x00:
				case 11:
					bLoc12.u0 = 0x06;
					break;
				case 0x01:
				case 0x02:
				case 0x03:
				case 0x04:
				case 0x05:
				case 0x06:
				case 0x07:
				case 0x08:
				case 0x09:
				case 0x0C:
				case 0x0D:
				case 0x0E:
				case 0x0F:
				case 0x10:
				case 0x11:
				case 0x12:
				case 0x13:
				case 0x14:
				case 0x15:
				case 22:
				case 0x17:
				case 0x18:
				case 0x19:
				case 0x1A:
				case 0x1B:
				case 0x1C:
				case 0x1D:
				case 0x1E:
				case 0x1F:
				case 0x20:
				case 0x22:
				case 0x26:
				case 0x27:
				case 0x28:
				case 0x2B:
				case 44:
				case 0x2D:
				case 0x2E:
				case 0x2F:
				case 0x30:
				case 0x31:
				case 0x32:
				case 0x33:
				case 0x34:
				case 0x35:
				case 0x36:
				case 55:
				case 0x38:
				case 0x39:
				case 0x3A:
				case 0x3D:
				case 0x3F:
				case 0x40:
				case 0x41:
				case 66:
				case 0x43:
				case 0x44:
				case 0x45:
				case 0x46:
				case 0x47:
				case 0x48:
				case 0x49:
				case 0x4A:
				case 0x4B:
				case 0x4C:
				case 77:
				case 0x4E:
				case 0x4F:
				case 0x50:
				case 0x51:
				case 0x52:
				case 0x53:
				case 0x54:
				case 0x55:
				case 0x56:
				case 0x57:
				case 88:
				case 0x59:
				case 0x5A:
				case 0x5B:
				case 0x5C:
				case 0x5E:
				case 0x5F:
				case 0x60:
				case 0x61:
				case 0x62:
				case 99:
				case 100:
				case 101:
				case 0x66:
				case 0x67:
				case 0x68:
				case 0x69:
				case 0x6A:
				case 0x6B:
				case 0x6C:
				case 0x6D:
				case 110:
				case 111:
				case 0x70:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 0x77:
				case 0x78:
				case 121:
				case 122:
				case 0x7B:
				case 0x7D:
					goto l00407122;
				case 0x0A:
				case 33:
					bLoc12 = 0x00 - (byte) (dwLoc08_321 < 0x01) & 0x05;
					break;
				case 0x23:
					bLoc12.u0 = 0x0E;
					break;
				case 0x24:
					bLoc12.u0 = 0x01;
					break;
				case 0x25:
					bLoc12.u0 = 0x07;
					break;
				case 0x29:
					bLoc12.u0 = 0x08;
					break;
				case 0x2A:
					bLoc12.u0 = 0x09;
					break;
				case 0x3B:
					bLoc12.u0 = 0x04;
					break;
				case 0x3C:
					bLoc12.u0 = 0x03;
					break;
				case 0x3E:
					bLoc12.u0 = 0x02;
					break;
				case 0x5D:
					bLoc12.u0 = 0x0D;
					break;
				case 0x7C:
					bLoc12.u0 = 11;
					break;
				case 0x7E:
					bLoc12.u0 = 0x0C;
					break;
				}
			}
			else
			{
l00407122:
				if ((g_b413A48 & 0x80) != 0x00)
				{
					if ((g_a4149C0[(uint32) bl_108] & 0x01) == 0x00 && (ebx_38 != 0x2A && ebx_38 != 0x40))
						bLoc12.u0 = 0x00;
					else
						bLoc12.u0 = 0x0A;
				}
				else
					bLoc12 = SLICE(cond((g_a4149C0[(uint32) bl_108] & 0x01) - 0x01), bool, 1) + ~0x00 & 0x0A;
			}
		}
		uint8 al_155 = ((uint32) bLoc11_326 * 0x0F)->a414700[(uint32) bLoc12];
		Eq_2 ebx_190 = ebx_38;
		ui24 eax_24_8_146 = 0x00;
		bLoc11_326 = al_155;
		if (dwLoc08_321 != 0x00 && al_155 == 0x01)
			bLoc11_326 = 0x10;
		if (dwLoc10_319 != 0x00)
		{
			if (bLoc12 == 0x06)
			{
				g_dw4133F0 = 0x01;
				g_t4133F4 = (word32) g_t4133F4 + 1;
				word32 ecx_495;
				Eq_2 eax_182 = fn00404DE0(out ecx_495);
				g_dw4133F0 = 0x00;
				ebx_190 = eax_182;
				if (eax_182 != 0x20 && eax_182 != 0x09)
				{
					Eq_15742 eax_210 = esi_14 - &g_b413AA1;
					eax_24_8_146 = SLICE(eax_210, word24, 8);
					bLoc11_326 = 0x00 - (byte) (eax_210 < 0x01) + 0x01;
				}
				else
				{
					bLoc11_326 = 0x40;
					do
					{
						word32 ecx_500;
						Eq_2 eax_197 = fn00404DE0(out ecx_500);
						eax_24_8_146 = SLICE(eax_197, word24, 8);
						ebx_190 = eax_197;
					} while (eax_197 == 0x20 || eax_197 == 0x09);
				}
			}
			else
			{
				esi_14->b0000 = 0x5C;
				++esi_14;
			}
		}
		byte bl_313 = (byte) ebx_190;
		dwLoc10_319 = 0x00;
		if (bLoc11_326 == 0x40)
			break;
		if ((bLoc11_326 & 0x20) != 0x00)
		{
			word32 ecx_496;
			word32 edx_497;
			fn00403220(g_t4133F4, (SEQ(eax_24_8_146, bLoc11_326) & 223) + 1000, out ecx_496, out edx_497);
		}
		if (bLoc11_326 == 0x0F)
			dwLoc10_319 = 0x01;
		else
		{
			esi_14->b0000 = bl_313;
			++esi_14;
		}
	}
	if (esi_14 >= dwArg08)
	{
		word32 edx_499;
		word32 ecx_498;
		fn00403220(g_t4133F4, 0x0434, out ecx_498, out edx_499);
	}
	fn00404D70(ebx_190, g_t4133D8);
	esi_14->b0000 = 0x00;
	return fn00408A90(dwArg04 - 1);
}

// 00407450: Register Eq_2 fn00407450(Stack Eq_2 dwArg04)
// Called from:
//      fn00406020
Eq_2 fn00407450(Eq_2 dwArg04)
{
	char bLoc0104;
	if (dwArg04 != 0x00 && *dwArg04 != 0x00)
	{
		Eq_2 edi_24 = dwArg04;
		word32 ecx_25 = ~0x00;
		while (ecx_25 != 0x00)
		{
			edi_24 = (word32) edi_24 + 1;
			--ecx_25;
			if (*edi_24 != 0x00)
				break;
		}
		uint32 ecx_37 = ~ecx_25;
		uint32 ecx_228;
		struct Eq_15835 * esi_213 = edi_24 - ecx_37;
		struct Eq_15837 * edi_216 = &bLoc0104;
		for (ecx_228 = ecx_37 >> 0x02; ecx_228 != 0x00; --ecx_228)
		{
			edi_216->t0000.u1 = esi_213->dw0000;
			esi_213 += 4;
			edi_216 += 4;
		}
		ui32 ecx_220;
		for (ecx_220 = ecx_37 & 0x03; ecx_220 != 0x00; --ecx_220)
		{
			edi_216->t0000.u1 = esi_213->dw0000;
			++esi_213;
			++edi_216;
		}
	}
	else
		bLoc0104 = (char) g_t413FE0;
	Eq_2 eax_124;
	_makepath(dwArg04, null, &bLoc0104, 4276168, 0x00);
	ptr32 esp_121 = (char *) &esp_79->t0000 + 4;
	if (mktemp(dwArg04) == 0x00)
	{
		if (g_b413FC9 == 122)
			g_b413FC9 = 0x61;
		else
			++g_b413FC9;
		esp_79->t0000.u0 = 0x00;
		esp_79->tFFFFFFFC.u0 = 4276168;
		esp_79->ptrFFFFFFF8 = (char *) &esp_79->t0000 + 16;
		esp_79->ptrFFFFFFF4 = null;
		esp_79->tFFFFFFF0 = dwArg04;
		_makepath(esp_79->tFFFFFFF0, esp_79->ptrFFFFFFF4, esp_79->ptrFFFFFFF8, esp_79->tFFFFFFFC, esp_79->t0000);
		esp_121 = esp_115 + 0x04;
		eax_124.u0 = 0x00;
		if (mktemp(dwArg04) == 0x00)
			return eax_124;
	}
	byte * edi_126 = &g_b413FD4;
	word32 ecx_127 = ~0x00;
	while (ecx_127 != 0x00)
	{
		++edi_126;
		--ecx_127;
		if (*edi_126 != 0x00)
			break;
	}
	uint32 ecx_139 = ~ecx_127;
	struct Eq_15935 * esi_143 = edi_126 - ecx_139;
	word32 ecx_144 = ~0x00;
	Eq_2 edi_148 = dwArg04;
	while (ecx_144 != 0x00)
	{
		edi_148 = (word32) edi_148 + 1;
		--ecx_144;
		if (*edi_148 != 0x00)
			break;
	}
	struct Eq_15951 * edi_160 = edi_148 - 0x01;
	uint32 ecx_164;
	for (ecx_164 = ecx_139 >> 0x02; ecx_164 != 0x00; --ecx_164)
	{
		edi_160->dw0000 = esi_143->dw0000;
		esi_143 += 4;
		edi_160 += 4;
	}
	struct Eq_15968 * esp_170 = esp_121 - 4;
	esp_170->dw0000 = 0x0041338C;
	esp_170->tFFFFFFFC = dwArg04;
	ui32 ecx_172;
	for (ecx_172 = ecx_139 & 0x03; ecx_172 != 0x00; --ecx_172)
	{
		edi_160->dw0000 = esi_143->dw0000;
		++esi_143;
		++edi_160;
	}
	eax_124 = fn0040CA80(esp_170->tFFFFFFFC);
	return eax_124;
}

// 00407550: void fn00407550()
// Called from:
//      fn004065D0
void fn00407550()
{
	int32 eax_8 = fclose(g_t4133D8);
	Eq_2 eax_11 = g_t4133F8;
	if (eax_8 == ~0x00)
	{
		word32 ecx_57;
		word32 edx_58;
		fn00403220(0x00, 0x0424, out ecx_57, out edx_58);
		eax_11 = g_t4133F8;
	}
	free(eax_11);
	int32 eax_35 = g_dw413400;
	g_dw413400 = eax_35 - 0x01;
	ui32 edx_39 = eax_35 - 0x01 + (eax_35 - 0x01) * 0x02;
	g_t4133D8 = *((char *) g_a411A58 + edx_39 * 0x04);
	g_t4133F8 = g_a411A54[edx_39 * 0x04 / 0x0C];
	g_t4133F4 = *((char *) g_a411A50 + edx_39 * 0x04);
}

// 004075C0: Register word32 fn004075C0(Stack Eq_2 dwArg04, Register out ptr32 ebpOut)
// Called from:
//      fn004065D0
word32 fn004075C0(Eq_2 dwArg04, ptr32 & ebpOut)
{
	Eq_12374 bl_33 = (byte) dwArg04;
	if (dwArg04 == 0x0A || dwArg04 == ~0x00)
	{
		word32 edx_190;
		word32 ecx_189;
		fn00403220(g_t4133F4, 0x0407, out ecx_189, out edx_190);
	}
	Eq_2 eax_31 = g_t4133D8;
	g_a413AA0[0] = bl_33;
	if (fgets(&g_b413AA1, 0x03FF, eax_31) == null)
	{
		if ((*((word32) g_t4133D8 + 0x0C) & 0x10) != 0x00)
		{
			word32 ecx_193;
			word32 edx_194;
			fn00403220(g_t4133F4, 0x0409, out ecx_193, out edx_194);
		}
		word32 ecx_191;
		word32 edx_192;
		fn00403220(g_t4133F4, 0x041D, out ecx_191, out edx_192);
	}
	byte * edi_83 = g_a413AA0;
	word32 ecx_84 = ~0x00;
	while (ecx_84 != 0x00)
	{
		edi_83 = edi_196 + 1;
		--ecx_84;
		edi_196 = edi_83;
		if (*edi_196 != 0x00)
			break;
	}
	struct Eq_16150 * ecx_96 = ~ecx_84;
	word24 ecx_24_8_145 = SLICE(ecx_96 - 0x02, word24, 8);
	if (ecx_96->b413A9E == 0x0A)
		ecx_96->b413A9E = 0x00;
	Eq_2 eax_102 = 4274848;
	while (true)
	{
		byte cl_105 = *eax_102;
		if (cl_105 != 0x20)
		{
			Eq_2 ecx_114 = SEQ(ecx_24_8_145, cl_105);
			if (cl_105 != 0x09)
			{
				ptr32 ebp_116;
				word32 ecx_195;
				word32 eax_115 = fn00407680(ecx_114, eax_102, out ecx_195, out ebp_116);
				ebpOut = ebp_116;
				return eax_115;
			}
		}
		eax_102 = (word32) eax_102 + 1;
	}
}

// 00407680: Register word32 fn00407680(Register Eq_2 ecx, Stack Eq_2 dwArg04, Register out Eq_2 ecxOut, Register out ptr32 ebpOut)
// Called from:
//      fn00404DE0
//      fn004075C0
word32 fn00407680(Eq_2 ecx, Eq_2 dwArg04, union Eq_2 & ecxOut, ptr32 & ebpOut)
{
	Eq_2 dwLoc30;
	fn0040CEB4((word32) g_t413EE0 + 3 & ~0x03, ecx, dwLoc30);
	int32 edi_101 = 0x00;
	Eq_2 ebx_166 = dwArg04;
	byte al_33 = *dwArg04;
	if (al_33 == 0x00 || al_33 == 0x23)
	{
		word32 ecx_1097;
		word32 edx_1098;
		fn00403220(g_t4133F4, 0x0407, out ecx_1097, out edx_1098);
	}
	struct Eq_16228 * eax_71 = mbspbrk(dwArg04, 4276204);
	word24 ecx_24_8_181 = SLICE(ecx_72, word24, 8);
	struct Eq_16228 * esi_151 = eax_71;
	if (eax_71 != null)
	{
		byte al_98 = eax_71->b0000;
		if (al_98 == 0x23)
			edi_101 = (int32) al_98;
		eax_71->b0000 = 0x00;
		if (edi_101 == 0x00)
		{
			Eq_2 edi_108 = &eax_71->b0001;
			if (eax_71->b0001 != 0x00)
			{
				do
				{
					byte al_113 = *edi_108;
					if (al_113 == 0x23)
						break;
					if (al_113 != 0x20 && al_113 != 0x09)
					{
						esp_70->t0004 = edi_108;
						Eq_2 eax_123 = g_t4133F4;
						esp_70->t0000.u0 = 0x0409;
						esp_70->tFFFFFFFC = eax_123;
						word32 ecx_129;
						word32 edx_1115;
						fn00403220(esp_70->tFFFFFFFC, esp_70->t0000, out ecx_129, out edx_1115);
						ecx_24_8_181 = SLICE(ecx_129, word24, 8);
					}
					edi_108 = (word32) edi_108 + 1;
				} while (*edi_108 != 0x00);
			}
		}
	}
	else
	{
		Eq_2 edi_81 = dwArg04;
		word32 ecx_82 = ~0x00;
		while (ecx_82 != 0x00)
		{
			edi_81 = (word32) edi_1116 + 1;
			--ecx_82;
			edi_1116 = edi_81;
			if (*edi_1116 != 0x00)
				break;
		}
		word32 ecx_94 = ~ecx_82;
		ecx_24_8_181 = SLICE(ecx_94, word24, 8);
		esi_151 = (word32) dwArg04 + (ecx_94 - 1);
	}
	struct Eq_16313 * ebp_192;
	Eq_2 ebx_193;
	ptr32 esp_231;
	byte cl_148 = *dwArg04;
	if (cl_148 == 0x3C)
	{
		byte * eax_154 = esi_151 - 1;
		Eq_2 ecx_625 = SEQ(ecx_24_8_181, cl_148);
		if (*eax_154 == 0x3E)
		{
			*eax_154 = 0x00;
			esp_70->t0004 = (word32) dwArg04 + 1;
			Eq_2 ebx_630;
			Eq_2 eax_626 = fn0040B690(ecx_625, esp_70->t0004, esp_70->t00E8, esp_70->t00EC, esp_70->t00F0, out ebx_630, out ebp_192);
			Eq_2 esi_637 = eax_626;
			if (eax_626 == ebx_630)
			{
				esp_70->t0004 = ebx_630;
				word32 ecx_1100;
				word32 edx_1101;
				esi_637 = fn0040ADD0(esp_70->t0004, out ecx_1100, out edx_1101);
			}
			Eq_2 eax_664;
			esp_70->t0004.u0 = 4276012;
			word32 ecx_1099;
			Eq_2 eax_653 = fn00407B70(esp_70->t0004, out ecx_1099);
			if (eax_653 != 0x00)
				eax_664 = *((word32) *((word32) eax_653 + 8) + 4);
			else
				eax_664.u0 = 0x00;
			Eq_2 edi_673;
			if (eax_664 != 0x00)
			{
				esp_70->t0004 = eax_664;
				Eq_2 ecx_680;
				word32 edx_1102;
				esp_70->t0004 = fn0040ADD0(esp_70->t0004, out ecx_680, out edx_1102);
				Eq_2 ebx_694;
				Eq_2 eax_690 = fn0040B690(ecx_680, esp_70->t0004, esp_70->t00E8, esp_70->t00EC, esp_70->t00F0, out ebx_694, out ebp_192);
				edi_673 = eax_690;
				if (eax_690 != ebx_694)
				{
					esp_70->t0004 = ebx_694;
					free(esp_70->t0004);
				}
			}
			else
				edi_673.u0 = 0x00;
			Eq_2 ecx_713 = ebp_192->tFFFFFFE8;
			esp_70->t0004 = ebp_192 - 28;
			esp_70->t0000 = ecx_713;
			esp_70->tFFFFFFFC = esi_637;
			esp_70->tFFFFFFF8 = edi_673;
			Eq_2 eax_727 = fn00405930(esp_70->tFFFFFFF8, esp_70->tFFFFFFFC);
			ebx_193 = eax_727;
			if (eax_727 == 0x00)
			{
				esp_70->t0004 = esi_637;
				Eq_2 eax_741 = g_t4133F4;
				esp_70->t0000.u0 = 0x041C;
				esp_70->tFFFFFFFC = eax_741;
				word32 ecx_1103;
				word32 edx_1104;
				fn00403220(esp_70->tFFFFFFFC, esp_70->t0000, out ecx_1103, out edx_1104);
			}
			if (edi_673 != 0x00)
			{
				esp_70->t0004 = edi_673;
				free(esp_70->t0004);
			}
			esp_70->t0004 = esi_637;
			free(esp_70->t0004);
			esp_231 = (char *) &esp_70->t0004 + 4;
			goto l004079B6;
		}
	}
	Eq_2 ecx_188 = SEQ(ecx_24_8_181, cl_148);
	if (cl_148 == 0x22)
	{
		byte * esi_161 = esi_151 - 0x01;
		if (*esi_161 == 0x22)
		{
			*esi_161 = 0x00;
			ebx_166 = (word32) dwArg04 + 1;
		}
	}
	esp_70->t0004 = ebx_166;
	Eq_2 eax_189 = fn0040B690(ecx_188, esp_70->t0004, esp_70->t00E8, esp_70->t00EC, esp_70->t00F0, out ebx_193, out ebp_192);
	ebp_192->tFFFFFFF4 = eax_189;
	if (eax_189 == ebx_193)
	{
		esp_70->t0004 = ebx_193;
		word32 edx_1106;
		word32 ecx_1105;
		ebp_192->tFFFFFFF4 = fn0040ADD0(esp_70->t0004, out ecx_1105, out edx_1106);
	}
	esp_70->t0004 = ebp_192 - 28;
	Eq_2 edx_219 = ebp_192->tFFFFFFF4;
	esp_70->t0000 = ebp_192 - 24;
	esp_70->tFFFFFFFC = edx_219;
	esp_231 = (char *) &esp_70->t0004 + 4;
	if (fn0040CD20(esp_70->tFFFFFFFC) == 0x00)
	{
		if (mbspbrk(ebp_192->tFFFFFFF4, 4276200) != 0x00)
		{
			Eq_2 ecx_268 = g_t4133F4;
			esp_257->t0004 = ebp_192->tFFFFFFF4;
			esp_257->t0000.u0 = 0x041C;
			esp_257->tFFFFFFFC = ecx_268;
			goto l004079AE;
		}
		int32 eax_275 = g_dw413400;
		ebp_192->dwFFFFFFEC = eax_275;
		if (eax_275 >= 0x00)
		{
			ebp_192->ptrFFFFFFF0 = eax_275 * 0x0C + 0x00411A54;
			do
			{
				Eq_2 eax_289;
				if (g_dw413400 == ebp_192->dwFFFFFFEC)
					eax_289 = g_t4133F8;
				else
					eax_289 = *ebp_192->ptrFFFFFFF0;
				esp_257->t0004 = eax_289;
				Eq_2 eax_296 = fn00407AD0(esp_257->t0004);
				ebp_192->tFFFFFFF8 = eax_296;
				if (eax_296 != 0x00)
				{
					Eq_2 edi_309 = ebp_192->tFFFFFFF4;
					word32 ecx_310 = ~0x00;
					while (ecx_310 != 0x00)
					{
						edi_309 = (word32) edi_1117 + 1;
						--ecx_310;
						edi_1117 = edi_309;
						if (*edi_1117 != 0x00)
							break;
					}
					word32 ecx_322 = ~ecx_310;
					Eq_2 edi_326 = ebp_192->tFFFFFFF8;
					word32 ecx_330 = ~0x00;
					while (ecx_330 != 0x00)
					{
						edi_326 = (word32) edi_1118 + 1;
						--ecx_330;
						edi_1118 = edi_326;
						if (*edi_1118 != 0x00)
							break;
					}
					esp_257->t0004 = ~ecx_330 - 1 + (ecx_322 - 1) + 0x02;
					fn0040ACF0(0x00, esp_257->t0004);
					Eq_2 edi_1119 = ebp_192->tFFFFFFF8;
					ebp_192->tFFFFFFFC.u0 = 0x00;
					word32 ecx_367 = ~0x00;
					while (ecx_367 != 0x00)
					{
						edi_1119 = (word32) edi_1119 + 1;
						--ecx_367;
						if (*edi_1119 != 0x00)
							break;
					}
					uint32 ecx_380 = ~ecx_367;
					uint32 ecx_384;
					struct Eq_16830 * esi_386 = edi_1119 - ecx_380;
					Eq_2 edi_390 = ebp_192->tFFFFFFFC;
					for (ecx_384 = ecx_380 >> 0x02; ecx_384 != 0x00; --ecx_384)
					{
						*edi_390 = esi_386->dw0000;
						esi_386 += 4;
						edi_390 = (word32) edi_390 + 4;
					}
					ui32 ecx_394;
					for (ecx_394 = ecx_380 & 0x03; ecx_394 != 0x00; --ecx_394)
					{
						*edi_390 = esi_386->dw0000;
						++esi_386;
						edi_390 = (word32) edi_390 + 1;
					}
					byte * edi_1120 = &g_b413FE4;
					word32 ecx_399 = ~0x00;
					while (ecx_399 != 0x00)
					{
						++edi_1120;
						--ecx_399;
						if (*edi_1120 != 0x00)
							break;
					}
					uint32 ecx_411 = ~ecx_399;
					struct Eq_16884 * esi_415 = edi_1120 - ecx_411;
					word32 ecx_416 = ~0x00;
					Eq_2 edi_1121 = ebp_192->tFFFFFFFC;
					while (ecx_416 != 0x00)
					{
						edi_1121 = (word32) edi_1121 + 1;
						--ecx_416;
						if (*edi_1121 != 0x00)
							break;
					}
					struct Eq_16903 * edi_433 = edi_1121 - 0x01;
					uint32 ecx_437;
					for (ecx_437 = ecx_411 >> 0x02; ecx_437 != 0x00; --ecx_437)
					{
						edi_433->dw0000 = esi_415->dw0000;
						esi_415 += 4;
						edi_433 += 4;
					}
					ui32 ecx_442;
					for (ecx_442 = ecx_411 & 0x03; ecx_442 != 0x00; --ecx_442)
					{
						edi_433->dw0000 = esi_415->dw0000;
						++esi_415;
						++edi_433;
					}
					Eq_2 edi_1122 = ebp_192->tFFFFFFF4;
					word32 ecx_449 = ~0x00;
					while (ecx_449 != 0x00)
					{
						edi_1122 = (word32) edi_1122 + 1;
						--ecx_449;
						if (*edi_1122 != 0x00)
							break;
					}
					uint32 ecx_461 = ~ecx_449;
					struct Eq_17030 * esi_465 = edi_1122 - ecx_461;
					word32 ecx_466 = ~0x00;
					Eq_2 edi_1123 = ebp_192->tFFFFFFFC;
					while (ecx_466 != 0x00)
					{
						edi_1123 = (word32) edi_1123 + 1;
						--ecx_466;
						if (*edi_1123 != 0x00)
							break;
					}
					struct Eq_17049 * edi_482 = edi_1123 - 0x01;
					uint32 ecx_486;
					for (ecx_486 = ecx_461 >> 0x02; ecx_486 != 0x00; --ecx_486)
					{
						edi_482->dw0000 = esi_465->dw0000;
						esi_465 += 4;
						edi_482 += 4;
					}
					ui32 ecx_491;
					for (ecx_491 = ecx_461 & 0x03; ecx_491 != 0x00; --ecx_491)
					{
						edi_482->dw0000 = esi_465->dw0000;
						++esi_465;
						++edi_482;
					}
					esp_257->t0004 = ebp_192 - 28;
					Eq_2 edx_501 = ebp_192->tFFFFFFFC;
					esp_257->t0000 = ebp_192 - 24;
					esp_257->tFFFFFFFC = edx_501;
					if (fn0040CD20(esp_257->tFFFFFFFC) != 0x00)
					{
						ebx_193 = ebp_192->tFFFFFFFC;
						esp_257->t0004 = ebp_192->tFFFFFFF8;
						free(esp_257->t0004);
						break;
					}
					esp_257->t0004 = ebp_192->tFFFFFFF8;
					free(esp_257->t0004);
					esp_257->t0004 = ebp_192->tFFFFFFFC;
					free(esp_257->t0004);
				}
				ebp_192->ptrFFFFFFF0 -= 0x0C;
				--ebp_192->dwFFFFFFEC;
			} while (ebp_192->ptrFFFFFFF0 >= g_a411A54);
		}
		esp_257->t0004 = ebp_192->tFFFFFFF4;
		free(esp_257->t0004);
		esp_231 = (char *) &esp_257->t0004 + 4;
		if (ebp_192->dwFFFFFFEC < 0x00)
		{
			esp_257->t0004 = ebx_193;
			Eq_2 eax_557 = g_t4133F4;
			esp_257->t0000.u0 = 0x041C;
			esp_257->tFFFFFFFC = eax_557;
l004079AE:
			word32 ecx_1109;
			word32 edx_1110;
			fn00403220(esp_257->tFFFFFFFC, esp_257->t0000, out ecx_1109, out edx_1110);
			esp_231 = (char *) &esp_257->t0004 + 4;
			goto l004079B6;
		}
	}
l004079B6:
	int32 edi_771 = 0x00;
	if (g_dw413400 > 0x00)
	{
		struct Eq_16678 * esi_775 = g_a411A54;
		do
		{
			if (mbsicmp(ebx_193, esi_775->dw0000) == 0x00)
			{
				esp_789->t0004 = ebx_193;
				Eq_2 eax_801 = g_t4133F4;
				esp_789->t0000.u0 = 0x0430;
				esp_789->tFFFFFFFC = eax_801;
				word32 edx_1108;
				word32 ecx_1107;
				fn00403220(esp_789->tFFFFFFFC, esp_789->t0000, out ecx_1107, out edx_1108);
			}
			esp_231 = (char *) &esp_789->t0004 + 4;
			++esi_775;
			++edi_771;
		} while (g_dw413400 > edi_771);
	}
	int32 eax_823 = g_dw413400;
	Eq_2 esi_824 = g_t4133F8;
	Eq_2 eax_826 = g_t4133D8;
	g_t413424.u0 = 0x00;
	*((char *) g_a411A58 + eax_823 * 0x0C) = (union Eq_2 *) eax_826;
	Eq_2 edx_830 = g_t4133F4;
	struct Eq_16645 * esp_834 = esp_231 - 4;
	esp_834->t0000.u0 = 0x00413014;
	esp_834->tFFFFFFFC = ebx_193;
	*((char *) g_a411A50 + eax_823 * 0x0C) = (union Eq_2 *) edx_830;
	g_a411A54[eax_823] = (struct Eq_30077) esi_824;
	++g_dw413400;
	Eq_2 eax_849 = fn0040CA80(esp_834->tFFFFFFFC);
	g_t4133D8 = eax_849;
	if (eax_849 == 0x00)
	{
		esp_834->t0000 = ebx_193;
		Eq_2 eax_862 = g_t4133F4;
		esp_834->tFFFFFFFC.u0 = 0x041C;
		esp_834->tFFFFFFF8 = eax_862;
		word32 edx_1114;
		word32 ecx_1113;
		fn00403220(esp_834->tFFFFFFF8, esp_834->tFFFFFFFC, out ecx_1113, out edx_1114);
	}
	struct Eq_16951 * esp_877 = esp_231 - 4;
	esp_877->t0000 = ebx_193;
	word32 ecx_1111;
	word32 edx_1112;
	g_t4133F8 = fn0040ADD0(esp_877->t0000, out ecx_1111, out edx_1112);
	g_t4133F4.u0 = 0x01;
	g_dw4133F0 = 0x01;
	Eq_2 ecx_937;
	Eq_2 eax_936 = fn00404DE0(out ecx_937);
	word24 eax_24_8_1065 = SLICE(eax_936, word24, 8);
	if (eax_936 != 0x20)
	{
		g_dw4133F0 = 0x01;
		if (eax_936 != 0x09)
		{
l00407A9C:
			if (g_dw4133F0 == 0x00)
			{
				ptr32 ebp_960 = ebp_192->ptr0000;
				ecxOut = ecx_937;
				ebpOut = ebp_960;
				return SEQ(eax_24_8_1065, 0x12);
			}
			else
			{
				Eq_2 ecx_962 = g_t4133D8;
				esp_877->t0000 = ecx_962;
				esp_877->tFFFFFFFC = eax_936;
				word24 eax_24_8_1063 = SLICE(fn00404D70(esp_877->tFFFFFFFC, esp_877->t0000), word24, 8);
				ptr32 ebp_984 = ebp_192->ptr0000;
				ecxOut = ecx_962;
				ebpOut = ebp_984;
				return SEQ(eax_24_8_1063, 0x11);
			}
		}
	}
	g_dw4133F0 = 0x00;
	goto l00407A9C;
}

// 00407AD0: Register uip32 fn00407AD0(Stack Eq_2 dwArg04)
// Called from:
//      fn00407680
uip32 fn00407AD0(Eq_2 dwArg04)
{
	char bLoc0104;
	char bLoc0100;
	_splitpath(dwArg04, &bLoc0104, &bLoc0100, 0x00, 0x00);
	char * edi_24 = &bLoc0100;
	word32 ecx_26 = ~0x00;
	while (ecx_26 != 0x00)
	{
		edi_24 = edi_187 + 1;
		--ecx_26;
		edi_187 = edi_24;
		if (*edi_187 != 0x00)
			break;
	}
	word32 ecx_38 = ~ecx_26;
	char * edi_41 = &bLoc0104;
	word32 ecx_45 = ~0x00;
	while (ecx_45 != 0x00)
	{
		edi_41 = edi_188 + 1;
		--ecx_45;
		edi_188 = edi_41;
		if (*edi_188 != 0x00)
			break;
	}
	fn0040ACC0(~ecx_45 - 1 + (ecx_38 - 1) + 0x01);
	_makepath(0x00, &bLoc0104, &bLoc0100, 0x00, 0x00);
	byte * edi_100 = null;
	word32 ecx_101 = ~0x00;
	while (ecx_101 != 0x00)
	{
		edi_100 = edi_189 + 1;
		--ecx_101;
		edi_189 = edi_100;
		if (*edi_189 != 0x00)
			break;
	}
	struct Eq_17319 * ecx_104 = ~ecx_101;
	byte cl_109 = ecx_104->bFFFFFFFE;
	if (cl_109 == 0x5C || cl_109 == 0x2F)
		ecx_104->bFFFFFFFE = 0x00;
	return 0x00;
}

// 00407B70: Register ui32 fn00407B70(Stack Eq_2 dwArg04, Register out Eq_2 ecxOut)
// Called from:
//      fn004019F0
//      fn00404DE0
//      fn00407680
//      fn004086D0
//      fn00409D70
//      fn0040B110
ui32 fn00407B70(Eq_2 dwArg04, union Eq_2 & ecxOut)
{
	Eq_2 ecx_114 = dwArg04;
	if (*dwArg04 != 0x00)
	{
		ui32 eax_20 = 0x00;
		do
		{
			eax_20 += (int32) *ecx_114;
			ecx_114 = (word32) ecx_114 + 1;
		} while (*ecx_114 != 0x00);
		ecx_114 = (eax_20 & 0xFF) * 0x04 + 0x00413428;
		g_t413FF0 = ecx_114;
		Eq_17378 edi_34 = *ecx_114;
		if (edi_34 != 0x00)
		{
			do
			{
				if (mbscmp(*((word32) edi_34 + 4), dwArg04) == 0x00)
				{
					ui32 eax_76 = 0x00 - (word32) ((*((word32) edi_34 + 0x0C) & 0x10) < 0x01) & edi_34;
					ecxOut = ecx_62;
					return eax_76;
				}
				edi_34 = *edi_34;
			} while (edi_34 != 0x00);
			ecxOut = ecx_62;
			return 0x00;
		}
	}
	else
		g_t413FF0.u0 = 0x00413428;
	ecxOut = ecx_114;
	return 0x00;
}

// 00407BF0: void fn00407BF0(Stack Eq_2 dwArg04)
// Called from:
//      fn004019F0
void fn00407BF0(Eq_2 dwArg04)
{
	fn0040AE10(g_t413FF0, dwArg04);
	g_t413FF0.u0 = 0x00;
}

// 00407C10: void fn00407C10(Stack (ptr32 word32) dwArg04)
// Called from:
//      fn00407C30
void fn00407C10(word32 * dwArg04)
{
	word32 * edi_10 = dwArg04;
	word32 ecx_11;
	for (ecx_11 = 0x0100; ecx_11 != 0x00; --ecx_11)
	{
		*edi_10 = 0x00;
		++edi_10;
	}
}

// 00407C30: void fn00407C30(Stack word32 dwArg04, Stack int32 dwArg08, Stack word32 dwArg0C, Stack Eq_2 dwArg60, Stack Eq_2 dwArg64, Stack Eq_2 dwArg68, Stack Eq_2 dwArg74, Stack Eq_2 dwArg78, Stack Eq_2 dwArg7C, Stack Eq_2 dwArg80, Stack Eq_2 dwArg8C, Stack Eq_2 dwArg90, Stack Eq_2 dwArg94, Stack Eq_2 dwArgA8, Stack Eq_2 dwArgAC, Stack Eq_2 dwArgB0)
// Called from:
//      Win32CrtStartup
void fn00407C30(word32 dwArg04, int32 dwArg08, word32 dwArg0C, Eq_2 dwArg60, Eq_2 dwArg64, Eq_2 dwArg68, Eq_2 dwArg74, Eq_2 dwArg78, Eq_2 dwArg7C, Eq_2 dwArg80, Eq_2 dwArg8C, Eq_2 dwArg90, Eq_2 dwArg94, Eq_2 dwArgA8, Eq_2 dwArgAC, Eq_2 dwArgB0)
{
	fn00407D80();
	g_b41400C = fn0040AAF0();
	byte al_26 = fn0040AB20();
	g_b414010 = al_26;
	if (al_26 != 0x00)
	{
		Eq_2 eax_33 = getenv(0x00414468);
		bool v20_212 = eax_33 != 0x00;
		if (eax_33 != 0x00)
		{
			char * edi_38 = &g_b414464;
			word32 ecx_39 = 0x02;
			Eq_2 esi_40 = eax_33;
			while (ecx_39 != 0x00)
			{
				v20_212 = *esi_377 != *edi_378;
				esi_40 = (word32) esi_377 + 1;
				edi_38 = edi_378 + 1;
				--ecx_39;
				esi_377 = esi_40;
				edi_378 = edi_38;
				if (*esi_377 == *edi_378)
					break;
			}
			if (!v20_212)
				g_b414014 = 0x01;
		}
	}
	fn0040A630();
	fn00407C10(g_a413428);
	g_t413EE0.u0 = 0x0118;
	g_dw413EDC = 0x0104;
	g_dw414004 = dwArg0C;
	g_t413ED4.u0 = 0x0100;
	g_t413ED8.u0 = 0x0100;
	if (g_t413FF8 == 0x00)
	{
		byte * edi_379 = *__p__pgmptr();
		word32 ecx_82 = ~0x00;
		while (ecx_82 != 0x00)
		{
			++edi_379;
			--ecx_82;
			if (*edi_379 != 0x00)
				break;
		}
		uint32 ecx_94 = ~ecx_82;
		uint32 ecx_102;
		struct Eq_17595 * esi_100 = edi_379 - ecx_94;
		struct Eq_17597 * edi_101 = &g_t410E30;
		for (ecx_102 = ecx_94 >> 0x02; ecx_102 != 0x00; --ecx_102)
		{
			edi_101->dw0000 = esi_100->dw0000;
			esi_100 += 4;
			edi_101 += 4;
		}
		ui32 ecx_108;
		for (ecx_108 = ecx_94 & 0x03; ecx_108 != 0x00; --ecx_108)
		{
			edi_101->dw0000 = esi_100->dw0000;
			++esi_100;
			++edi_101;
		}
		if (fn00408140(0x00410E30, &g_t413FF8) == 0x00)
			g_t413FF8.u0 = 0x00413038;
	}
	fn0040A890(0x00414458, *__p__pgmptr(), 0x01);
	signal(0x02, (char *) &g_t0400 + 0x00408540);
	signal(0x0F, (char *) &g_t0400 + 0x00408540);
	fn00403400();
	fn00407F70(dwArg04, dwArg08, dwArg60, dwArg64, dwArg68, dwArg74, dwArg78, dwArg7C, dwArg80, dwArg8C, dwArg90, dwArg94, dwArgA8, dwArgAC, dwArgB0);
	fn00408A20();
	int32 esi_180 = dwArg08;
	if (g_dw4133B0 == 0x00)
		esi_180 = 0x01;
	exit(esi_180);
}

// 00407D80: void fn00407D80()
// Called from:
//      fn00407C30
void fn00407D80()
{
}

// 00407D90: Register word32 fn00407D90(Stack Eq_2 dwArg8C, Stack Eq_2 dwArg90, Stack Eq_2 dwArg94, Stack Eq_2 dwArgA0, Stack Eq_2 dwArgA4, Stack Eq_2 dwArgA8, Stack Eq_2 dwArgD4, Stack Eq_2 dwArgD8, Stack Eq_2 dwArgDC)
// Called from:
//      fn00407F70
word32 fn00407D90(Eq_2 dwArg8C, Eq_2 dwArg90, Eq_2 dwArg94, Eq_2 dwArgA0, Eq_2 dwArgA4, Eq_2 dwArgA8, Eq_2 dwArgD4, Eq_2 dwArgD8, Eq_2 dwArgDC)
{
	Eq_2 ecx_32;
	word32 ecx_675;
	word32 edx_674;
	word32 ecx_672;
	word32 edx_673;
	fn00401980(ecx_32, fn0040ADD0(4277448, out ecx_672, out edx_673), fn0040ADD0(4277444, out ecx_32, out edx_674), 0x00, dwArg8C, dwArg90, dwArg94, dwArgA0, dwArgA4, dwArgA8, out ecx_675);
	Eq_2 ecx_67;
	word32 edx_678;
	word32 ecx_679;
	word32 edx_677;
	word32 ecx_676;
	fn00401980(ecx_67, fn0040ADD0(0x004144C0, out ecx_676, out edx_677), fn0040ADD0(4277444, out ecx_67, out edx_678), 0x00, dwArg8C, dwArg90, dwArg94, dwArgA0, dwArgA4, dwArgA8, out ecx_679);
	Eq_2 ecx_102;
	word32 ecx_683;
	word32 edx_681;
	word32 ecx_680;
	word32 edx_682;
	fn00401980(ecx_102, fn0040ADD0(0x004144BC, out ecx_680, out edx_681), fn0040ADD0(4277444, out ecx_102, out edx_682), 0x00, dwArg8C, dwArg90, dwArg94, dwArgA0, dwArgA4, dwArgA8, out ecx_683);
	Eq_2 ecx_137;
	word32 edx_685;
	word32 ecx_684;
	word32 edx_686;
	word32 ecx_687;
	fn00401980(ecx_137, fn0040ADD0(4277432, out ecx_684, out edx_685), fn0040ADD0(0x004144B4, out ecx_137, out edx_686), 0x00, dwArg8C, dwArg90, dwArg94, dwArgA0, dwArgA4, dwArgA8, out ecx_687);
	Eq_2 ecx_172;
	word32 ecx_691;
	word32 edx_689;
	word32 edx_690;
	word32 ecx_688;
	fn00401980(ecx_172, fn0040ADD0(4277424, out ecx_688, out edx_689), fn0040ADD0(4277420, out ecx_172, out edx_690), 0x00, dwArg8C, dwArg90, dwArg94, dwArgA0, dwArgA4, dwArgA8, out ecx_691);
	Eq_2 ecx_207;
	word32 edx_693;
	word32 ecx_692;
	word32 edx_694;
	word32 ecx_695;
	fn00401980(ecx_207, fn0040ADD0(0x004144A4, out ecx_692, out edx_693), fn0040ADD0(4277404, out ecx_207, out edx_694), 0x00, dwArg8C, dwArg90, dwArg94, dwArgA0, dwArgA4, dwArgA8, out ecx_695);
	Eq_2 ecx_242;
	word32 ecx_699;
	word32 edx_697;
	word32 edx_698;
	word32 ecx_696;
	fn00401980(ecx_242, fn0040ADD0(4272756, out ecx_696, out edx_697), fn0040ADD0(4277400, out ecx_242, out edx_698), 0x00, dwArg8C, dwArg90, dwArg94, dwArgA0, dwArgA4, dwArgA8, out ecx_699);
	Eq_2 ecx_277;
	word32 ecx_703;
	word32 ecx_700;
	word32 edx_701;
	word32 edx_702;
	fn00401980(ecx_277, fn0040ADD0(0x00414490, out ecx_700, out edx_701), fn0040ADD0(0x0041448C, out ecx_277, out edx_702), 0x00, dwArg8C, dwArg90, dwArg94, dwArgA0, dwArgA4, dwArgA8, out ecx_703);
	Eq_2 ecx_312;
	word32 ecx_707;
	word32 ecx_704;
	word32 edx_706;
	word32 edx_705;
	fn00401980(ecx_312, fn0040ADD0(0x00414488, out ecx_704, out edx_705), fn0040ADD0(0x00414484, out ecx_312, out edx_706), 0x00, dwArg8C, dwArg90, dwArg94, dwArgA0, dwArgA4, dwArgA8, out ecx_707);
	Eq_2 ecx_348;
	word32 ecx_708;
	word32 edx_709;
	word32 edx_710;
	word32 ecx_362;
	fn00401980(ecx_348, fn0040ADD0(4277372, out ecx_708, out edx_709), fn0040ADD0(g_t413FF8, out ecx_348, out edx_710), 0x0C, dwArg8C, dwArg90, dwArg94, dwArgA0, dwArgA4, dwArgA8, out ecx_362);
	Eq_2 eax_369 = g_t414018;
	if (eax_369 != 0x00)
	{
		union Eq_2 * dwLoc04_582 = &g_t414018;
		word32 * ebx_374 = &g_dw414118;
		do
		{
			word32 ecx_711;
			word32 edx_712;
			g_t413A3C = fn0040ADD0(eax_369, out ecx_711, out edx_712);
			g_a413AA0[0] = g_t414478;
			fn00401230();
			byte ** ebp_398 = *ebx_374;
			while (*ebp_398 != null)
			{
				byte * edi_403 = *ebp_398;
				word32 ecx_404 = ~0x00;
				while (ecx_404 != 0x00)
				{
					++edi_403;
					--ecx_404;
					if (*edi_403 != 0x00)
						break;
				}
				uint32 ecx_416 = ~ecx_404;
				uint32 ecx_420;
				struct Eq_17881 * esi_421 = edi_403 - ecx_416;
				struct Eq_17883 * edi_422 = g_a413AA0;
				for (ecx_420 = ecx_416 >> 0x02; ecx_420 != 0x00; --ecx_420)
				{
					edi_422->dw0000 = esi_421->dw0000;
					esi_421 += 4;
					edi_422 += 4;
				}
				ui32 ecx_430;
				for (ecx_430 = ecx_416 & 0x03; ecx_430 != 0x00; --ecx_430)
				{
					edi_422->dw0000 = esi_421->dw0000;
					++esi_421;
					++edi_422;
				}
				ebx_374 = fn00401030(dwArgD4, dwArgD8, dwArgDC, out ebp_398);
			}
			if (ebx_374 == &g_dw414118)
				fn004015E0();
			union Eq_2 * v17_472 = (char *) dwLoc04_582 + 4;
			ecx_362 = fn00401710();
			++ebx_374;
			dwLoc04_582 = v17_472;
			eax_369 = *v17_472;
		} while (eax_369 != 0x00);
	}
	return ecx_362;
}

// 00407F70: void fn00407F70(Stack word32 dwArg04, Stack int32 dwArg08, Stack Eq_2 dwArg7C, Stack Eq_2 dwArg80, Stack Eq_2 dwArg84, Stack Eq_2 dwArg90, Stack Eq_2 dwArg94, Stack Eq_2 dwArg98, Stack Eq_2 dwArg9C, Stack Eq_2 dwArgA8, Stack Eq_2 dwArgAC, Stack Eq_2 dwArgB0, Stack Eq_2 dwArgC4, Stack Eq_2 dwArgC8, Stack Eq_2 dwArgCC)
// Called from:
//      fn00407C30
void fn00407F70(word32 dwArg04, int32 dwArg08, Eq_2 dwArg7C, Eq_2 dwArg80, Eq_2 dwArg84, Eq_2 dwArg90, Eq_2 dwArg94, Eq_2 dwArg98, Eq_2 dwArg9C, Eq_2 dwArgA8, Eq_2 dwArgAC, Eq_2 dwArgB0, Eq_2 dwArgC4, Eq_2 dwArgC8, Eq_2 dwArgCC)
{
	g_dw4133C0 = 0x00;
	word32 ecx_576;
	word32 edx_577;
	Eq_2 eax_16 = fn0040ADD0(4277484, out ecx_576, out edx_577);
	Eq_2 ecx_26;
	Eq_2 eax_25 = fn0040CE40(out ecx_26);
	word32 ecx_578;
	fn00401980(ecx_26, eax_16, eax_25, 0x00, dwArg94, dwArg98, dwArg9C, dwArgA8, dwArgAC, dwArgB0, out ecx_578);
	Eq_2 eax_49 = getenv(4277472);
	Eq_2 ebx_141 = eax_49;
	if (eax_49 != 0x00)
	{
		word32 ecx_56 = ~0x00;
		byte * edi_57 = (word32) g_t4133C4 + 0x0A;
		while (ecx_56 != 0x00)
		{
			edi_57 = edi_587 + 1;
			--ecx_56;
			edi_587 = edi_57;
			if (*edi_587 != 0x00)
				break;
		}
		word32 ecx_69 = ~ecx_56;
		mbsnbcpy(ecx_69 - 0x01, (word32) g_t4133C4 + 0x0A, eax_49, ecx_69 - 0x01);
	}
	Eq_2 eax_101 = g_t4133C4;
	g_dw4133B4 = 0x01;
	Eq_2 ecx_120;
	word32 ecx_579;
	word32 edx_580;
	word32 edx_581;
	word32 ecx_582;
	fn00401980(ecx_120, fn0040ADD0(4277472, out ecx_120, out edx_581), fn0040ADD0((word32) eax_101 + 0x0A, out ecx_579, out edx_580), 0x06, dwArg94, dwArg98, dwArg9C, dwArgA8, dwArgAC, dwArgB0, out ecx_582);
	if (eax_49 != 0x00)
	{
		do
		{
			Eq_2 al_143 = *ebx_141;
			if (al_143 == 0x00)
				break;
			fn004086D0(al_143, 0x01);
			ebx_141 = (word32) ebx_141 + 1;
		} while (ebx_141 != 0x00);
	}
	fn00408320(dwArg04 - 0x01, dwArg08 + 0x04);
	if (g_dw4133CC == 0x00)
		fn00403420();
	if ((g_b4133D4 & 0x02) == 0x00)
	{
		Eq_2 ecx_195 = fn00407D90(dwArg7C, dwArg80, dwArg84, dwArg90, dwArg94, dwArg98, dwArgC4, dwArgC8, dwArgCC);
		g_t4133F8.u0 = 0x004144D4;
		if (fn00405860(ecx_195, 0x004144CC, 0x004144D4, g_t413FF8) != 0x00)
		{
			g_t413408.u0 = 0x01;
			g_t4133F4 = (word32) g_t4133F4 + 1;
			fn00408AE0(ebx_141);
			if (fclose(g_t4133D8) == ~0x00)
			{
				word32 ecx_584;
				word32 edx_585;
				fn00403220(0x00, 0x0424, out ecx_584, out edx_585);
			}
		}
	}
	word32 edx_583;
	Eq_2 ecx_263;
	if (_putenv(fn0040ADD0(g_t4133C4, out ecx_263, out edx_583)) == ~0x00)
	{
		word32 edx_586;
		fn00403220(0x00, 1055, out ecx_263, out edx_586);
	}
	if (g_t4133E0 == 0x00)
		fn004085F0(ecx_263);
	fn00408270();
	fn00408190();
	g_t413424.u0 = 0x00;
	fn0040A3C0();
	if ((g_b4133D4 & 0x01) != 0x00)
	{
		fn00409000();
		fn004090A0();
		fn00409170();
	}
	if (g_t413A74 != 0x00)
		free(g_t413A74);
	fn00401F10();
	_chdir(eax_25);
}

// 00408140: Register word32 fn00408140(Stack Eq_2 dwArg04, Stack (ptr32 Eq_2) dwArg08)
// Called from:
//      fn00407C30
word32 fn00408140(Eq_2 dwArg04, union Eq_2 * dwArg08)
{
	char bLoc0100;
	_splitpath(dwArg04, null, null, &bLoc0100, 0x00);
	word32 ecx_78;
	word32 edx_79;
	Eq_2 eax_25 = fn0040ADD0(&bLoc0100, out ecx_78, out edx_79);
	*dwArg08 = (union Eq_2 *) eax_25;
	Eq_2 edi_34 = eax_25;
	word32 ecx_36 = ~0x00;
	while (ecx_36 != 0x00)
	{
		edi_34 = (word32) edi_80 + 1;
		--ecx_36;
		edi_80 = edi_34;
		if (*edi_80 != 0x00)
			return ~ecx_36 - 1;
	}
	return ~ecx_36 - 1;
}

// 00408190: void fn00408190()
// Called from:
//      fn00407F70
void fn00408190()
{
	ptr32 fp;
	struct Eq_18243 * esp_13 = fp - 16;
	Eq_2 ebp_153 = g_t4133E0;
	while (ebp_153 != 0x00)
	{
		Eq_2 eax_27 = *((word32) ebp_153 + 4);
		if (*eax_27 == 0x2D && *((word32) eax_27 + 1) == 0x00)
		{
			union Eq_2 * esp_81 = esp_13 - 4;
			*esp_81 = (union Eq_2 *) 0x004144F4;
			word32 edx_223;
			word32 ecx_222;
			g_t4133F8 = fn0040ADD0(*esp_81, out ecx_222, out edx_223);
			g_t4133D8 = _p__iob();
		}
		else
		{
			struct Eq_18255 * esp_35 = esp_13 - 4;
			esp_35->t0000 = eax_27;
			word32 edx_221;
			word32 ecx_220;
			Eq_2 eax_38 = fn0040ADD0(esp_35->t0000, out ecx_220, out edx_221);
			esp_35->t0000.u0 = 0x00413014;
			g_t4133F8 = eax_38;
			esp_35->tFFFFFFFC = eax_38;
			Eq_2 eax_51 = fn0040CA80(esp_35->tFFFFFFFC);
			g_t4133D8 = eax_51;
			if (eax_51 == 0x00)
			{
				esp_35->t0000 = g_t4133F8;
				esp_35->tFFFFFFFC.u0 = 0x041C;
				esp_35->tFFFFFFF8.u0 = 0x00;
				word32 ecx_226;
				word32 edx_227;
				fn00403220(esp_35->tFFFFFFF8, esp_35->tFFFFFFFC, out ecx_226, out edx_227);
			}
		}
		g_t4133F4.u0 = 0x00;
		g_t413408.u0 = 0x00;
		union Eq_2 * ebp_106 = fn00408AE0(0x00);
		if (_p__iob() != g_t4133D8)
		{
			esp_120->tFFFFFFFC = g_t4133D8;
			if (fclose(esp_120->tFFFFFFFC) == ~0x00)
			{
				esp_120->tFFFFFFFC = g_t4133F8;
				esp_120->tFFFFFFF8.u0 = 0x0424;
				esp_120->tFFFFFFF4.u0 = 0x00;
				word32 ecx_224;
				word32 edx_225;
				fn00403220(esp_120->tFFFFFFF4, esp_120->tFFFFFFF8, out ecx_224, out edx_225);
			}
		}
		esp_13 = esp_120;
		ebp_153 = *ebp_106;
	}
	fn00402C40(g_t4133E0);
}

// 00408270: void fn00408270()
// Called from:
//      fn00407F70
void fn00408270()
{
	word32 * esi_119 = *__p__environ();
	while (*esi_119 != 0x00)
	{
		byte * eax_32 = mbschr(*esi_119, 0x3D);
		if (eax_32 != null && mbsnbicmp(*esi_119, 4277472, 0x08) != 0x00)
		{
			*eax_32 = 0x00;
			Eq_2 eax_56 = *esi_119;
			if (*eax_56 != 0x00)
			{
				esp_47->t0008 = eax_56;
				word32 ecx_186;
				word32 edx_187;
				Eq_2 eax_72 = mbsupr(fn0040ADD0(esp_47->t0008, out ecx_186, out edx_187));
				esp_71->t0000 = eax_32 + 1;
				Eq_2 ecx_84;
				word32 edx_188;
				Eq_2 eax_83 = fn0040ADD0(esp_71->t0000, out ecx_84, out edx_188);
				esp_71->t0000.u0 = 0x04;
				esp_71->tFFFFFFFC = eax_83;
				*eax_32 = 0x3D;
				g_dw4133B4 = 0x00;
				esp_71->tFFFFFFF8 = eax_72;
				word32 ecx_189;
				if (fn00401980(ecx_84, esp_71->tFFFFFFF8, esp_71->tFFFFFFFC, esp_71->t0000, esp_71->t00A4, esp_71->t00A8, esp_71->t00AC, esp_71->t00B8, esp_71->t00BC, esp_71->t00C0, out ecx_189) == 0x00)
				{
					esp_71->t0000 = eax_72;
					free(esp_71->t0000);
					esp_71->t0000 = eax_83;
					free(esp_71->t0000);
				}
			}
		}
		++esi_119;
	}
}

// 00408320: void fn00408320(Stack word32 dwArg04, Stack (ptr32 Eq_5298) dwArg08)
// Called from:
//      fn00402CC0
//      fn00407F70
void fn00408320(word32 dwArg04, struct Eq_5298 * dwArg08)
{
	ptr32 fp;
	word32 esi_110 = dwArg04;
	ptr32 esp_169 = fp - 0x18;
	if (dwArg04 != 0x00)
	{
		struct Eq_5298 * edi_115 = dwArg08;
		do
		{
			struct Eq_18575 * ebx_26 = edi_115->ptr0000;
			byte al_27 = ebx_26->b0000;
			if (al_27 == 0x40)
			{
				word32 * esp_491 = esp_169 - 4;
				*esp_491 = &ebx_26->b0001;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				fn00402CC0(stackArg4);
				esp_169 = esp_491 + 1;
			}
			else if (al_27 != 0x2D && al_27 != 0x2F)
			{
				byte * eax_334 = mbschr(ebx_26, 0x3D);
				if (eax_334 != null)
				{
					if (edi_115->ptr0000 == eax_334)
					{
						esp_333->t0004.u0 = 0x0427;
						esp_333->t0000.u0 = 0x00;
						word32 ecx_727;
						word32 edx_728;
						fn00403220(esp_333->t0000, esp_333->t0004, out ecx_727, out edx_728);
					}
					*eax_334 = 0x00;
					struct Eq_18662 * ecx_406 = eax_334 - 1;
					while (true)
					{
						byte al_412 = ecx_406->b0000;
						if (al_412 != 0x20 && al_412 != 0x09)
							break;
						--ecx_406;
					}
					ecx_406[1] = (struct Eq_18662) 0x00;
					g_dw4133B4 = 0x01;
					byte * ebx_420 = edi_115->ptr0000;
					esp_431->t0004 = eax_334 + 1 + mbsspn(eax_334 + 1, 0x00413008, 0x02);
					word32 edx_742;
					word32 ecx_741;
					esp_456->t0004 = ebx_420 + mbsspn(ebx_420, 0x00413008, fn0040ADD0(esp_431->t0004, out ecx_741, out edx_742));
					Eq_2 ecx_468;
					word32 edx_743;
					esp_456->t0004 = fn0040ADD0(esp_456->t0004, out ecx_468, out edx_743);
					word32 ecx_744;
					fn00401980(ecx_468, esp_456->t0004, esp_456->t0008, esp_456->t000C, esp_456->t00B0, esp_456->t00B4, esp_456->t00B8, esp_456->t00C4, esp_456->t00C8, esp_456->t00CC, out ecx_744);
					edi_115->ptr0000 = null;
					esp_169 = (char *) &esp_456->t000C + 4;
				}
				else
				{
					esp_333->t0004 = edi_115->ptr0000;
					fn00408A90(esp_333->t0004);
					if (*edi_115->ptr0000 != 0x00)
					{
						word32 ecx_729;
						Eq_2 eax_357 = fn0040AD20(out ecx_729);
						esp_333->t0004 = edi_115->ptr0000;
						word32 edx_731;
						word32 ecx_730;
						Eq_2 eax_368 = fn0040ADD0(esp_333->t0004, out ecx_730, out edx_731);
						esp_333->t0004 = eax_357;
						*((word32) eax_357 + 4) = eax_368;
						esp_333->t0000.u0 = 0x004133DC;
						fn0040AE30(esp_333->t0000, esp_333->t0004);
					}
					edi_115->ptr0000 = null;
					esp_169 = (char *) &esp_333->t0004 + 4;
				}
			}
			else
			{
				struct Eq_18613 * ebx_314 = &ebx_26->b0001;
				esp_169 = (char *) esp_50 + 8;
				if (mbsicmp(&ebx_26->b0001, 0x00414508) == 0x00)
				{
					esp_50->dw001C = 0x01;
					break;
				}
				if (ebx_26->b0001 != 0x00)
				{
					do
					{
						word32 eax_73 = mbsicmp(ebx_314, 0x00414500);
						word24 eax_24_8_85 = SLICE(eax_73, word24, 8);
						esp_169 = (char *) &esp_72->t0004 + 4;
						if (eax_73 == 0x00)
						{
							esp_72->t0004.u0 = 0x01;
							esp_72->t0000 = SEQ(eax_24_8_85, ebx_314[2]);
							fn004086D0(esp_72->t0000, esp_72->t0004);
							esp_169 = (char *) &esp_72->t0004 + 4;
							break;
						}
						byte al_96 = ebx_314->b0000;
						if (al_96 == 0x3F)
						{
							esp_72->dw0018 = 0x01;
							break;
						}
						if (al_96 == 0x66 || al_96 == 0x46)
						{
							Eq_2 ebx_105 = ebx_314 + 1;
							if (*ebx_105 == 0x00)
							{
								--esi_110;
								if (esi_110 != 0x00)
								{
									Eq_2 eax_114 = edi_115[1];
									++edi_115;
									if (eax_114 == 0x00)
										goto l00408568;
									ebx_105 = eax_114;
									if (*eax_114 == 0x00)
										goto l00408568;
								}
								else
								{
l00408568:
									esp_72->t0004.u0 = 1061;
									esp_72->t0000.u0 = 0x00;
									word32 ecx_737;
									word32 edx_738;
									fn00403220(esp_72->t0000, esp_72->t0004, out ecx_737, out edx_738);
								}
							}
							word32 ecx_734;
							Eq_2 eax_137 = fn0040AD20(out ecx_734);
							esp_72->t0004 = ebx_105;
							word32 edx_736;
							word32 ecx_735;
							Eq_2 eax_150 = fn0040ADD0(esp_72->t0004, out ecx_735, out edx_736);
							esp_72->t0004 = eax_137;
							*((word32) eax_137 + 4) = eax_150;
							esp_72->t0000.u0 = 0x004133E0;
							fn0040AE30(esp_72->t0000, esp_72->t0004);
							esp_169 = (char *) &esp_72->t0004 + 4;
							break;
						}
						if (al_96 == 0x78)
						{
l004084B0:
							Eq_2 ebx_175 = ebx_314 + 1;
							if (*ebx_175 == 0x00)
							{
								--esi_110;
								if (esi_110 != 0x00)
								{
									Eq_2 eax_184 = edi_115[1];
									++edi_115;
									if (eax_184 == 0x00)
										goto l004084CA;
									ebx_175 = eax_184;
									if (*eax_184 == 0x00)
										goto l004084CA;
								}
								else
								{
l004084CA:
									esp_72->t0004.u0 = 0x0426;
									esp_72->t0000.u0 = 0x00;
									word32 ecx_732;
									word32 edx_733;
									fn00403220(esp_72->t0000, esp_72->t0004, out ecx_732, out edx_733);
								}
							}
							if (*ebx_175 == 0x2D && *((word32) ebx_175 + 1) == 0x00)
							{
								dup2(_p__iob(_p__iob()->dw0050)->dw0030);
								esp_169 = esp_304 + 0x08;
							}
							else
							{
								esp_72->t0004.u0 = 0x004144FC;
								esp_72->t0000 = ebx_175;
								Eq_2 eax_221 = fopen(esp_72->t0000, esp_72->t0004);
								if (eax_221 == 0x00)
								{
									esp_72->t0004 = ebx_175;
									esp_72->t0000.u0 = 0x0418;
									esp_72->tFFFFFFFC.u0 = 0x00;
									word32 edx_740;
									word32 ecx_739;
									fn00403220(esp_72->tFFFFFFFC, esp_72->t0000, out ecx_739, out edx_740);
								}
								dup2(*((word32) eax_221 + 16), _p__iob()->dw0050);
								esp_271->t0004 = eax_221;
								fclose(esp_271->t0004);
								esp_169 = (char *) &esp_271->t0004 + 4;
							}
							break;
						}
						Eq_2 eax_317 = SEQ(eax_24_8_85, al_96);
						if (al_96 == 88)
							goto l004084B0;
						esp_72->t0004.u0 = 0x01;
						esp_72->t0000 = eax_317;
						fn004086D0(esp_72->t0000, esp_72->t0004);
						++ebx_314;
						esp_169 = (char *) &esp_72->t0004 + 4;
					} while (ebx_314->b0000 != 0x00);
				}
			}
			--esi_110;
			++edi_115;
		} while (esi_110 != 0x00);
	}
	if (true)
	{
		if (true)
			return;
		fn00403490();
		exit(0x00);
	}
	else
	{
		fn00403490();
		exit(0x00);
	}
}

// 004085F0: void fn004085F0(Register Eq_2 ecx)
// Called from:
//      fn00407F70
void fn004085F0(Eq_2 ecx)
{
	ptr32 fp;
	Eq_2 tLoc0108;
	Eq_2 dwLoc0118;
	fn0040CEB4((word32) g_t413EE0 + 3 & ~0x03, ecx, dwLoc0118);
	if (access(0x00414510, 0x04) != 0x00)
	{
		if (g_t4133DC == 0x00)
		{
			if ((g_b4133D4 & 0x01) == 0x00)
			{
				esp_36->t0004.u0 = 0x0428;
				esp_36->t0000.u0 = 0x00;
				word32 ecx_227;
				word32 edx_228;
				fn00403220(esp_36->t0000, esp_36->t0004, out ecx_227, out edx_228);
			}
		}
		else
		{
			Eq_2 esi_65 = *((word32) g_t4133DC + 4);
			if (access(esi_65, 0x04) != 0x00)
				return;
			word32 eax_83 = mbsrchr(esi_65, 0x2E);
			if (eax_83 != 0x00)
			{
				esp_82->ptr0004 = fp - 0x0114;
				esp_82->dw0000 = eax_83;
				esp_82->tFFFFFFFC = esi_65;
				esp_82->tFFFFFFF8 = &tLoc0108;
				if (fn00409EF0(esp_82->tFFFFFFF8) != 0x00)
					return;
			}
			Eq_2 ecx_124 = g_t4133DC;
			g_t4133DC = *ecx_124;
			g_t4133E0 = ecx_124;
		}
	}
	else
	{
		word32 ecx_224;
		Eq_2 eax_138 = fn0040AD20(out ecx_224);
		esp_36->t0004.u0 = 0x00414510;
		word32 ecx_225;
		word32 edx_226;
		*((word32) eax_138 + 4) = fn0040ADD0(esp_36->t0004, out ecx_225, out edx_226);
		g_t4133E0 = eax_138;
	}
}

// 004086D0: void fn004086D0(Stack Eq_2 bArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00401310
//      fn004051E0
//      fn00407F70
//      fn00408320
void fn004086D0(Eq_2 bArg04, Eq_2 dwArg08)
{
	byte bLoc01;
	byte bl_128;
	byte al_25 = (byte) mbctoupper((int32) bArg04);
	byte * edi_123 = &g_t4133D0;
	Eq_19263 esi_26 = (int32) al_25;
	if (esi_26 <= 0x54)
	{
		switch (esi_26)
		{
		case 0x20:
			return;
		case 33:
		case 0x22:
		case 0x23:
		case 0x24:
		case 0x25:
		case 0x26:
		case 0x27:
		case 0x28:
		case 0x29:
		case 0x2A:
		case 0x2B:
		case 44:
		case 0x2D:
		case 0x2E:
		case 0x2F:
		case 0x30:
		case 0x31:
		case 0x32:
		case 0x33:
		case 0x34:
		case 0x35:
		case 0x36:
		case 55:
		case 0x38:
		case 0x39:
		case 0x3A:
		case 0x3B:
		case 0x3C:
		case 0x3D:
		case 0x3E:
		case 0x3F:
		case 0x40:
		case 0x46:
		case 0x47:
		case 0x48:
		case 0x4A:
		case 77:
			goto l00408708;
		case 0x41:
			bl_128 = 0x10;
			break;
		case 66:
			g_dw4133B8 = 0x01;
			return;
		case 0x43:
			g_dw4133CC = 0x01;
			bl_128 = 0x20;
			edi_123 = &g_b4133D4;
			break;
		case 0x44:
			bl_128 = 0x01;
			break;
		case 0x45:
			bl_128 = 0x04;
			goto l004087A9;
		case 0x49:
			bl_128 = 0x02;
			break;
		case 0x4B:
			g_dw4133A4 = 0x01;
			return;
		case 0x4C:
			g_dw4133CC = 0x01;
			bl_128 = 0x80;
			edi_123 = &g_b4133D4;
			break;
		case 0x4E:
			bl_128 = 0x04;
			break;
		case 0x4F:
			g_dw4133A8 = 0x01;
			return;
		case 0x50:
			bl_128 = 0x01;
			goto l004087A9;
		case 0x51:
			bl_128 = 0x08;
			goto l004087A9;
		case 0x52:
			bl_128 = 0x02;
			goto l004087A9;
		case 0x53:
			bl_128 = 0x08;
			break;
		case 0x54:
			bl_128 = 0x10;
l004087A9:
			edi_123 = &g_b4133D4;
			break;
		}
	}
	else
	{
l00408708:
		word32 edx_429;
		word32 ecx_428;
		fn00403220(0x00, 0x0429, out ecx_428, out edx_429);
		bl_128 = bLoc01;
	}
	if (g_t4133E8 == 0x00)
	{
		word32 ecx_430;
		Eq_2 eax_107 = fn00407B70(4277472, out ecx_430);
		g_t4133E8 = eax_107;
		g_t4133EC = *((word32) eax_107 + 8);
	}
	if (dwArg08 == 0x00)
	{
		if (edi_123 == &g_t4133D0)
		{
			*edi_123 &= ~bl_128;
			byte * eax_155 = mbschr(*((word32) g_t4133EC + 4), esi_26);
			if (eax_155 != null)
			{
				do
				{
					byte * ecx_165 = eax_155 + 1;
					*eax_155 = *ecx_165;
					eax_155 = ecx_165;
				} while (*ecx_165 != 0x00);
			}
			esp_154->t0004 = g_t4133C4;
			word32 ecx_433;
			word32 edx_434;
			esp_154->t0004 = fn0040ADD0(esp_154->t0004, out ecx_433, out edx_434);
			if (_putenv(esp_154->t0004) == ~0x00)
			{
				esp_154->t0004.u0 = 1055;
				esp_154->t0000 = g_t4133F4;
				word32 ecx_435;
				word32 edx_436;
				fn00403220(esp_154->t0000, esp_154->t0004, out ecx_435, out edx_436);
			}
		}
	}
	else
	{
		byte al_207 = *edi_123 | bl_128;
		*edi_123 = al_207;
		if (al_25 == 0x51)
			*edi_123 = al_207 | 0x20;
		if (mbschr(*((word32) g_t4133EC + 4), esi_26) != 0x00)
			return;
		byte * eax_246 = mbschr(*((word32) g_t4133EC + 4), 0x20);
		if (eax_246 != null)
			*eax_246 = al_25;
		word32 edx_432;
		word32 ecx_431;
		if (_putenv(fn0040ADD0(g_t4133C4, out ecx_431, out edx_432)) != ~0x00)
			return;
		word32 ecx_437;
		word32 edx_438;
		fn00403220(g_t4133F4, 1055, out ecx_437, out edx_438);
	}
}

// 00408A20: void fn00408A20()
// Called from:
//      fn00403220
//      fn00407C30
void fn00408A20()
{
	fcloseall();
	struct Eq_19468 * ebp_20;
	for (ebp_20 = g_ptr4133BC; ebp_20 != null; ebp_20 = ebp_20->ptr0000)
	{
		unlink(ebp_20->dw0004);
		if ((g_t4133D0 & 0x04) != 0x00)
		{
			word32 eax_45 = ebp_20->dw0004;
			printf(esp_37->tFFFFFFFC, esp_37->ptr0000);
			MSVCRT20.dll!fflush(_p__iob(0x0041451C, eax_45) + 0x20);
		}
	}
}

// 00408A90: Register Eq_2 fn00408A90(Stack Eq_2 dwArg04)
// Called from:
//      fn00407070
//      fn00408320
Eq_2 fn00408A90(Eq_2 dwArg04)
{
	word32 ecx_15 = ~0x00;
	Eq_2 edi_12 = dwArg04;
	while (ecx_15 != 0x00)
	{
		edi_12 = (word32) edi_122 + 1;
		--ecx_15;
		edi_122 = edi_12;
		if (*edi_122 != 0x00)
			break;
	}
	Eq_2 eax_27 = (word32) dwArg04 + (~ecx_15 - 2);
	word32 ecx_28 = 0x00;
	if (*dwArg04 == 0x22 && *eax_27 == 0x22)
	{
		--eax_27;
		ecx_28 = 0x01;
	}
	for (; eax_27 > dwArg04; --eax_27)
	{
		byte dl_43 = *eax_27;
		if (dl_43 != 0x20 && dl_43 != 0x2E)
			break;
	}
	if (ecx_28 != 0x00)
	{
		*((word32) eax_27 + 1) = 0x22;
		eax_27 = (word32) eax_27 + 1;
	}
	*((word32) eax_27 + 1) = 0x00;
	return eax_27;
}

// 00408AE0: Register word32 fn00408AE0(Register Eq_2 ebx)
// Called from:
//      fn00407F70
//      fn00408190
word32 fn00408AE0(Eq_2 ebx)
{
	ptr32 fp;
	word24 ebx_24_8_271 = SLICE(ebx, word24, 8);
	g_dw4133C8 = 0x01;
	g_ptr413420 = (struct Eq_19582 *) ((char *) g_ptr413420 + 1);
	struct Eq_19582 * eax_21 = g_ptr413420;
	Eq_2 edx_22 = g_t4133F4;
	g_ptr413420 = (struct Eq_19582 *) ((char *) g_ptr413420 + 1);
	eax_21->b413410 = 0x17;
	struct Eq_19582 * eax_31 = g_ptr413420;
	g_t413424 = edx_22;
	eax_31->b413410 = 0x00;
	word32 ebp_108;
	fn00406500(0x0400, 0x00, out ebp_108);
	struct Eq_19619 * esp_177 = fp - 0x10;
	byte bl_253 = g_ptr413420->b413410;
	while (bl_253 != 0x17)
	{
		if ((bl_253 & 0x40) != 0x00)
		{
			struct Eq_19582 * eax_234 = g_ptr413420;
			--g_ptr413420;
			ui32 eax_239 = SEQ(SLICE(eax_234, word24, 8), eax_234->b413410);
			(*((char *) g_a414630 + (eax_239 & 0x0F) * 0x04))();
		}
		else if ((bl_253 & 0x10) != 0x00)
		{
			if (esp_177->b000F != bl_253)
			{
				struct Eq_19720 * esp_218 = esp_177 - 4;
				esp_218->dw0000 = 4274848;
				Eq_2 eax_220 = g_t413424;
				esp_218->tFFFFFFFC.u0 = 0x0409;
				esp_218->tFFFFFFF8 = eax_220;
				word32 ecx_360;
				word32 edx_361;
				fn00403220(esp_218->tFFFFFFF8, esp_218->tFFFFFFFC, out ecx_360, out edx_361);
				esp_177 = (struct Eq_19619 *) (&esp_218->dw0000 + 1);
			}
			else
			{
				--g_ptr413420;
				struct Eq_19582 * eax_160 = g_ptr413420;
				byte al_161 = eax_160->b413410;
				ui32 eax_166 = SEQ(SLICE(eax_160, word24, 8), al_161);
				if ((al_161 & 0x40) != 0x00)
				{
					--g_ptr413420;
					(*((char *) g_a414630 + (eax_166 & 0x0F) * 0x04))();
				}
				Eq_2 eax_186 = g_t4133F4;
				g_t413424 = eax_186;
				if (esp_177->b000E != 0x00)
				{
					if (g_a413AA0[0] == 0x0A)
						g_t413424 = eax_186 - 0x01;
					uint8 al_215 = esp_177->b000E;
					esp_177->b000E = 0x00;
					esp_177->b000F = al_215;
				}
				else
				{
					struct Eq_19582 * eax_189 = g_ptr413420;
					struct Eq_19873 * esp_191 = esp_177 - 4;
					esp_191->t0000 = SEQ(SLICE(eax_189, word24, 8), eax_189->b413410);
					esp_191->dwFFFFFFFC = 0x0400;
					esp_191->b0013 = (byte) fn00406500(esp_191->dwFFFFFFFC, esp_191->t0000, out ebp_108);
					esp_177 = (struct Eq_19619 *) ((char *) &esp_191->t0000 + 4);
				}
			}
		}
		else
		{
			uint32 eax_59 = (uint32) bl_253;
			ui24 eax_24_8_120 = 0x00;
			uint32 esi_133 = (word32) (eax_59 * 0x08)->a4145D8[(uint32) esp_177->b000F & 0x0F];
			Eq_14276 ebx_101 = SEQ(ebx_24_8_271, bl_253);
			if ((esi_133 & 0x20) != 0x00)
			{
				struct Eq_19761 * esp_70 = esp_177 - 4;
				esp_70->dw0000 = 4274848;
				esp_70->tFFFFFFFC = esi_133 + 1000;
				esp_70->tFFFFFFF8 = g_t413424;
				word32 ecx_362;
				word32 edx_363;
				eax_24_8_120 = SLICE(fn00403220(esp_70->tFFFFFFF8, esp_70->tFFFFFFFC, out ecx_362, out edx_363), word24, 8);
			}
			--g_ptr413420;
			if ((esi_133 & 0x80) != 0x00)
			{
				if (esp_177->b000E == 0x00)
				{
					struct Eq_19823 * esp_98 = esp_177 - 4;
					esp_98->t0000 = ebx_101;
					esp_98->dwFFFFFFFC = 0x0400;
					word32 eax_105 = fn00406500(esp_98->dwFFFFFFFC, esp_98->t0000, out ebp_108);
					esp_98->b0012 = (byte) eax_105;
					eax_24_8_120 = SLICE(eax_105, word24, 8);
				}
				esi_133 = (esi_133 & 0x0F) + (uint32) ((eax_59 * 0x08)->a414618)[SEQ(eax_24_8_120, esp_177->b000E) & 0x0F];
			}
			byte * eax_137 = *((char *) g_a414588 + esi_133 * 0x04);
			Eq_19796 ecx_141 = (uint32) *eax_137;
			while (ecx_141 != 0x00)
			{
				g_ptr413420 = (struct Eq_19582 *) ((char *) g_ptr413420 + 1);
				--ecx_141;
				g_ptr413420->b413410 = eax_137[(word32) ecx_141 + 1];
			}
		}
		bl_253 = g_ptr413420->b413410;
	}
	--g_ptr413420;
	return ebp_108;
}

// 00408CD0: Register up32 fn00408CD0(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00408D80
up32 fn00408CD0(Eq_2 dwArg04, Eq_2 dwArg08)
{
	word32 ecx_11 = ~0x00;
	Eq_2 edi_13 = dwArg08;
	while (ecx_11 != 0x00)
	{
		edi_13 = (word32) edi_65 + 1;
		--ecx_11;
		edi_65 = edi_13;
		if (*edi_65 != 0x00)
			break;
	}
	up32 eax_25 = (word32) dwArg04 + (~ecx_11 - 1);
	if (eax_25 > 0x28)
	{
		printf(0x00414820);
		eax_25 = 0x00;
	}
	return eax_25;
}

// 00408D10: void fn00408D10(Stack Eq_2 dwArg0C)
// Called from:
//      fn004020E0
void fn00408D10(Eq_2 dwArg0C)
{
	ptr32 fp;
	if (dwArg0C != 0x00)
	{
		MSVCRT20.dll!ctime(fp - 0x04, dwArg0C)->b0018 = 0x00;
		fn00403370();
	}
	else
		fn00403370();
}

// 00408D80: void fn00408D80(Stack Eq_2 dwArg04)
// Called from:
//      fn00409170
void fn00408D80(Eq_2 dwArg04)
{
	ptr32 fp;
	Eq_2 eax_6 = g_t413EE0;
	fn0040ACF0(eax_6, eax_6);
	fn00403370();
	Eq_2 edi_111 = 0x00;
	struct Eq_19998 * esp_110 = fp - 0x1C;
	if (dwArg04 != 0x00)
	{
		do
		{
			if (mbschr(esp_110->ptr0020->dw0004, 0x24) != 0x00)
			{
				struct Eq_20008 * ecx_260 = esp_58->ptr0028;
				esp_58->t0004 = (char *) &esp_58->ptr0028 + 4;
				esp_58->t0000 = ecx_260->t0004;
				word32 edx_576;
				fn0040B700(esp_58->t0000, esp_58->t0004, out edx_576);
				esp_58->ptr0020 = (char *) &esp_58->ptr0028 + 4;
				esp_58->t0004.u0 = 0x00413008;
				esp_58->t0000 = (char *) &esp_58->ptr0028 + 4;
				while (true)
				{
					Eq_2 eax_285 = mbstok();
					if (eax_285 == 0x00)
						break;
					if (mbspbrk(eax_285, 0x00413000) != 0x00)
					{
						esp_325->t0004 = &esp_325->t001C;
						esp_325->t0000 = (char *) &esp_325->t0004 + 20;
						esp_325->tFFFFFFFC = eax_285;
						if (fn0040CD20(esp_325->tFFFFFFFC) != 0x00)
						{
							esp_325->t0004 = (char *) &esp_325->t0004 + 20;
							esp_325->t0004 = fn00404C90(esp_325->t0004);
							esp_325->t0000 = eax_285;
							Eq_2 eax_391 = fn0040C340(esp_325->t0000, esp_325->t0004);
							esp_325->t0004 = eax_391;
							esp_325->t0000.u0 = 0x00414828;
							printf(esp_325->t0000, esp_325->t0004);
							esp_325->t0004 = eax_391;
							esp_325->t0000 = edi_111;
							edi_111 = fn00408CD0(esp_325->t0000, esp_325->t0004);
							esp_325->t0004 = eax_391;
							free(esp_325->t0004);
							esp_325->t0004 = esp_325->t001C;
							esp_325->t0000 = (char *) &esp_325->t0004 + 20;
							while (fn0040CE00(esp_325->t0000, esp_325->t0004) != 0x00)
							{
								esp_325->t0004 = (char *) &esp_325->t0004 + 20;
								esp_325->t0004 = fn00404C90(esp_325->t0004);
								esp_325->t0000 = eax_285;
								Eq_2 eax_453 = fn0040C340(esp_325->t0000, esp_325->t0004);
								esp_325->t0004 = eax_453;
								esp_325->t0000.u0 = 0x00414828;
								printf(esp_325->t0000, esp_325->t0004);
								esp_325->t0004 = eax_453;
								esp_325->t0000 = edi_111;
								edi_111 = fn00408CD0(esp_325->t0000, esp_325->t0004);
								esp_325->t0004 = eax_453;
								free(esp_325->t0004);
								esp_325->t0004 = esp_325->t001C;
								esp_325->t0000 = (char *) &esp_325->t0004 + 20;
							}
						}
					}
					else
					{
						esp_325->t0004 = eax_285;
						esp_325->t0000.u0 = 0x00414828;
						printf(esp_325->t0000, esp_325->t0004);
						esp_325->t0004 = eax_285;
						esp_325->t0000 = edi_111;
						edi_111 = fn00408CD0(esp_325->t0000, esp_325->t0004);
					}
					esp_325->t0004.u0 = 0x00413008;
					esp_325->t0000.u0 = 0x00;
				}
				esp_284->t0004 = esp_284->t0020;
				free(esp_284->t0004);
				esp_110 = (struct Eq_19998 *) ((char *) &esp_284->t0004 + 4);
			}
			else if (mbspbrk(esp_58->ptr0028->t0004, 0x00413000) != 0x00)
			{
				struct Eq_20307 * edx_114 = esp_74->ptr0028;
				esp_74->t0004 = &esp_74->t001C;
				esp_74->t0000 = (char *) &esp_74->t0004 + 20;
				esp_74->tFFFFFFFC = edx_114->t0004;
				esp_110 = (struct Eq_19998 *) ((char *) &esp_74->t0004 + 4);
				if (fn0040CD20(esp_74->tFFFFFFFC) != 0x00)
				{
					esp_74->t0004 = (char *) &esp_74->t0004 + 20;
					esp_74->t0004 = fn00404C90(esp_74->t0004);
					esp_74->t0000 = esp_74->ptr0028->t0004;
					Eq_2 eax_148 = fn0040C340(esp_74->t0000, esp_74->t0004);
					esp_74->t0004 = eax_148;
					esp_74->t0000.u0 = 0x00414828;
					printf(esp_74->t0000, esp_74->t0004);
					esp_74->t0004 = eax_148;
					esp_74->t0000 = edi_111;
					edi_111 = fn00408CD0(esp_74->t0000, esp_74->t0004);
					esp_74->t0004 = eax_148;
					free(esp_74->t0004);
					esp_74->t0004 = esp_74->t001C;
					esp_74->t0000 = (char *) &esp_74->t0004 + 20;
					esp_110 = (struct Eq_19998 *) ((char *) &esp_74->t0004 + 4);
					while (fn0040CE00(esp_74->t0000, esp_74->t0004) != 0x00)
					{
						esp_74->t0004 = (char *) &esp_74->t0004 + 20;
						esp_74->t0004 = fn00404C90(esp_74->t0004);
						esp_74->t0000 = esp_74->ptr0028->t0004;
						Eq_2 eax_211 = fn0040C340(esp_74->t0000, esp_74->t0004);
						esp_74->t0004 = eax_211;
						esp_74->t0000.u0 = 0x00414828;
						printf(esp_74->t0000, esp_74->t0004);
						esp_74->t0004 = eax_211;
						esp_74->t0000 = edi_111;
						edi_111 = fn00408CD0(esp_74->t0000, esp_74->t0004);
						esp_74->t0004 = eax_211;
						free(esp_74->t0004);
						esp_74->t0004 = esp_74->t001C;
						esp_74->t0000 = (char *) &esp_74->t0004 + 20;
						esp_110 = (struct Eq_19998 *) ((char *) &esp_74->t0004 + 4);
					}
				}
			}
			else
			{
				esp_74->t0004 = esp_74->ptr0028->t0004;
				esp_74->t0000.u0 = 0x00414828;
				printf(esp_74->t0000, esp_74->t0004);
				esp_74->t0004 = esp_74->ptr0028->t0004;
				esp_74->t0000 = edi_111;
				esp_110 = (struct Eq_19998 *) ((char *) &esp_74->t0004 + 4);
				edi_111 = fn00408CD0(esp_74->t0000, esp_74->t0004);
			}
			struct Eq_20292 * ecx_304 = esp_110->ptr0020->ptr0000;
			esp_110->ptr0020 = ecx_304;
		} while (ecx_304 != null);
	}
}

// 00409000: void fn00409000()
// Called from:
//      fn00407F70
void fn00409000()
{
	fn00403370();
	word32 * ebx_13 = g_a413428;
	do
	{
		struct Eq_20566 * esi_31;
		for (esi_31 = *ebx_13; esi_31 != null; esi_31 = esi_31->ptr0000)
		{
			struct Eq_20565 * eax_37 = esi_31->ptr0008;
			if (eax_37 != null && eax_37->dw0004 != 0x00)
			{
				fn00403370();
				struct Eq_20584 * ebp_62;
				for (ebp_62 = esi_31->ptr0008->ptr0000; ebp_62 != null; ebp_62 = ebp_62->ptr0000)
				{
					char * eax_68 = ebp_62->ptr0004;
					if (eax_68 != null)
						printf(0x0041482C, eax_68);
				}
			}
		}
		++ebx_13;
	} while (ebx_13 < &g_dw413828);
	MSVCRT20.dll!putchar(0x0A);
	MSVCRT20.dll!fflush(_p__iob() + 0x20);
}

// 004090A0: void fn004090A0()
// Called from:
//      fn00407F70
void fn004090A0()
{
	ptr32 fp;
	fn00403370();
	ptr32 esp_103 = fp - 0x10;
	Eq_2 ebx_104 = g_t413A34;
	while (ebx_104 != 0x00)
	{
		struct Eq_20663 * esp_36 = esp_103 - 4;
		esp_36->t0000 = *((word32) ebx_104 + 8);
		esp_36->tFFFFFFFC.u0 = 0x00414848;
		printf(esp_36->tFFFFFFFC, esp_36->t0000);
		esp_36->t0000.u0 = 0x0A;
		fn00403370();
		Eq_2 ebp_53 = *((word32) ebx_104 + 0x0C);
		if (ebp_53 != 0x00)
		{
			esp_36->t0000 = *((word32) ebp_53 + 4);
			esp_36->tFFFFFFFC.u0 = 0x00414844;
			printf(esp_36->tFFFFFFFC, esp_36->t0000);
			struct Eq_20726 * ebp_64;
			for (ebp_64 = *ebp_53; ebp_64 != null; ebp_64 = ebp_64->ptr0000)
			{
				struct Eq_20732 * esp_72 = esp_103 - 4;
				esp_72->t0000 = ebp_64->t0004;
				esp_72->tFFFFFFFC.u0 = 4278332;
				printf(esp_72->tFFFFFFFC, esp_72->t0000);
			}
		}
		MSVCRT20.dll!putchar(0x0A);
		esp_103 = esp_97 + 0x04;
		ebx_104 = *ebx_104;
	}
	struct Eq_20637 * esp_109 = esp_103 - 4;
	esp_109->t0000.u0 = 4275880;
	esp_109->tFFFFFFFC.u0 = 0x00414834;
	printf(esp_109->tFFFFFFFC, esp_109->t0000);
	Eq_2 ebx_125 = g_t413A2C;
	while (ebx_125 != 0x00)
	{
		struct Eq_20768 * esp_133 = esp_103 - 4;
		esp_133->t0000 = *((word32) ebx_125 + 4);
		esp_133->tFFFFFFFC.u0 = 0x00414828;
		printf(esp_133->tFFFFFFFC, esp_133->t0000);
		ebx_125 = *ebx_125;
	}
	MSVCRT20.dll!putchar(0x0A);
	MSVCRT20.dll!fflush(_p__iob() + 0x20);
}

// 00409170: void fn00409170()
// Called from:
//      fn00407F70
void fn00409170()
{
	ptr32 fp;
	fn00403370();
	struct Eq_20796 * esp_243 = fp - 0x18;
	do
	{
		struct Eq_20815 * ecx_33 = *esp_243->ptr0014;
		esp_243->ptr0010 = ecx_33;
		if (ecx_33 != null)
		{
			do
			{
				char * edx_46 = esp_243->ptr0010->ptr0004;
				struct Eq_20819 * esp_52 = esp_243 - 4;
				esp_52->t0000 = (0x00 - (word32) (((((esp_243->ptr0010)->ptr0010)->ptr0004)->b0010 & 0x20) < 0x01) & ~0x19) + 0x3A;
				esp_52->ptrFFFFFFFC = edx_46;
				esp_52->tFFFFFFF8.u0 = 0x00414854;
				printf(esp_52->tFFFFFFF8, esp_52->ptrFFFFFFFC, esp_52->t0000);
				struct Eq_20869 * ecx_59 = esp_52->ptr0014;
				Eq_2 edx_61 = ecx_59->t0004;
				g_t413A84 = edx_61;
				g_t413A90 = edx_61;
				g_t413A8C = edx_61;
				struct Eq_20883 * esp_157 = (char *) &esp_52->t0000 + 4;
				struct Eq_20886 * esi_201;
				for (esi_201 = ecx_59->ptr0010; esi_201 != null; esi_201 = esi_201->ptr0000)
				{
					struct Eq_20910 * edi_71 = esi_201->ptr0004;
					esp_157->ptrFFFFFFFC = (char *) 11;
					fn00403370();
					int32 ebp_106 = 0x00;
					ui32 ebx_374 = 0x01;
					do
					{
						bui8 bl_90 = (byte) ebx_377;
						if ((edi_71->b0010 & bl_90) != 0x00)
						{
							struct Eq_20937 * esp_98 = esp_157 - 4;
							esp_98->t0000.u1 = (int32) (g_ptr414814 + ebp_106);
							esp_98->tFFFFFFFC.u0 = 0x0041484C;
							printf(esp_98->tFFFFFFFC, esp_98->t0000);
						}
						++ebp_106;
						ebx_374 = SEQ(SLICE(ebx_377 * 0x02, word24, 8), bl_90 * 0x02);
						ebx_377 = ebx_374;
					} while (ebx_377 * 0x02 < 0x10);
					Eq_2 ecx_116 = edi_71->t0000;
					esp_157->ptrFFFFFFFC = edi_71->ptr0004;
					esp_157->tFFFFFFF8 = ecx_116;
					fn00408D80(esp_157->tFFFFFFF8);
					esp_157->ptrFFFFFFFC = (char *) 0x0A;
					fn00403370();
					struct Eq_21027 * edi_140 = edi_71->ptr0008;
					if (edi_140 != null)
					{
						char * eax_159 = edi_140->ptr0004;
						if (eax_159 != null)
						{
							esp_157->ptrFFFFFFFC = eax_159;
							esp_157->tFFFFFFF8.u0 = 0x00414844;
							printf(esp_157->tFFFFFFF8, esp_157->ptrFFFFFFFC);
						}
						struct Eq_21046 * edi_172;
						for (edi_172 = edi_140->ptr0000; edi_172 != null; edi_172 = edi_172->ptr0000)
						{
							char * eax_178 = edi_172->ptr0004;
							if (eax_178 != null)
							{
								struct Eq_21085 * esp_183 = esp_157 - 4;
								esp_183->ptr0000 = eax_178;
								esp_183->tFFFFFFFC.u0 = 4278332;
								printf(esp_183->tFFFFFFFC, esp_183->ptr0000);
							}
						}
					}
					else
					{
						MSVCRT20.dll!putchar(0x0A);
						esp_157 = esp_151 + 0x04;
					}
				}
				MSVCRT20.dll!putchar(0x0A, *esp_157->ptr0010);
				esp_243 = (struct Eq_20796 *) ((char *) esp_237 + 4);
			} while (esp_237->dw0014 != 0x00);
		}
		esp_243->ptr0014 = (struct Eq_20815 **) ((char *) esp_243->ptr0014 + 4);
	} while (esp_243->ptr0014 < &g_t413A28);
	g_t413A84.u0 = 0x00;
	g_t413A90.u0 = 0x00;
	g_t413A8C.u0 = 0x00;
	MSVCRT20.dll!putchar(0x0A);
	MSVCRT20.dll!fflush(_p__iob() + 0x20);
}

// 004095C0: Register word32 fn004095C0(Stack cu8 bArg04, Register out ptr32 ecxOut)
// Called from:
//      fn00409AE0
word32 fn004095C0(cu8 bArg04, ptr32 & ecxOut)
{
	Eq_2 ecx_5 = g_t40EA24;
	if (*g_t40EA24 != 22)
	{
		ecxOut = <invalid>;
		return 0x00;
	}
	else
	{
		uint32 eax_16 = (uint32) bArg04;
		if (eax_16 == 0x13)
		{
			*((word32) ecx_5 + 4) = -*((word32) ecx_5 + 4);
			ecxOut = <invalid>;
			return 0x01;
		}
		else if (eax_16 == 0x14)
		{
			*((word32) ecx_5 + 4) = ~*((word32) ecx_5 + 4);
			ecxOut = <invalid>;
			return 0x01;
		}
		else if (eax_16 == 0x15)
		{
			*((word32) ecx_5 + 4) = (word32) (*((word32) ecx_5 + 4) < 0x01);
			ecxOut = <invalid>;
			return 0x01;
		}
		else
		{
			ecxOut = <invalid>;
			return 0x00;
		}
	}
}

// 00409620: Register Eq_2 fn00409620()
// Called from:
//      fn00409800
Eq_2 fn00409620()
{
	g_t40EA18 = (word32) g_t40EA18 + 1;
	Eq_2 esi_9 = g_t40EA18;
	if (*esi_9 != 0x00)
	{
		do
		{
			Eq_2 eax_13 = g_t40EA18;
			if (*eax_13 == 0x22)
			{
				if (*((word32) eax_13 + 1) != 0x22)
					break;
				g_t40EA18 = (word32) eax_13 + 1;
			}
			g_t40EA18 = (word32) g_t40EA18 + 1;
		} while (*g_t40EA18 != 0x00);
	}
	if (*g_t40EA18 == 0x00)
	{
		word32 ecx_91;
		word32 edx_92;
		fn00403220(g_t4133F4, 1022, out ecx_91, out edx_92);
	}
	*g_t40EA18 = 0x00;
	g_t40EA18 = (word32) g_t40EA18 + 1;
	return esi_9;
}

// 00409690: Register Eq_2 fn00409690()
// Called from:
//      fn00409800
Eq_2 fn00409690()
{
	g_t40EA18 = (word32) g_t40EA18 + 1;
	Eq_2 esi_15 = g_t40EA18;
	if (*esi_15 != 0x00)
	{
		do
		{
			byte al_21 = *g_t40EA18;
			if (al_21 == 0x5E)
			{
				Eq_2 edx_24 = g_t40EA18;
				if (*((word32) edx_24 + 1) != 0x5D)
					goto l004096DD;
				byte * edi_31 = (word32) edx_24 + 1;
				word32 ecx_32 = ~0x00;
				while (ecx_32 != 0x00)
				{
					edi_31 = edi_180 + 1;
					--ecx_32;
					edi_180 = edi_31;
					if (*edi_180 != 0x00)
						break;
				}
				memmove(g_t40EA18, (word32) edx_24 + 1, ~ecx_32);
			}
			else
			{
l004096DD:
				if (al_21 == 0x5D)
					break;
			}
			g_t40EA18 = (word32) g_t40EA18 + 1;
		} while (*g_t40EA18 != 0x00);
	}
	if (*g_t40EA18 == 0x00)
	{
		word32 edx_179;
		word32 ecx_178;
		fn00403220(g_t4133F4, 1022, out ecx_178, out edx_179);
	}
	*g_t40EA18 = 0x00;
	g_t40EA18 = (word32) g_t40EA18 + 1;
	return esi_15;
}

// 00409730: Register Eq_21321 fn00409730(Stack Eq_21322 bArg04)
// Called from:
//      fn00409790
Eq_21321 fn00409730(Eq_21322 bArg04)
{
	Eq_21323 bl_14;
	if (bArg04 == 0x19)
		bl_14.u0 = 0x03;
	else if (bArg04 == 0x00)
		bl_14.u0 = 0x04;
	else
	{
		bl_14.u0 = 0x00;
		if (bArg04 <= 0x15)
			bl_14 = SLICE(cond(0x12 - bArg04), bool, 1) + 0x01;
	}
	Eq_21321 ecx_35 = (uint32) bl_14;
	if (Mem8[CONVERT(Mem8[0x0040EA1C<p32>:byte], byte, uint32) * 0x05 + 0x00414880 + ecx_35:byte] == 0x00)
	{
		word32 edx_80;
		fn00403220(g_t4133F4, 0x03FF, out ecx_35, out edx_80);
	}
	g_t40EA1C = bl_14;
	return ecx_35;
}

// 00409790: Register word32 fn00409790(Stack Eq_21322 bArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00409800
//      fn00409BE0
word32 fn00409790(Eq_21322 bArg04, Eq_2 dwArg08)
{
	word32 ecx_13 = fn00409730(bArg04);
	g_t40EA08 = bArg04;
	g_t40EA10 = bArg04;
	g_t40EA14 = dwArg08;
	return ecx_13;
}

// 004097C0: Register byte fn004097C0(Stack (ptr32 byte) dwArg04)
// Called from:
//      fn00409800
byte fn004097C0(byte * dwArg04)
{
	Eq_2 ecx_12 = g_t40EA18;
	byte * eax_16 = dwArg04;
	if (*dwArg04 != 0x00)
	{
		while (*ecx_12 == *eax_16)
		{
			ecx_12 = (word32) ecx_12 + 1;
			++eax_16;
			if (*eax_16 == 0x00)
				break;
		}
		if (*eax_16 != 0x00)
			return 0x00;
	}
	g_t40EA18 = ecx_12;
	return 0x01;
}

// 00409800: Register word32 fn00409800()
// Called from:
//      fn00409BE0
word32 fn00409800()
{
	byte bl_14 = *g_t40EA18;
	if ((bl_14 == 0x20 || bl_14 == 0x09) && ismbcspace((int32) bl_14) != 0x00)
	{
		do
		{
			g_t40EA18 = (word32) g_t40EA18 + 1;
			bl_14 = (byte) *g_t40EA18;
		} while (ismbcspace((int32) bl_14) != 0x00);
	}
	struct Eq_21428 * esi_72;
	if ((g_a4149C0[(uint32) bl_14] & 0x80) != 0x00)
	{
		esi_72 = (struct Eq_21428 *) &g_dw4148A0;
		if (g_dw4148A0 != 0x00)
		{
			while (fn004097C0(esi_72->dw0000) == 0x00)
			{
				++esi_72;
				if (esi_72->dw0000 == 0x00)
					break;
			}
		}
	}
	else
		esi_72 = &g_t414948;
	if (esi_72->dw0000 != 0x00)
		return fn00409790(esi_72->b0004, 0x00);
	if (bl_14 != 0x2D)
	{
		if (bl_14 == 0x22)
			return fn00409790(0x17, fn00409620());
		if (bl_14 == 0x5B)
			return fn00409790(0x18, fn00409690());
		if (ismbcdigit((int32) bl_14) == 0x00)
		{
			if (bl_14 == 0x00)
			{
				g_dw40EA20 = 0x01;
				return fn00409790(0x00, 0x00);
			}
			else if (mbsnbicmp(g_t40EA18, 0x004149B0, 0x07) != 0x00)
			{
				if (mbsnbicmp(g_t40EA18, 0x004149A8, 0x05) != 0x00)
				{
					word32 ecx_198;
					word32 edx_689;
					fn00403220(g_t4133F4, 0x03FF, out ecx_198, out edx_689);
					return ecx_198;
				}
				else
				{
					word32 eax_218 = mbschr(g_t40EA18, 0x28);
					if (eax_218 == 0x00)
					{
						esp_217->t0004.u0 = 0x03FF;
						esp_217->t0000 = g_t4133F4;
						word32 edx_691;
						word32 ecx_690;
						fn00403220(esp_217->t0000, esp_217->t0004, out ecx_690, out edx_691);
					}
					Eq_2 eax_260 = mbscspn(eax_218 + 0x01, 4278688) + (eax_218 + 0x01);
					g_t40EA18 = eax_260;
					*eax_260 = 0x00;
					g_t40EA18 = (word32) g_t40EA18 + 1;
					return fn00409790(22, fn00409DE0(eax_218 + 0x01));
				}
			}
			else
			{
				word32 eax_301 = mbschr(g_t40EA18, 0x28);
				if (eax_301 == 0x00)
				{
					esp_300->t0004.u0 = 0x03FF;
					esp_300->t0000 = g_t4133F4;
					word32 ecx_687;
					word32 edx_688;
					fn00403220(esp_300->t0000, esp_300->t0004, out ecx_687, out edx_688);
				}
				Eq_2 eax_343 = mbscspn(eax_301 + 0x01, 4278688) + (eax_301 + 0x01);
				g_t40EA18 = eax_343;
				*eax_343 = 0x00;
				g_t40EA18 = (word32) g_t40EA18 + 1;
				return fn00409790(22, fn00409D70(eax_301 + 0x01));
			}
		}
		else
		{
			*_errno() = 0x00;
			Eq_2 eax_389 = strtol(g_t40EA18, 4254232, 0x00);
			if (*_errno() == 0x22)
			{
				*g_t40EA18 = 0x00;
				word32 edx_686;
				word32 ecx_685;
				fn00403220(g_t4133F4, 0x0436, out ecx_685, out edx_686);
			}
			if (mbctoupper((int32) *g_t40EA18) == 0x4C)
				g_t40EA18 = (word32) g_t40EA18 + 1;
			return fn00409790(22, eax_389);
		}
	}
	else
	{
		g_t40EA18 = (word32) g_t40EA18 + 1;
		if (g_t40EA08 != 22)
			return fn00409790(0x13, 0x00);
		return fn00409790(0x0E, 0x00);
	}
}

// 00409A90: Register Eq_2 fn00409A90(Register Eq_2 ecx, Stack (ptr32 Eq_21739) dwArg04)
// Called from:
//      fn00409AE0
Eq_2 fn00409A90(Eq_2 ecx, struct Eq_21739 * dwArg04)
{
	g_t40EA24 = (word32) g_t40EA24 + 8;
	if (dwArg04->b0000 != 0x18)
	{
		Eq_2 ecx_11 = g_t40EA24;
		Eq_2 eax_12 = dwArg04->t0004;
		*ecx_11 = dwArg04->b0000;
		*((word32) ecx_11 + 4) = eax_12;
		return ecx_11;
	}
	else
	{
		*((word32) g_t40EA24 + 4) = fn00403AF0(ecx, dwArg04->t0004, 0x01);
		Eq_2 ecx_37 = g_t40EA24;
		*ecx_37 = 22;
		return ecx_37;
	}
}

// 00409AE0: Register word32 fn00409AE0(Register Eq_2 ecx)
// Called from:
//      fn00409BE0
word32 fn00409AE0(Eq_2 ecx)
{
	word24 ecx_24_8 = SLICE(ecx, word24, 8);
	struct Eq_21739 * esi_10 = g_a40EE30;
	if (g_ptr40EA0C > g_a40EE30)
	{
		do
		{
			word32 ecx_155;
			cu8 cl_12 = esi_10->b0000;
			Eq_2 ecx_52 = SEQ(ecx_24_8, cl_12);
			if (cl_12 > 0x15)
				ecx_155 = fn00409A90(ecx_52, esi_10);
			else if (fn004095C0(cl_12, out ecx_155) == 0x00)
			{
				word32 edx_158;
				fn00403220(g_t4133F4, 1080, out ecx_155, out edx_158);
			}
			ecx_24_8 = SLICE(ecx_155, word24, 8);
			++esi_10;
		} while (esi_10 < g_ptr40EA0C);
	}
	if (g_t40EA24 == 0x0040FE30)
	{
		Eq_2 eax_70 = g_t40EA24;
		if (*eax_70 == 22)
			return 0x00 - (word32) (*((word32) eax_70 + 4) < 0x01) + 0x01;
	}
	word32 ecx_156;
	word32 edx_157;
	return fn00403220(g_t4133F4, 0x03FF, out ecx_156, out edx_157);
}

// 00409B70: Register (ptr32 Eq_21739) fn00409B70()
// Called from:
//      fn00409BE0
struct Eq_21739 * fn00409B70()
{
	if (g_t40EA24 < 0x0040FE30)
	{
		word32 ecx_63;
		word32 edx_64;
		fn00403220(g_t4133F4, 0x03FF, out ecx_63, out edx_64);
	}
	if (g_ptr414954 < g_ptr40EA0C)
	{
		word32 ecx_65;
		word32 edx_66;
		fn00403220(g_t4133F4, 0x0412, out ecx_65, out edx_66);
	}
	Eq_2 eax_41 = g_t40EA24;
	struct Eq_21739 * ecx_42 = g_ptr40EA0C;
	Eq_2 eax_44 = *((word32) eax_41 + 4);
	ecx_42->b0000 = (byte) *eax_41;
	ecx_42->t0004 = eax_44;
	g_t40EA24 -= 0x08;
	++g_ptr40EA0C;
	return ecx_42;
}

// 00409BE0: Register word32 fn00409BE0()
// Called from:
//      fn00409E80
word32 fn00409BE0()
{
	g_t40EA24.u0 = 0x0040FE30;
	g_ptr40EA0C = (struct Eq_21739 *) g_a40EE30;
	g_t40EA1C.u0 = 0x03;
	g_t40EA08.u0 = 0x19;
	g_dw40EA20 = 0x00;
	fn00409790(0x19, 0x00);
	Eq_2 edx_36 = g_t40EA24;
	Eq_2 ecx_139 = g_t40EA14;
	*edx_36 = g_t40EA10;
	*((word32) edx_36 + 4) = ecx_139;
	while (g_dw40EA20 == 0x00)
	{
		word32 esi_142 = 0x00;
		ecx_139 = fn00409800();
		if (g_t40EA10 != 0x19)
		{
			ecx_139 = (uint32) *g_t40EA24;
			while (*((word32) ecx_139 + 0x00414860) >= g_a414860[(uint32) g_t40EA10])
			{
				if (g_a414860[(uint32) g_t40EA10] != 0x00)
					fn00409B70();
				else
				{
					while (*g_t40EA24 != 0x19)
						ecx_139 = fn00409B70();
					esi_142 = 0x01;
					if (g_t40EA24 >= 0x0040FE30)
					{
						g_t40EA24 = (word32) g_t40EA24 - 8;
						break;
					}
					word32 ecx_298;
					word32 edx_299;
					fn00403220(g_t4133F4, 0x03FF, out ecx_298, out edx_299);
				}
				ecx_139 = (uint32) *g_t40EA24;
			}
		}
		if (esi_142 == 0x00)
		{
			if (g_t414950 == g_t40EA24)
			{
				word32 edx_300;
				fn00403220(g_t4133F4, 0x0412, out ecx_139, out edx_300);
			}
			else
			{
				g_t40EA24 = (word32) g_t40EA24 + 8;
				Eq_2 edx_155 = g_t40EA24;
				ecx_139 = g_t40EA14;
				*edx_155 = g_t40EA10;
				*((word32) edx_155 + 4) = ecx_139;
			}
		}
	}
	if (g_t40EA24 != 0x0040FE28)
	{
		word32 edx_297;
		fn00403220(g_t4133F4, 0x03FF, out ecx_139, out edx_297);
	}
	return fn00409AE0(ecx_139);
}

// 00409D70: Register word32 fn00409D70(Stack Eq_2 dwArg04)
// Called from:
//      fn00409800
//      fn00409E80
word32 fn00409D70(Eq_2 dwArg04)
{
	Eq_2 eax_18 = mbstok(dwArg04, 0x00413008);
	if (mbstok(0x00, 0x00413008) != 0x00)
	{
		word32 ecx_124;
		word32 edx_125;
		fn00403220(g_t4133F4, 0x0409, out ecx_124, out edx_125);
	}
	Eq_2 eax_53 = g_t4133F4;
	if (eax_18 == 0x00)
	{
		word32 ecx_127;
		word32 edx_128;
		fn00403220(eax_53, 0x0417, out ecx_127, out edx_128);
	}
	word32 ecx_126;
	return 0x00 - (word32) (fn00407B70(eax_18, out ecx_126) < 0x01) + 0x01;
}

// 00409DE0: Register word32 fn00409DE0(Stack word32 dwArg04)
// Called from:
//      fn00409800
word32 fn00409DE0(word32 dwArg04)
{
	Eq_2 eax_25 = mbstok(dwArg04, 0x00413008);
	word32 esi_120 = 0x00;
	if (mbstok(0x00, 0x00413008) != 0x00)
	{
		esp_35->t0004 = eax_25;
		Eq_2 eax_45 = g_t4133F4;
		esp_35->t0000.u0 = 0x0409;
		esp_35->tFFFFFFFC = eax_45;
		word32 ecx_174;
		word32 edx_175;
		fn00403220(esp_35->tFFFFFFFC, esp_35->t0000, out ecx_174, out edx_175);
	}
	Eq_2 edi_100;
	if (eax_25 != 0x00)
	{
		esp_35->t0004 = eax_25;
		Eq_2 eax_68 = fn0040CA30(esp_35->t0004);
		edi_100 = eax_68;
		if (eax_68 != 0x00)
			goto l00409E4B;
	}
	else
		edi_100 = esp_35->t0014;
	esp_35->t0004.u0 = 0x0417;
	esp_35->t0000 = g_t4133F4;
	word32 edx_177;
	word32 ecx_176;
	fn00403220(esp_35->t0000, esp_35->t0004, out ecx_176, out edx_177);
l00409E4B:
	if (access(edi_100, 0x00) == 0x00)
		esi_120 = 0x01;
	free(edi_100);
	return esi_120;
}

// 00409E80: Register Eq_2 fn00409E80(Stack Eq_2 dwArg04, Stack Eq_2 bArg08)
// Called from:
//      fn00405530
Eq_2 fn00409E80(Eq_2 dwArg04, Eq_2 bArg08)
{
	if (*dwArg04 == 0x00)
	{
		word32 ecx_106;
		word32 edx_107;
		fn00403220(g_t4133F4, 1018, out ecx_106, out edx_107);
	}
	uint32 eax_29 = (uint32) bArg08;
	if (eax_29 > 0x07)
	{
		g_t40EA18 = dwArg04;
		return fn00409BE0();
	}
	else
	{
		switch (eax_29)
		{
		case 0x04:
		case 0x06:
			return fn00409D70(dwArg04);
		case 0x05:
		case 0x07:
			return (word32) (fn00409D70(dwArg04) < 0x01);
		}
	}
}

// 00409EF0: Register Eq_2 fn00409EF0(Stack Eq_2 dwArg04)
// Called from:
//      fn004085F0
//      fn0040A500
Eq_2 fn00409EF0(Eq_2 dwArg04)
{
	ptr32 fp;
	Eq_2 eax_6 = g_t413A34;
	struct Eq_22267 * esp_141 = fp - 0x24;
	if (eax_6 != 0x00)
	{
		do
		{
			word32 ecx_28 = esp_141->ptr0020->dw0008;
			byte * eax_38 = mbsrchr(ecx_28, 0x2E, ecx_28);
			byte * ecx_43 = esp_37->ptr0038;
			esp_37->ptr0020 = eax_38;
			esp_37->ptr0004 = ecx_43;
			esp_37->ptr0000 = eax_38;
			esp_141 = (struct Eq_22267 *) ((char *) &esp_37->ptr0004 + 4);
			if (fn0040C980(esp_37->ptr0000, esp_37->ptr0004) == 0x00)
			{
				struct Eq_22326 * ebx_63 = esp_37->ptr001C;
				*esp_37->ptr0030 = 0x00;
				struct Eq_22337 * ebx_64 = &ebx_63->b0001;
				if (ebx_63->b0001 != 0x00)
				{
					do
					{
						byte al_70 = ebx_64->b0000;
						if (al_70 == 0x7B)
							break;
						if (al_70 == 0x5E)
							++ebx_64;
						else if (al_70 == 0x22)
						{
							++ebx_64;
							while (ebx_64->b0000 != 0x22)
								++ebx_64;
						}
						++ebx_64;
					} while (ebx_64->b0000 != 0x00);
				}
				if (ebx_64->b0000 != 0x00)
				{
					struct Eq_22337 * edi_106 = ebx_64;
					do
					{
						byte al_101 = edi_106->b0000;
						if (al_101 == 0x7D)
							break;
						if (al_101 == 0x5E)
							++edi_106;
						++edi_106;
					} while (edi_106->b0000 != 0x00);
					int32 ebp_127 = edi_106 - ebx_64;
					byte * esi_123 = esp_37->ptr0034;
					int32 ebp_128 = ebp_127 - 0x01;
					if (*esi_123 == 0x22)
						++esi_123;
					esp_37->ptr0020 = (byte *) (ebx_64 + 1);
					if (ebp_127 != 0x01)
					{
						do
						{
							byte al_144 = *esp_141->ptr0018;
							esp_141->b0010 = al_144;
							if (al_144 != 0x5C && al_144 != 0x2F)
							{
								esp_141 = (struct Eq_22267 *) ((char *) esp_177 + 4);
								if (esp_177->dw0020 != mbctoupper((int32) esp_165->b0014, mbctoupper((int32) (*esi_123))))
									goto l00409FF1;
							}
							else
							{
								byte al_153 = *esi_123;
								if (al_153 != 0x5C && al_153 != 0x2F)
								{
l00409FF1:
									ebp_128 = ~0x00;
									break;
								}
							}
							++esp_141->ptr0018;
							--ebp_128;
							++esi_123;
						} while (ebp_128 != 0x00);
					}
					if (ebp_128 == ~0x00)
						goto l0040A260;
					ptr32 esi_221 = esp_141->ptr002C + (edi_106 - ebx_64);
					ptr32 eax_239 = mbschr(esi_221, 0x5C, ebx_64);
					esp_141 = esp_238 + 0x08;
					if (eax_239 == 0x00)
					{
						eax_239 = mbschr(esi_221, 0x2F);
						esp_141 = esp_252 + 0x08;
						if (eax_239 != 0x00)
							goto l0040A02D;
						goto l0040A048;
					}
l0040A02D:
					if (eax_239 != esi_221)
						goto l0040A260;
					byte al_268 = edi_106->bFFFFFFFF;
					if (al_268 != 0x5C && al_268 != 0x2F)
						goto l0040A048;
					goto l0040A260;
				}
l0040A048:
				byte * ebx_367;
				struct Eq_22383 * esp_393;
				if (*esp_141->ptr0014 == 0x7B)
				{
					++esp_141->ptr0014;
					byte * ebx_397 = esp_141->ptr0014;
					while (*ebx_397 != 0x00)
					{
						byte al_402 = *ebx_397;
						if (al_402 == 0x7D)
							break;
						if (al_402 == 0x5E)
							++ebx_397;
						++ebx_397;
					}
					struct Eq_22455 * esp_450;
					Eq_22456 ebx_419 = ebx_397 - esp_141->ptr0014;
					if (ebx_419 != 0x00)
					{
						mbsnbcpy(esp_141->ptr0028, esp_141->ptr0014, ebx_419);
						struct Eq_22628 * edx_468 = esp_460->ptr0020 + ((word32) ebx_419.u0 + 1);
						esp_460->ptr0020 = edx_468;
						esp_450 = (struct Eq_22455 *) ((char *) esp_460 + 0x0C);
						if (edx_468->bFFFFFFFE != 0x5C)
						{
							*((word32) ebx_419.u0 + esp_460->dw0034) = 0x5C;
							ebx_419 = (word32) ebx_419.u0 + 1;
						}
					}
					else
					{
						mbsnbcpy(esp_141->ptr0028, 4278712, 0x02);
						++esp_442->dw0020;
						ebx_419.u0 = 0x02;
						esp_450 = (struct Eq_22455 *) ((char *) esp_442 + 0x0C);
					}
					byte * eax_489 = mbsrchr(esp_450->dw002C, 0x5C);
					byte * eax_503 = mbsrchr(esp_488->dw0034, 0x2F);
					esp_393 = (struct Eq_22383 *) ((char *) esp_502 + 8);
					if (eax_503 <= eax_489)
						eax_503 = eax_489;
					if (eax_503 != null)
					{
						byte * edi_1172 = eax_503 + 1;
						word32 ecx_576 = ~0x00;
						while (ecx_576 != 0x00)
						{
							++edi_1172;
							--ecx_576;
							if (*edi_1172 != 0x00)
								break;
						}
						uint32 ecx_588 = ~ecx_576;
						uint32 ecx_592;
						struct Eq_22759 * esi_593 = edi_1172 - ecx_588;
						struct Eq_22761 * edi_600 = (word32) ebx_419 + esp_502->dw0030;
						for (ecx_592 = ecx_588 >> 0x02; ecx_592 != 0x00; --ecx_592)
						{
							edi_600->dw0000 = esi_593->dw0000;
							esi_593 += 4;
							edi_600 += 4;
						}
						ui32 ecx_605;
						for (ecx_605 = ecx_588 & 0x03; ecx_605 != 0x00; --ecx_605)
						{
							edi_600->dw0000 = esi_593->dw0000;
							++esi_593;
							++edi_600;
						}
						ebx_367 = ebx_419 + ((Mem610[esp_502 + 0x38:word32] - eax_503) - 0x01);
					}
					else
					{
						byte * edi_1171 = esp_502->ptr0034;
						word32 ecx_520 = ~0x00;
						while (ecx_520 != 0x00)
						{
							++edi_1171;
							--ecx_520;
							if (*edi_1171 != 0x00)
								break;
						}
						uint32 ecx_532 = ~ecx_520;
						uint32 ecx_536;
						struct Eq_22868 * esi_537 = edi_1171 - ecx_532;
						struct Eq_22870 * edi_545 = (word32) ebx_419 + esp_502->dw0030;
						for (ecx_536 = ecx_532 >> 0x02; ecx_536 != 0x00; --ecx_536)
						{
							edi_545->dw0000 = esi_537->dw0000;
							esi_537 += 4;
							edi_545 += 4;
						}
						ui32 ecx_550;
						for (ecx_550 = ecx_532 & 0x03; ecx_550 != 0x00; --ecx_550)
						{
							edi_545->dw0000 = esi_537->dw0000;
							++esi_537;
							++edi_545;
						}
						ebx_367 = ebx_419 - Mem556[esp_502 + 0x34:word32] + Mem556[esp_502 + 0x38:word32];
					}
				}
				else
				{
					byte * eax_283;
					if (ebx_64->b0000 != 0x00)
					{
						eax_283 = mbsrchr(esp_141->ptr002C, 0x2E);
						esp_141 = (struct Eq_22267 *) ((char *) esp_307 + 8);
						while (*eax_283 != 0x3A)
						{
							byte cl_318 = *eax_283;
							if (cl_318 == 0x5C || (cl_318 == 0x2F || eax_283 <= esp_307->ptr0034))
								break;
							--eax_283;
						}
						byte cl_331 = *eax_283;
						if (cl_331 == 0x3A || (cl_331 == 0x5C || cl_331 == 0x2F))
							++eax_283;
					}
					else
						eax_283 = esp_141->ptr002C;
					word32 esi_347 = 0x00;
					ui32 ebx_349 = esp_141->dw0030 - eax_283;
					if (eax_283 != esp_141->ptr002C && *esp_141->ptr002C == 0x22)
					{
						*esp_141->ptr0028 = 0x22;
						esi_347 = 0x01;
					}
					mbsnbcpy(esp_141->ptr0028 + esi_347, eax_283, ebx_349);
					ebx_367 = ebx_349 + esi_347;
					esp_393 = esp_387 + 0x0C;
				}
				Eq_22713 esi_621 = esp_393->dw0018 - esp_393->dw0014;
				if (ebx_367 + esi_621 > 0x0101)
				{
					struct Eq_22720 * esp_626 = esp_393 - 4;
					esp_626->t0000.u0 = 0x0434;
					esp_626->tFFFFFFFC.u0 = 0x00;
					word32 ecx_1169;
					word32 edx_1170;
					fn00403220(esp_626->tFFFFFFFC, esp_626->t0000, out ecx_1169, out edx_1170);
				}
				mbsnbcpy(ebx_367 + esp_393->dw0028, esp_393->dw0014, esi_621);
				if (*dwArg04 == 0x22)
				{
					Mem685[esi_621 + dwArg04 + ebx_367:byte] = 0x22;
					esi_621 = (word32) esi_621 + 1;
				}
				Mem699[dwArg04 + esi_621 + ebx_367:byte] = 0x00;
				Eq_2 eax_703 = fn0040AEC0(dwArg04, 0x80, 4274216, 0x01);
				if (eax_703 == 0x00)
				{
					esp_141 = fp - 0x24;
					if (fn0040CBF0(dwArg04, fp + 0x10) == 0x00)
						goto l0040A260;
					if (eax_703 != 0x00)
						goto l0040A282;
				}
				else
				{
l0040A282:
					fn00404CC0(fp + 0x10, *((word32) eax_703 + 0x0C));
				}
				return eax_6;
			}
l0040A260:
			struct Eq_22276 * ecx_767 = esp_141->ptr0020->ptr0000;
			esp_141->ptr0020 = ecx_767;
		} while (ecx_767 != null);
	}
	return 0x00;
}

// 0040A2A0: void fn0040A2A0(Stack Eq_2 dwArg04, Stack word32 dwArg08)
// Called from:
//      fn0040A3C0
void fn0040A2A0(Eq_2 dwArg04, word32 dwArg08)
{
	Eq_2 ebx_10 = dwArg04;
	Eq_2 esi_17 = dwArg04;
	if (dwArg04 != 0x00)
	{
		do
		{
			if (dwArg08 != 0x00 && (g_b4133D4 & 0x01) != 0x00)
			{
				word32 ecx_154;
				word32 edx_155;
				fn00403220(0x00, 4005, out ecx_154, out edx_155);
			}
			free(*((word32) ebx_10 + 8));
			fn00402C40(*((word32) ebx_10 + 0x0C));
			fn00402C40(*((word32) ebx_10 + 16));
			ebx_10 = *ebx_10;
			free(esi_17);
			esi_17 = ebx_10;
		} while (ebx_10 != 0x00);
	}
}

// 0040A310: Register word32 fn0040A310(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn0040A3C0
word32 fn0040A310(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 edi_13 = dwArg08;
	if (dwArg08 != 0x00)
	{
		do
		{
			if (mbsicmp(*((word32) edi_13 + 8), *((word32) dwArg04 + 8)) == 0x00)
			{
				free(*((word32) dwArg04 + 8));
				Eq_2 ebx_45 = *((word32) dwArg04 + 0x0C);
				while (ebx_45 != 0x00)
				{
					*((word32) dwArg04 + 0x0C) = *ebx_45;
					free(*((word32) ebx_45 + 4));
					fn0040ADA0(ebx_45);
					ebx_45 = *((word32) dwArg04 + 0x0C);
				}
				free(dwArg04);
				return 0x01;
			}
			edi_13 = *edi_13;
		} while (edi_13 != 0x00);
	}
	return 0x00;
}

// 0040A390: Register Eq_2 fn0040A390(Stack Eq_2 dwArg04)
// Called from:
//      fn0040A3C0
Eq_2 fn0040A390(Eq_2 dwArg04)
{
	Eq_2 eax_11 = dwArg04;
	byte cl_6 = *dwArg04;
	if (cl_6 == 0x7B)
	{
		if (cl_6 != 0x7D)
		{
			do
			{
				eax_11 = (word32) eax_11 + 1;
				if (*eax_11 == 0x5E)
					eax_11 = (word32) eax_11 + 1;
			} while (*eax_11 != 0x7D);
		}
		eax_11 = (word32) eax_11 + 1;
	}
	return eax_11;
}

// 0040A3C0: void fn0040A3C0()
// Called from:
//      fn00407F70
void fn0040A3C0()
{
	ptr32 fp;
	Eq_2 eax_6 = g_t413A34;
	g_t413A34.u0 = 0x00;
	struct Eq_23093 * esp_198 = fp - 0x20;
	if (g_t413A2C != 0x00)
	{
		do
		{
			byte * ecx_30 = esp_198->ptr001C->ptr0004;
			esp_198->ptr0018 = ecx_30;
			byte * edi_33 = ecx_30;
			word32 ecx_35 = ~0x00;
			while (ecx_35 != 0x00)
			{
				edi_33 = edi_373 + 1;
				--ecx_35;
				edi_373 = edi_33;
				if (*edi_373 != 0x00)
					break;
			}
			Eq_2 edi_117 = esp_198->t0014;
			int32 esi_165 = ~ecx_35 - 1;
			while (edi_117 != 0x00)
			{
				struct Eq_23149 * esp_58 = esp_198 - 4;
				esp_58->t0000 = *((word32) edi_117 + 8);
				ptr32 eax_60 = fn0040A390(esp_58->t0000);
				if (mbsnbicmp(esp_58->dw001C, eax_60, esi_165) == 0x00)
				{
					byte al_87 = eax_60 + esi_165;
					if (al_87 != 0x2E && al_87 != 0x7B)
						goto l0040A4C4;
					Eq_2 ebx_162 = edi_117;
					Eq_2 eax_98 = *((word32) edi_117 + 4);
					if (eax_98 != 0x00)
						*eax_98 = *edi_117;
					else
						esp_78->t0020 = *edi_117;
					Eq_2 eax_109 = *edi_117;
					if (eax_109 != 0x00)
						*((word32) eax_109 + 4) = *((word32) edi_117 + 4);
					edi_117 = *edi_117;
					edi_117->u0 = 0x00;
					esp_78->t0008 = g_t413A34;
					esp_78->t0004 = edi_117;
					if (fn0040A310(esp_78->t0004, esp_78->t0008) == 0x00)
					{
						Eq_2 ebp_138 = *((word32) edi_117 + 0x0C);
						while (ebp_138 != 0x00)
						{
							esp_78->t0008.u0 = 0x00;
							esp_78->t0004.u0 = 0x00;
							Eq_2 ecx_149 = *((word32) ebp_138 + 4);
							esp_78->dw0000 = 0x00;
							esp_78->dwFFFFFFFC = 0x00;
							esp_78->dwFFFFFFF8 = 0x00;
							esp_78->ptrFFFFFFF4 = (word32 *) &esp_78->t001C;
							esp_78->tFFFFFFF0 = ecx_149;
							union Eq_2 * ebp_161;
							word32 ecx_372;
							fn0040B110(ecx_149, esp_78->t0100, esp_78->t0104, esp_78->t0108, out ecx_372, out ebx_162, out ebp_161, out esi_165, out edi_117);
							ebp_138 = *ebp_161;
						}
						Eq_2 eax_178 = esp_78->t001C;
						esp_78->t0008 = ebx_162;
						esp_78->t0004.u0 = 4274740;
						*((word32) ebx_162 + 16) = eax_178;
						esp_78->t001C.u0 = 0x00;
						fn0040AE30(esp_78->t0004, esp_78->t0008);
					}
				}
				else
				{
l0040A4C4:
					edi_117 = *edi_117;
				}
				esp_198 = (struct Eq_23093 *) ((char *) &esp_78->t0008 + 4);
			}
			struct Eq_23105 * ecx_204 = esp_198->ptr001C->ptr0000;
			esp_198->ptr001C = ecx_204;
		} while (ecx_204 != null);
	}
	if (eax_6 != 0x00)
		fn0040A2A0(eax_6, 0x01);
}

// 0040A500: Register word32 fn0040A500(Register Eq_2 ecx, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack Eq_2 dwArg20)
// Called from:
//      fn004020E0
word32 fn0040A500(Eq_2 ecx, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, Eq_2 dwArg20)
{
	ptr32 fp;
	Eq_2 tLoc10;
	Eq_2 dwLoc20;
	fn0040CEB4((word32) g_t413EE0 + 3 & ~0x03, ecx, dwLoc20);
	tLoc10 = fp - 0x1C;
	word32 eax_38 = mbsrchr(*((word32) dwArg04 + 4), 0x2E);
	if (eax_38 == 0x00)
		return 0x00;
	esp_37->t0004 = tLoc10;
	esp_37->dw0000 = eax_38;
	esp_37->tFFFFFFFC = *((word32) dwArg04 + 4);
	esp_37->tFFFFFFF8 = dwArg08;
	word32 eax_58 = fn00409EF0(esp_37->tFFFFFFF8);
	if (eax_58 == 0x00)
		return 0x00;
	esp_37->t0004 = &tLoc10;
	word32 ecx_398;
	Eq_2 eax_87 = fn00404CA0(esp_37->t0004, out ecx_398);
	*dwArg20 = dwArg08;
	ptr32 esp_120 = (char *) &esp_37->t0004 + 4;
	word24 ecx_24_8_150 = SLICE(dwArg14, word24, 8);
	struct Eq_23410 * ebx_106 = *dwArg14;
	if (ebx_106 != null)
	{
		do
		{
			ecx_24_8_150 = SLICE(ecx_116, word24, 8);
			esp_120 = esp_114 + 0x08;
			if (mbsicmp(ebx_106->dw0004, dwArg08) == 0x00)
				break;
			ebx_106 = ebx_106->ptr0000;
		} while (ebx_106 != null);
		if (ebx_106 != null)
			*((word32) dwArg04 + 8) &= ~0x01;
	}
	struct Eq_23416 * esp_140 = esp_120 - 4;
	esp_140->dw0000 = 0x00;
	esp_140->ptrFFFFFFFC = fp - 8;
	esp_140->dwFFFFFFF8 = SEQ(ecx_24_8_150, *((word32) dwArg04 + 8));
	esp_140->tFFFFFFF4 = dwArg08;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	Eq_2 stackArg8 = <invalid>;
	*dwArg18 = (word32) *dwArg18 + fn00402080(stackArg4, stackArg8);
	if ((*((word32) dwArg04 + 8) & 0x10) != 0x00 || (dwArg0C < eax_87 || g_dw4133B8 != 0x00 && dwArg0C == eax_87))
	{
		if (ebx_106 == null)
		{
			word32 ecx_401;
			Eq_2 eax_186 = fn0040AD20(out ecx_401);
			esp_140->tFFFFFFF0 = dwArg08;
			word32 ecx_402;
			word32 edx_403;
			Eq_2 eax_198 = fn0040ADD0(esp_140->tFFFFFFF0, out ecx_402, out edx_403);
			esp_140->tFFFFFFF0 = eax_186;
			*((word32) eax_186 + 4) = eax_198;
			esp_140->tFFFFFFEC = dwArg10;
			fn0040AE30(esp_140->tFFFFFFEC, esp_140->tFFFFFFF0);
			if (*dwArg14 == null)
				*dwArg14 = *dwArg10;
		}
		Eq_2 al_229 = *((word32) dwArg04 + 8);
		if ((al_229 & 0x01) != 0x00 && (al_229 & 0x10) == 0x00)
		{
			esp_140->tFFFFFFF0 = *((word32) dwArg04 + 4);
			esp_140->tFFFFFFEC = dwArg08;
			esp_140->dwFFFFFFE8 = 0x03;
			fn00403370();
		}
	}
	Eq_2 ecx_259 = *dwArg1C;
	if (ecx_259 <= eax_87)
		ecx_259 = eax_87;
	*dwArg1C = ecx_259;
	return eax_58;
}

// 0040A630: void fn0040A630()
// Called from:
//      fn00407C30
void fn0040A630()
{
	int32 ebx_10;
	for (ebx_10 = 0x00; ebx_10 <= 0x7F; ++ebx_10)
	{
		byte bl_29 = (byte) ebx_10;
		if (ismbcalnum(ebx_10) != 0x00)
		{
			struct Eq_23579 * eax_32 = (uint32) bl_29;
			eax_32->b4149C0 |= 0x01;
		}
	}
}

// 0040A660: Register ptr32 fn0040A660(Stack (ptr32 byte) dwArg04)
// Called from:
//      fn00403410
ptr32 fn0040A660(byte * dwArg04)
{
	Eq_2 esi_10 = g_t414AC0;
	if (esi_10 != 0x00)
	{
		if (esi_10 == ~0x00)
			return 4272224;
		goto l0040A6A0;
	}
	else
	{
		Eq_2 eax_21 = g_t414AC4;
		if (eax_21 != 0x00)
		{
			Eq_2 eax_29 = fopen(eax_21, 0x00413390);
			g_t414AC0 = eax_29;
			if (eax_29 != 0x00)
			{
				fn0040CF7B((char *) &g_t0400 + 0x0040A5F0);
				esi_10 = g_t414AC0;
l0040A6A0:
				fseek(esi_10, fn0040AA70(dwArg04), 0x00);
				return fn0040A6F0(dwArg04, &g_t40EA28, 0x0400);
			}
		}
		g_t414AC0.u0 = ~0x00;
		return 4272224;
	}
}

// 0040A6F0: Register ptr32 fn0040A6F0(Stack (ptr32 byte) dwArg04, Stack (ptr32 Eq_5168) dwArg08, Stack int32 dwArg0C)
// Called from:
//      fn0040A660
ptr32 fn0040A6F0(byte * dwArg04, struct Eq_5168 * dwArg08, int32 dwArg0C)
{
	byte * tLoc08;
	do
	{
		int32 eax_26 = ftell(g_t414AC0);
		if (fgets(dwArg08, dwArg0C, g_t414AC0) == null)
			return 4272224;
		struct Eq_23651 * eax_59 = fn0040A820(dwArg08, &tLoc08);
		if (dwArg04 == tLoc08)
		{
l0040A785:
			fn0040AA20(eax_26, dwArg04);
			return fn0040A7A0(eax_59);
		}
		if ((int32) ((int64) tLoc08 % 1000) != 999)
			continue;
		if (dwArg04 == tLoc08)
			goto l0040A785;
	} while ((int32) ((int64) dwArg04 /32 ~0x03E7) != (int32) ((int64) tLoc08 /32 ~0x03E7));
	return fn0040A7A0(eax_59);
}

// 0040A7A0: Register (ptr32 Eq_23651) fn0040A7A0(Stack (ptr32 Eq_23651) dwArg04)
// Called from:
//      fn0040A6F0
struct Eq_23651 * fn0040A7A0(struct Eq_23651 * dwArg04)
{
	struct Eq_23651 * edi_16 = dwArg04;
	do
	{
		edi_16 = edi_144 + 1;
		edi_144 = edi_16;
	} while (edi_144->b0000 != 0x22);
	struct Eq_23651 * ebx_23 = edi_16;
	if (edi_16->b0000 != 0x22)
	{
		edi_30 = edi_16;
		do
		{
			struct Eq_23651 * edi_30;
			if ((*((word32) ((uint32) edi_30->b0000 + 1) + _p__mbctype()) & 0x04) != 0x00)
			{
				ebx_23->b0000 = edi_30->b0000;
				++edi_30;
				goto l0040A7FA;
			}
			if (edi_30->b0000 == 0x5C)
			{
				byte al_49 = edi_30[1];
				++edi_30;
				if (al_49 == 110)
					edi_30->b0000 = 0x0A;
				else if (al_49 == 116)
					edi_30->b0000 = 0x09;
				else if (al_49 == 0x22)
					edi_30->b0000 = 0x22;
				else
				{
					ebx_23->b0000 = 0x5C;
l0040A7FA:
					++ebx_23;
				}
			}
			ebx_23->b0000 = edi_30->b0000;
			++edi_30;
			++ebx_23;
		} while (edi_30->b0000 != 0x22);
	}
	ebx_23->b0000 = 0x00;
	return edi_16;
}

// 0040A820: Register (ptr32 Eq_5168) fn0040A820(Stack (ptr32 Eq_5168) dwArg04, Stack (ptr32 (ptr32 byte)) dwArg08)
// Called from:
//      fn0040A6F0
struct Eq_5168 * fn0040A820(struct Eq_5168 * dwArg04, byte ** dwArg08)
{
	byte * ebx_13 = null;
	struct Eq_5168 * edi_14 = dwArg04;
	if (dwArg04->b0000 != 0x00)
	{
		do
		{
			int32 eax_47;
			if (*_p___mb_cur_max() > 0x01)
			{
				int32 eax_50 = (int32) edi_14->b0000;
				esp_29->dwFFFFFFFC = 0x04;
				esp_29->dwFFFFFFF8 = eax_50;
				eax_47 = _isctype(esp_29->dwFFFFFFF8, esp_29->dwFFFFFFFC);
			}
			else
			{
				uint16 eax_42[] = *_p__pctype();
				eax_47 = SEQ(SLICE(eax_42, word16, 16), eax_42[(int32) edi_14->b0000]) & 0x04;
			}
			if (eax_47 == 0x00)
				break;
			++edi_14;
			ebx_13 = (int32) edi_14->bFFFFFFFF - 48 + ebx_13 * 0x0A;
		} while (edi_14->b0000 != 0x00);
	}
	*dwArg08 = (byte **) ebx_13;
	return edi_14;
}

// 0040A890: void fn0040A890(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack word32 dwArg0C)
// Called from:
//      fn00407C30
void fn0040A890(Eq_2 dwArg04, Eq_2 dwArg08, word32 dwArg0C)
{
	char bLoc0408;
	char bLoc0404;
	char bLoc0304;
	char bLoc0204;
	char bLoc0104;
	if (dwArg0C != 0x00)
	{
		_splitpath(dwArg08, &bLoc0408, &bLoc0204, 0x00, 0x00);
		_splitpath(dwArg04, null, null, &bLoc0404, &bLoc0304);
		_makepath(&bLoc0104, &bLoc0408, &bLoc0204, &bLoc0404, &bLoc0304);
		if (access(&bLoc0104, &bLoc0104, 0x00) != 0x00)
		{
			esp_70->t0004 = (char *) &esp_70->t0004 + 0x0114;
			esp_70->t0000 = (char *) &esp_70->t0004 + 20;
			esp_70->ptrFFFFFFFC = null;
			esp_70->ptrFFFFFFF8 = null;
			esp_70->tFFFFFFF4 = (char *) &esp_70->t0004 + 788;
			_makepath(esp_70->tFFFFFFF4, esp_70->ptrFFFFFFF8, esp_70->ptrFFFFFFFC, esp_70->t0000, esp_70->t0004);
			if (access((char *) &esp_70->t0004 + 788, (char *) &esp_70->t0004 + 788, 0x00) != 0x00)
			{
				esp_114->ptrFFFFFFFC = _p__iob(4279144, dwArg04) + 0x40;
				fprintf(esp_114->ptrFFFFFFFC, esp_114->ptr0000, 0x00);
			}
			else
			{
				esp_100->t0004 = (char *) &esp_100->t0004 + 788;
				g_t414AC4 = _strdup(esp_100->t0004);
			}
		}
		else
		{
			esp_70->t0004 = (char *) &esp_70->t0004 + 788;
			g_t414AC4 = _strdup(esp_70->t0004);
		}
	}
	else
	{
		if (access(dwArg04) != 0x00)
			return;
		esp_147->t0004 = dwArg04;
		g_t414AC4 = _strdup(esp_147->t0004);
	}
}

// 0040AA20: void fn0040AA20(Stack int32 dwArg04, Stack (ptr32 byte) dwArg08)
// Called from:
//      fn0040A6F0
void fn0040AA20(int32 dwArg04, byte * dwArg08)
{
	int32 eax_22 = 0x00;
	struct Eq_24029 * edx_10 = g_a414AC8;
	do
	{
		byte * ecx_14 = edx_10->dw0000;
		if (ecx_14 == null)
			break;
		if (dwArg08 == ecx_14)
			return;
		++edx_10;
		++eax_22;
	} while (edx_10 < &g_t414B68);
	if (eax_22 < 0x14)
	{
		g_a414AC8[eax_22] = (struct Eq_30109) dwArg08;
		(&g_a414AC8->dw0004)[eax_22 * 0x08] = dwArg04;
	}
}

// 0040AA70: Register word32 fn0040AA70(Stack (ptr32 byte) dwArg04)
// Called from:
//      fn0040A660
word32 fn0040AA70(byte * dwArg04)
{
	int32 ecx_22;
	int32 ebx_17 = ~0x00;
	int32 edi_21 = 0x7FFF;
	for (ecx_22 = 0x00; ecx_22 < 0x14; ++ecx_22)
	{
		word32 eax_24 = g_a414AC8[ecx_22];
		if (eax_24 == 0x00)
			break;
		int32 esi_30 = dwArg04 - eax_24;
		if (esi_30 == 0x00)
		{
			ebx_17 = ecx_22;
			break;
		}
		if (esi_30 > 0x00 && (edi_21 > esi_30 && (int32) ((int64) eax_24 /32 ~0x03E7) == (int32) ((int64) dwArg04 /32 ~0x03E7)))
		{
			edi_21 = esi_30;
			ebx_17 = ecx_22;
		}
	}
	if (ebx_17 < 0x00)
		return 0x00;
	return (&g_a414AC8->dw0004)[ebx_17 * 0x08];
}

// 0040AAF0: Register byte fn0040AAF0()
// Called from:
//      fn00407C30
byte fn0040AAF0()
{
	Eq_24096 eax_6 = GetModuleHandleA(0x00414BB4);
	if (eax_6 == null)
		return 0x00;
	Eq_24104 eax_15 = GetProcAddress(eax_6, 4279212);
	return 0x00 - (byte) (eax_15 < (int32 (*)()) 0x01) + 0x01;
}

// 0040AB20: Register byte fn0040AB20()
// Called from:
//      fn00407C30
byte fn0040AB20()
{
	Eq_24120 eax_4 = GetVersion();
	cu8 al_11 = (byte) eax_4;
	if ((eax_4 & 0x80000000) == 0x00)
		return 0x00;
	return 0x00 - (byte) (al_11 < 0x04) + 0x01;
}

// 0040AB40: Register word32 fn0040AB40(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00403AF0
word32 fn0040AB40(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_24139 tLoc018E;
	Eq_24140 tLoc0188;
	char bLoc0100;
	word32 eax_154;
	_splitpath(dwArg04, null, null, 0x00, &bLoc0100);
	if (_strnicmp(&bLoc0100, &g_b413FA0, 0x03) != 0x00)
	{
		Eq_24164 eax_50 = OpenFile(dwArg04, &tLoc0188, 0x40);
		if (eax_50 == ~0x00)
		{
			*dwArg08 = 0x03;
			goto l0040ACAD;
		}
		_lread(eax_50, &tLoc018E, 0x02);
		if (_memicmp(&tLoc018E, &g_v414BC8, 0x02) != 0x00)
		{
			_lclose(eax_50);
			*dwArg08 = 0x02;
			goto l0040ACAD;
		}
		if (_llseek(eax_50, 0x3C, 0x00) != 0x3C)
		{
			_lclose(eax_50);
			*dwArg08 = 0x02;
			goto l0040ACAD;
		}
		if ((word32) (_lread(eax_50, (char *) &tLoc018E + 2, 0x04) < 0x05) != 0x00)
		{
			if (_llseek(eax_50, tLoc018E.t0002, 0x00) != tLoc018E.t0002)
			{
				_lclose(eax_50);
				*dwArg08 = 0x02;
l0040ACAD:
				eax_154 = 0x00;
				return eax_154;
			}
			_lread(eax_50, &tLoc018E, 0x04);
			if (_memicmp(&tLoc018E, &g_v414BC4, 0x02) == 0x00)
			{
				_lclose(eax_50);
				*dwArg08 = 0x00;
				eax_154 = 0x01;
				return eax_154;
			}
		}
		_lclose(eax_50);
	}
	*dwArg08 = 0x01;
	goto l0040ACAD;
}

// 0040ACC0: Register word32 fn0040ACC0(Stack Eq_2 dwArg04)
// Called from:
//      fn00401E00
//      fn00407AD0
//      fn0040ACF0
//      fn0040ADD0
//      fn0040AEC0
//      fn0040B700
//      fn0040BB00
//      fn0040CA30
//      fn0040CE40
word32 fn0040ACC0(Eq_2 dwArg04)
{
	word32 edx;
	if (malloc(dwArg04) == null)
	{
		word32 ecx_58;
		fn00403220(g_t413424, 1051, out ecx_58, out edx);
	}
	return edx;
}

// 0040ACF0: void fn0040ACF0(Register Eq_2 eax, Stack Eq_2 dwArg04)
// Called from:
//      fn004015E0
//      fn004019F0
//      fn00401BC0
//      fn00401BF0
//      fn00401ED0
//      fn00402870
//      fn00402C70
//      fn004031B0
//      fn00404F80
//      fn00405C20
//      fn00405EF0
//      fn00406A80
//      fn00407680
//      fn00408D80
//      fn0040AEC0
//      fn0040BB90
//      fn0040C170
void fn0040ACF0(Eq_2 eax, Eq_2 dwArg04)
{
	fn0040ACC0(dwArg04);
	Eq_2 edi_21 = eax;
	uint32 ecx_25;
	for (ecx_25 = dwArg04 >> 0x02; ecx_25 != 0x00; --ecx_25)
	{
		*edi_21 = 0x00;
		edi_21 = (word32) edi_21 + 4;
	}
	ui32 ecx_30;
	for (ecx_30 = dwArg04 & 0x03; ecx_30 != 0x00; --ecx_30)
	{
		*edi_21 = 0x00;
		edi_21 = (word32) edi_21 + 1;
	}
}

// 0040AD20: Register Eq_2 fn0040AD20(Register out ptr32 ecxOut)
// Called from:
//      fn00401030
//      fn00401170
//      fn004013D0
//      fn004019F0
//      fn00401D00
//      fn004020E0
//      fn00406020
//      fn00408320
//      fn004085F0
//      fn0040A500
//      fn0040B110
//      fn0040CB30
Eq_2 fn0040AD20(ptr32 & ecxOut)
{
	ptr32 ecx;
	Eq_2 eax_35;
	if (g_t40EE28 != 0x00)
	{
		eax_35 = g_t40EE28;
		g_t40EE28 = *eax_35;
	}
	else
	{
		if (g_dw414BDC < 0x08)
		{
			Eq_2 eax_11 = malloc(0x8000);
			g_t414BE0 = eax_11;
			if (eax_11 == 0x00)
			{
				word32 edx_74;
				fn00403220(g_t413424, 1051, out ecx, out edx_74);
			}
			g_dw414BDC = 0x8000;
		}
		g_dw414BDC -= 0x08;
		eax_35 = g_t414BE0;
		g_t414BE0 = (word32) g_t414BE0 + 8;
	}
	eax_35->u0 = 0x00;
	((word32) eax_35 + 4)->u0 = 0x00;
	ecxOut = ecx;
	return eax_35;
}

// 0040ADA0: Register Eq_2 fn0040ADA0(Stack Eq_2 dwArg04)
// Called from:
//      fn00401030
//      fn00401170
//      fn00401230
//      fn004013D0
//      fn00401710
//      fn00401870
//      fn00401CC0
//      fn00401D00
//      fn00401F10
//      fn00402C40
//      fn0040A310
//      fn0040B690
Eq_2 fn0040ADA0(Eq_2 dwArg04)
{
	Eq_2 ecx;
	if (g_t40EE28 != 0x00)
	{
		Eq_2 ecx_7 = g_t40EE28;
		*dwArg04 = ecx_7;
		g_t40EE28 = dwArg04;
		return ecx_7;
	}
	else
	{
		dwArg04->u0 = 0x00;
		g_t40EE28 = dwArg04;
		return ecx;
	}
}

// 0040ADD0: Register uip32 fn0040ADD0(Stack Eq_2 dwArg04, Register out (ptr32 Eq_33) ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00401000
//      fn00401030
//      fn004013D0
//      fn00401D00
//      fn004020E0
//      fn00402870
//      fn00402C70
//      fn00402CC0
//      fn00402F60
//      fn004031B0
//      fn00403580
//      fn00403AF0
//      fn004043A0
//      fn00404680
//      fn00405930
//      fn00405EF0
//      fn00406020
//      fn00406A80
//      fn00407680
//      fn00407D90
//      fn00407F70
//      fn00408140
//      fn00408190
//      fn00408270
//      fn00408320
//      fn004085F0
//      fn004086D0
//      fn0040A500
//      fn0040B110
//      fn0040BB90
//      fn0040C340
uip32 fn0040ADD0(Eq_2 dwArg04, struct Eq_33 & ecxOut, ptr32 & edxOut)
{
	word32 ecx_18 = ~0x00;
	Eq_2 esi_13 = dwArg04;
	Eq_2 edi_17 = dwArg04;
	while (ecx_18 != 0x00)
	{
		edi_17 = (word32) edi_117 + 1;
		--ecx_18;
		edi_117 = edi_17;
		if (*edi_117 != 0x00)
			break;
	}
	Eq_2 ecx_27 = ~ecx_18;
	ptr32 edx_34 = fn0040ACC0(ecx_27);
	struct Eq_24404 * edi_45 = null;
	uint32 ecx_47;
	for (ecx_47 = ecx_27 >> 0x02; ecx_47 != 0x00; --ecx_47)
	{
		edi_45->dw0000 = (word32) *esi_13;
		esi_13 = (word32) esi_13 + 4;
		edi_45 += 4;
	}
	struct Eq_33 * ecx_52;
	for (ecx_52 = ecx_27 & 0x03; ecx_52 != null; --ecx_52)
	{
		edi_45->dw0000 = (word32) *esi_13;
		esi_13 = (word32) esi_13 + 1;
		++edi_45;
	}
	ecxOut = ecx_52;
	edxOut = edx_34;
	return 0x00;
}

// 0040AE10: Register Eq_2 fn0040AE10(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn004013D0
//      fn004019F0
//      fn00401BC0
//      fn00401BF0
//      fn00402C70
//      fn00407BF0
//      fn0040CB30
Eq_2 fn0040AE10(Eq_2 dwArg04, Eq_2 dwArg08)
{
	*dwArg08 = *dwArg04;
	*dwArg04 = dwArg08;
	return dwArg08;
}

// 0040AE30: Register Eq_2 fn0040AE30(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00401030
//      fn004013D0
//      fn00401BF0
//      fn00401D00
//      fn004020E0
//      fn00402870
//      fn00406020
//      fn00408320
//      fn0040A3C0
//      fn0040A500
Eq_2 fn0040AE30(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 eax_10 = dwArg04;
	if (*dwArg04 != 0x00)
	{
		do
			eax_10 = *eax_10;
		while (*eax_10 != 0x00);
	}
	*eax_10 = dwArg08;
	return dwArg08;
}

// 0040AE50: Register uint32 fn0040AE50(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      fn00401BF0
//      fn00402C70
//      fn0040AEC0
uint32 fn0040AE50(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	word32 edi_16;
	if (dwArg0C != 0x00)
	{
		edi_16 = 0x00;
		Eq_2 esi_29 = dwArg04;
		int32 eax_30 = (int32) *dwArg04;
		while (eax_30 != 0x00)
		{
			word32 eax_46;
			if (eax_30 == 0x2F)
				eax_46 = 0x5C;
			else
				eax_46 = mbctoupper(eax_30);
			esi_29 = (word32) esi_29 + 1;
			edi_16 += eax_46;
			eax_30 = (int32) *esi_29;
		}
	}
	else
	{
		edi_16 = 0x00;
		Eq_2 esi_17 = dwArg04;
		if (*dwArg04 != 0x00)
		{
			do
			{
				edi_16 += (int32) *esi_17;
				esi_17 = (word32) esi_17 + 1;
			} while (*esi_17 != 0x00);
		}
	}
	return (uint32) ((uint64) edi_16 % dwArg08);
}

// 0040AEC0: Register ui32 fn0040AEC0(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      fn00401BF0
//      fn00402080
//      fn004020E0
//      fn00409EF0
ui32 fn0040AEC0(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	ui32 eax_680;
	word32 esi_13 = 0x00;
	if (*dwArg04 != 0x00)
	{
		ui32 eax_28 = fn0040AE50(dwArg04, dwArg08, dwArg10);
		if (dwArg10 != 0x00)
		{
			eax_680 = fn0040C8D0(dwArg0C, eax_28);
			if (eax_680 != 0x00)
				return eax_680;
			Eq_2 ebp_151;
			if (mbsnbcmp(dwArg04, 4278712, 0x02) != 0x00 && mbsnbcmp(dwArg04, 4279272, 0x02) != 0x00)
			{
				Eq_2 edi_152 = dwArg04;
				word32 ecx_153 = ~0x00;
				while (ecx_153 != 0x00)
				{
					edi_152 = (word32) edi_997 + 1;
					--ecx_153;
					edi_997 = edi_152;
					if (*edi_997 != 0x00)
						break;
				}
				esp_140->t0008 = ~ecx_153 + 0x02;
				fn0040ACC0(esp_140->t0008);
				null = (word16 *) g_w4149B8;
				*(byte *) 2 = g_b4149BA;
				ebp_151.u0 = 0x00;
				Eq_2 edi_190 = dwArg04;
				word32 ecx_191 = ~0x00;
				while (ecx_191 != 0x00)
				{
					edi_190 = (word32) edi_190 + 1;
					--ecx_191;
					if (*edi_190 != 0x00)
						break;
				}
				uint32 ecx_205 = ~ecx_191;
				struct Eq_24616 * esi_209 = edi_190 - ecx_205;
				word32 ecx_210 = ~0x00;
				byte * edi_213 = null;
				while (ecx_210 != 0x00)
				{
					++edi_213;
					--ecx_210;
					if (*edi_213 != 0x00)
						break;
				}
				struct Eq_24633 * edi_225 = edi_213 - 0x01;
				uint32 ecx_229;
				for (ecx_229 = ecx_205 >> 0x02; ecx_229 != 0x00; --ecx_229)
				{
					edi_225->dw0000 = esi_209->dw0000;
					esi_209 += 4;
					edi_225 += 4;
				}
				ui32 ecx_234;
				for (ecx_234 = ecx_205 & 0x03; ecx_234 != 0x00; --ecx_234)
				{
					edi_225->dw0000 = esi_209->dw0000;
					++esi_209;
					++edi_225;
				}
				esi_13 = 0x01;
			}
			else
				ebp_151 = (word32) dwArg04 + 2;
			ui32 eax_269 = fn0040C8D0(dwArg0C, fn0040AE50(ebp_151, dwArg08, dwArg10));
			if (eax_269 == 0x00)
			{
				if (dwArg04 - ebp_151 != ~0x01)
					*((byte) ebp_151.u0 + 1) = 0x2F;
				ui32 eax_313 = fn0040C8D0(dwArg0C, fn0040AE50(ebp_151, dwArg08, dwArg10));
				if (esi_13 != 0x00)
					free(ebp_151);
				if (eax_313 != 0x00)
					return eax_313;
				Eq_2 ebp_377;
				if (*dwArg04 == 0x22)
					ebp_377 = fn0040CA30(dwArg04);
				else
				{
					Eq_2 edi_341 = dwArg04;
					word32 ecx_342 = ~0x00;
					while (ecx_342 != 0x00)
					{
						edi_341 = (word32) edi_1000 + 1;
						--ecx_342;
						edi_1000 = edi_341;
						if (*edi_1000 != 0x00)
							break;
					}
					fn0040ACF0(0x00, ~ecx_342 + 0x02);
					null = (word16 *) g_w414BE4;
					Eq_2 edi_1001 = dwArg04;
					ebp_377.u0 = 0x00;
					word32 ecx_378 = ~0x00;
					while (ecx_378 != 0x00)
					{
						edi_1001 = (word32) edi_1001 + 1;
						--ecx_378;
						if (*edi_1001 != 0x00)
							break;
					}
					uint32 ecx_392 = ~ecx_378;
					struct Eq_24781 * esi_396 = edi_1001 - ecx_392;
					word32 ecx_397 = ~0x00;
					byte * edi_1002 = null;
					while (ecx_397 != 0x00)
					{
						++edi_1002;
						--ecx_397;
						if (*edi_1002 != 0x00)
							break;
					}
					struct Eq_24798 * edi_412 = edi_1002 - 0x01;
					uint32 ecx_416;
					for (ecx_416 = ecx_392 >> 0x02; ecx_416 != 0x00; --ecx_416)
					{
						edi_412->dw0000 = esi_396->dw0000;
						esi_396 += 4;
						edi_412 += 4;
					}
					ui32 ecx_421;
					for (ecx_421 = ecx_392 & 0x03; ecx_421 != 0x00; --ecx_421)
					{
						edi_412->dw0000 = esi_396->dw0000;
						++esi_396;
						++edi_412;
					}
					byte * edi_1003 = &g_w414BE4;
					word32 ecx_426 = ~0x00;
					while (ecx_426 != 0x00)
					{
						++edi_1003;
						--ecx_426;
						if (*edi_1003 != 0x00)
							break;
					}
					uint32 ecx_438 = ~ecx_426;
					struct Eq_24852 * esi_442 = edi_1003 - ecx_438;
					word32 ecx_443 = ~0x00;
					byte * edi_1004 = null;
					while (ecx_443 != 0x00)
					{
						++edi_1004;
						--ecx_443;
						if (*edi_1004 != 0x00)
							break;
					}
					struct Eq_24869 * edi_459 = edi_1004 - 0x01;
					uint32 ecx_463;
					for (ecx_463 = ecx_438 >> 0x02; ecx_463 != 0x00; --ecx_463)
					{
						edi_459->dw0000 = esi_442->dw0000;
						esi_442 += 4;
						edi_459 += 4;
					}
					ui32 ecx_468;
					for (ecx_468 = ecx_438 & 0x03; ecx_468 != 0x00; --ecx_468)
					{
						edi_459->dw0000 = esi_442->dw0000;
						++esi_442;
						++edi_459;
					}
				}
				ui32 eax_556 = fn0040C8D0(dwArg0C, fn0040AE50(ebp_377, dwArg08, dwArg10));
				free(ebp_377);
				return eax_556;
			}
			else
			{
				if (esi_13 != 0x00)
					free(ebp_151);
				return eax_269;
			}
		}
		struct Eq_24547 * esi_38;
		for (esi_38 = *((word32) dwArg0C + eax_28 * 0x04); esi_38 != null; esi_38 = esi_38->ptr0000)
		{
			if (mbscmp(esi_38->dw0004, dwArg04) == 0x00)
				return 0x00 - (word32) ((esi_38->b000C & 0x10) < 0x01) & esi_38;
		}
	}
	eax_680 = 0x00;
	return eax_680;
}

// 0040B110: Register word32 fn0040B110(Register Eq_2 ecx, Stack Eq_2 dwArg0114, Stack Eq_2 dwArg0118, Stack Eq_2 dwArg011C, Register out Eq_2 ecxOut, Register out (ptr32 Eq_18) ebxOut, Register out ptr32 ebpOut, Register out (ptr32 Eq_20) esiOut, Register out (ptr32 Eq_21) ediOut)
// Called from:
//      fn00401000
//      fn00401030
//      fn004019F0
//      fn0040A3C0
//      fn0040B110
//      fn0040B690
word32 fn0040B110(Eq_2 ecx, Eq_2 dwArg0114, Eq_2 dwArg0118, Eq_2 dwArg011C, union Eq_2 & ecxOut, struct Eq_18 & ebxOut, ptr32 & ebpOut, struct Eq_20 & esiOut, struct Eq_21 & ediOut)
{
	ptr32 fp;
	Eq_2 dwLoc04;
	ptr32 dwLoc0120;
	struct Eq_21 * dwLoc011C;
	struct Eq_20 * dwLoc0118;
	struct Eq_18 * dwLoc0114;
	Eq_2 ecx_130 = fn0040CEB4(0x0110, ecx, dwLoc04);
	struct Eq_24928 * esp_113 = fp - 16;
	up32 edi_100 = 0x00;
	if (dwArg0118 != 0x00)
	{
		if (dwArg011C != 0x00)
			ecx_130 = dwArg011C;
		else
		{
			ecx_130 = *dwArg0118;
			Eq_2 dwArg00_707 = ecx_130;
			if (ecx_130 != 0x00 && *ecx_130 != 0x00)
			{
				do
				{
					ecx_130 = *dwArg00_707;
					dwArg00_707 = ecx_130;
				} while (*ecx_130 != 0x00);
			}
		}
	}
	word32 eax_132;
	Eq_2 ebx_114 = dwArg0114;
	if (*dwArg0114 != 0x00 && *dwArg0114 != 0x00)
	{
		do
		{
			byte al_58 = *ebx_114;
			if (al_58 != 0x24)
			{
				if (al_58 == 0x22)
					edi_100 = (word32) (edi_100 < 0x01);
				if (edi_100 == 0x00 && al_58 == 0x5E)
				{
					ebx_114 = (word32) ebx_114 + 1;
					if (*ebx_114 == 0x22)
						edi_100 = (word32) (edi_100 < 0x01);
				}
				Eq_2 eax_108 = mbsinc(ebx_114);
				esp_113 = esp_107 + 0x04;
				ebx_114 = eax_108;
				ecx_130 = ecx_109;
				ecx_130 = ecx_109;
				if (*eax_108 != 0x00)
					continue;
			}
			if (*ebx_114 == 0x00)
				break;
			if (*((word32) ebx_114 + 1) == 0x00)
			{
				if ((esp_113->b013C & 0x04) != 0x00)
				{
					if (esp_113->t012C != 0x00)
					{
						ecx_130 = esp_113->t012C;
						*ecx_130 = esp_113->t0010;
					}
					eax_132 = 0x00;
					goto l0040B49D;
				}
				struct Eq_25054 * esp_135 = esp_113 - 4;
				esp_135->t0000.u0 = 1002;
				esp_135->tFFFFFFFC = g_t413424;
				word32 ecx_907;
				word32 edx_908;
				fn00403220(esp_135->tFFFFFFFC, esp_135->t0000, out ecx_907, out edx_908);
			}
			struct Eq_25031 * eax_164 = mbsinc(ebx_114);
			ptr32 esp_169 = esp_163 + 0x04;
			struct Eq_25031 * ebx_170 = eax_164;
			if (edi_100 == 0x00 && eax_164->b0000 == 0x5E)
			{
				struct Eq_25031 * eax_179 = mbsinc(eax_164);
				byte cl_184 = eax_179->b0000;
				word24 ecx_24_8_236 = SLICE(ecx_180, word24, 8);
				esp_169 = &esp_178->dw0000 + 1;
				ebx_170 = eax_179;
				if ((g_a4149C0[(uint32) cl_184] & 0x01) == 0x00)
				{
					ecx_130 = SEQ(ecx_24_8_236, cl_184);
					if ((esp_178->b0140 & 0x04) != 0x00)
					{
						if (esp_178->t0130 != 0x00)
						{
							ecx_130 = esp_178->t0130;
							*ecx_130 = esp_178->dw0014;
						}
						eax_132 = 0x00;
						goto l0040B49D;
					}
					esp_178->dw0000 = (int32) cl_184;
					Eq_2 ecx_208 = g_t413424;
					esp_178->tFFFFFFFC.u0 = 1001;
					esp_178->tFFFFFFF8 = ecx_208;
					word32 ecx_909;
					word32 edx_910;
					fn00403220(esp_178->tFFFFFFF8, esp_178->tFFFFFFFC, out ecx_909, out edx_910);
					esp_169 = &esp_178->dw0000 + 1;
				}
			}
			byte al_224 = ebx_170->b0000;
			if (al_224 == 0x24)
			{
				struct Eq_25031 ** esp_637 = esp_169 - 4;
				*esp_637 = (struct Eq_25031 **) ebx_170;
				esp_113 = (struct Eq_24928 *) ((char *) esp_637 + 4);
				ebx_170 = fn0040B5D0(*esp_637, out ecx_130);
				goto l0040B477;
			}
			if (al_224 == 0x28)
			{
				struct Eq_25208 * esp_293 = esp_169 - 4;
				esp_293->ptr0000 = esp_169 + 28;
				esp_293->ptrFFFFFFFC = (struct Eq_25217 *) (ebx_170 + 1);
				ebx_170 = fn0040B520(esp_293->ptrFFFFFFFC, esp_293->ptr0000);
				esp_113 = esp_311 + 0x08;
				if (mbschr(4279244, (int32) esp_293->b0020) != 0x00)
					goto l0040B477;
				goto l0040B2DB;
			}
			esp_113 = (struct Eq_24928 *) ((char *) &esp_242->t0004 + 4);
			if (mbschr(4279244, (int32) al_224) == 0x00)
			{
				if ((g_a4149C0[(uint32) ebx_170->b0000] & 0x01) == 0x00)
				{
					if ((esp_242->b0144 & 0x04) != 0x00)
					{
						if (esp_242->t0134 != 0x00)
						{
							ecx_130 = esp_242->t0134;
							*ecx_130 = esp_242->dw0018;
						}
						eax_132 = 0x00;
						goto l0040B49D;
					}
					esp_242->t0004.u0 = 1002;
					esp_242->t0000 = g_t413424;
					word32 edx_912;
					word32 ecx_911;
					fn00403220(esp_242->t0000, esp_242->t0004, out ecx_911, out edx_912);
				}
				byte al_286 = ebx_170->b0000;
				esp_242->b0025 = 0x00;
				esp_242->b0024 = al_286;
				esp_113 = (struct Eq_24928 *) ((char *) &esp_242->t0004 + 4);
l0040B2DB:
				Eq_2 esi_336;
				if (esp_113->t0128 != 0x00)
				{
					word32 ecx_915;
					esi_336 = fn0040AD20(out ecx_915);
				}
				else
				{
					esp_113->dw0014 = 0x00;
					struct Eq_25311 * esp_326 = esp_113 - 4;
					esp_326->t0000.u0 = 4279276;
					word32 edx_914;
					word32 ecx_913;
					esp_326->t001C = fn0040ADD0(esp_326->t0000, out ecx_913, out edx_914);
					esi_336 = (char *) &esp_326->t0000 + 24;
				}
				struct Eq_25336 * esp_348 = esp_113 - 4;
				esp_348->t0000 = &esp_113->dw0014 + 2;
				Eq_2 eax_350 = fn00407B70(esp_348->t0000, out ecx_130);
				struct Eq_24928 * esp_357 = (char *) &esp_348->t0000 + 4;
				if (eax_350 != 0x00)
				{
					if (esp_348->dw0134 != 0x00)
					{
						esp_357 = (struct Eq_24928 *) ((char *) &esp_379->t0004 + 4);
						ecx_130 = ecx_381;
						if (mbscmp(esp_348->dw0134, (char *) &esp_348->t0000 + 32) != 0x00)
							goto l0040B37E;
						struct Eq_25387 * eax_427 = *((word32) eax_350 + 8);
						for (ecx_130 = esp_379->t013C; esp_379->t0140 != ecx_130; --ecx_130)
						{
							if (eax_427 == null)
								goto l0040B36F;
							eax_427 = eax_427->ptr0000;
						}
						if (eax_427 != null)
							*((word32) esi_336 + 4) = eax_427->t0004;
						else
						{
l0040B36F:
							esp_379->t0004.u0 = 4272224;
							word32 edx_916;
							*((word32) esi_336 + 4) = fn0040ADD0(esp_379->t0004, out ecx_130, out edx_916);
							esp_357 = (struct Eq_24928 *) ((char *) &esp_379->t0004 + 4);
						}
					}
					else
					{
l0040B37E:
						if ((*((word32) eax_350 + 0x0C) & 0x01) != 0x00)
						{
							if ((esp_357->b013C & 0x04) != 0x00)
							{
								if (esp_357->t012C != 0x00)
								{
									ecx_130 = esp_357->t012C;
									*ecx_130 = esp_357->t0010;
								}
								eax_132 = 0x00;
								goto l0040B49D;
							}
							Eq_2 ecx_411 = g_t413424;
							struct Eq_25467 * esp_412 = esp_357 - 4;
							esp_412->ptr0000 = &esp_357->dw0014 + 2;
							esp_412->tFFFFFFFC.u0 = 1070;
							esp_412->tFFFFFFF8 = ecx_411;
							word32 edx_917;
							fn00403220(esp_412->tFFFFFFF8, esp_412->tFFFFFFFC, out ecx_130, out edx_917);
							esp_357 = (struct Eq_24928 *) (&esp_412->ptr0000 + 1);
						}
						else
						{
							ecx_130 = *((word32) *((word32) eax_350 + 8) + 4);
							*((word32) esi_336 + 4) = ecx_130;
						}
					}
				}
				if (esp_357->t0128 != 0x00)
				{
					if (eax_350 == 0x00 || (*((word32) eax_350 + 0x0C) & 0x10) != 0x00)
					{
						union Eq_2 * esp_480 = esp_357 - 4;
						*esp_480 = (union Eq_2 *) 4272224;
						word32 edx_918;
						*((word32) esi_336 + 4) = fn0040ADD0(*esp_480, out ecx_130, out edx_918);
					}
					Eq_2 eax_498;
					*esi_336 = 0x00;
					if (esp_357->t0010 != 0x00)
						eax_498 = esp_357->t0010;
					else
						eax_498 = esp_357->t0128;
					*eax_498 = esi_336;
					esp_357->t0010 = esi_336;
				}
				esp_113 = esp_357;
				if (eax_350 == 0x00)
					goto l0040B477;
				word32 eax_552 = mbschr(*((word32) esi_336 + 4), 0x24);
				word24 eax_24_8_590 = SLICE(eax_552, word24, 8);
				esp_113 = (struct Eq_24928 *) ((char *) esp_551 + 8);
				ecx_130 = ecx_553;
				if (eax_552 == 0x00)
					goto l0040B477;
				word32 ecx_584;
				*((word32) eax_350 + 0x0C) |= 0x01;
				if (esp_551->dw0138 != 0x00)
				{
					word32 eax_573 = mbscmp(esp_551->dw0138, (char *) esp_551 + 36);
					eax_24_8_590 = SLICE(eax_573, word24, 8);
					esp_113 = (struct Eq_24928 *) ((char *) esp_572 + 8);
					if (eax_573 == 0x00)
						goto l0040B43F;
					ecx_584 = esp_572->dw013C;
				}
				else
				{
l0040B43F:
					ecx_584 = esp_113->dw0138;
				}
				struct Eq_25607 * esp_589 = esp_113 - 4;
				esp_589->dw0000 = SEQ(eax_24_8_590, esp_113->b013C);
				esp_589->dwFFFFFFFC = ecx_584;
				esp_589->dwFFFFFFF8 = esp_589->dw0138 + 0x01;
				esp_589->ptrFFFFFFF4 = &esp_589->dw0000 + 8;
				word32 eax_608 = esp_589->dw012C;
				esp_589->ptrFFFFFFF0 = &esp_589->dw0000 + 5;
				esp_589->dwFFFFFFEC = eax_608;
				Eq_2 ecx_615 = *((word32) esi_336 + 4);
				esp_589->tFFFFFFE8 = ecx_615;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg276 = <invalid>;
				Eq_2 stackArg280 = <invalid>;
				Eq_2 stackArg284 = <invalid>;
				word32 ebp_923;
				word32 esi_924;
				word32 edi_925;
				word32 ebx_922;
				fn0040B110(ecx_615, stackArg276, stackArg280, stackArg284, out ecx_130, out ebx_922, out ebp_923, out esi_924, out edi_925);
				*((word32) eax_350 + 0x0C) &= ~0x01;
				esp_113 = (struct Eq_24928 *) (&esp_589->dw0000 + 1);
			}
l0040B477:
			ebx_114 = ebx_170 + 1;
		} while (*ebx_114 != 0x00);
	}
	if (esp_113->t012C != 0x00)
	{
		ecx_130 = esp_113->t012C;
		*ecx_130 = esp_113->t0010;
	}
	eax_132 = 0x01;
l0040B49D:
	ecxOut = ecx_130;
	ebxOut = dwLoc0114;
	ebpOut = dwLoc0120;
	esiOut = dwLoc0118;
	ediOut = dwLoc011C;
	return eax_132;
}

// 0040B520: Register (ptr32 Eq_25217) fn0040B520(Stack (ptr32 Eq_25217) dwArg04, Stack (ptr32 byte) dwArg08)
// Called from:
//      fn0040B110
struct Eq_25217 * fn0040B520(struct Eq_25217 * dwArg04, byte * dwArg08)
{
	struct Eq_25217 * esi_10 = dwArg04;
	byte * edi_110 = dwArg08;
	if (dwArg04->b0000 != 0x00)
	{
		do
		{
			byte al_24 = esi_10->b0000;
			if (al_24 == 0x29 || al_24 == 0x3A)
				break;
			if (al_24 == 0x5E)
			{
				++esi_10;
				if ((g_a4149C0[(uint32) esi_10[1]] & 0x01) == 0x00)
				{
					word32 edx_239;
					word32 ecx_238;
					fn00403220(g_t413424, 1001, out ecx_238, out edx_239);
				}
			}
			*edi_110 = esi_10->b0000;
			++esi_10;
			++edi_110;
		} while (esi_10->b0000 != 0x00);
	}
	if (esi_10->b0000 != 0x29)
	{
		do
		{
			if (esi_10->b0000 == 0x5E)
				++esi_10;
			if (esi_10->b0000 == 0x00)
				break;
			++esi_10;
		} while (esi_10->b0000 != 0x29);
		if (esi_10->b0000 != 0x29)
		{
			word32 ecx_240;
			word32 edx_241;
			fn00403220(g_t413424, 1000, out ecx_240, out edx_241);
		}
	}
	*edi_110 = 0x00;
	if (edi_110 - dwArg08 > 0x0101)
	{
		word32 edx_243;
		word32 ecx_242;
		fn00403220(g_t413424, 0x0434, out ecx_242, out edx_243);
	}
	return esi_10;
}

// 0040B5D0: Register (ptr32 Eq_25031) fn0040B5D0(Stack (ptr32 Eq_25031) dwArg04, Register out (ptr32 Eq_25185) ecxOut)
// Called from:
//      fn0040B110
struct Eq_25031 * fn0040B5D0(struct Eq_25031 * dwArg04, struct Eq_25185 & ecxOut)
{
	struct Eq_25185 * ecx;
	word24 ecx_24_8 = SLICE(ecx, word24, 8);
	struct Eq_25031 * eax_107 = dwArg04 + 1;
	byte dl_12 = dwArg04[1];
	struct Eq_25185 * ecx_146 = ecx;
	if (dl_12 != 0x5E)
	{
		ecx_146 = ecx;
		if (dl_12 != 0x28)
		{
l0040B61C:
			eax_107 = dwArg04;
			goto l0040B61E;
		}
		byte cl_18 = dwArg04[2];
		struct Eq_25185 * ecx_145 = SEQ(ecx_24_8, cl_18);
		if (cl_18 == 0x5E)
		{
			ecxOut = ecx_145;
			return dwArg04 + 2;
		}
		ecx_146 = SEQ(ecx_24_8, cl_18);
		if (cl_18 == 0x40)
		{
			byte al_30 = dwArg04[3];
			if (al_30 == 0x5E)
			{
				word32 edx_210;
				fn00403220(g_t413424, 1001, out ecx_146, out edx_210);
			}
			else
			{
				if (al_30 == 0x29)
				{
					ecxOut = ecx_146;
					return dwArg04 + 3;
				}
				if (mbschr(0x00414BD4, (int32) al_30) != 0x00)
				{
					byte al_51 = dwArg04[4];
					if (al_51 == 0x5E)
					{
						struct Eq_25185 * ecx_71;
						word32 edx_211;
						fn00403220(g_t413424, 1001, out ecx_71, out edx_211);
						ecxOut = ecx_71;
						return dwArg04;
					}
					if (al_51 == 0x29)
					{
						ecxOut = ecx_146;
						return dwArg04 + 4;
					}
				}
			}
			goto l0040B61C;
		}
		if (dl_12 != 0x5E)
		{
			ecxOut = ecx_146;
			return dwArg04 + 2;
		}
	}
l0040B61E:
	ecxOut = ecx_146;
	return eax_107;
}

// 0040B690: Register Eq_2 fn0040B690(Register Eq_2 ecx, Stack Eq_2 dwArg04, Stack Eq_2 dwArgE8, Stack Eq_2 dwArgEC, Stack Eq_2 dwArgF0, Register out ptr32 ebxOut, Register out (ptr32 Eq_1515) ebpOut)
// Called from:
//      fn004019F0
//      fn00404F80
//      fn00407680
Eq_2 fn0040B690(Eq_2 ecx, Eq_2 dwArg04, Eq_2 dwArgE8, Eq_2 dwArgEC, Eq_2 dwArgF0, ptr32 & ebxOut, struct Eq_1515 & ebpOut)
{
	ptr32 fp;
	struct Eq_1515 * ebp;
	ptr32 ebx;
	Eq_2 esi_13 = dwArg04;
	if (mbschr(dwArg04, 0x24) != 0x00)
	{
		Eq_2 esi_47;
		word32 ecx_148;
		word32 edi_149;
		fn0040B110(ecx, dwArgE8, dwArgEC, dwArgF0, out ecx_148, out ebx, out ebp, out esi_47, out edi_149);
		word32 edx_150;
		fn0040B700(esi_47, fp - 0x04, out edx_150);
		Eq_2 edi_54 = 0x00;
		esi_13 = fp - 0x04;
		Eq_2 dwLoc04_138 = 0x00;
		if (false)
		{
			do
			{
				edi_54 = *edi_54;
				fn0040ADA0(dwLoc04_138);
				dwLoc04_138 = edi_54;
			} while (edi_54 != 0x00);
		}
	}
	ebxOut = ebx;
	ebpOut = ebp;
	return esi_13;
}

// 0040B700: Register Eq_2 fn0040B700(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out ptr32 edxOut)
// Called from:
//      fn004013D0
//      fn00401870
//      fn00401D00
//      fn00402870
//      fn004036C0
//      fn004048B0
//      fn00406020
//      fn00408D80
//      fn0040B690
//      fn0040B700
Eq_2 fn0040B700(Eq_2 dwArg04, Eq_2 dwArg08, ptr32 & edxOut)
{
	struct Eq_25901 * fp;
	up32 ebx_102 = 0x00;
	struct Eq_25904 * esp_19 = fp - 0x0420;
	word32 ebp_175 = 0x00;
	if (*dwArg04 != 0x00)
	{
		do
		{
			if (*esp_19[265] != 0x00)
			{
				while (*esp_19[265] != 0x24)
				{
					if (esp_19[5] == esp_19[4])
					{
						struct Eq_25948 * esp_46 = esp_19 - 4;
						esp_46->t0000 = esp_19 + 8;
						esp_46->tFFFFFFFC = esp_19 + 7;
						esp_46->tFFFFFFF8 = esp_19 + 5;
						esp_46->tFFFFFFF4 = (char *) &esp_46->t0000 + 20;
						esp_46->tFFFFFFF0 = (char *) &esp_46->t0000 + 28;
						fn0040BB00(esp_46->tFFFFFFF0, esp_46->tFFFFFFF4, esp_46->tFFFFFFF8, esp_46->tFFFFFFFC, esp_46->t0000);
					}
					byte al_69 = *esp_19[265];
					if (al_69 == 0x22)
						ebx_102 = (word32) (ebx_102 < 0x01);
					if (ebx_102 == 0x00 && al_69 == 0x5E)
					{
						*esp_19[4] = (struct Eq_25904) 0x5E;
						esp_19[4] = (struct Eq_25904) ((word32) esp_19[4] + 1);
						esp_19[265] = (struct Eq_25904) ((word32) esp_19[265] + 1);
						if (*esp_19[265] == 0x22)
							ebx_102 = (word32) (ebx_102 < 0x01);
					}
					*esp_19[4] = *esp_19[265];
					esp_19[265] = (struct Eq_25904) ((word32) esp_19[265] + 1);
					esp_19[4] = (struct Eq_25904) ((word32) esp_19[4] + 1);
					if (*esp_19[265] == 0x00)
						break;
				}
			}
			if (esp_19[5] == esp_19[4])
			{
				struct Eq_26157 * esp_125 = esp_19 - 4;
				esp_125->t0000 = esp_19 + 8;
				esp_125->tFFFFFFFC = esp_19 + 7;
				esp_125->tFFFFFFF8 = esp_19 + 5;
				esp_125->tFFFFFFF4 = (char *) &esp_125->t0000 + 20;
				esp_125->tFFFFFFF0 = (char *) &esp_125->t0000 + 28;
				fn0040BB00(esp_125->tFFFFFFF0, esp_125->tFFFFFFF4, esp_125->tFFFFFFF8, esp_125->tFFFFFFFC, esp_125->t0000);
			}
			struct Eq_25904 * esp_145 = esp_19;
			struct Eq_26148 * eax_147 = esp_19[265];
			if (eax_147->b0000 == 0x00)
				break;
			if (eax_147->b0001 == 0x28)
			{
				esp_145 = (struct Eq_25904 *) ((char *) &esp_183->t0004 + 4);
				if (mbschr(4279244, (int32) eax_147->b0002) == 0x00)
					goto l0040B87A;
				esp_183->t0004 = (char *) &esp_183->t0004 + 36;
				esp_183->t0000.u0 = 0x03;
				esp_183->tFFFFFFFC = (char *) &esp_183->t0004 + 32;
				esp_183->tFFFFFFF8 = (char *) &esp_183->t0004 + 24;
				esp_183->tFFFFFFF4 = (char *) &esp_183->t0004 + 20;
				esp_183->ptrFFFFFFF0 = (struct Eq_27019 **) ((char *) &esp_183->t0004 + 0x0428);
				esp_183->tFFFFFFEC = (char *) &esp_183->t0004 + 28;
				fn0040BB90(esp_183->tFFFFFFEC, esp_183->ptrFFFFFFF0, esp_183->tFFFFFFF4, esp_183->tFFFFFFF8, esp_183->tFFFFFFFC, esp_183->t0000, esp_183->t0004);
				esp_19 = (struct Eq_25904 *) ((char *) &esp_183->t0004 + 4);
				goto l0040BA6A;
			}
l0040B87A:
			struct Eq_26207 * edi_195 = &eax_147->b0002;
			if (eax_147->b0001 == 0x24)
			{
				byte al_346 = eax_147->b0002;
				if (al_346 == 0x5E)
				{
					struct Eq_26330 * esp_493 = esp_145 - 4;
					esp_493->t0000 = esp_145 + 8;
					esp_493->tFFFFFFFC.u0 = 0x05;
					esp_493->tFFFFFFF8 = esp_145 + 7;
					esp_493->tFFFFFFF4 = esp_145 + 5;
					esp_493->tFFFFFFF0 = (char *) &esp_493->t0000 + 20;
					esp_493->ptrFFFFFFEC = (struct Eq_27019 **) ((char *) &esp_493->t0000 + 0x0428);
					esp_493->tFFFFFFE8 = (char *) &esp_493->t0000 + 28;
					fn0040BB90(esp_493->tFFFFFFE8, esp_493->ptrFFFFFFEC, esp_493->tFFFFFFF0, esp_493->tFFFFFFF4, esp_493->tFFFFFFF8, esp_493->tFFFFFFFC, esp_493->t0000);
					esp_19 = (struct Eq_25904 *) ((char *) &esp_493->t0000 + 4);
					goto l0040BA6A;
				}
				if (al_346 == 0x40)
				{
					struct Eq_26394 * esp_465 = esp_145 - 4;
					esp_465->t0000 = esp_145 + 8;
					esp_465->tFFFFFFFC.u0 = 0x02;
					esp_465->tFFFFFFF8 = esp_145 + 7;
					esp_465->tFFFFFFF4 = esp_145 + 5;
					esp_465->tFFFFFFF0 = (char *) &esp_465->t0000 + 20;
					esp_465->ptrFFFFFFEC = (struct Eq_27019 **) ((char *) &esp_465->t0000 + 0x0428);
					esp_465->tFFFFFFE8 = (char *) &esp_465->t0000 + 28;
					fn0040BB90(esp_465->tFFFFFFE8, esp_465->ptrFFFFFFEC, esp_465->tFFFFFFF0, esp_465->tFFFFFFF4, esp_465->tFFFFFFF8, esp_465->tFFFFFFFC, esp_465->t0000);
					esp_19 = (struct Eq_25904 *) ((char *) &esp_465->t0000 + 4);
					goto l0040BA6A;
				}
				if (al_346 == 0x28)
				{
					byte al_353 = eax_147->b0003;
					edi_195 = (struct Eq_26207 *) &eax_147->b0003;
					if (al_353 != 0x40 || al_353 != 0x29)
						goto l0040B927;
					struct Eq_26540 * esp_437 = esp_145 - 4;
					esp_437->t0000 = esp_145 + 8;
					esp_437->tFFFFFFFC.u0 = 0x02;
					esp_437->tFFFFFFF8 = esp_145 + 7;
					esp_437->tFFFFFFF4 = esp_145 + 5;
					esp_437->tFFFFFFF0 = (char *) &esp_437->t0000 + 20;
					esp_437->ptrFFFFFFEC = (struct Eq_27019 **) ((char *) &esp_437->t0000 + 0x0428);
					esp_437->tFFFFFFE8 = (char *) &esp_437->t0000 + 28;
					fn0040BB90(esp_437->tFFFFFFE8, esp_437->ptrFFFFFFEC, esp_437->tFFFFFFF0, esp_437->tFFFFFFF4, esp_437->tFFFFFFF8, esp_437->tFFFFFFFC, esp_437->t0000);
					esp_19 = (struct Eq_25904 *) ((char *) &esp_437->t0000 + 4);
				}
				else
				{
l0040B927:
					byte al_361 = edi_195->b0001;
					struct Eq_26525 * edi_362 = &edi_195->b0001;
					if (al_361 != 0x46 && (al_361 != 0x44 && (al_361 != 66 && al_361 != 0x52)) || edi_362->b0001 != 0x29)
					{
						struct Eq_26613 * esp_381 = esp_145 - 4;
						esp_381->t0000 = esp_145 + 8;
						esp_381->tFFFFFFFC.u0 = 0x05;
						esp_381->tFFFFFFF8 = esp_145 + 7;
						esp_381->tFFFFFFF4 = esp_145 + 5;
						esp_381->tFFFFFFF0 = (char *) &esp_381->t0000 + 20;
						esp_381->ptrFFFFFFEC = (struct Eq_27019 **) ((char *) &esp_381->t0000 + 0x0428);
						esp_381->tFFFFFFE8 = (char *) &esp_381->t0000 + 28;
						fn0040BB90(esp_381->tFFFFFFE8, esp_381->ptrFFFFFFEC, esp_381->tFFFFFFF0, esp_381->tFFFFFFF4, esp_381->tFFFFFFF8, esp_381->tFFFFFFFC, esp_381->t0000);
						esp_19 = (struct Eq_25904 *) ((char *) &esp_381->t0000 + 4);
					}
					else
					{
						struct Eq_26675 * esp_409 = esp_145 - 4;
						esp_409->t0000 = esp_145 + 8;
						esp_409->tFFFFFFFC.u0 = 0x04;
						esp_409->tFFFFFFF8 = esp_145 + 7;
						esp_409->tFFFFFFF4 = esp_145 + 5;
						esp_409->tFFFFFFF0 = (char *) &esp_409->t0000 + 20;
						esp_409->ptrFFFFFFEC = (struct Eq_27019 **) ((char *) &esp_409->t0000 + 0x0428);
						esp_409->tFFFFFFE8 = (char *) &esp_409->t0000 + 28;
						fn0040BB90(esp_409->tFFFFFFE8, esp_409->ptrFFFFFFEC, esp_409->tFFFFFFF0, esp_409->tFFFFFFF4, esp_409->tFFFFFFF8, esp_409->tFFFFFFFC, esp_409->t0000);
						esp_19 = (struct Eq_25904 *) ((char *) &esp_409->t0000 + 4);
					}
				}
			}
			else if (mbschr(4279244, (int32) *((word32) esp_145[265] + 1)) != 0x00)
			{
				esp_210->t0004 = (char *) &esp_210->t0004 + 36;
				esp_210->t0000.u0 = 0x01;
				esp_210->tFFFFFFFC = (char *) &esp_210->t0004 + 32;
				esp_210->tFFFFFFF8 = (char *) &esp_210->t0004 + 24;
				esp_210->tFFFFFFF4 = (char *) &esp_210->t0004 + 20;
				esp_210->ptrFFFFFFF0 = (struct Eq_27019 **) ((char *) &esp_210->t0004 + 0x0428);
				esp_210->tFFFFFFEC = (char *) &esp_210->t0004 + 28;
				fn0040BB90(esp_210->tFFFFFFEC, esp_210->ptrFFFFFFF0, esp_210->tFFFFFFF4, esp_210->tFFFFFFF8, esp_210->tFFFFFFFC, esp_210->t0000, esp_210->t0004);
				esp_19 = (struct Eq_25904 *) ((char *) &esp_210->t0004 + 4);
			}
			else
			{
				if (*dwArg08 == 0x00)
				{
					esp_210->t0004.u0 = 0x0410;
					esp_210->t0000 = g_t413424;
					word32 ecx_852;
					word32 edx_853;
					fn00403220(esp_210->t0000, esp_210->t0004, out ecx_852, out edx_853);
				}
				Eq_2 edi_260;
				word32 eax_250 = mbschr(*((word32) *dwArg08 + 4), 0x24);
				Eq_2 eax_258 = *dwArg08;
				if (eax_250 != 0x00)
				{
					Eq_2 ecx_263 = *eax_258;
					esp_249->t0004 = dwArg08;
					*dwArg08 = ecx_263;
					esp_249->t0000 = *((word32) eax_258 + 4);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					Eq_2 stackArg8 = <invalid>;
					ebp_175 = 0x01;
					word32 edx_856;
					edi_260 = fn0040B700(stackArg4, stackArg8, out edx_856);
				}
				else
				{
					edi_260 = *((word32) eax_258 + 4);
					*dwArg08 = *eax_258;
				}
				esp_249->t0004 = (char *) &esp_249->t0004 + 36;
				esp_249->t0000 = (char *) &esp_249->t0004 + 32;
				esp_249->tFFFFFFFC = edi_260;
				esp_249->tFFFFFFF8 = (char *) &esp_249->t0004 + 24;
				esp_249->tFFFFFFF4 = (char *) &esp_249->t0004 + 20;
				esp_249->ptrFFFFFFF0 = (struct Eq_27019 **) ((char *) &esp_249->t0004 + 0x0428);
				esp_249->tFFFFFFEC = (char *) &esp_249->t0004 + 28;
				fn0040C060(esp_249->tFFFFFFEC, esp_249->ptrFFFFFFF0, esp_249->tFFFFFFF4, esp_249->tFFFFFFF8, esp_249->tFFFFFFFC, esp_249->t0000, esp_249->t0004);
				esp_19 = (struct Eq_25904 *) ((char *) &esp_249->t0004 + 4);
				if (ebp_175 != 0x00)
				{
					esp_249->t0004 = edi_260;
					free(esp_249->t0004);
					ebp_175 = 0x00;
					esp_19 = (struct Eq_25904 *) ((char *) &esp_249->t0004 + 4);
				}
			}
l0040BA6A:
		} while (*esp_19[265] != 0x00);
	}
	if (fp == fp - (struct Eq_30143 *) 0x0400)
		fn0040BB00(fp - (struct Eq_30151 *) 0x0408, fp - (struct Eq_30153 *) 1040, fp - (struct Eq_30155 *) 0x040C, fp - (struct Eq_30157 *) 0x0404, fp - (struct Eq_30159 *) 0x0400);
	Eq_2 eax_586 = fp - (struct Eq_30147 *) 0x03FF - (fp - (struct Eq_30143 *) 0x0400);
	ptr32 edx_591 = fn0040ACC0(eax_586);
	if (eax_586 == 0x00)
	{
		word32 ecx_851;
		fn00403220(g_t413424, 0x0419, out ecx_851, out edx_591);
	}
	struct Eq_26021 * eax_620 = fp - (struct Eq_30147 *) 0x03FF - (fp - (struct Eq_30143 *) 0x0400);
	Eq_2 edi_619 = eax_586;
	Eq_26026 esi_621 = fp - (struct Eq_30143 *) 0x0400;
	uint32 ecx_623;
	for (ecx_623 = eax_620 >> 0x02; ecx_623 != 0x00; --ecx_623)
	{
		*edi_619 = *esi_621;
		esi_621 += 4;
		edi_619 = (word32) edi_619 + 4;
	}
	ui32 ecx_632;
	for (ecx_632 = eax_620 & 0x03; ecx_632 != 0x00; --ecx_632)
	{
		*edi_619 = *esi_621;
		++esi_621;
		edi_619 = (word32) edi_619 + 1;
	}
	edxOut = edx_591;
	return eax_586;
}

// 0040BB00: void fn0040BB00(Stack Eq_25972 dwArg04, Stack Eq_25967 dwArg08, Stack Eq_25962 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14)
// Called from:
//      fn0040B700
//      fn0040BB90
//      fn0040C060
//      fn0040C170
void fn0040BB00(Eq_25972 dwArg04, Eq_25967 dwArg08, Eq_25962 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14)
{
	if (*dwArg04 == dwArg14)
	{
		Eq_2 eax_22 = *dwArg10;
		fn0040ACC0(eax_22);
		Eq_2 edx_32 = *dwArg10;
		Eq_2 edi_107 = eax_22;
		Eq_2 esi_104 = *dwArg04;
		uint32 ecx_119;
		for (ecx_119 = edx_32 >> 0x02; ecx_119 != 0x00; --ecx_119)
		{
			*edi_107 = *esi_104;
			esi_104 = (word32) esi_104 + 4;
			edi_107 = (word32) edi_107 + 4;
		}
		ui32 ecx_111;
		for (ecx_111 = edx_32 & 0x03; ecx_111 != 0x00; --ecx_111)
		{
			*edi_107 = *esi_104;
			esi_104 = (word32) esi_104 + 1;
			edi_107 = (word32) edi_107 + 1;
		}
		*dwArg04 = eax_22;
	}
	Eq_2 esi_51 = *dwArg10;
	Eq_2 eax_61 = realloc(*dwArg04, (word32) esi_51 + 0x0400);
	*dwArg04 = eax_61;
	if (eax_61 == 0x00)
	{
		word32 ecx_174;
		word32 edx_175;
		fn00403220(g_t413424, 0x0419, out ecx_174, out edx_175);
	}
	Mem88[dwArg08 + 0x00:word32] = Mem82[dwArg10 + 0x00:word32] + Mem82[dwArg04 + 0x00:word32];
	*dwArg10 = (word32) esi_51 + 0x0400;
	*dwArg0C = (word32) *dwArg04 + ((word32) esi_51 + 0x0400);
}

// 0040BB90: void fn0040BB90(Stack Eq_25972 dwArg04, Stack (ptr32 (ptr32 Eq_27019)) dwArg08, Stack Eq_25967 dwArg0C, Stack Eq_25962 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C)
// Called from:
//      fn0040B700
void fn0040BB90(Eq_25972 dwArg04, struct Eq_27019 ** dwArg08, Eq_25967 dwArg0C, Eq_25962 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C)
{
	ptr32 fp;
	Eq_2 tLoc0118;
	Eq_2 tLoc0114;
	Eq_2 tLoc0110;
	word32 tLoc0108;
	Eq_26994 tLoc0104;
	tLoc0118.u0 = 0x00;
	tLoc0108 = 0x00;
	word32 esi_105 = 0x00;
	int32 edi_100 = 0x01;
	word32 dwLoc010C_518 = 0x00;
	if (dwArg18 > 0x05)
		return;
	Eq_2 eax_104;
	switch (dwArg18)
	{
	case 0x01:
		goto l0040BBD2;
	case 0x02:
		break;
	case 0x03:
		dwLoc010C_518 = 0x01;
		edi_100 = 0x02;
l0040BBD2:
		struct Eq_27016 * ecx_78 = (char *) *dwArg08 + edi_100;
		Eq_27021 eax_79 = (int32) ecx_78->b0000;
		eax_104 = eax_79 - 0x2A;
		if (eax_79 <= 0x40)
		{
			switch (eax_79)
			{
			case 0x2A:
				if (ecx_78->b0001 != 0x2A)
				{
					eax_104 = g_t413A8C;
					tLoc0108 = 0x01;
					tLoc0118 = eax_104;
					++edi_100;
				}
				else
				{
					eax_104 = g_t413A98;
					tLoc0118 = eax_104;
					esi_105 = 0x01;
					edi_100 += 0x02;
				}
				break;
			case 0x2B:
			case 44:
			case 0x2D:
			case 0x2E:
			case 0x2F:
			case 0x30:
			case 0x31:
			case 0x32:
			case 0x33:
			case 0x34:
			case 0x35:
			case 0x36:
			case 55:
			case 0x38:
			case 0x39:
			case 0x3A:
			case 0x3B:
			case 0x3D:
			case 0x3E:
				goto l0040BE20;
			case 0x3C:
				eax_104 = g_t413A88;
				tLoc0118 = eax_104;
				++edi_100;
				break;
			case 0x3F:
				eax_104 = g_t413A94;
				tLoc0118 = eax_104;
				esi_105 = 0x01;
				++edi_100;
				break;
			case 0x40:
				eax_104 = g_t413A90;
				tLoc0118 = eax_104;
				goto l0040BE20;
			}
		}
		else
		{
l0040BE20:
			++edi_100;
		}
		goto l0040BC19;
	case 0x04:
		dwLoc010C_518 = 0x01;
		edi_100 = 0x04;
		break;
	case 0x05:
		if (*dwArg10 == *dwArg0C)
			fn0040BB00(dwArg04, dwArg0C, dwArg10, dwArg14, dwArg1C);
		**dwArg0C = 0x24;
		*dwArg0C = (word32) *dwArg0C + 1;
		*dwArg08 = (struct Eq_27019 **) ((char *) *dwArg08 + 2);
		return;
	}
	eax_104 = g_t413A84;
	tLoc0118 = eax_104;
l0040BC19:
	if (tLoc0118 == 0x00)
	{
		struct Eq_27019 * esi_124 = *dwArg08;
		while (esi_124->a0000[0] != 0x00)
		{
			byte al_129 = esi_124->a0000[0];
			if (al_129 == 0x20 || al_129 == 0x09)
				break;
			++esi_124;
		}
		byte bl_139 = esi_124->a0000[0];
		esi_124->a0000[0] = 0x00;
		word32 edx_810;
		word32 ecx_809;
		fn00403220(g_t413424, 4006, out ecx_809, out edx_810);
		esi_124->a0000[0] = bl_139;
		word32 ecx_811;
		word32 edx_812;
		eax_104 = fn0040ADD0(4272224, out ecx_811, out edx_812);
		tLoc0118 = eax_104;
		esi_105 = 0x00;
	}
	Eq_2 eax_229;
	if (esi_105 != 0x00)
	{
		Eq_2 esi_237 = tLoc0118;
		tLoc0108 = 0x0400;
		fn0040ACF0(eax_104, 0x0400);
		tLoc0110 = eax_104;
		tLoc0114 = (word32) eax_104 + 0x0400;
		tLoc0118 = tLoc0110;
		while (esi_237 != 0x00)
		{
			Eq_2 ebx_263 = *((word32) esi_237 + 4);
			if (dwLoc010C_518 != 0x00)
				ebx_263 = fn0040BF30(*((char *) *dwArg08 + edi_100), &tLoc0104, ebx_263);
			while (*ebx_263 != 0x00)
			{
				if (tLoc0118 == tLoc0114)
					fn0040BB00(&tLoc0110, &tLoc0118, &tLoc0114, &tLoc0108, 0x00);
				*tLoc0118.u0 = *ebx_263;
				tLoc0118 = (byte) tLoc0118.u0 + 1;
				ebx_263 = (word32) ebx_263 + 1;
			}
			if (tLoc0118 == tLoc0114)
				fn0040BB00(&tLoc0110, &tLoc0118, &tLoc0114, &tLoc0108, 0x00);
			*tLoc0118 = 0x00;
			if (*esi_237 != 0x00)
			{
				*tLoc0118 = 0x20;
				Eq_2 ecx_371 = tLoc0114;
				tLoc0118 = (word32) tLoc0118 + 1;
				if (tLoc0118 == ecx_371)
					fn0040BB00(&tLoc0110, &tLoc0118, &tLoc0114, &tLoc0108, 0x00);
				*tLoc0118 = 0x00;
			}
			esi_237 = *esi_237;
		}
		eax_229 = tLoc0110;
	}
	else
	{
		if (tLoc0108 != 0x00)
			tLoc0118 = fn0040BF30(0x52, &tLoc0104, tLoc0118);
		if (dwLoc010C_518 == 0x00)
		{
l0040BE63:
			fn0040C060(dwArg04, dwArg08, dwArg0C, dwArg10, tLoc0118, dwArg14, dwArg1C);
			if (tLoc0118 != g_t413A90)
			{
				Eq_2 eax_459 = tLoc0118;
				if (g_t413A84 != eax_459 && (g_t413A88 != eax_459 && (tLoc0118 < &tLoc0104 || tLoc0118 >= fp - 0x03)))
					free(tLoc0118);
			}
			return;
		}
		eax_229 = fn0040BF30(*((char *) *dwArg08 + edi_100), &tLoc0104, tLoc0118);
	}
	tLoc0118 = eax_229;
	goto l0040BE63;
}

// 0040BF30: Register (ptr32 Eq_27188) fn0040BF30(Stack byte bArg04, Stack (ptr32 Eq_27188) dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      fn0040BB90
struct Eq_27188 * fn0040BF30(byte bArg04, struct Eq_27188 * dwArg08, Eq_2 dwArg0C)
{
	struct Eq_27188 * edx_129 = null;
	word32 ecx_11 = ~0x00;
	struct Eq_27188 * ebp_119 = null;
	Eq_2 edi_19 = dwArg0C;
	while (ecx_11 != 0x00)
	{
		edi_19 = (word32) edi_19 + 1;
		--ecx_11;
		if (*edi_19 != 0x00)
			break;
	}
	uint32 ecx_31 = ~ecx_11;
	uint32 ecx_249;
	struct Eq_27462 * esi_235 = edi_19 - ecx_31;
	struct Eq_27188 * ebx_167 = dwArg08;
	struct Eq_27188 * edi_237 = dwArg08;
	for (ecx_249 = ecx_31 >> 0x02; ecx_249 != 0x00; --ecx_249)
	{
		edi_237->t0000.u1 = esi_235->dw0000;
		esi_235 += 4;
		edi_237 += 4;
	}
	ui32 ecx_241;
	for (ecx_241 = ecx_31 & 0x03; ecx_241 != 0x00; --ecx_241)
	{
		edi_237->t0000.u1 = esi_235->dw0000;
		++esi_235;
		++edi_237;
	}
	struct Eq_27188 * edi_53 = dwArg08;
	word32 ecx_55 = ~0x00;
	word32 esi_59 = (word32) (dwArg08->t0000 < 0x23);
	while (ecx_55 != 0x00)
	{
		edi_53 = edi_389 + 1;
		--ecx_55;
		edi_389 = edi_53;
		if (edi_389->t0000 != 0x00)
			break;
	}
	struct Eq_27188 * ecx_74;
	for (ecx_74 = dwArg08 + (~ecx_55 - 2); ecx_74 >= dwArg08; --ecx_74)
	{
		byte al_79 = ecx_74->t0000;
		if (al_79 == 0x5C || al_79 == 0x2F)
		{
			edx_129 = ecx_74;
			break;
		}
		if (al_79 == 0x2E && ebp_119 == null)
			ebp_119 = ecx_74;
	}
	Eq_27536 eax_110 = (int32) bArg04;
	if (eax_110 <= 0x52)
	{
		switch (eax_110)
		{
		case 66:
			if (ebp_119 != null)
				ebp_119->t0000.u0 = 0x00;
			goto l0040BFBF;
		case 0x43:
		case 0x45:
		case 0x47:
		case 0x48:
		case 0x49:
		case 0x4A:
		case 0x4B:
		case 0x4C:
		case 77:
		case 0x4E:
		case 0x4F:
		case 0x50:
		case 0x51:
			break;
		case 0x44:
			if (edx_129 != null)
			{
				if (dwArg08[1] == 0x3A && dwArg08 - edx_129 == ~0x01)
					++edx_129;
				edx_129->t0000.u0 = 0x00;
			}
			else if (dwArg08[1] == 0x3A)
				dwArg08[2] = (struct Eq_27188) 0x00;
			else
				dwArg08->t0000 = g_t413FE0;
			break;
		case 0x46:
l0040BFBF:
			if (edx_129 != null)
				ebx_167 = edx_129 + 1;
			else if (dwArg08[1] == 0x3A)
				ebx_167 = dwArg08 + 2;
			break;
		case 0x52:
			if (ebp_119 != null)
				ebp_119->t0000.u0 = 0x00;
			break;
		}
	}
	if (esi_59 != 0x00)
	{
		struct Eq_27612 * eax_215 = mbschr(ebx_167, 0x00);
		eax_215->b0000 = 0x22;
		eax_215->b0001 = 0x00;
	}
	return ebx_167;
}

// 0040C060: void fn0040C060(Stack Eq_25972 dwArg04, Stack (ptr32 (ptr32 Eq_27019)) dwArg08, Stack Eq_25967 dwArg0C, Stack Eq_25962 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C)
// Called from:
//      fn0040B700
//      fn0040BB90
void fn0040C060(Eq_25972 dwArg04, struct Eq_27019 ** dwArg08, Eq_25967 dwArg0C, Eq_25962 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C)
{
	ptr32 fp;
	struct Eq_27019 * eax_18 = *dwArg08;
	*dwArg08 = (struct Eq_27019 **) (eax_18 + 1);
	if (eax_18[1] == 0x5E)
		*dwArg08 = (struct Eq_27019 **) (eax_18 + 2);
	struct Eq_27019 * eax_38 = mbschr(*dwArg08, 0x3A);
	struct Eq_27019 * eax_45 = *dwArg08;
	byte dl_46 = eax_45->a0000[0];
	if (dl_46 != 0x00)
	{
		do
		{
			byte cl_52 = eax_45->a0000[0];
			if (cl_52 == 0x29)
				break;
			if (cl_52 == 0x5E)
				++eax_45;
			++eax_45;
		} while (eax_45->a0000[0] != 0x00);
	}
	if (dl_46 != 0x28 || (eax_38 == null || eax_38 >= eax_45))
	{
		Eq_2 ebx_114 = dwArg14;
		if (*dwArg14 != 0x00)
		{
			do
			{
				if (*dwArg10 == *dwArg0C)
					fn0040BB00(dwArg04, dwArg0C, dwArg10, dwArg18, dwArg1C);
				**dwArg0C = *ebx_114;
				*dwArg0C = (word32) *dwArg0C + 1;
				ebx_114 = (word32) ebx_114 + 1;
			} while (*ebx_114 != 0x00);
		}
		struct Eq_27019 * eax_133 = *dwArg08;
		if (eax_133->a0000[0] == 0x24)
			*dwArg08 = (struct Eq_27019 **) (eax_133 + 1);
		struct Eq_27019 * eax_141 = *dwArg08;
		byte cl_142 = eax_141->a0000[0];
		if (cl_142 != 0x28)
		{
			if (cl_142 == 0x2A && eax_141[1] == 0x2A)
				*dwArg08 = (struct Eq_27019 **) (eax_141 + 1);
		}
		else
		{
			do
			{
				struct Eq_27019 * eax_147 = *dwArg08;
				*dwArg08 = (struct Eq_27019 **) (eax_147 + 1);
			} while (eax_147[1] != 0x29);
		}
		*dwArg08 = (struct Eq_27019 **) ((char *) *dwArg08 + 1);
	}
	else
	{
		fn0040C170(fp - 4, dwArg0C, dwArg10, dwArg14);
		*dwArg08 = (struct Eq_27019 **) eax_38;
	}
}

// 0040C170: void fn0040C170(Stack Eq_2 dwArg08, Stack Eq_25967 dwArg0C, Stack Eq_25962 dwArg10, Stack Eq_2 dwArg14)
// Called from:
//      fn0040C060
void fn0040C170(Eq_2 dwArg08, Eq_25967 dwArg0C, Eq_25962 dwArg10, Eq_2 dwArg14)
{
	ptr32 fp;
	Eq_27792 esi_16 = *dwArg08;
	*dwArg08 = (word32) esi_16 + 1;
	Eq_27792 esi_20 = (word32) esi_16 + 1;
	if (*((word32) esi_16 + 1) != 0x00)
	{
		do
		{
			byte al_26 = *esi_20;
			if (al_26 == 0x3D)
				break;
			if (al_26 == 0x5E)
				esi_20 = (word32) esi_20 + 1;
			esi_20 = (word32) esi_20 + 1;
		} while (*esi_20 != 0x00);
	}
	if (*esi_20 != 0x3D)
	{
		word32 ecx_675;
		word32 edx_676;
		fn00403220(g_t4133F4, 1003, out ecx_675, out edx_676);
	}
	if (*dwArg08 == esi_20)
	{
		word32 ecx_677;
		word32 edx_678;
		fn00403220(g_t4133F4, 1005, out ecx_677, out edx_678);
	}
	Eq_27792 ebx_80 = esi_20;
	if (*esi_20 != 0x00)
	{
		do
		{
			byte al_86 = *ebx_80;
			if (al_86 == 0x29)
				break;
			if (al_86 == 0x5E)
				ebx_80 = (word32) ebx_80 + 1;
			ebx_80 = (word32) ebx_80 + 1;
		} while (*ebx_80 != 0x00);
	}
	if (*ebx_80 != 0x29)
	{
		word32 edx_680;
		word32 ecx_679;
		fn00403220(g_t4133F4, 1000, out ecx_679, out edx_680);
	}
	fn0040ACF0(dwArg08, esi_20 - *dwArg08 + 0x01);
	Eq_2 ecx_141 = dwArg08;
	Eq_27792 ebp_144 = *dwArg08;
	while (*ebp_144 != 0x3D)
	{
		if (*ebp_144 == 0x5E)
			ebp_144 = (word32) ebp_144 + 1;
		*ecx_141 = *ebp_144;
		ebp_144 = (word32) ebp_144 + 1;
		ecx_141 = (word32) ecx_141 + 1;
	}
	*ecx_141 = 0x00;
	Eq_2 edi_167 = dwArg08;
	word32 ecx_172 = ~0x00;
	while (ecx_172 != 0x00)
	{
		edi_167 = (word32) edi_681 + 1;
		--ecx_172;
		edi_681 = edi_167;
		if (*edi_681 != 0x00)
			break;
	}
	Eq_2 eax_228;
	Eq_2 eax_203 = ebx_80 - esi_20;
	fn0040ACF0(eax_203, eax_203);
	byte * ebp_187 = (word32) ebp_144 + 1;
	struct Eq_27943 * esp_213 = fp - 0x1C;
	eax_228 = eax_203;
	eax_228 = eax_203;
	while (*ebp_187 != 0x29)
	{
		if (*ebp_187 == 0x5E)
			++ebp_187;
		*eax_228 = *ebp_187;
		++ebp_187;
		eax_228 = (word32) eax_228 + 1;
	}
	*eax_228 = 0x00;
	*dwArg08 = (word32) ebx_80 + 1;
	Eq_2 ebp_243 = dwArg14;
	if (*dwArg14 != 0x00)
	{
		do
		{
			byte * ecx_253 = esp_213->ptr0010;
			if (*ecx_253 == *ebp_243)
			{
				esp_213 = (struct Eq_27943 *) ((char *) &esp_267->t0008 + 4);
				if (mbsnbcmp(ebp_243, ecx_253, esp_213->dw0018) != 0x00)
					goto l0040C2E8;
				byte * ebx_316 = esp_267->ptr0020;
				while (*ebx_316 != 0x00)
				{
					if (*dwArg10 == *dwArg0C)
					{
						Eq_2 ecx_327 = esp_267->t0040;
						Eq_25972 edx_328 = esp_267->t002C;
						esp_267->t0008 = esp_267->t0044;
						esp_267->t0004 = ecx_327;
						esp_267->t0000 = dwArg10;
						esp_267->tFFFFFFFC = dwArg0C;
						esp_267->tFFFFFFF8 = edx_328;
						fn0040BB00(esp_267->tFFFFFFF8, esp_267->tFFFFFFFC, esp_267->t0000, esp_267->t0004, esp_267->t0008);
					}
					**dwArg0C = *ebx_316;
					*dwArg0C = (word32) *dwArg0C + 1;
					++ebx_316;
				}
				esp_213 = (struct Eq_27943 *) ((char *) &esp_267->t0008 + 4);
				ebp_243 = (word32) ebp_243 + esp_267->dw0024;
			}
			else
			{
l0040C2E8:
				if (*dwArg10 == *dwArg0C)
				{
					Eq_2 ecx_285 = esp_213->t0034;
					Eq_25972 edx_286 = esp_213->t0020;
					struct Eq_28137 * esp_287 = esp_213 - 4;
					esp_287->t0000 = esp_213->t0038;
					esp_287->tFFFFFFFC = ecx_285;
					esp_287->tFFFFFFF8 = dwArg10;
					esp_287->tFFFFFFF4 = dwArg0C;
					esp_287->tFFFFFFF0 = edx_286;
					fn0040BB00(esp_287->tFFFFFFF0, esp_287->tFFFFFFF4, esp_287->tFFFFFFF8, esp_287->tFFFFFFFC, esp_287->t0000);
				}
				**dwArg0C = *ebp_243;
				*dwArg0C = (word32) *dwArg0C + 1;
				ebp_243 = (word32) ebp_243 + 1;
			}
		} while (*ebp_243 != 0x00);
	}
	free(dwArg08);
	free(eax_203);
}

// 0040C340: Register Eq_2 fn0040C340(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00401F10
//      fn00402870
//      fn00408D80
//      fn0040CB30
Eq_2 fn0040C340(Eq_2 dwArg04, Eq_2 dwArg08)
{
	char bLoc0208;
	char bLoc0204;
	char bLoc0104;
	_splitpath(dwArg04, &bLoc0208, &bLoc0204, 0x00, 0x00);
	_makepath(&bLoc0104, &bLoc0208, &bLoc0204, dwArg08, 0x00);
	word32 ecx_68;
	word32 edx_69;
	return fn0040ADD0(&bLoc0104, out ecx_68, out edx_69);
}

// 0040C3A0: Register word32 fn0040C3A0(Stack Eq_2 dwArg04, Register out ptr32 ecxOut)
// Called from:
//      fn00401030
//      fn00401170
//      fn004013D0
word32 fn0040C3A0(Eq_2 dwArg04, ptr32 & ecxOut)
{
	ptr32 ecx;
	word24 ecx_24_8_383 = SLICE(ecx, word24, 8);
	Eq_2 edx_18 = dwArg04;
	word32 esi_15 = 0x00;
	if (*dwArg04 == 0x7B)
	{
		edx_18 = (word32) dwArg04 + 1;
		if (*((word32) dwArg04 + 1) != 0x00)
		{
			do
			{
				byte al_23 = *edx_18;
				if (al_23 == 0x7D)
					break;
				if (al_23 == 0x5E)
					edx_18 = (word32) edx_18 + 1;
				edx_18 = (word32) edx_18 + 1;
			} while (*edx_18 != 0x00);
			if (*edx_18 != 0x00)
				edx_18 = (word32) edx_18 + 1;
		}
	}
	byte al_43 = *edx_18;
	if (al_43 == 0x2E)
	{
		Eq_2 edi_46 = edx_18;
		if (al_43 != 0x00)
		{
			do
			{
				byte al_52 = *edi_46;
				if (al_52 == 0x7B)
					break;
				if (al_52 == 0x5E)
					edi_46 = (word32) edi_46 + 1;
				edi_46 = (word32) edi_46 + 1;
			} while (*edi_46 != 0x00);
		}
		Eq_2 edx_71;
		edx_71 = edx_18;
		edx_71 = edx_18;
		if (edi_46 > edx_18)
		{
			do
			{
				byte cl_73 = *edx_71;
				ecx = SEQ(ecx_24_8_383, cl_73);
				if (cl_73 == 0x5C)
					break;
				ecx = SEQ(ecx_24_8_383, cl_73);
				if (cl_73 == 0x2F)
					break;
				edx_71 = (word32) edx_71 + 1;
				ecx = SEQ(ecx_24_8_383, cl_73);
			} while (edi_46 > edx_71);
		}
		if (*edi_46 != 0x00 && edi_46 == edx_71)
		{
			byte * edi_218 = (word32) edi_46 + 1;
			if (*edi_218 != 0x00)
			{
				do
				{
					byte al_223 = *edi_218;
					if (al_223 == 0x7D)
						break;
					if (al_223 == 0x5E)
						++edi_218;
					++edi_218;
				} while (*edi_218 != 0x00);
				if (*edi_218 != 0x00)
				{
					byte * edi_239 = edi_218 + 1;
					if (*edi_239 == 0x2E && (mbschr(edi_239 + 1, 0x2F) == 0x00 && mbschr(edi_239 + 1, 0x5C) == 0x00))
					{
						if (mbschr(edi_239 + 1, 0x2E) == 0x00)
						{
							ecxOut = ecx_299;
							return 0x01;
						}
						else
						{
							ptr32 ecx_320;
							word32 edx_502;
							fn00403220(g_t413424, 0x0444, out ecx_320, out edx_502);
							ecxOut = ecx_320;
							return 0x00;
						}
					}
				}
			}
		}
		else
		{
			byte * eax_142 = mbspbrk((word32) edx_18 + 1, 0x00414BF0);
			if (eax_142 != null && (*eax_142 == 0x2E && (mbschr(eax_142 + 1, 0x2F) == 0x00 && mbschr(eax_142 + 1, 0x5C) == 0x00)))
			{
				if (mbschr(eax_142 + 1, 0x2E) != 0x00)
				{
					ptr32 ecx_203;
					word32 edx_503;
					fn00403220(g_t413424, 0x0444, out ecx_203, out edx_503);
					ecxOut = ecx_203;
					return 0x00;
				}
				esi_15 = 0x01;
			}
		}
	}
	ecxOut = ecx;
	return esi_15;
}

// 0040C510: Register word32 fn0040C510(Stack Eq_2 dwArg04, Stack word32 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      fn0040C790
word32 fn0040C510(Eq_2 dwArg04, word32 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	ptr32 fp;
	char bLoc0100;
	word32 eax_358;
	Eq_2 ebx_13 = dwArg04;
	Eq_2 esi_17 = dwArg0C;
	Eq_2 ebp_21 = (word32) dwArg04 + dwArg08;
	byte al_22 = *dwArg0C;
	while (al_22 != 0x00)
	{
		if (ebp_21 <= ebx_13)
			goto l0040C731;
		if (al_22 != 0x25)
		{
			*ebx_13 = al_22;
			ebx_13 = (word32) ebx_13 + 1;
		}
		else
		{
			int32 eax_35 = (int32) *((word32) esi_17 + 1);
			esi_17 = (word32) esi_17 + 1 + 1;
			if (eax_35 != 0x25)
			{
				if (eax_35 != 115)
				{
					if (eax_35 != 0x7C)
					{
						*ebx_13 = 0x25;
						Eq_2 ebx_291 = (word32) ebx_13 + 1;
						if (ebp_21 == ebx_291)
							goto l0040C731;
						*ebx_291 = *esi_17;
						ebx_13 = (word32) ebx_291 + 1;
					}
					else
					{
						bLoc0100 = 0x00;
						Eq_2 ecx_281 = esi_17 - 1;
						word32 edi_130 = 0x00;
						word32 dwLoc010C_396 = 0x00;
						word32 dwLoc0108_397 = 0x00;
						word32 dwLoc0104_398 = 0x00;
						word32 edx_67 = 0x00;
						do
						{
							struct Eq_28537 * eax_74 = (int32) *esi_17;
							esi_17 = (word32) esi_17 + 1;
							word24 eax_24_8_80 = SLICE(eax_74 - 0x46, word24, 8);
							if (eax_74 <= (struct Eq_28537 *) 0x70)
							{
								switch (SEQ(eax_24_8_80, eax_74->b40C716))
								{
								case 0x00:
									if (*((word32) esi_17 - 1) == 0x7C)
									{
										edi_130 = 0x01;
										dwLoc0104_398 = 0x01;
										dwLoc0108_397 = 0x01;
										dwLoc010C_396 = 0x01;
									}
									break;
								case 0x01:
									edi_130 = 0x01;
									break;
								case 0x02:
									dwLoc010C_396 = 0x01;
									break;
								case 0x03:
									dwLoc0108_397 = 0x01;
									break;
								case 0x04:
									dwLoc0104_398 = 0x01;
									break;
								case 0x05:
									goto l0040C5EA;
								}
							}
							else
							{
l0040C5EA:
								edx_67 = 0x01;
							}
							if (edx_67 != 0x00)
								goto l0040C63A;
						} while (*esi_17 != 0x46);
						if (edx_67 != 0x00)
						{
l0040C63A:
							if (esi_17 - 1 <= esi_17)
							{
								while (ebp_21 > ebx_13)
								{
									*ebx_13 = *ecx_281;
									ecx_281 = (word32) ecx_281 + 1;
									ebx_13 = (word32) ebx_13 + 1;
									if (ecx_281 > esi_17)
										break;
								}
							}
						}
						else
						{
							if (dwArg10 == 0x00)
							{
								word32 edx_607;
								word32 ecx_606;
								fn00403220(0x00, 0x0449, out ecx_606, out edx_607);
							}
							if (edi_130 != 0x00)
								fn0040C7D0(dwArg10, &bLoc0100);
							if (dwLoc0104_398 != 0x00)
							{
								char * edi_155 = &bLoc0100;
								word32 ecx_156 = ~0x00;
								while (ecx_156 != 0x00)
								{
									edi_155 = edi_608 + 1;
									--ecx_156;
									edi_608 = edi_155;
									if (*edi_608 != 0x00)
										break;
								}
								fn0040C890(dwArg10, fp - 0x0101 + ~ecx_156);
							}
							if (dwLoc0108_397 != 0x00)
							{
								char * edi_189 = &bLoc0100;
								word32 ecx_190 = ~0x00;
								while (ecx_190 != 0x00)
								{
									edi_189 = edi_609 + 1;
									--ecx_190;
									edi_609 = edi_189;
									if (*edi_609 != 0x00)
										break;
								}
								fn0040C850(dwArg10, fp - 0x0101 + ~ecx_190);
							}
							if (dwLoc010C_396 != 0x00)
							{
								char * edi_223 = &bLoc0100;
								word32 ecx_224 = ~0x00;
								while (ecx_224 != 0x00)
								{
									edi_223 = edi_610 + 1;
									--ecx_224;
									edi_610 = edi_223;
									if (*edi_610 != 0x00)
										break;
								}
								fn0040C810(dwArg10, fp - 0x0101 + ~ecx_224);
							}
							char * ecx_256 = &bLoc0100;
							if (bLoc0100 != 0x00)
							{
								while (ebp_21 > ebx_13)
								{
									*ebx_13 = *ecx_256;
									++ecx_256;
									ebx_13 = (word32) ebx_13 + 1;
									if (*ecx_256 == 0x00)
										break;
								}
							}
						}
					}
				}
				else
				{
					Eq_2 ecx_45 = dwArg10;
					if (*dwArg10 != 0x00)
					{
						while (ebp_21 > ebx_13)
						{
							*ebx_13 = *ecx_45;
							ecx_45 = (word32) ecx_45 + 1;
							ebx_13 = (word32) ebx_13 + 1;
							if (*ecx_45 == 0x00)
								break;
						}
					}
				}
			}
			else
			{
				*ebx_13 = 0x25;
				ebx_13 = (word32) ebx_13 + 1;
			}
		}
		al_22 = (byte) *((word32) esi_17 + 1);
		esi_17 = (word32) esi_17 + 1;
	}
	if (ebp_21 > ebx_13)
	{
		*ebx_13 = 0x00;
		eax_358 = 0x00;
	}
	else
	{
l0040C731:
		eax_358 = 0x01;
	}
	return eax_358;
}

// 0040C790: void fn0040C790(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      fn004036C0
//      fn004048B0
void fn0040C790(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	if (fn0040C510(dwArg04, 0x0800, dwArg08, dwArg0C) != 0x00)
	{
		word32 ecx_75;
		word32 edx_76;
		fn00403220(0x00, 0x0447, out ecx_75, out edx_76);
	}
}

// 0040C7D0: void fn0040C7D0(Stack Eq_2 dwArg04, Stack (ptr32 char) dwArg08)
// Called from:
//      fn0040C510
void fn0040C7D0(Eq_2 dwArg04, char * dwArg08)
{
	_splitpath(dwArg04, dwArg08, null, 0x00, 0x00);
	char * edi_26 = dwArg08;
	word32 ecx_21 = ~0x00;
	while (ecx_21 != 0x00)
	{
		edi_26 = edi_78 + 1;
		--ecx_21;
		edi_78 = edi_26;
		if (*edi_78 != 0x00)
			return;
	}
}

// 0040C810: void fn0040C810(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn0040C510
void fn0040C810(Eq_2 dwArg04, Eq_2 dwArg08)
{
	_splitpath(dwArg04, null, null, 0x00, dwArg08);
	Eq_2 edi_26 = dwArg08;
	word32 ecx_21 = ~0x00;
	while (ecx_21 != 0x00)
	{
		edi_26 = (word32) edi_78 + 1;
		--ecx_21;
		edi_78 = edi_26;
		if (*edi_78 != 0x00)
			return;
	}
}

// 0040C850: void fn0040C850(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn0040C510
void fn0040C850(Eq_2 dwArg04, Eq_2 dwArg08)
{
	_splitpath(dwArg04, null, null, dwArg08, 0x00);
	Eq_2 edi_26 = dwArg08;
	word32 ecx_21 = ~0x00;
	while (ecx_21 != 0x00)
	{
		edi_26 = (word32) edi_78 + 1;
		--ecx_21;
		edi_78 = edi_26;
		if (*edi_78 != 0x00)
			return;
	}
}

// 0040C890: void fn0040C890(Stack Eq_2 dwArg04, Stack (ptr32 char) dwArg08)
// Called from:
//      fn0040C510
void fn0040C890(Eq_2 dwArg04, char * dwArg08)
{
	_splitpath(dwArg04, null, dwArg08, 0x00, 0x00);
	char * edi_26 = dwArg08;
	word32 ecx_21 = ~0x00;
	while (ecx_21 != 0x00)
	{
		edi_26 = edi_78 + 1;
		--ecx_21;
		edi_78 = edi_26;
		if (*edi_78 != 0x00)
			return;
	}
}

// 0040C8D0: Register word32 fn0040C8D0(Stack Eq_2 dwArg08, Stack ui32 dwArg0C)
// Called from:
//      fn0040AEC0
word32 fn0040C8D0(Eq_2 dwArg08, ui32 dwArg0C)
{
	ptr32 fp;
	word32 edx_8 = *((word32) dwArg08 + dwArg0C * 0x04);
	struct Eq_28824 * esp_100 = fp - 0x18;
	if (edx_8 != 0x00)
	{
		do
		{
			byte * esi_28 = esp_100->ptr001C;
			byte * edi_30 = esp_100->ptr0014->ptr0004;
			if (*esi_28 != 0x00)
			{
				do
				{
					byte al_35 = *edi_30;
					if (al_35 == 0x00)
						break;
					byte bl_40 = *esi_28;
					if (bl_40 != 0x5C && bl_40 != 0x2F)
					{
						esp_100 = (struct Eq_28824 *) ((char *) esp_71 + 4);
						if (esp_71->dw0014 != mbctoupper((int32) bl_40, mbctoupper((int32) al_35)))
							break;
					}
					else if (al_35 != 0x5C && al_35 != 0x2F)
						break;
					++esi_28;
					++edi_30;
				} while (*esi_28 != 0x00);
				if (*esi_28 == 0x00)
					goto l0040C944;
			}
			else
			{
l0040C944:
				esp_100 = fp - 24;
				if (*edi_30 == 0x00)
					return edx_8;
			}
			struct Eq_28883 * ecx_117 = esp_100->ptr0014->ptr0000;
			esp_100->ptr0014 = ecx_117;
		} while (ecx_117 != null);
	}
	return 0x00;
}

// 0040C980: Register word32 fn0040C980(Stack (ptr32 byte) dwArg04, Stack (ptr32 byte) dwArg08)
// Called from:
//      fn00409EF0
word32 fn0040C980(byte * dwArg04, byte * dwArg08)
{
	ptr32 fp;
	Eq_2 dwLoc18;
	word32 ecx_23 = ~0x00;
	byte * ebx_21 = dwArg04;
	byte * edi_22 = dwArg04;
	while (ecx_23 != 0x00)
	{
		edi_22 = edi_318 + 1;
		--ecx_23;
		edi_318 = edi_22;
		if (*edi_318 != 0x00)
			break;
	}
	Eq_2 ecx_32 = ~ecx_23;
	fn0040CEB4((word32) ecx_32 + 3 & ~0x03, ecx_32, dwLoc18);
	byte * esi_119 = dwArg08;
	word32 ecx_50 = ~0x00;
	byte * edi_51 = dwArg08;
	while (ecx_50 != 0x00)
	{
		edi_51 = edi_319 + 1;
		--ecx_50;
		edi_319 = edi_51;
		if (*edi_319 != 0x00)
			break;
	}
	Eq_2 ecx_63 = ~ecx_50;
	fn0040CEB4((word32) ecx_63 + 3 & ~0x03, ecx_63, dwLoc18);
	if (*dwArg04 == 0x22)
		ebx_21 = dwArg04 + 1;
	byte * ecx_100 = fp - 0x14;
	while (*ebx_21 != 0x00)
	{
		*ecx_100 = *ebx_21;
		++ebx_21;
		++ecx_100;
	}
	byte * eax_104 = ecx_100 - 1;
	if (*eax_104 == 0x22)
		ecx_100 = eax_104;
	*ecx_100 = 0x00;
	if (*dwArg08 == 0x22)
		esi_119 = dwArg08 + 1;
	byte * ecx_126 = fp - 0x14;
	while (*esi_119 != 0x00)
	{
		*ecx_126 = *esi_119;
		++esi_119;
		++ecx_126;
	}
	byte * eax_141 = ecx_126 - 1;
	if (*eax_141 == 0x22)
		ecx_126 = eax_141;
	*ecx_126 = 0x00;
	return mbsicmp(fp - 0x14, fp - 0x14);
}

// 0040CA30: Register uip32 fn0040CA30(Stack Eq_2 dwArg04)
// Called from:
//      fn00409DE0
//      fn0040AEC0
//      fn0040CBF0
//      fn0040CD20
uip32 fn0040CA30(Eq_2 dwArg04)
{
	word32 ecx_15 = ~0x00;
	Eq_2 esi_40 = dwArg04;
	Eq_2 edi_12 = dwArg04;
	while (ecx_15 != 0x00)
	{
		edi_12 = (word32) edi_113 + 1;
		--ecx_15;
		edi_113 = edi_12;
		if (*edi_113 != 0x00)
			break;
	}
	fn0040ACC0(~ecx_15);
	if (*dwArg04 == 0x22)
		esi_40 = (word32) dwArg04 + 1;
	byte * ecx_48 = null;
	while (*esi_40 != 0x00)
	{
		*ecx_48 = (byte) *esi_40;
		esi_40 = (word32) esi_40 + 1;
		++ecx_48;
	}
	byte * edx_63 = ecx_48 - 1;
	if (*edx_63 == 0x22)
		ecx_48 = edx_63;
	*ecx_48 = 0x00;
	return 0x00;
}

// 0040CA80: Register word32 fn0040CA80(Stack Eq_2 dwArg04)
// Called from:
//      fn00402CC0
//      fn00404C10
//      fn00405860
//      fn00406020
//      fn00407450
//      fn00407680
//      fn00408190
word32 fn0040CA80(Eq_2 dwArg04)
{
	ptr32 fp;
	struct Eq_29114 * esp_11 = fp - 0x0C;
	if (*dwArg04 == 0x22)
	{
		*mbsrchr(dwArg04, 0x22) = 0x00;
		byte * edi_142 = (word32) dwArg04 + 1;
		esp_11 = esp_21 + 0x08;
		word32 ecx_27 = ~0x00;
		while (ecx_27 != 0x00)
		{
			++edi_142;
			--ecx_27;
			if (*edi_142 != 0x00)
				break;
		}
		uint32 ecx_40 = ~ecx_27;
		uint32 ecx_101;
		struct Eq_29150 * esi_46 = edi_142 - ecx_40;
		Eq_2 edi_100 = dwArg04;
		for (ecx_101 = ecx_40 >> 0x02; ecx_101 != 0x00; --ecx_101)
		{
			*edi_100 = esi_46->dw0000;
			esi_46 += 4;
			edi_100 = (word32) edi_100 + 4;
		}
		ui32 ecx_53;
		for (ecx_53 = ecx_40 & 0x03; ecx_53 != 0x00; --ecx_53)
		{
			*edi_100 = esi_46->dw0000;
			++esi_46;
			edi_100 = (word32) edi_100 + 1;
		}
	}
	return fsopen(dwArg04, esp_11->dw0014, 0x20);
}

// 0040CAE0: void fn0040CAE0(Stack (ptr32 char) dwArg04, Stack Eq_17480 dwArg08)
// Called from:
//      fn0040CC50
void fn0040CAE0(char * dwArg04, Eq_17480 dwArg08)
{
	char * ebx_17 = dwArg04;
	if (*dwArg04 == 0x00)
		return;
	do
	{
		byte * eax_43 = 0x00 - (word32) ((*((word32) ((uint32) (*ebx_17) + 1) + _p__mbctype()) & 0x04) < 0x01);
		if (ebx_17 - dwArg04 + (eax_43 + 0x02) >u dwArg08)
		{
			*ebx_17 = 0x00;
			return;
		}
		ebx_17 += eax_43 + 0x02;
	} while (*ebx_17 != 0x00);
}

// 0040CB30: Register Eq_2 fn0040CB30(Register Eq_2 ecx, Stack Eq_2 dwArg04)
// Called from:
//      fn004013D0
Eq_2 fn0040CB30(Eq_2 ecx, Eq_2 dwArg04)
{
	ptr32 fp;
	Eq_2 tLoc0C;
	ptr32 tLoc08;
	Eq_2 dwLoc20;
	Eq_2 dwLoc10;
	fn0040CEB4((word32) g_t413EE0 + 3 & ~0x03, ecx, dwLoc20);
	tLoc08 = fp - 0x1C;
	Eq_2 eax_40 = fn0040CD20(dwArg04);
	if (eax_40 == 0x00)
		return 0x00;
	word32 ecx_200;
	tLoc0C = fn0040AD20(out ecx_200);
	*((word32) tLoc0C + 4) = fn0040C340(dwArg04, eax_40);
	while (true)
	{
		fn00404C90(&tLoc08);
		Eq_2 eax_91 = fn0040CE00(&tLoc08, dwLoc10);
		if (eax_91 == 0x00)
			break;
		word32 ecx_201;
		Eq_2 eax_111 = fn0040AD20(out ecx_201);
		*((word32) eax_111 + 4) = fn0040C340(dwArg04, eax_91);
		fn0040AE10(&tLoc0C, eax_111);
	}
	return tLoc0C;
}

// 0040CBD0: void fn0040CBD0(Stack word32 dwArg04)
// Called from:
//      fn00404680
void fn0040CBD0(word32 dwArg04)
{
	chdrive(dwArg04);
}

// 0040CBF0: Register Eq_2 fn0040CBF0(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00409EF0
Eq_2 fn0040CBF0(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 edx_46 = dwArg04;
	word32 ecx_12 = ~0x00;
	Eq_2 edi_13 = dwArg04;
	while (ecx_12 != 0x00)
	{
		edi_13 = (word32) edi_133 + 1;
		--ecx_12;
		edi_133 = edi_13;
		if (*edi_133 != 0x00)
			break;
	}
	byte * eax_30 = (word32) dwArg04 + (~ecx_12 - 2);
	if (*dwArg04 == 0x22 && *eax_30 == 0x22)
		edx_46 = fn0040CA30(dwArg04);
	Eq_2 eax_56 = _findfirst(edx_46, *dwArg08);
	if (eax_56 == ~0x00)
		return 0x00;
	findclose(eax_56);
	return fn00404C90(dwArg08);
}

// 0040CC50: void fn0040CC50(Stack Eq_2 dwArg04)
// Called from:
//      fn0040CD20
void fn0040CC50(Eq_2 dwArg04)
{
	char bLoc0304;
	char bLoc0300;
	char bLoc0200;
	char bLoc0100;
	_splitpath(dwArg04, &bLoc0304, &bLoc0100, &bLoc0300, &bLoc0200);
	word32 esi_100 = 0x00;
	char * edi_30 = &bLoc0300;
	word32 ecx_32 = ~0x00;
	while (ecx_32 != 0x00)
	{
		edi_30 = edi_211 + 1;
		--ecx_32;
		edi_211 = edi_30;
		if (*edi_211 != 0x00)
			break;
	}
	Eq_17480 eax_47 = g_t413ED8;
	if (~ecx_32 - 0x01 > eax_47)
	{
		fn0040CAE0(&bLoc0300, eax_47);
		esi_100 = 0x01;
	}
	char * edi_66 = &bLoc0200;
	word32 ecx_67 = ~0x00;
	while (ecx_67 != 0x00)
	{
		edi_66 = edi_212 + 1;
		--ecx_67;
		edi_212 = edi_66;
		if (*edi_212 != 0x00)
			break;
	}
	Eq_17480 eax_82 = g_t413ED4;
	if (~ecx_67 - 0x01 > eax_82)
	{
		fn0040CAE0(&bLoc0200, eax_82);
		esi_100 = 0x01;
	}
	if (esi_100 != 0x00)
		_makepath(dwArg04, &bLoc0304, &bLoc0100, &bLoc0300, &bLoc0200);
}

// 0040CD20: Register word32 fn0040CD20(Stack Eq_2 dwArg04)
// Called from:
//      fn00401F10
//      fn004020E0
//      fn00402870
//      fn00405930
//      fn00407680
//      fn00408D80
//      fn0040CB30
word32 fn0040CD20(Eq_2 dwArg04)
{
	Eq_2 esi_101 = dwArg04;
	word32 ebx_31 = 0x00 - (word32) (mbspbrk(dwArg04, 0x00414BF4) < 0x01);
	if (ebx_31 != 0x01)
	{
		Eq_2 edi_36 = dwArg04;
		word32 ecx_37 = ~0x00;
		while (ecx_37 != 0x00)
		{
			edi_36 = (word32) edi_278 + 1;
			--ecx_37;
			edi_278 = edi_36;
			if (*edi_278 != 0x00)
				break;
		}
		byte * eax_54 = (word32) dwArg04 + (~ecx_37 - 2);
		if (*dwArg04 == 0x22 && *eax_54 == 0x22)
		{
			esp_23->t0004 = dwArg04;
			esi_101 = fn0040CA30(esp_23->t0004);
		}
		byte * eax_72 = (char *) &esp_23->t0004 + 20;
		while (*esi_101 != 0x00)
		{
			if (*esi_101 == 0x5E)
				esi_101 = (word32) esi_101 + 1;
			*eax_72 = (byte) *esi_101;
			esi_101 = (word32) esi_101 + 1;
			++eax_72;
		}
		*eax_72 = 0x00;
		esi_101 = (char *) &esp_23->t0004 + 20;
	}
	word32 eax_191;
	esp_23->t0004 = esi_101;
	fn0040CC50(esp_23->t0004);
	union Eq_2 * edi_111 = esp_23->ptr0124;
	esp_23->t0004 = *edi_111;
	esp_23->t0000 = esi_101;
	Eq_2 eax_118 = _findfirst(esp_23->t0000, esp_23->t0004);
	union Eq_2 * ebp_119 = esp_23->ptr0128;
	*ebp_119 = (union Eq_2 *) eax_118;
	if (eax_118 == ~0x00)
		eax_191 = 0x00;
	else
	{
		if (ebx_31 == 0x01 || mbschr(esi_101, 0x2A) == 0x00 && mbschr(esi_101, 0x3F) == 0x00)
			findclose(*ebp_119);
		eax_191 = (char *) *edi_111 + 20;
	}
	return eax_191;
}

// 0040CE00: Register Eq_2 fn0040CE00(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00401F10
//      fn00402870
//      fn00408D80
//      fn0040CB30
Eq_2 fn0040CE00(Eq_2 dwArg04, Eq_2 dwArg08)
{
	if (_findnext(dwArg08, *dwArg04) == 0x00)
		return fn00404C90(dwArg04);
	findclose(dwArg08);
	return 0x00;
}

// 0040CE40: Register uip32 fn0040CE40(Register out Eq_17990 ecxOut)
// Called from:
//      fn00407F70
uip32 fn0040CE40(union Eq_17990 & ecxOut)
{
	char bLoc0104;
	char * edi_18 = _getcwd(&bLoc0104, 0x0101);
	word32 ecx_19 = ~0x00;
	while (ecx_19 != 0x00)
	{
		edi_18 = edi_140 + 1;
		--ecx_19;
		edi_140 = edi_18;
		if (*edi_140 != 0x00)
			break;
	}
	fn0040ACC0(~ecx_19);
	char * edi_141 = &bLoc0104;
	word32 ecx_50 = ~0x00;
	while (ecx_50 != 0x00)
	{
		++edi_141;
		--ecx_50;
		if (*edi_141 != 0x00)
			break;
	}
	uint32 ecx_62 = ~ecx_50;
	uint32 ecx_103;
	struct Eq_29641 * esi_101 = edi_141 - ecx_62;
	struct Eq_29643 * edi_102 = null;
	for (ecx_103 = ecx_62 >> 0x02; ecx_103 != 0x00; --ecx_103)
	{
		edi_102->dw0000 = esi_101->dw0000;
		esi_101 += 4;
		edi_102 += 4;
	}
	Eq_17990 ecx_75;
	for (ecx_75 = ecx_62 & 0x03; ecx_75 != 0x00; --ecx_75)
	{
		edi_102->dw0000 = esi_101->dw0000;
		++esi_101;
		++edi_102;
	}
	ecxOut = ecx_75;
	return 0x00;
}

// 0040CEA0: void fn0040CEA0(Stack Eq_2 dwArg04)
// Called from:
//      fn004020E0
void fn0040CEA0(Eq_2 dwArg04)
{
	time(dwArg04);
}

// 0040CEB4: Register Eq_2 fn0040CEB4(Register uint32 eax, Register Eq_2 ecx, Stack Eq_2 dwArg00)
// Called from:
//      fn00401F10
//      fn004020E0
//      fn00404180
//      fn00404830
//      fn00405860
//      fn004062A0
//      fn00407680
//      fn004085F0
//      fn0040A500
//      fn0040B110
//      fn0040C980
//      fn0040CB30
Eq_2 fn0040CEB4(uint32 eax, Eq_2 ecx, Eq_2 dwArg00)
{
	ptr32 fp;
	struct Eq_29693 * ecx_13 = fp + 0x04;
	for (; eax >= 0x1000; eax -= 0x1000)
	{
		ecx_13 -= 0x1000;
		ecx_13->dw0000 = ecx_13->dw0000;
	}
	word32 * ecx_14 = ecx_13 - eax;
	*ecx_14 = *ecx_14;
	Eq_2 ecx_27;
	dwArg00();
	return ecx_27;
}

// 0040CEE1: Register Eq_23623 fn0040CEE1(Stack Eq_23623 dwArg04)
// Called from:
//      fn0040CF7B
Eq_23623 fn0040CEE1(Eq_23623 dwArg04)
{
	int32 ecx_21 = g_dw414BFC;
	if (ecx_21 == 0x00)
	{
		Eq_24120 eax_11 = GetVersion();
		int32 ecx_15 = g_dw414BFC;
		if ((eax_11 & 0xFF) == 0x03 && (eax_11 & 0x80000000) != 0x00)
			ecx_21 = ecx_15 + 0x01;
		else
			ecx_21 = ecx_15 - 0x01;
	}
	g_dw414BFC = ecx_21;
	if (ecx_21 > 0x00)
	{
		int32 eax_29 = g_dw414C00;
		while (eax_29 > 0x00)
		{
			Sleep(0x00);
			eax_29 = g_dw414C00;
		}
		g_dw414C00 = eax_29 + 0x01;
	}
	Eq_23623 eax_100;
	if (g_dw411B18 == ~0x00)
		eax_100 = _onexit(dwArg04);
	else
		eax_100 = __dllonexit(dwArg04, &g_dw411B18, &g_dw411B14);
	if (g_dw414BFC > 0x00)
		--g_dw414C00;
	return eax_100;
}

// 0040CF7B: void fn0040CF7B(Stack Eq_23623 dwArg04)
// Called from:
//      fn0040A660
void fn0040CF7B(Eq_23623 dwArg04)
{
	fn0040CEE1(dwArg04);
}

// 0040CF8D: Register Eq_24120 Win32CrtStartup()
Eq_24120 Win32CrtStartup()
{
	ptr32 fp;
	struct Eq_29796 * fs;
	char ** ptrLoc2C;
	int32 dwLoc28;
	char ** ptrLoc24;
	fs->ptr0000 = fp - 20;
	g_dw411B14 = ~0x00;
	g_dw411B18 = g_dw411B14;
	*__p__fmode() = g_dw414C10;
	*__p__commode() = g_dw414C0C;
	fn0040D0C1();
	fn0040D0AE();
	_initterm(&g_t414C1C, &g_t414C20);
	__getmainargs(&dwLoc28, &ptrLoc2C, &ptrLoc24, g_dw414C04);
	_initterm(&g_t414C14, &g_t414C18);
	*_p___initenv() = ptrLoc24;
	esp_75->dwFFFFFFFC = ptrLoc24;
	esp_75->dwFFFFFFF8 = ptrLoc2C;
	esp_75->dwFFFFFFF4 = dwLoc28;
	fn00407C30(esp_75->dwFFFFFFF4, esp_75->dwFFFFFFF8, esp_75->dwFFFFFFFC, esp_75->t0050, esp_75->t0054, esp_75->t0058, esp_75->t0064, esp_75->t0068, esp_75->t006C, esp_75->t0070, esp_75->t007C, esp_75->t0080, esp_75->t0084, esp_75->t0098, esp_75->t009C, esp_75->t00A0);
}

// 0040D0AE: void fn0040D0AE()
// Called from:
//      Win32CrtStartup
void fn0040D0AE()
{
	_controlfp(0x00010000, 0x00030000);
}

// 0040D0C1: void fn0040D0C1()
// Called from:
//      Win32CrtStartup
void fn0040D0C1()
{
}

// tmp3zoxja9l_idata.c
// Generated by decompiling tmp3zoxja9l
// using Reko decompiler version 0.11.2.0.

#include "tmp3zoxja9l.h"

word32 g_dw41503C = 0x0001579C; // 0041503C
word32 g_dw415040 = 0x00015790; // 00415040
word32 g_dw415044 = 0x0001577C; // 00415044
word32 g_dw415048 = 0x00015772; // 00415048
word32 g_dw41504C = 0x00015786; // 0041504C
word32 g_dw415050 = 87888; // 00415050
word32 g_dw415054 = 87870; // 00415054
word32 g_dw415058 = 87908; // 00415058
word32 g_dw415060 = 0x000153A6; // 00415060
word32 g_dw415064 = 86968; // 00415064
word32 g_dw415068 = 86978; // 00415068
word32 g_dw41506C = 86986; // 0041506C
word32 g_dw415070 = 86996; // 00415070
word32 g_dw415074 = 87004; // 00415074
word32 g_dw415078 = 0x000153E8; // 00415078
word32 g_dw41507C = 0x000153F2; // 0041507C
word32 g_dw415080 = 87038; // 00415080
word32 g_dw415084 = 87048; // 00415084
word32 g_dw415088 = 0x00015412; // 00415088
word32 g_dw41508C = 0x0001541C; // 0041508C
word32 g_dw415090 = 87082; // 00415090
word32 g_dw415094 = 0x00015438; // 00415094
word32 g_dw415098 = 0x00015444; // 00415098
word32 g_dw41509C = 0x00015450; // 0041509C
word32 g_dw4150A0 = 0x0001545A; // 004150A0
word32 g_dw4150A4 = 0x00015464; // 004150A4
word32 g_dw4150A8 = 87148; // 004150A8
word32 g_dw4150AC = 87158; // 004150AC
word32 g_dw4150B0 = 0x00015484; // 004150B0
word32 g_dw4150B4 = 87184; // 004150B4
word32 g_dw4150B8 = 87198; // 004150B8
word32 g_dw4150BC = 0x000154AA; // 004150BC
word32 g_dw4150C0 = 87224; // 004150C0
word32 g_dw4150C4 = 87232; // 004150C4
word32 g_dw4150C8 = 87242; // 004150C8
word32 g_dw4150CC = 0x000154D8; // 004150CC
word32 g_dw4150D0 = 0x000154E4; // 004150D0
word32 g_dw4150D4 = 87288; // 004150D4
word32 g_dw4150D8 = 0x00015506; // 004150D8
word32 g_dw4150DC = 0x00015514; // 004150DC
word32 g_dw4150E0 = 0x0001551E; // 004150E0
word32 g_dw4150E4 = 0x00015528; // 004150E4
word32 g_dw4150E8 = 0x00015532; // 004150E8
word32 g_dw4150EC = 0x0001553A; // 004150EC
word32 g_dw4150F0 = 0x0001554A; // 004150F0
word32 g_dw4150F4 = 0x00015552; // 004150F4
word32 g_dw4150F8 = 0x0001539C; // 004150F8
word32 g_dw4150FC = 86960; // 004150FC
word32 g_dw415100 = 86868; // 00415100
word32 g_dw415104 = 0x00015582; // 00415104
word32 g_dw415108 = 0x0001558A; // 00415108
word32 g_dw41510C = 87444; // 0041510C
word32 g_dw415110 = 0x0001559E; // 00415110
word32 g_dw415114 = 0x000155A8; // 00415114
word32 g_dw415118 = 0x000155B8; // 00415118
word32 g_dw41511C = 87488; // 0041511C
word32 g_dw415120 = 0x000155CA; // 00415120
word32 g_dw415124 = 0x000155D4; // 00415124
word32 g_dw415128 = 0x000155E2; // 00415128
word32 g_dw41512C = 0x000155EA; // 0041512C
word32 g_dw415130 = 0x000155F4; // 00415130
word32 g_dw415134 = 0x000155FE; // 00415134
word32 g_dw415138 = 0x0001560A; // 00415138
word32 g_dw41513C = 0x00015618; // 0041513C
word32 g_dw415140 = 87584; // 00415140
word32 g_dw415144 = 0x00015628; // 00415144
word32 g_dw415148 = 0x00015632; // 00415148
word32 g_dw41514C = 0x0001563C; // 0041514C
word32 g_dw415150 = 0x00015646; // 00415150
word32 g_dw415154 = 0x00015650; // 00415154
word32 g_dw415158 = 0x0001565C; // 00415158
word32 g_dw41515C = 0x0001566A; // 0041515C
word32 g_dw415160 = 87672; // 00415160
word32 g_dw415164 = 87684; // 00415164
word32 g_dw415168 = 0x0001568E; // 00415168
word32 g_dw41516C = 87716; // 0041516C
word32 g_dw415170 = 87730; // 00415170
word32 g_dw415174 = 87740; // 00415174
word32 g_dw415178 = 87748; // 00415178
word32 g_dw41517C = 87762; // 0041517C
word32 g_dw415180 = 87778; // 00415180
word32 g_dw415184 = 0x000156EE; // 00415184
word32 g_dw415188 = 87806; // 00415188
word32 g_dw41518C = 87822; // 0041518C
word32 g_dw415190 = 0x0001571C; // 00415190
word32 g_dw415194 = 87856; // 00415194
word32 g_dw415198 = 0x0001537E; // 00415198
word32 g_dw41519C = 0x00015392; // 0041519C
word32 g_dw4151A0 = 0x00015388; // 004151A0
word32 g_dw4151A4 = 86876; // 004151A4
word32 g_dw4151A8 = 86898; // 004151A8
word32 g_dw4151AC = 86886; // 004151AC
word32 g_dw4151B0 = 0x0001555C; // 004151B0
word32 g_dw4151B4 = 0x00015568; // 004151B4
word32 g_dw4151B8 = 0x00015576; // 004151B8
word32 g_dw4151BC = 87986; // 004151BC
word32 g_dw4151C0 = 87998; // 004151C0
<anonymous> * __imp__Sleep = &g_t1579C; // 004151C8
<anonymous> * __imp__OpenFile = &g_t15790; // 004151CC
<anonymous> * __imp___llseek = &g_t1577C; // 004151D0
<anonymous> * __imp___lclose = &g_t15772; // 004151D4
<anonymous> * __imp___lread = &g_t15786; // 004151D8
<anonymous> * __imp__GetModuleHandleA = &g_t15750; // 004151DC
<anonymous> * __imp__GetProcAddress = &g_t1573E; // 004151E0
<anonymous> * __imp__GetVersion = &g_t15764; // 004151E4
<anonymous> * __imp__fclose = &g_t153A6; // 004151EC
<anonymous> * __imp__realloc = &g_t153B8; // 004151F0
<anonymous> * __imp__exit = &g_t153C2; // 004151F4
<anonymous> * __imp__fflush = &g_t153CA; // 004151F8
<anonymous> * __imp__putc = &g_t153D4; // 004151FC
<anonymous> * __imp__vfprintf = &g_t153DC; // 00415200
<anonymous> * __imp__fprintf = &g_t153E8; // 00415204
<anonymous> * __imp____p__iob = &g_t153F2; // 00415208
<anonymous> * __imp___mbsspn = &g_t153FE; // 0041520C
<anonymous> * __imp___errno = &g_t15408; // 00415210
<anonymous> * __imp__strtol = &g_t15412; // 00415214
<anonymous> * __imp___ismbcdigit = &g_t1541C; // 00415218
<anonymous> * __imp___ismbcspace = &g_t1542A; // 0041521C
<anonymous> * __imp___strerror = &g_t15438; // 00415220
<anonymous> * __imp___spawnvp = &g_t15444; // 00415224
<anonymous> * __imp__system = &g_t15450; // 00415228
<anonymous> * __imp__printf = &g_t1545A; // 0041522C
<anonymous> * __imp___dup2 = &g_t15464; // 00415230
<anonymous> * __imp___close = &g_t1546C; // 00415234
<anonymous> * __imp___mbctoupper = &g_t15476; // 00415238
<anonymous> * __imp___makepath = &g_t15484; // 0041523C
<anonymous> * __imp___splitpath = &g_t15490; // 00415240
<anonymous> * __imp___mbsnbcpy = &g_t1549E; // 00415244
<anonymous> * __imp____p__pgmptr = &g_t154AA; // 00415248
<anonymous> * __imp___dup = &g_t154B8; // 0041524C
<anonymous> * __imp___chdir = &g_t154C0; // 00415250
<anonymous> * __imp____p__pctype = &g_t154CA; // 00415254
<anonymous> * __imp___isctype = &g_t154D8; // 00415258
<anonymous> * __imp____p___mb_cur_max = &g_t154E4; // 0041525C
<anonymous> * __imp___mbsnbicmp = &g_t154F8; // 00415260
<anonymous> * __imp___ismbcalpha = &g_t15506; // 00415264
<anonymous> * __imp___lseek = &g_t15514; // 00415268
<anonymous> * __imp__freopen = &g_t1551E; // 0041526C
<anonymous> * __imp___write = &g_t15528; // 00415270
<anonymous> * __imp___read = &g_t15532; // 00415274
<anonymous> * __imp____p__mbctype = &g_t1553A; // 00415278
<anonymous> * __imp__getc = &g_t1554A; // 0041527C
<anonymous> * __imp__ungetc = &g_t15552; // 00415280
<anonymous> * __imp___putenv = &g_t1539C; // 00415284
<anonymous> * __imp__fgets = &g_t153B0; // 00415288
<anonymous> * __imp__free = &g_t15354; // 0041528C
<anonymous> * __imp__fputc = &g_t15582; // 00415290
<anonymous> * __imp___mktemp = &g_t1558A; // 00415294
<anonymous> * __imp__signal = &g_t15594; // 00415298
<anonymous> * __imp___mbsupr = &g_t1559E; // 0041529C
<anonymous> * __imp____p__environ = &g_t155A8; // 004152A0
<anonymous> * __imp__fopen = &g_t155B8; // 004152A4
<anonymous> * __imp___access = &g_t155C0; // 004152A8
<anonymous> * __imp___unlink = &g_t155CA; // 004152AC
<anonymous> * __imp___fcloseall = &g_t155D4; // 004152B0
<anonymous> * __imp__ctime = &g_t155E2; // 004152B4
<anonymous> * __imp__putchar = &g_t155EA; // 004152B8
<anonymous> * __imp__memmove = &g_t155F4; // 004152BC
<anonymous> * __imp___mbscspn = &g_t155FE; // 004152C0
<anonymous> * __imp___ismbcalnum = &g_t1560A; // 004152C4
<anonymous> * __imp__fseek = &g_t15618; // 004152C8
<anonymous> * __imp__ftell = &g_t15620; // 004152CC
<anonymous> * __imp___strdup = &g_t15628; // 004152D0
<anonymous> * __imp__malloc = &g_t15632; // 004152D4
<anonymous> * __imp___mbsinc = &g_t1563C; // 004152D8
<anonymous> * __imp___fsopen = &g_t15646; // 004152DC
<anonymous> * __imp___chdrive = &g_t15650; // 004152E0
<anonymous> * __imp___findclose = &g_t1565C; // 004152E4
<anonymous> * __imp___findfirst = &g_t1566A; // 004152E8
<anonymous> * __imp___findnext = &g_t15678; // 004152EC
<anonymous> * __imp___getcwd = &g_t15684; // 004152F0
<anonymous> * __imp__time = &g_t1568E; // 004152F4
<anonymous> * __imp____dllonexit = &g_t156A4; // 004152F8
<anonymous> * __imp___onexit = &g_t156B2; // 004152FC
<anonymous> * __imp___exit = &g_t156BC; // 00415300
<anonymous> * __imp___XcptFilter = &g_t156C4; // 00415304
<anonymous> * __imp____p___initenv = &g_t156D2; // 00415308
<anonymous> * __imp___initterm = &g_t156E2; // 0041530C
<anonymous> * __imp____getmainargs = &g_t156EE; // 00415310
<anonymous> * __imp____p__commode = &g_t156FE; // 00415314
<anonymous> * __imp____p__fmode = &g_t1570E; // 00415318
<anonymous> * __imp___except_handler3 = &g_t1571C; // 0041531C
<anonymous> * __imp___controlfp = &g_t15730; // 00415320
<anonymous> * __imp___mbschr = &g_t1537E; // 00415324
<anonymous> * __imp___mbstok = &g_t15392; // 00415328
<anonymous> * __imp__getenv = &g_t15388; // 0041532C
<anonymous> * __imp___mbscmp = &g_t1535C; // 00415330
<anonymous> * __imp___mbspbrk = &g_t15372; // 00415334
<anonymous> * __imp___mbsicmp = &g_t15366; // 00415338
<anonymous> * __imp___mbsrchr = &g_t1555C; // 0041533C
<anonymous> * __imp___searchenv = &g_t15568; // 00415340
<anonymous> * __imp___mbsnbcmp = &g_t15576; // 00415344
<anonymous> * __imp___memicmp = &g_t157B2; // 00415348
<anonymous> * __imp___strnicmp = &g_t157BE; // 0041534C
// tmp3zoxja9l_data.c
// Generated by decompiling tmp3zoxja9l
// using Reko decompiler version 0.11.2.0.

#include "tmp3zoxja9l.h"

byte g_b41300C = 0x3D; // 0041300C
ui32 g_dw413010 = 0x00; // 00413010
word32 g_a413068[] = // 00413068
	{
	};
char g_b413254 = 'P'; // 00413254
word32 g_dw4133A4 = 0x00; // 004133A4
word32 g_dw4133A8 = 0x00; // 004133A8
word32 g_dw4133B0 = 0x01; // 004133B0
word32 g_dw4133B4 = 0x00; // 004133B4
word32 g_dw4133B8 = 0x00; // 004133B8
struct Eq_19468 * g_ptr4133BC = null; // 004133BC
word32 g_dw4133C0 = 0x00; // 004133C0
Eq_2 g_t4133C4 = // 004133C4
	{
		228
	};
word32 g_dw4133C8 = 0x00; // 004133C8
word32 g_dw4133CC = 0x00; // 004133CC
Eq_2 g_t4133D0 = // 004133D0
	{
		0x00
	};
byte g_b4133D4 = 0x00; // 004133D4
Eq_2 g_t4133D8 = // 004133D8
	{
		0x00
	};
Eq_2 g_t4133DC = // 004133DC
	{
		0x00
	};
Eq_2 g_t4133E0 = // 004133E0
	{
		0x00
	};
Eq_2 g_t4133E8 = // 004133E8
	{
		0x00
	};
Eq_2 g_t4133EC = // 004133EC
	{
		0x00
	};
word32 g_dw4133F0 = 0x01; // 004133F0
Eq_2 g_t4133F4 = // 004133F4
	{
		0x00
	};
Eq_2 g_t4133F8 = // 004133F8
	{
		0x00
	};
Eq_2 g_t4133FC = // 004133FC
	{
		0x00
	};
int32 g_dw413400 = 0; // 00413400
struct Eq_12523 * g_ptr413404 = null; // 00413404
Eq_2 g_t413408 = // 00413408
	{
		0x00
	};
struct Eq_19582 * g_ptr413420 = &g_tFFFFFFFF; // 00413420
Eq_2 g_t413424 = // 00413424
	{
		0x00
	};
struct Eq_20566 * g_a413428[257] = // 00413428
	{
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
	};
word32 g_dw413828 = 0x00; // 00413828
Eq_2 g_t413A28 = // 00413A28
	{
		0x00
	};
Eq_2 g_t413A2C = // 00413A2C
	{
		0x00
	};
Eq_2 g_t413A34 = // 00413A34
	{
		0x00
	};
Eq_2 g_t413A38 = // 00413A38
	{
		0x00
	};
Eq_2 g_t413A3C = // 00413A3C
	{
		0x00
	};
Eq_2 g_t413A40 = // 00413A40
	{
		0x00
	};
Eq_2 g_t413A44 = // 00413A44
	{
		0x00
	};
byte g_b413A48 = 0x00; // 00413A48
Eq_2 g_t413A4C = // 00413A4C
	{
		0x00
	};
word32 g_dw413A50 = 0x00; // 00413A50
Eq_2 g_t413A54 = // 00413A54
	{
		0x00
	};
word32 g_dw413A58 = 0x00; // 00413A58
Eq_2 g_t413A5C = // 00413A5C
	{
		0x00
	};
struct Eq_11664 * g_ptr413A70 = &g_tFFFFFFFF; // 00413A70
Eq_2 g_t413A74 = // 00413A74
	{
		0x00
	};
Eq_2 g_t413A78 = // 00413A78
	{
		0x00
	};
Eq_10911 g_t413A7C = // 00413A7C
	{
		0
	};
Eq_2 g_t413A80 = // 00413A80
	{
		~0x00
	};
Eq_2 g_t413A84 = // 00413A84
	{
		0x00
	};
Eq_2 g_t413A88 = // 00413A88
	{
		0x00
	};
Eq_2 g_t413A8C = // 00413A8C
	{
		0x00
	};
Eq_2 g_t413A90 = // 00413A90
	{
		0x00
	};
Eq_2 g_t413A94 = // 00413A94
	{
		0x00
	};
Eq_2 g_t413A98 = // 00413A98
	{
		0x00
	};
Eq_12374 g_a413AA0[] = // 00413AA0
	{
	};
byte g_b413AA1 = 0x00; // 00413AA1
Eq_17480 g_t413ED4 = // 00413ED4
	{
		4
	};
Eq_17480 g_t413ED8 = // 00413ED8
	{
		8
	};
word32 g_dw413EDC = 0x0D; // 00413EDC
Eq_2 g_t413EE0 = // 00413EE0
	{
		0x24
	};
char g_b413FA0 = '.'; // 00413FA0
word16 g_w413FAC = 0x3C3C; // 00413FAC
byte g_b413FAE = 0x00; // 00413FAE
byte g_b413FC9 = 0x6D; // 00413FC9
byte g_b413FD4 = 0x2E; // 00413FD4
Eq_78 g_t413FE0 = // 00413FE0
	{
		0x2E
	};
byte g_b413FE4 = 0x5C; // 00413FE4
Eq_2 g_t413FF0 = // 00413FF0
	{
		0x00
	};
Eq_2 g_t413FF8 = // 00413FF8
	{
		0x00
	};
word32 g_dw414004 = 0x00; // 00414004
byte g_b414008 = 0x00; // 00414008
byte g_b41400C = 0x00; // 0041400C
byte g_b414010 = 0x00; // 00414010
byte g_b414014 = 0x00; // 00414014
Eq_2 g_t414018 = // 00414018
	{
		0x4C
	};
word32 g_dw414118 = 0x00414060; // 00414118
char g_b414464 = '1'; // 00414464
Eq_12374 g_t414478 = // 00414478
	{
		0x3A
	};
byte * g_a414588[] = // 00414588
	{
	};
<anonymous> * g_a414630[] = // 00414630
	{
	};
ptr32 g_ptr414814 = 0x00414818; // 00414814
cu8 g_a414860[] = // 00414860
	{
	};
word32 g_dw4148A0 = 0x004149A4; // 004148A0
Eq_21428 g_t414948 = // 00414948
	{
		0x00,
		0x00,
	};
Eq_2 g_t414950 = // 00414950
	{
		0x28
	};
struct Eq_21739 * g_ptr414954 = &g_t40FE28; // 00414954
word16 g_w4149B8 = 0x5C2E; // 004149B8
byte g_b4149BA = 0x00; // 004149BA
byte g_a4149C0[] = // 004149C0
	{
	};
Eq_2 g_t414AC0 = // 00414AC0
	{
		0x00
	};
Eq_2 g_t414AC4 = // 00414AC4
	{
		0x00
	};
Eq_30109 g_a414AC8[21] = // 00414AC8
	{
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			null,
			0,
		},
		
		{
			&g_b4E524157,
			0x3A474E49,
		},
	};
Eq_24029 g_t414B68 = // 00414B68
	{
		1314013527,
	};
void g_v414BC4 = ??void??; // 00414BC4
void g_v414BC8 = ??void??; // 00414BC8
up32 g_dw414BDC = 0x00; // 00414BDC
Eq_2 g_t414BE0 = // 00414BE0
	{
		0x00
	};
word16 g_w414BE4 = 0x22; // 00414BE4
int32 g_dw414BFC = 0; // 00414BFC
int32 g_dw414C00 = 0; // 00414C00
int32 g_dw414C04 = 0; // 00414C04
word32 g_dw414C0C = 0x00; // 00414C0C
word32 g_dw414C10 = 0x00; // 00414C10
Eq_29835 g_t414C14 = null; // 00414C14
Eq_29836 g_t414C18 = null; // 00414C18
Eq_29835 g_t414C1C = null; // 00414C1C
Eq_29836 g_t414C20 = null; // 00414C20
// tmp3zoxja9l_bss.c
// Generated by decompiling tmp3zoxja9l
// using Reko decompiler version 0.11.2.0.

#include "tmp3zoxja9l.h"

Eq_21322 g_t40EA08 = // 0040EA08
	{
		0x00
	};
struct Eq_21739 * g_ptr40EA0C = null; // 0040EA0C
Eq_21322 g_t40EA10 = // 0040EA10
	{
		0x00
	};
Eq_2 g_t40EA14 = // 0040EA14
	{
		0x00
	};
Eq_2 g_t40EA18 = // 0040EA18
	{
		0x00
	};
Eq_21323 g_t40EA1C = // 0040EA1C
	{
		0x00
	};
word32 g_dw40EA20 = 0x00; // 0040EA20
Eq_2 g_t40EA24 = // 0040EA24
	{
		0x00
	};
Eq_5168 g_t40EA28 = // 0040EA28
	{
		0x00,
		'\0',
	};
Eq_2 g_t40EE28 = // 0040EE28
	{
		0x00
	};
Eq_30095 g_a40EE30[] = // 0040EE30
	{
	};
Eq_21739 g_t40FE28 = // 0040FE28
	{
		0x00,
		
		{
			0x00
		},
	};
Eq_17597 g_t410E30 = // 00410E30
	{
		0x00,
	};
byte g_b410F40 = 0x00; // 00410F40
Eq_2 g_a411A50[] = // 00411A50
	{
	};
Eq_30077 g_a411A54[] = // 00411A54
	{
	};
Eq_2 g_a411A58[] = // 00411A58
	{
	};
Eq_2 g_t411B10 = // 00411B10
	{
		0x00
	};
word32 g_dw411B14 = 0x00; // 00411B14
word32 g_dw411B18 = 0x00; // 00411B18
// tmp3zoxja9l.globals.c
// Generated by decompiling tmp3zoxja9l
// using Reko decompiler version 0.11.2.0.

#include "tmp3zoxja9l.h"

word16 g_w0000; // 00000000
Eq_10234 g_t0001;
byte g_b0002; // 00000002
char g_b000A; // 0000000A
char g_b000B; // 0000000B
Eq_11664 g_t000F;
byte g_b0014; // 00000014
byte g_b0018; // 00000018
byte g_b0019; // 00000019
byte g_b0067; // 00000067
byte g_b006F; // 0000006F
Eq_28537 g_t0070;
byte g_b0077; // 00000077
byte g_b0078; // 00000078
Eq_5195 g_t0400;
