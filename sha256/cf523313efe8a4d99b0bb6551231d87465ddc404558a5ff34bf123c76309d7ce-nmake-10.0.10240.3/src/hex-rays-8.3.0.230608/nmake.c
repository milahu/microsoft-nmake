/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

wchar_t *sub_140001000();
__int64 sub_140001044();
char sub_1400011B8();
void sub_1400012A0();
char __fastcall sub_1400013B0(wchar_t *String1);
void __fastcall sub_140001474(wchar_t *Control, __int64 *a2, _QWORD *a3);
_WORD *__fastcall sub_14000160C(_WORD **a1);
char __fastcall sub_14000169C(__int64 a1, wchar_t *a2);
void sub_1400017F0();
void sub_140001968();
char __fastcall sub_140001AC8(wchar_t *Name, wchar_t *Str, char a3);
char __fastcall sub_140001C2C(wchar_t *Name, wchar_t *Str, char a3);
void __fastcall sub_140001DDC(wchar_t *Block, char a2);
void **__fastcall sub_140001F10(wchar_t **a1, wchar_t *a2);
__int64 __fastcall sub_140002054(wchar_t *a1, char a2, unsigned __int64 *a3);
__int64 __fastcall sub_14000209C(wchar_t *Src, char a2, unsigned __int64 *a3, wchar_t *a4, struct _FILETIME a5);
__int64 __fastcall sub_140002160(__int64 a1, char a2, unsigned __int64 *a3, char a4, wchar_t *a5, struct _FILETIME a6);
_QWORD *__fastcall sub_140002B20(__int64 *a1, __int64 a2);
__int64 __fastcall sub_140002F98(_QWORD *a1);
void *__fastcall sub_140002FE0(_QWORD *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_1400030D8(__int64 *a1);
void __fastcall sub_140003278(_QWORD *a1);
wchar_t *__fastcall sub_1400032C8(void **a1, __int64 *a2);
void *__fastcall sub_1400033D0(_WORD *Src, unsigned int a2, void **a3);
int __fastcall sub_140003468(const wchar_t *a1, unsigned int *a2, void **a3);
void __fastcall sub_140003510(const wchar_t *a1, unsigned int *a2, void **a3);
void __fastcall sub_1400036EC(const wchar_t *a1);
int sub_140003898(unsigned int a1, unsigned int a2, ...);
int sub_1400039C0(unsigned int a1, ...);
void sub_140003A8C();
size_t __fastcall sub_140003AE0(_DWORD *a1, const wchar_t **a2, wchar_t *a3);
__int64 __fastcall sub_140003C94(_WORD *Src, _QWORD *a2, __int64 a3, char a4, const wchar_t *a5);
__int64 __fastcall sub_140003D14(__int64 **a1, _QWORD *a2, __int64 a3, char a4, const wchar_t *a5);
wchar_t *sub_140004288();
_WORD *__fastcall sub_140004564(wchar_t *Str);
char __fastcall sub_140004690(int a1, wint_t **a2, int *a3);
bool __fastcall sub_1400048B4(wchar_t *FileName, int a2);
char __fastcall sub_1400049FC(const wchar_t *Src, __int64 a2, int *a3, int *a4);
bool __fastcall sub_140004C30(_WORD *a1, unsigned __int64 *a2);
char __fastcall sub_140004CC4(const wchar_t *a1, wchar_t *a2);
__int64 __fastcall sub_140005114(wchar_t *Source, char a2, char a3, char a4, void **a5);
void *sub_140005938();
char __fastcall sub_1400059E0(const wchar_t *a1, __int64 a2, char a3, char a4, const wchar_t *a5, unsigned int *a6);
WCHAR *__fastcall sub_140005CA8(wchar_t *Str, LPWIN32_FIND_DATAW lpFindFileData, HANDLE *a3);
WCHAR *__fastcall sub_140005E30(LPWIN32_FIND_DATAW lpFindFileData, HANDLE hFindFile);
void *__fastcall sub_140005E6C(wchar_t *a1, wchar_t *a2, struct _WIN32_FIND_DATAW *a3, HANDLE *a4);
char __fastcall sub_140005F9C(const wchar_t *a1, __int64 a2);
wint_t sub_14000613C();
wchar_t *sub_140006490();
const wchar_t *__fastcall sub_1400065F8(wchar_t *String1, char *a2);
char __fastcall sub_140006774(wchar_t *String1, __int64 a2, const wchar_t **a3);
void __fastcall sub_1400069A4(wchar_t *a1, char a2);
unsigned __int16 sub_140006B10();
char __fastcall sub_140006C34(wchar_t *a1);
wint_t *__fastcall sub_140006D18(wint_t *a1, int a2);
wchar_t *__fastcall sub_140006DAC(const wchar_t **a1);
char *__fastcall sub_140006EE0(char *a1, __int64 a2, char **a3);
errno_t __fastcall sub_140007294(void **a1, const wchar_t *a2);
int __fastcall sub_1400073BC(FILE *Stream, __int64 a2, const wchar_t **a3, char a4, _BYTE *a5);
char __fastcall sub_1400077D0(wchar_t *Src, void **a2, _QWORD *a3, char a4);
wint_t __fastcall sub_140007B64(char a1);
char __fastcall sub_140007BF0(wchar_t a1);
char __fastcall sub_140007CC8(wint_t a1, _DWORD *a2, unsigned __int64 a3);
char __fastcall sub_140007F84(__int64 a1, __int64 a2);
wint_t __fastcall sub_140008044(char a1);
__int64 __fastcall sub_140008128(wint_t a1, char a2);
wchar_t *__fastcall sub_1400081F0(char a1, __int64 a2, char *a3);
_WORD *__fastcall sub_140008874(_WORD *a1, unsigned __int64 a2);
char __fastcall sub_140008BCC(wchar_t *Src);
wchar_t *__fastcall sub_140009078(const wchar_t *a1);
char *__fastcall sub_14000918C(__int16 *a1);
void *__fastcall sub_140009214(size_t a1);
void *__fastcall sub_140009244(size_t Size);
void *__fastcall sub_140009274(void *a1, size_t a2);
__int64 __fastcall sub_1400092B4(wchar_t *Source, wchar_t *a2);
int __fastcall sub_1400098FC(__int64 a1, const wchar_t *a2, int a3, unsigned int *a4);
void __cdecl guard_check_icall_nop(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); // idb
bool sub_140009A74();
bool sub_140009AA8();
char __fastcall sub_140009B54(BYTE *lpDst);
char sub_140009C10();
__int64 __fastcall sub_140009C94(__int64 a1);
__int64 __fastcall TopLevelExceptionFilter(__int64 ExceptionInfo);
__int64 __fastcall sub_14000A1E0(struct _EXCEPTION_POINTERS *ExceptionInfo, __int64 a2, _OWORD *a3);
int __fastcall main(int argc, const char **argv, const char **envp);
wchar_t *sub_14000A944();
__int64 __fastcall sub_14000AB18(int a1, __int64 a2);
void __fastcall sub_14000B43C(unsigned int a1, __int64 a2);
__int16 __fastcall sub_14000B804(wint_t a1, char a2);
void __fastcall Function();
int sub_14000BB48();
_WORD *__fastcall sub_14000BB94(_WORD *a1);
__int64 __fastcall sub_14000BBEC(unsigned int a1);
void *sub_14000BD80();
// int swprintf(wchar_t *const Buffer, const size_t BufferCount, const wchar_t *const Format, ...);
void *sub_14000BDDC();
int sub_14000BDE4(wchar_t *Buffer, wchar_t *Format, ...);
bool __fastcall sub_14000BE34(FILE *a1);
int sub_14000BE7C(wchar_t *a1, ...);
__int64 sub_14000BEA4();
bool __fastcall sub_14000BEE0(FILE *Stream);
int __fastcall sub_14000BF3C(wchar_t *Format, va_list ArgList);
int sub_14000BFB0();
int sub_14000BFE0(wchar_t *a1, ...);
__int64 sub_14000C008();
int __fastcall sub_14000C044(wchar_t *Format, va_list ArgList);
char sub_14000C0B8();
unsigned __int64 __fastcall sub_14000C304(__int64 a1, __int64 a2);
int __fastcall sub_14000C33C(unsigned int a1, __int64 a2, FILETIME a3);
void __fastcall sub_14000C458(__int64 **a1, __int64 a2);
char __fastcall sub_14000C658(unsigned __int8 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_14000C914(unsigned __int8 a1);
wchar_t *sub_14000C958();
wchar_t *sub_14000C9E0();
int __fastcall sub_14000CAA0(char a1, __int64 a2);
wchar_t *sub_14000CB34();
int sub_14000CC64();
_OWORD *sub_14000CEE0();
char sub_14000CF64();
bool __fastcall sub_14000D180(wchar_t *a1);
char __fastcall sub_14000D1F8(wchar_t *a1, char a2);
_QWORD *__fastcall sub_14000D274(wchar_t *Block, rsize_t a2, wchar_t *a3, char *a4, LPWIN32_FIND_DATAW lpFindFileData);
void sub_14000D80C();
_QWORD *__fastcall sub_14000DA54(__int64 a1, wchar_t *a2, __int64 a3, unsigned __int64 a4, __int64 ***a5, __int64 ***a6, _DWORD *a7, FILETIME *a8, wchar_t **a9);
_QWORD *sub_14000DC58();
void *__fastcall sub_14000DCC4(_WORD *Src);
wchar_t *__fastcall sub_14000DD24(_WORD *a1, const wchar_t *a2);
__int64 __fastcall sub_14000DD88(wint_t *a1);
_QWORD *__fastcall sub_14000DDE0(wchar_t *Source);
char __fastcall sub_14000DFD0(_WORD *a1, __int64 **a2, _QWORD *a3, __int64 a4, int a5, int a6, char a7);
wchar_t *__fastcall sub_14000E6A4(const wchar_t *a1);
void *__fastcall sub_14000E740(const wchar_t *a1, char a2, _QWORD *a3);
char *__fastcall sub_14000EB78(const void **a1, char **a2, char **a3, unsigned __int64 *a4, const void *a5);
void __fastcall sub_14000EC20(const void **a1, const wchar_t **a2, char **a3, char **a4, unsigned __int64 *a5, int a6, const void *a7);
wchar_t *__fastcall sub_14000EFF8(__int16 a1, wchar_t *a2, rsize_t a3, const wchar_t *a4);
wchar_t *__fastcall sub_14000F188(const void **a1, const wchar_t **a2, char **a3, char **a4, wchar_t *String1, unsigned __int64 *a6, const void *a7);
void __fastcall sub_14000F300(const void **a1, wchar_t **a2, char **a3, char **a4, wchar_t *String1, unsigned __int64 *a6, const void *a7);
void *__fastcall sub_14000F570(const wchar_t *a1, const wchar_t *a2);
char __fastcall sub_14000F614(_WORD *a1);
char __fastcall sub_14000F778(char *a1, __int64 a2, unsigned __int16 *a3, const wchar_t *a4);
_QWORD *__fastcall sub_14000FAA4(wint_t *a1, __int64 a2, int a3);
int __fastcall sub_14000FB60(char *a1, char *a2);
_WORD *__fastcall sub_14000FCAC(char *a1);
FILE *__fastcall sub_14000FD2C(__int64 a1, const wchar_t *a2);
void *__fastcall sub_14000FD90(void *a1, unsigned __int64 a2);
WCHAR *__fastcall sub_14000FDE8(wchar_t *a1);
// void __fastcall __noreturn _report_rangecheckfailure(_QWORD); weak
void sub_140010754();
void *sub_14001078C();
void *sub_140010794();
__int64 __fastcall UserMathErrorFunction(struct _exception *a1);
__int64 sub_140010984();
void __fastcall sub_1400109D0();
void __cdecl j__guard_check_icall_nop(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); // idb
// void *__cdecl memset(void *, int Val, size_t Size);
__int64 sub_140010CA4();
char sub_140010CC8();
// void *__cdecl memcpy(void *, const void *Src, size_t Size);

//-------------------------------------------------------------------------
// Data declarations

// extern LSTATUS (__stdcall *RegQueryValueExW)(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern LSTATUS (__stdcall *RegOpenKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// extern HRSRC (__stdcall *FindResourceExW)(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage);
// extern HGLOBAL (__stdcall *LoadResource)(HMODULE hModule, HRSRC hResInfo);
// extern BOOL (__stdcall *NeedCurrentDirectoryForExePathW)(LPCWSTR ExeName);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern BOOL (__stdcall *GetExitCodeProcess)(HANDLE hProcess, LPDWORD lpExitCode);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *SetFileTime)(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *GetFileTime)(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
// extern UINT (__stdcall *GetTempFileNameW)(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern HMODULE (__stdcall *LoadLibraryExW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// extern DWORD (__stdcall *GetLastError)();
// extern DWORD (__stdcall *GetEnvironmentVariableW)(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern PVOID (__stdcall *EncodePointer)(PVOID Ptr);
// extern PVOID (__stdcall *DecodePointer)(PVOID Ptr);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern LANGID (__stdcall *GetUserDefaultUILanguage)();
// extern DWORD (__stdcall *GetVersion)();
// extern DWORD (__stdcall *ExpandEnvironmentStringsW)(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
// extern HANDLE (__stdcall *CreateFileMappingW)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
// extern LPVOID (__stdcall *MapViewOfFileEx)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress);
// extern HANDLE (__stdcall *CreateEventW)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// extern HANDLE (__stdcall *CreateMutexW)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern BOOL (__stdcall *DuplicateHandle)(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern BOOL (__stdcall *CreateProcessW)(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern BOOL (__stdcall *ReleaseMutex)(HANDLE hMutex);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern BOOL (__stdcall *UnmapViewOfFile)(LPCVOID lpBaseAddress);
// extern UINT (__stdcall *SetErrorMode)(UINT uMode);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern DWORD (__stdcall *GetFileType)(HANDLE hFile);
// extern BOOL (__stdcall *GetConsoleMode)(HANDLE hConsoleHandle, LPDWORD lpMode);
// extern BOOL (__stdcall *FileTimeToLocalFileTime)(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
// extern BOOL (__stdcall *FileTimeToSystemTime)(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
// extern int (__stdcall *GetDateFormatW)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate);
// extern int (__stdcall *GetTimeFormatW)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern wchar_t *(__cdecl *wcsstr)(const wchar_t *Str, const wchar_t *SubStr);
// extern wchar_t *(__cdecl *wcsrchr)(const wchar_t *Str, wchar_t Ch);
// extern void *(__cdecl *memmove)(void *, const void *Src, size_t Size);
// extern wchar_t *(__cdecl *wcschr)(const wchar_t *Str, wchar_t Ch);
// extern wint_t (__cdecl *putwch)(wchar_t Character);
// extern int (__cdecl *_conio_common_vcwprintf)(unsigned __int64 Options, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern errno_t (__cdecl *itow_s)(int Value, wchar_t *Buffer, size_t BufferCount, int Radix);
// extern unsigned int (__cdecl *wcstoul)(const wchar_t *String, wchar_t **EndPtr, int Radix);
// extern int (__cdecl *wcstol)(const wchar_t *String, wchar_t **EndPtr, int Radix);
// extern errno_t (__cdecl *wputenv_s)(const wchar_t *Name, const wchar_t *Value);
// extern errno_t (__cdecl *wdupenv_s)(wchar_t **Buffer, size_t *BufferCount, const wchar_t *VarName);
// extern errno_t (__cdecl *wgetenv_s)(size_t *RequiredCount, wchar_t *Buffer, size_t BufferCount, const wchar_t *VarName);
// extern int (__cdecl *wputenv)(const wchar_t *EnvString);
// extern void (__cdecl *wsearchenv)(const wchar_t *Filename, const wchar_t *VarName, wchar_t *ResultPath);
// extern wchar_t ***(__cdecl *_p__wenviron)();
// extern wchar_t *(__cdecl *wgetcwd)(wchar_t *DstBuf, int SizeInWords);
// extern int (__cdecl *chdrive)(int Drive);
// extern int (__cdecl *wchdir)(const wchar_t *Path);
// extern errno_t (__cdecl *waccess_s)(const wchar_t *FileName, int AccessMode);
// extern int (__cdecl *wunlink)(const wchar_t *FileName);
// extern int (__cdecl *waccess)(const wchar_t *FileName, int AccessMode);
// extern errno_t (__cdecl *wsplitpath_s)(const wchar_t *FullPath, wchar_t *Drive, size_t DriveCount, wchar_t *Dir, size_t DirCount, wchar_t *Filename, size_t FilenameCount, wchar_t *Ext, size_t ExtCount);
// extern errno_t (__cdecl *wmakepath_s)(wchar_t *Buffer, size_t BufferCount, const wchar_t *Drive, const wchar_t *Dir, const wchar_t *Filename, const wchar_t *Ext);
// extern void *(__cdecl *realloc)(void *Block, size_t Size);
// extern void *(__cdecl *malloc)(size_t Size);
// extern void (__cdecl *free)(void *Block);
// extern char *(__cdecl *setlocale)(int Category, const char *Locale);
// extern intptr_t (__cdecl *wspawnvp)(int Mode, const wchar_t *FileName, const wchar_t *const *ArgList);
// extern errno_t (__cdecl *wcserror_s)(wchar_t *Buffer, size_t SizeInWords, int ErrorNumber);
// extern unsigned int *(__cdecl *_doserrno)();
// extern void (__cdecl *invalid_parameter_noinfo)();
// extern _invalid_parameter_handler (__cdecl *set_invalid_parameter_handler)(_invalid_parameter_handler Handler);
// extern _crt_signal_t (__cdecl *signal)(int Signal, _crt_signal_t Function);
// extern wchar_t **(__cdecl *_p__wpgmptr)();
// extern int *(__cdecl *errno)();
// extern void (__cdecl __noreturn *exit)(int Code);
// extern int (__cdecl *_stdio_common_vfwprintf)(unsigned __int64 Options, FILE *Stream, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern wint_t (__cdecl *fputwc)(wchar_t Character, FILE *Stream);
// extern int (__cdecl *fflush)(FILE *Stream);
// extern intptr_t (__cdecl *get_osfhandle)(int FileHandle);
// extern int (__cdecl *fcloseall)();
// extern errno_t (__cdecl *wfopen_s)(FILE **Stream, const wchar_t *FileName, const wchar_t *Mode);
// extern int (__cdecl *_stdio_common_vswscanf)(unsigned __int64 Options, const wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern size_t (__cdecl *fwrite)(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// extern int (__cdecl *feof)(FILE *Stream);
// extern wint_t (__cdecl *ungetwc)(wint_t Character, FILE *Stream);
// extern wint_t (__cdecl *getwc)(FILE *Stream);
// extern int (__cdecl *dup)(int FileHandle);
// extern int (__cdecl *lseek)(int FileHandle, int Offset, int Origin);
// extern int (__cdecl *close)(int FileHandle);
// extern int (__cdecl *fileno)(FILE *Stream);
// extern int (__cdecl *dup2)(int FileHandleSrc, int FileHandleDst);
// extern errno_t (__cdecl *wsopen_s)(int *FileHandle, const wchar_t *FileName, int OpenFlag, int ShareFlag, int PermissionFlag);
// extern FILE *(__cdecl *wfsopen)(const wchar_t *FileName, const wchar_t *Mode, int ShFlag);
// extern wchar_t *(__cdecl *fgetws)(wchar_t *Buffer, int BufferCount, FILE *Stream);
// extern int (__cdecl *fclose)(FILE *Stream);
// extern FILE *(__cdecl *_acrt_iob_func)(unsigned int Ix);
// extern errno_t (__cdecl *wcsupr_s)(wchar_t *String, size_t Size);
// extern errno_t (__cdecl *wcsncat_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source, rsize_t MaxCount);
// extern int (__cdecl *wcsncmp)(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// extern errno_t (__cdecl *wcsncpy_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source, rsize_t MaxCount);
// extern int (__cdecl *wcsnicmp)(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// extern wint_t (__cdecl *towupper)(wint_t C);
// extern errno_t (__cdecl *wcscat_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// extern errno_t (__cdecl *wcscpy_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// extern int (__cdecl *iswalpha)(wint_t C);
// extern wchar_t *(__cdecl *wcstok_s)(wchar_t *String, const wchar_t *Delimiter, wchar_t **Context);
// extern int (__cdecl *iswdigit)(wint_t C);
// extern int (__cdecl *iswspace)(wint_t C);
// extern wchar_t *(__cdecl *wcspbrk)(const wchar_t *String, const wchar_t *Control);
// extern int (__cdecl *wcsicmp)(const wchar_t *String1, const wchar_t *String2);
// extern size_t (__cdecl *wcsspn)(const wchar_t *String, const wchar_t *Control);
_BYTE byte_140011640[128] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  0,
  0,
  0,
  2,
  2,
  0,
  2,
  2,
  2,
  2,
  0,
  0,
  0,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  2,
  2,
  2,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  2,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  2,
  0,
  2,
  0
}; // weak
wchar_t **off_140011770[12] =
{
  &off_1400118A0,
  &off_140011880,
  &off_140011868,
  &off_140011850,
  &off_140011838,
  &off_140011850,
  &off_140011838,
  &off_140011820,
  &off_140011808,
  &off_1400117F0,
  &off_1400117D8,
  &off_140011758
}; // weak
void *const off_140011900 = &aSuffixes_0; // idb
_BYTE byte_140011970[472] =
{
  1,
  64,
  64,
  64,
  1,
  64,
  64,
  2,
  1,
  1,
  1,
  8,
  1,
  15,
  16,
  1,
  64,
  64,
  64,
  64,
  64,
  64,
  2,
  1,
  1,
  1,
  8,
  1,
  15,
  39,
  33,
  34,
  33,
  33,
  33,
  34,
  34,
  1,
  3,
  33,
  1,
  33,
  33,
  33,
  33,
  33,
  32,
  33,
  33,
  36,
  36,
  32,
  33,
  33,
  36,
  4,
  33,
  33,
  33,
  33,
  33,
  32,
  33,
  33,
  5,
  32,
  32,
  33,
  33,
  1,
  4,
  33,
  33,
  33,
  33,
  6,
  6,
  37,
  6,
  6,
  6,
  32,
  6,
  6,
  35,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  6,
  6,
  6,
  37,
  6,
  6,
  37,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  37,
  7,
  7,
  1,
  7,
  7,
  7,
  7,
  7,
  8,
  64,
  8,
  8,
  8,
  8,
  64,
  9,
  8,
  8,
  8,
  8,
  18,
  8,
  8,
  33,
  34,
  33,
  33,
  33,
  34,
  34,
  8,
  10,
  33,
  8,
  33,
  33,
  33,
  33,
  33,
  32,
  33,
  33,
  36,
  10,
  32,
  33,
  33,
  36,
  11,
  33,
  33,
  33,
  33,
  33,
  32,
  33,
  33,
  12,
  32,
  32,
  33,
  33,
  8,
  11,
  33,
  33,
  33,
  33,
  13,
  13,
  37,
  13,
  13,
  13,
  32,
  13,
  13,
  35,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  14,
  13,
  13,
  13,
  37,
  13,
  13,
  37,
  13,
  13,
  13,
  13,
  13,
  14,
  14,
  14,
  14,
  14,
  14,
  37,
  14,
  14,
  8,
  14,
  14,
  14,
  14,
  14,
  1,
  64,
  64,
  64,
  64,
  64,
  64,
  2,
  1,
  1,
  1,
  8,
  1,
  1,
  1,
  16,
  16,
  16,
  16,
  16,
  16,
  38,
  2,
  16,
  16,
  16,
  8,
  16,
  15,
  17,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  1,
  64,
  64,
  64,
  64,
  64,
  64,
  2,
  1,
  1,
  1,
  8,
  1,
  15,
  16,
  0,
  0,
  0,
  1,
  2,
  1,
  3,
  1,
  2,
  64,
  4,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  3,
  1,
  2,
  64,
  4,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  3,
  1,
  2,
  64,
  4,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  0,
  4,
  1,
  1,
  1,
  1,
  1,
  1,
  33,
  33,
  33,
  33,
  33,
  34,
  34,
  1,
  5,
  33,
  1,
  1,
  1,
  1,
  33,
  33,
  33,
  33,
  33,
  36,
  32,
  33,
  33,
  36,
  6,
  11,
  8,
  6,
  33,
  33,
  33,
  33,
  9,
  32,
  32,
  33,
  33,
  2,
  6,
  34,
  34,
  6,
  33,
  33,
  33,
  33,
  9,
  32,
  32,
  33,
  33,
  2,
  34,
  34,
  34,
  34,
  33,
  33,
  33,
  33,
  9,
  32,
  32,
  33,
  33,
  2,
  34,
  34,
  34,
  7,
  10,
  10,
  37,
  10,
  10,
  10,
  32,
  10,
  10,
  37,
  10,
  10,
  10,
  10,
  10,
  10,
  12,
  10,
  10,
  10,
  32,
  10,
  10,
  35,
  10,
  10,
  10,
  10,
  33,
  33,
  33,
  33,
  9,
  32,
  32,
  33,
  33,
  2,
  34,
  8,
  34,
  7,
  12,
  12,
  12,
  12,
  12,
  12,
  32,
  12,
  12,
  2,
  12,
  12,
  12,
  12,
  0,
  0
}; // weak
__int64 (__fastcall *off_140011B50[6])() =
{
  &sub_140001000,
  &sub_140001044,
  &sub_140001968,
  &sub_14000169C,
  &sub_1400012A0,
  &sub_1400017F0
}; // weak
unsigned __int8 byte_140011B80[24] =
{
  1u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
unsigned __int8 byte_140011BA0[64] =
{
  34u,
  129u,
  1u,
  33u,
  37u,
  37u,
  32u,
  0u,
  33u,
  141u,
  15u,
  33u,
  33u,
  33u,
  33u,
  13u,
  39u,
  139u,
  10u,
  39u,
  33u,
  33u,
  33u,
  11u,
  39u,
  7u,
  8u,
  9u,
  33u,
  33u,
  33u,
  7u,
  3u,
  35u,
  35u,
  34u,
  3u,
  3u,
  4u,
  35u,
  6u,
  5u,
  5u,
  5u,
  5u,
  5u,
  36u,
  5u,
  17u,
  16u,
  17u,
  17u,
  33u,
  33u,
  33u,
  16u,
  39u,
  34u,
  34u,
  34u,
  18u,
  19u,
  33u,
  34u
}; // weak
void *off_140011BE0 = &unk_14001171E; // weak
_BYTE byte_140011CC0[32] =
{
  0,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  0,
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_BYTE byte_140011CE0[32] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  6,
  7,
  7,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  10,
  11,
  11,
  11,
  12,
  12,
  12,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_WORD word_140011DEC[2] = { 0, 0 }; // weak
const wchar_t asc_1400120A8[] = L"."; // idb
_UNKNOWN unk_1400120B4; // weak
wchar_t aDinsb[6] = L"dinsb"; // weak
_QWORD qword_140013438[2] = { 0i64, 0i64 }; // weak
_QWORD qword_140013448 = 0i64; // weak
char byte_140015040 = '\x01'; // weak
char byte_140015041 = '\x01'; // weak
char byte_140015042 = '\x01'; // weak
int dword_140015044 = -1; // weak
int dword_140015048 = -1; // weak
wchar_t aMakeflags_0[29] = L"MAKEFLAGS=                  "; // weak
wchar_t *off_140015090 = &word_140011DEC; // idb
wchar_t *off_140015098 = &word_140011DEC; // idb
wchar_t *off_1400150A0 = L"("; // weak
_UNKNOWN unk_1400151F0; // weak
union _SLIST_HEADER stru_1400157C0; // weak
__int64 qword_1400157E0; // weak
int dword_1400157E8; // weak
char byte_1400157EC; // weak
char byte_1400157ED; // weak
char byte_1400157EE; // weak
char byte_1400157EF; // weak
wchar_t *qword_1400157F0; // idb
__int64 qword_1400157F8; // weak
wchar_t Destination; // idb
wchar_t Str; // idb
_QWORD qword_140025800[128]; // weak
void *qword_140025C00; // idb
__int64 qword_140025C08; // weak
__int64 qword_140025C10; // weak
__int64 qword_140025C18; // weak
int dword_140025C20; // weak
int dword_140025C24; // weak
__int64 qword_140025C28; // weak
wchar_t *qword_140025C30; // idb
char byte_140025C38; // weak
char byte_140025C39; // weak
char byte_140025C3A; // weak
char byte_140025C3B; // weak
int dword_140025C3C; // weak
wchar_t *Block; // idb
__int64 qword_140025C48; // weak
wchar_t Src; // idb
wchar_t word_140025C52; // idb
__int16 word_14002644C; // weak
__int64 qword_140026450; // weak
__int64 qword_140026458; // weak
void *qword_140026460; // idb
__int64 qword_140026468; // weak
wchar_t *qword_140026470; // idb
__int64 qword_140026478; // weak
FILE *Stream; // idb
char byte_140026488; // weak
char byte_140026489; // weak
char byte_14002648A; // weak
char byte_14002648B; // weak
int dword_14002648C; // weak
void *qword_140026490; // idb
wchar_t *qword_140026498; // idb
wchar_t word_1400264A0[32768]; // weak
__int64 qword_1400364A0; // weak
__int64 qword_1400364A8; // weak
void *qword_1400364B0; // idb
void *qword_1400364B8; // idb
_BYTE byte_1400364C0[16]; // weak
_QWORD qword_1400364D0[256]; // weak
char byte_140036CD0[]; // weak
__int64 qword_140036CE0; // weak
int dword_140036CE8; // weak
char byte_140036CEC; // weak
char byte_140036CED; // weak
char byte_140036CEE; // weak
char byte_140036CEF; // weak
_UNKNOWN unk_140036CF0; // weak
_UNKNOWN unk_140036CF8; // weak
__int64 qword_140036E70; // weak
__int64 qword_140036E78; // weak
__int64 qword_140036E80; // weak
__int64 qword_140036E88; // weak
_UNKNOWN unk_140036E90; // weak
char byte_140037092; // weak
char byte_140037093; // weak
int dword_140037094; // weak
__int64 qword_140037098; // weak
HANDLE hObject; // idb
LPCVOID lpBaseAddress; // idb
char byte_1400370B0; // weak
char byte_1400370B1; // weak
char byte_1400370B2; // weak
char byte_1400370B3; // weak
__int128 xmmword_1400370B8; // weak
__int64 qword_1400370C8; // weak
__int64 qword_1400370D0; // weak
wchar_t *EndPtr; // idb
_UNKNOWN unk_1400370E0; // weak
_UNKNOWN unk_14003B0D0; // weak
unsigned __int8 byte_14003B0E0[8176]; // weak
_UNKNOWN unk_14003D0D0; // weak
__int64 qword_14003D0E0; // weak
__int64 qword_14003D0E8; // weak
__int64 qword_14003D0F0; // weak
struct _SECURITY_ATTRIBUTES MutexAttributes; // idb
char byte_14003D110; // weak
__int64 qword_14003D118; // weak
_UNKNOWN unk_14003D120; // weak
HANDLE hHandle; // idb
_UNKNOWN unk_14003D130; // weak
PVOID qword_14003D138; // idb
PVOID Ptr; // idb
wchar_t word_14003D150[1024]; // weak
WCHAR Dst[264]; // weak
wchar_t Buffer[264]; // weak
struct _STARTUPINFOW StartupInfo; // idb
HANDLE ProcessInformation; // idb
char byte_14003DDF0; // weak
__int64 qword_14003DDF8; // weak
__int16 word_14003DE00; // weak
_UNKNOWN unk_14003DE08; // weak
_UNKNOWN unk_14003DE10; // weak


//----- (0000000140001000) ----------------------------------------------------
wchar_t *sub_140001000()
{
  wchar_t *result; // rax

  sub_14000DFD0(&Src, (__int64 **)&qword_140025C48, 0i64, 0i64, 0, 0, 0);
  result = (wchar_t *)sub_14000DCC4(&Src);
  Block = result;
  return result;
}
// 140025C48: using guessed type __int64 qword_140025C48;

//----- (0000000140001044) ----------------------------------------------------
__int64 sub_140001044()
{
  _QWORD *v0; // rax
  char v1; // dl
  __int64 v2; // rbx
  wchar_t *v3; // rcx
  void *v4; // rax
  __int64 *v5; // rbx
  __int64 *v6; // rax
  __int64 v7; // rcx
  __int64 *v8; // rax
  __int64 *v9; // rcx
  __int64 result; // rax
  __int64 v11; // [rsp+50h] [rbp+8h] BYREF

  if ( Block )
  {
    byte_140025C38 |= 0x20u;
    sub_1400011B8();
    Block = 0i64;
  }
  if ( (byte_140025C38 & 0x20) != 0 && sub_14000F614(&Src) )
  {
    if ( (byte_140025C38 & 0x10) != 0 )
      sub_140003898(dword_140025C24, 0x444u);
    sub_140003898(dword_140025C24, 0x43Du);
  }
  v0 = sub_14000DC58();
  v1 = byte_140025C38;
  v2 = (__int64)v0;
  if ( (byte_140025C38 & 0x40) != 0 )
  {
    v3 = qword_140025C30;
    qword_140025C30 = 0i64;
    v0[1] = v3;
  }
  else
  {
    v4 = sub_14000DCC4(&Src);
    v1 = byte_140025C38;
    *(_QWORD *)(v2 + 8) = v4;
  }
  v11 = v2;
  if ( (v1 & 0x30) != 16 )
  {
    sub_14000DFD0(*(_WORD **)(v2 + 8), (__int64 **)&qword_140025C48, 0i64, 0i64, 0, 0, 0);
    v1 = byte_140025C38;
  }
  if ( (v1 & 0x20) != 0 )
  {
    v5 = (__int64 *)qword_140025C48;
    sub_140001474((wchar_t *)L"$", &v11, &qword_140025C48);
    sub_140001474((wchar_t *)L"*?", &v11, 0i64);
    qword_140025C48 = (__int64)v5;
    v6 = v5;
    if ( v5 )
    {
      v7 = qword_14003D0E0;
      do
      {
        v5 = (__int64 *)*v5;
        *v6 = v7;
        v7 = (__int64)v6;
        qword_140025C48 = (__int64)v5;
        v6 = v5;
      }
      while ( v5 );
      qword_14003D0E0 = v7;
    }
  }
  v8 = (__int64 *)qword_140025C28;
  v9 = &qword_140025C28;
  while ( v8 )
  {
    v9 = v8;
    v8 = (__int64 *)*v8;
  }
  result = v11;
  *v9 = v11;
  return result;
}
// 140025C24: using guessed type int dword_140025C24;
// 140025C28: using guessed type __int64 qword_140025C28;
// 140025C38: using guessed type char byte_140025C38;
// 140025C48: using guessed type __int64 qword_140025C48;
// 14003D0E0: using guessed type __int64 qword_14003D0E0;

//----- (00000001400011B8) ----------------------------------------------------
char sub_1400011B8()
{
  _QWORD *v0; // rax
  __int64 *v1; // rbx
  __int64 *v2; // rax
  __int64 v3; // rcx
  __int64 v4; // rcx

  byte_1400157EF = byte_1400157EE;
  v0 = sub_14000DC58();
  v0[1] = Block;
  v1 = (__int64 *)qword_140025C48;
  qword_140025C28 = (__int64)v0;
  sub_140001474((wchar_t *)L"$", &qword_140025C28, &qword_140025C48);
  sub_140001474((wchar_t *)L"*?", &qword_140025C28, 0i64);
  qword_140025C48 = (__int64)v1;
  v2 = v1;
  if ( v1 )
  {
    v3 = qword_14003D0E0;
    do
    {
      v1 = (__int64 *)*v1;
      *v2 = v3;
      v3 = (__int64)v2;
      qword_140025C48 = (__int64)v1;
      v2 = v1;
    }
    while ( v1 );
    qword_14003D0E0 = v3;
  }
  v4 = qword_140025C28;
  if ( qword_140025C28
    || (byte_140025C38 & 0x20) == 0
    && (LOBYTE(v2) = sub_140003898(dword_140025C20, 0x43Bu, Block), (v4 = qword_140025C28) != 0) )
  {
    LOBYTE(v2) = sub_14000F614(*(_WORD **)(v4 + 8));
    if ( (_BYTE)v2 )
      byte_140025C38 |= 0x10u;
  }
  return (char)v2;
}
// 1400157EE: using guessed type char byte_1400157EE;
// 1400157EF: using guessed type char byte_1400157EF;
// 140025C20: using guessed type int dword_140025C20;
// 140025C28: using guessed type __int64 qword_140025C28;
// 140025C38: using guessed type char byte_140025C38;
// 140025C48: using guessed type __int64 qword_140025C48;
// 14003D0E0: using guessed type __int64 qword_14003D0E0;

//----- (00000001400012A0) ----------------------------------------------------
void sub_1400012A0()
{
  char v0; // bl
  __int64 v1; // rdi
  _QWORD *v2; // rax
  __int64 v3; // rax

  if ( Block )
  {
    sub_1400011B8();
    Block = 0i64;
  }
  else
  {
    byte_140025C38 &= ~0x20u;
  }
  v0 = byte_1400157EF;
  if ( word_140025C52 )
  {
    v0 = byte_1400157EF | 0x20;
    byte_1400157EF |= 0x20u;
  }
  v1 = qword_140025C28;
  if ( !qword_140025C28 )
  {
    sub_140003898(dword_140025C24, 0x40Du);
    __debugbreak();
  }
  if ( (byte_140025C38 & 0x10) != 0 )
  {
    v2 = sub_140009244(0x30ui64);
    v2[2] = *(_QWORD *)(v1 + 8);
    *((_BYTE *)v2 + 40) = (v0 & 0x20) != 0;
    *v2 = qword_140025C00;
    qword_140025C00 = v2;
    if ( *v2 )
      *(_QWORD *)(*v2 + 8i64) = v2;
    goto LABEL_14;
  }
  if ( *(_QWORD *)qword_140025C28 )
  {
LABEL_16:
    qword_1400157E0 = v1;
    goto LABEL_17;
  }
  if ( !sub_1400013B0(*(wchar_t **)(qword_140025C28 + 8)) )
  {
    v1 = qword_140025C28;
    goto LABEL_16;
  }
  free(*(void **)(qword_140025C28 + 8));
LABEL_14:
  v3 = qword_14003D0E0;
  qword_14003D0E0 = qword_140025C28;
  *(_QWORD *)qword_140025C28 = v3;
LABEL_17:
  byte_140025C38 |= 0x80u;
  qword_140025C28 = 0i64;
}
// 1400157E0: using guessed type __int64 qword_1400157E0;
// 1400157EF: using guessed type char byte_1400157EF;
// 140025C24: using guessed type int dword_140025C24;
// 140025C28: using guessed type __int64 qword_140025C28;
// 140025C38: using guessed type char byte_140025C38;
// 14003D0E0: using guessed type __int64 qword_14003D0E0;

//----- (00000001400013B0) ----------------------------------------------------
char __fastcall sub_1400013B0(wchar_t *String1)
{
  const wchar_t *v1; // rdi
  char v2; // bl
  const wchar_t *v3; // rax
  int v4; // r8d
  int v5; // ecx
  char *v6; // rdx
  int v7; // ecx
  int v8; // eax

  v1 = String1;
  v2 = 0;
  if ( !wcsicmp(String1, L".SILENT") )
  {
    byte_140025C38 |= 2u;
    sub_14000B804(0x73u, 1);
    v2 = 1;
  }
  if ( !wcsicmp(v1, L".IGNORE") )
  {
    byte_140025C38 |= 4u;
    sub_14000B804(0x69u, 1);
    return 1;
  }
  v3 = v1;
  do
  {
    v4 = *(const wchar_t *)((char *)v3 + (char *)L".SUFFIXES" - (char *)v1);
    v5 = *v3 - v4;
    if ( v5 )
      break;
    ++v3;
  }
  while ( v4 );
  if ( !v5 )
  {
    byte_140025C38 |= 1u;
    return 1;
  }
  v6 = (char *)((char *)L".PRECIOUS" - (char *)v1);
  do
  {
    v7 = *(unsigned __int16 *)&v6[(_QWORD)v1];
    v8 = *v1 - v7;
    if ( v8 )
      break;
    ++v1;
  }
  while ( v7 );
  if ( !v8 )
  {
    byte_140025C38 |= 8u;
    return 1;
  }
  return v2;
}
// 140011708: using guessed type wchar_t aPrecious[10];
// 140011720: using guessed type wchar_t aSuffixes[10];
// 140025C38: using guessed type char byte_140025C38;

//----- (0000000140001474) ----------------------------------------------------
void __fastcall sub_140001474(wchar_t *Control, __int64 *a2, _QWORD *a3)
{
  __int64 v3; // rbx
  __int64 *v4; // rdi
  _WORD *v5; // r12
  void *v6; // r13
  _QWORD *v7; // rbp
  __int64 *v8; // rsi
  wchar_t *v11; // rcx
  _WORD *v12; // rbp
  __int64 *v13; // rax
  __int64 *v14; // rax
  __int64 *v15; // [rsp+68h] [rbp+10h]
  _WORD *v17; // [rsp+78h] [rbp+20h] BYREF

  v3 = *a2;
  v4 = 0i64;
  v5 = 0i64;
  v15 = 0i64;
  v6 = 0i64;
  v7 = a3;
  v8 = 0i64;
  while ( v3 )
  {
    if ( !wcspbrk(*(const wchar_t **)(v3 + 8), Control) )
      goto LABEL_26;
    v11 = *(wchar_t **)(v3 + 8);
    if ( *Control == 36 )
    {
      v5 = sub_14000E740(v11, 255, v7);
      free(*(void **)(v3 + 8));
LABEL_8:
      if ( v8 )
      {
        *v8 = *(_QWORD *)v3;
        *(_QWORD *)v3 = qword_14003D0E0;
        qword_14003D0E0 = v3;
        v3 = *v8;
      }
      else
      {
        *a2 = *(_QWORD *)v3;
        *(_QWORD *)v3 = qword_14003D0E0;
        qword_14003D0E0 = v3;
        v3 = *a2;
      }
      if ( *Control == 36 )
      {
        v17 = v5;
        while ( 1 )
        {
          v12 = sub_14000160C(&v17);
          if ( !v12 )
            break;
          v15 = sub_14000DC58();
          v4 = v15;
          v15[1] = (__int64)sub_14000DCC4(v12);
          *v15 = *a2;
          if ( !v8 )
            v8 = v15;
          *a2 = (__int64)v15;
        }
        free(v5);
        v7 = a3;
      }
      else
      {
        if ( v4 )
        {
          if ( !v8 )
          {
            v13 = (__int64 *)*v4;
            v8 = v4;
            while ( v13 )
            {
              v8 = v13;
              v13 = (__int64 *)*v13;
            }
          }
          do
          {
            v14 = v4;
            v4 = (__int64 *)*v4;
          }
          while ( v4 );
          *v14 = *a2;
          v4 = v15;
          *a2 = (__int64)v15;
        }
        free(v6);
      }
    }
    else
    {
      if ( !sub_14000F614(v11) )
      {
        v15 = (__int64 *)sub_14000FDE8(*(wchar_t **)(v3 + 8));
        v4 = v15;
        if ( v15 )
        {
          v6 = *(void **)(v3 + 8);
          goto LABEL_8;
        }
      }
LABEL_26:
      v8 = (__int64 *)v3;
      v3 = *(_QWORD *)v3;
    }
  }
}
// 14003D0E0: using guessed type __int64 qword_14003D0E0;

//----- (000000014000160C) ----------------------------------------------------
_WORD *__fastcall sub_14000160C(_WORD **a1)
{
  _WORD *i; // rcx
  __int16 v3; // ax
  _WORD *v4; // r8
  _WORD *result; // rax

  for ( i = *a1; *i == 32 || *i == 9; ++i )
    ;
  v3 = *i;
  v4 = i;
  if ( !*i )
    return 0i64;
  if ( v3 != 34 )
  {
    while ( v3 != 32 )
    {
      if ( v3 != 9 )
      {
        v3 = *++i;
        if ( *i )
          continue;
      }
      goto LABEL_14;
    }
    goto LABEL_18;
  }
  do
    ++i;
  while ( *i && *i != 34 );
LABEL_14:
  if ( *i != 32 && *i != 9 )
  {
    if ( *i == 34 )
    {
      if ( *++i )
        goto LABEL_18;
    }
    else if ( *i )
    {
      goto LABEL_19;
    }
    --i;
    goto LABEL_19;
  }
LABEL_18:
  *i = 0;
LABEL_19:
  result = v4;
  *a1 = i + 1;
  return result;
}

//----- (000000014000169C) ----------------------------------------------------
char __fastcall sub_14000169C(__int64 a1, wchar_t *a2)
{
  char v2; // al
  __int64 *v3; // rcx
  __int64 v4; // rbx
  __int64 *v5; // rcx
  const wchar_t *v6; // r8
  char result; // al

  v2 = byte_140025C38;
  if ( byte_140025C38 < 0 )
  {
    v2 = byte_140025C38 & 0x7F;
    byte_140025C38 &= ~0x80u;
  }
  if ( (v2 & 0x10) == 0 )
  {
    if ( (v2 & 6) != 0 )
    {
      if ( qword_140025C28 )
      {
        if ( (v2 & 2) != 0 )
        {
          v6 = L".SILENT";
        }
        else
        {
          v6 = L".IGNORE";
          if ( (v2 & 4) == 0 )
            v6 = 0i64;
        }
        sub_140003898(dword_140025C24, 0x442u, v6);
        goto LABEL_24;
      }
      goto LABEL_25;
    }
    if ( (v2 & 1) != 0 )
    {
      if ( !qword_140025C28 )
      {
        v3 = (__int64 *)qword_140025C18;
        v4 = qword_140025C18;
        if ( qword_140025C18 )
        {
          do
          {
            qword_140025C18 = *v3;
            free(*(void **)(v4 + 8));
            *(_QWORD *)v4 = qword_14003D0E0;
            v3 = (__int64 *)qword_140025C18;
            qword_14003D0E0 = v4;
            v4 = qword_140025C18;
          }
          while ( qword_140025C18 );
          goto LABEL_24;
        }
        goto LABEL_25;
      }
      v5 = &qword_140025C18;
    }
    else
    {
      if ( (v2 & 8) == 0 )
      {
        qword_140025C08 = (__int64)sub_140009244(0x30ui64);
        *(_QWORD *)qword_140025C08 = qword_140025C28;
        *(_QWORD *)(qword_140025C08 + 8) = qword_140025C48;
        goto LABEL_24;
      }
      if ( !qword_140025C28 )
        goto LABEL_25;
      v5 = &qword_140025C10;
    }
    sub_140001F10((wchar_t **)v5, a2);
    goto LABEL_24;
  }
  if ( qword_140025C28 )
  {
    sub_140003898(dword_140025C24, 0x43Eu);
LABEL_24:
    v2 = byte_140025C38;
  }
LABEL_25:
  result = v2 | 0x40;
  byte_140025C38 = result;
  qword_140025C28 = 0i64;
  qword_140025C48 = 0i64;
  return result;
}
// 140025C08: using guessed type __int64 qword_140025C08;
// 140025C10: using guessed type __int64 qword_140025C10;
// 140025C18: using guessed type __int64 qword_140025C18;
// 140025C24: using guessed type int dword_140025C24;
// 140025C28: using guessed type __int64 qword_140025C28;
// 140025C38: using guessed type char byte_140025C38;
// 140025C48: using guessed type __int64 qword_140025C48;
// 14003D0E0: using guessed type __int64 qword_14003D0E0;

//----- (00000001400017F0) ----------------------------------------------------
void sub_1400017F0()
{
  char v0; // di
  char v1; // si
  __int64 v2; // rbx
  __int64 v3; // rcx
  const wchar_t *v4; // r8

  v0 = 1;
  v1 = 1;
  if ( (byte_140025C38 & 0x10) != 0 )
  {
    *((_QWORD *)qword_140025C00 + 3) = qword_140025C28;
  }
  else if ( (byte_140025C38 & 0xF) != 0 )
  {
    if ( qword_140025C28 )
    {
      if ( (byte_140025C38 & 2) != 0 )
      {
        v4 = L".SILENT";
      }
      else if ( (byte_140025C38 & 4) != 0 )
      {
        v4 = L".IGNORE";
      }
      else if ( (byte_140025C38 & 8) != 0 )
      {
        v4 = L".PRECIOUS";
      }
      else
      {
        v4 = L".SUFFIXES";
        if ( (byte_140025C38 & 1) == 0 )
          v4 = 0i64;
      }
      sub_140003898(dword_140025C24, 0x441u, v4);
    }
  }
  else
  {
    v2 = qword_1400157E0;
    *(_QWORD *)(qword_140025C08 + 16) = qword_140025C28;
    *(_QWORD *)(qword_140025C08 + 24) = qword_140025C48;
    *(_BYTE *)(qword_140025C08 + 32) = byte_1400157EF;
    if ( v2 )
    {
      do
      {
        if ( sub_1400013B0(*(wchar_t **)(v2 + 8)) )
          sub_140003898(dword_140025C24, 0x445u);
        sub_140001DDC(*(wchar_t **)(v2 + 8), v1);
        if ( !qword_1400157F8 )
        {
          qword_1400157F8 = v2;
          v0 = 0;
        }
        v3 = *(_QWORD *)v2;
        qword_1400157E0 = *(_QWORD *)v2;
        if ( v0 )
        {
          *(_QWORD *)v2 = qword_14003D0E0;
          qword_14003D0E0 = v2;
        }
        v1 = 0;
        v2 = v3;
      }
      while ( v3 );
    }
  }
  qword_1400157E0 = 0i64;
  qword_140025C28 = 0i64;
  qword_140025C48 = 0i64;
  qword_140025C08 = 0i64;
  byte_140025C38 = 0;
}
// 140011708: using guessed type wchar_t aPrecious[10];
// 140011720: using guessed type wchar_t aSuffixes[10];
// 1400157E0: using guessed type __int64 qword_1400157E0;
// 1400157EF: using guessed type char byte_1400157EF;
// 1400157F8: using guessed type __int64 qword_1400157F8;
// 140025C08: using guessed type __int64 qword_140025C08;
// 140025C24: using guessed type int dword_140025C24;
// 140025C28: using guessed type __int64 qword_140025C28;
// 140025C38: using guessed type char byte_140025C38;
// 140025C48: using guessed type __int64 qword_140025C48;
// 14003D0E0: using guessed type __int64 qword_14003D0E0;

//----- (0000000140001968) ----------------------------------------------------
void sub_140001968()
{
  __int64 *v0; // rbx
  wchar_t *v1; // rdi
  __int64 *v2; // rcx
  __int64 v3; // rdx
  wchar_t *v4; // rbx
  wint_t v5; // ax
  char v6; // cl

  if ( wcschr(Block, 0x24u) )
  {
    v0 = (__int64 *)qword_140025C48;
    v1 = (wchar_t *)sub_14000E740(Block, 255, &qword_140025C48);
    if ( !*v1 )
      sub_140003898(dword_140025C24, 0x3ECu);
    qword_140025C48 = (__int64)v0;
    v2 = v0;
    if ( v0 )
    {
      v3 = qword_14003D0E0;
      do
      {
        v0 = (__int64 *)*v0;
        *v2 = v3;
        v3 = (__int64)v2;
        qword_140025C48 = (__int64)v0;
        v2 = v0;
      }
      while ( v0 );
      qword_14003D0E0 = v3;
    }
    free(Block);
    Block = v1;
  }
  v4 = Block;
  v5 = *Block;
  if ( *Block )
  {
    do
    {
      if ( v5 >= 0x80u )
        v6 = iswspace(v5) == 0;
      else
        v6 = byte_140011640[v5] & 1;
      if ( !v6 )
        break;
      v5 = *++v4;
    }
    while ( *v4 );
    if ( *v4 )
      sub_140003898(dword_140025C24, 0x3E9u, *v4);
  }
  byte_1400157ED = 1;
  if ( !sub_140001C2C(Block, qword_140025C30, 0) )
  {
    free(Block);
    free(qword_140025C30);
  }
  qword_140025C30 = 0i64;
  Block = 0i64;
}
// 140011640: using guessed type _BYTE byte_140011640[128];
// 1400157ED: using guessed type char byte_1400157ED;
// 140025C24: using guessed type int dword_140025C24;
// 140025C48: using guessed type __int64 qword_140025C48;
// 14003D0E0: using guessed type __int64 qword_14003D0E0;

//----- (0000000140001AC8) ----------------------------------------------------
char __fastcall sub_140001AC8(wchar_t *Name, wchar_t *Str, char a3)
{
  wint_t *i; // rbx
  char v7; // cl
  __int64 v9; // rbx
  wchar_t *v10; // rax
  __int64 v11; // rax
  wchar_t *v12; // rax
  wchar_t v13; // dx
  wchar_t *v14; // rbx
  wchar_t *v15; // r8
  wchar_t *v16; // rcx

  for ( i = Name; *i; ++i )
  {
    if ( *i >= 0x80u )
      v7 = iswspace(*i) == 0;
    else
      v7 = byte_140011640[*i] & 1;
    if ( !v7 )
      break;
  }
  if ( *i )
  {
    if ( (a3 & 4) != 0 )
      return 0;
    sub_140003898(dword_140025C24, 0x3E9u, *i);
  }
  if ( (a3 & 0x40) != 0 )
  {
    v9 = 0i64;
    v10 = wcschr(Str, 0x24u);
    if ( v10 )
    {
      do
      {
        ++v9;
        v10 = wcschr(v10 + 1, 0x24u);
      }
      while ( v10 );
      if ( v9 )
      {
        v11 = -1i64;
        do
          ++v11;
        while ( Str[v11] );
        v12 = (wchar_t *)sub_140009214(saturated_mul(v11 + v9 + 1, 2ui64));
        v13 = *Str;
        v14 = v12;
        v15 = Str;
        v16 = v12;
        while ( v13 )
        {
          *v16 = v13;
          ++v15;
          ++v16;
          if ( v13 == 36 )
            *v16++ = 36;
          v13 = *v15;
        }
        *v16 = 0;
        free(Str);
        Str = v14;
      }
    }
  }
  return sub_140001C2C(Name, Str, a3);
}
// 140011640: using guessed type _BYTE byte_140011640[128];
// 140025C24: using guessed type int dword_140025C24;

//----- (0000000140001C2C) ----------------------------------------------------
char __fastcall sub_140001C2C(wchar_t *Name, wchar_t *Str, char a3)
{
  char v6; // r15
  const wchar_t *v7; // rcx
  char *v8; // rax
  char v9; // al
  wchar_t *v11; // rax
  char *v12; // rax
  _QWORD *v13; // rbx
  char v14; // al
  _QWORD *v15; // rsi
  _QWORD *v16; // rcx
  char v17; // al
  char v18; // cl
  size_t RequiredCount; // [rsp+88h] [rbp+20h] BYREF

  RequiredCount = 0i64;
  v6 = 0;
  if ( (a3 & 2) != 0 )
  {
    if ( !*Str )
      goto LABEL_15;
    v7 = Str;
  }
  else
  {
    if ( !byte_1400157ED || (byte_1400157EC & 4) != 0 || wgetenv_s(&RequiredCount, 0i64, 0i64, Name) || !RequiredCount )
      goto LABEL_15;
    v8 = sub_14000918C((__int16 *)Name);
    if ( v8 )
    {
      v9 = v8[24];
      if ( (v9 & 2) != 0 || ((unsigned __int8)byte_1400157EC & (unsigned __int8)v9 & 4) != 0 )
        return 0;
    }
    v7 = Str;
  }
  v11 = sub_14000E6A4(v7);
  if ( wputenv_s(Name, v11) )
    sub_140003898(dword_140025C24, 0x41Fu);
LABEL_15:
  byte_1400157ED = 0;
  v12 = sub_14000918C((__int16 *)Name);
  v13 = v12;
  if ( v12 )
  {
    v14 = v12[24];
    if ( (v14 & 2) != 0 || ((unsigned __int8)byte_1400157EC & (unsigned __int8)v14 & 4) != 0 )
      return 0;
  }
  v15 = sub_14000DC58();
  v15[1] = Str;
  if ( v13 )
  {
    v6 = 1;
  }
  else
  {
    v13 = sub_140009244(0x20ui64);
    v13[1] = Name;
  }
  *((_BYTE *)v13 + 24) &= ~0x10u;
  *((_BYTE *)v13 + 24) |= a3;
  *v15 = v13[2];
  v13[2] = v15;
  if ( !v6 )
  {
    v16 = (_QWORD *)qword_140037098;
    qword_140037098 = 0i64;
    *v13 = *v16;
    *v16 = v13;
  }
  if ( (a3 & 0x40) == 0 && wcschr(Str, 0x24u) )
  {
    *((_BYTE *)v13 + 24) |= 1u;
    v17 = sub_14000DFD0(Str, 0i64, 0i64, (__int64)Name, 1, 0, a3);
    *((_BYTE *)v13 + 24) &= ~1u;
    if ( !v17 )
    {
      v18 = *((_BYTE *)v13 + 24) | 0x10;
      v13[2] = 0i64;
      *((_BYTE *)v13 + 24) = v18;
    }
  }
  return 1;
}
// 1400157EC: using guessed type char byte_1400157EC;
// 1400157ED: using guessed type char byte_1400157ED;
// 140025C24: using guessed type int dword_140025C24;
// 140037098: using guessed type __int64 qword_140037098;

//----- (0000000140001DDC) ----------------------------------------------------
void __fastcall sub_140001DDC(wchar_t *Block, char a2)
{
  _QWORD *v2; // rbx
  _QWORD *v5; // rax
  bool v6; // zf
  _QWORD *v7; // rdi
  _QWORD *v8; // rax
  _QWORD *v9; // rax
  _QWORD *v10; // rbx
  _QWORD *v11; // rax
  _QWORD *i; // rcx
  _BYTE *v13; // rbx
  __int64 v14; // rdx

  v2 = (_QWORD *)qword_140025C08;
  if ( !qword_140025C08 )
  {
    v2 = sub_140009244(0x30ui64);
    qword_140025C08 = (__int64)v2;
  }
  v5 = sub_140009244(0x10ui64);
  v6 = a2 == 0;
  v7 = v5;
  if ( v6 )
  {
    v8 = sub_140009244(0x30ui64);
    *v8 = *v2;
    v8[1] = v2[1];
    v8[2] = v2[2];
    v8[3] = v2[3];
    *((_BYTE *)v8 + 32) = *((_BYTE *)v2 + 32);
    v8[5] = v2[5];
    v7[1] = v8;
  }
  else
  {
    v5[1] = qword_140025C08;
  }
  v9 = sub_14000DDE0(Block);
  v10 = v9;
  if ( v9 )
  {
    if ( (((unsigned __int8)byte_1400157EF ^ *((_BYTE *)v9 + 16)) & 0x20) != 0 )
      sub_140003898(dword_140025C24, 0x43Fu);
    v11 = v10 + 4;
    for ( i = (_QWORD *)v10[4]; i; i = (_QWORD *)*i )
      v11 = i;
    *v11 = v7;
    free(Block);
  }
  else
  {
    *v7 = 0i64;
    v13 = sub_140009244(0x30ui64);
    v13[16] = byte_1400157EF;
    *((_QWORD *)v13 + 1) = Block;
    *((_QWORD *)v13 + 4) = v7;
    v14 = (unsigned int)sub_14000DD88(Block);
    *(_QWORD *)v13 = qword_140025800[v14];
    qword_140025800[v14] = v13;
  }
}
// 1400157EF: using guessed type char byte_1400157EF;
// 140025800: using guessed type _QWORD qword_140025800[128];
// 140025C08: using guessed type __int64 qword_140025C08;
// 140025C24: using guessed type int dword_140025C24;

//----- (0000000140001F10) ----------------------------------------------------
void **__fastcall sub_140001F10(wchar_t **a1, wchar_t *a2)
{
  void **result; // rax
  __int64 v3; // rbx
  _QWORD *v5; // rcx
  __int64 *v6; // rsi
  void *v7; // rax
  void *v8; // r15
  __int64 v9; // rdx
  __int64 *v10; // rcx
  wchar_t *i; // rcx
  _QWORD *v12; // rbp
  _QWORD *v13; // rdx
  wchar_t *v14; // rsi
  _QWORD *v15; // rdi
  void *retaddr; // [rsp+38h] [rbp+0h] BYREF
  wchar_t *Context; // [rsp+48h] [rbp+10h] BYREF

  result = &retaddr;
  Context = a2;
  v3 = qword_140025C28;
  while ( 1 )
  {
    v15 = (_QWORD *)v3;
    if ( !v3 )
      break;
    if ( wcschr(*(const wchar_t **)(v3 + 8), 0x24u) )
    {
      v6 = (__int64 *)qword_140025C48;
      v7 = sub_14000E740(*(const wchar_t **)(v3 + 8), 255, &qword_140025C48);
      v8 = v7;
      if ( v6 != (__int64 *)qword_140025C48 )
      {
        v9 = qword_14003D0E0;
        do
        {
          v10 = (__int64 *)*v6;
          *v6 = v9;
          v9 = (__int64)v6;
          v6 = v10;
        }
        while ( v10 != (__int64 *)qword_140025C48 );
        qword_14003D0E0 = v9;
      }
      Context = 0i64;
      i = (wchar_t *)v7;
      while ( 1 )
      {
        v14 = wcstok_s(i, L" \t", &Context);
        if ( !v14 )
          break;
        v12 = sub_14000DC58();
        v12[1] = sub_14000DCC4(v14);
        v13 = a1;
        for ( i = *a1; i; i = *(wchar_t **)i )
          v13 = i;
        *v13 = v12;
      }
      free(v8);
      free(*(void **)(v3 + 8));
      result = (void **)qword_14003D0E0;
      v3 = *(_QWORD *)v3;
      *v15 = qword_14003D0E0;
      qword_14003D0E0 = (__int64)v15;
    }
    else
    {
      v3 = *(_QWORD *)v3;
      v5 = a1;
      *v15 = 0i64;
      for ( result = (void **)*a1; result; result = (void **)*result )
        v5 = result;
      *v5 = v15;
    }
  }
  return result;
}
// 140025C28: using guessed type __int64 qword_140025C28;
// 140025C48: using guessed type __int64 qword_140025C48;
// 14003D0E0: using guessed type __int64 qword_14003D0E0;

//----- (0000000140002054) ----------------------------------------------------
__int64 __fastcall sub_140002054(wchar_t *a1, char a2, unsigned __int64 *a3)
{
  unsigned int v3; // eax
  unsigned int v4; // ebx
  __int64 *v6; // [rsp+58h] [rbp+20h] BYREF

  v6 = 0i64;
  v3 = sub_14000209C(a1, a2, a3, 0i64, (struct _FILETIME)&v6);
  v4 = v3;
  if ( v6 )
  {
    v4 = sub_1400030D8(v6) + v3;
    sub_140003278(&v6);
  }
  return v4;
}

//----- (000000014000209C) ----------------------------------------------------
__int64 __fastcall sub_14000209C(wchar_t *Src, char a2, unsigned __int64 *a3, wchar_t *a4, struct _FILETIME a5)
{
  char v9; // bp
  _QWORD *v10; // rbx
  void *v11; // rax
  int v12; // eax
  __int64 result; // rax

  ++dword_1400157E8;
  v9 = 1;
  v10 = sub_14000DDE0(Src);
  if ( !v10 )
  {
    v10 = sub_140009244(0x30ui64);
    v11 = sub_14000DCC4(Src);
    v10[3] = 0i64;
    v10[4] = 0i64;
    v10[1] = v11;
    *((_BYTE *)v10 + 16) = a2;
    *((_BYTE *)v10 + 17) = 0;
    v12 = sub_14000DD88(Src);
    v9 = 0;
    *v10 = qword_140025800[v12];
    qword_140025800[v12] = v10;
  }
  result = sub_140002160((__int64)v10, a2, a3, v9, a4, a5);
  --dword_1400157E8;
  return result;
}
// 1400157E8: using guessed type int dword_1400157E8;
// 140025800: using guessed type _QWORD qword_140025800[128];

//----- (0000000140002160) ----------------------------------------------------
__int64 __fastcall sub_140002160(__int64 a1, char a2, unsigned __int64 *a3, char a4, wchar_t *a5, struct _FILETIME a6)
{
  unsigned __int64 v6; // r13
  unsigned __int64 *v7; // r15
  __int64 **v11; // rsi
  unsigned int v12; // ebx
  unsigned __int64 v13; // rax
  char v14; // al
  _QWORD *v15; // rdx
  FILETIME ftLastWriteTime; // rbx
  wchar_t *v17; // rcx
  struct _FILETIME v18; // r12
  __int64 *v19; // rsi
  FILETIME *v20; // rax
  bool v21; // zf
  __int64 v22; // rdx
  __int64 v23; // r14
  __int64 v24; // r15
  int v25; // r12d
  __int64 *v26; // r15
  int v27; // eax
  __int64 v28; // r8
  unsigned __int64 v29; // rcx
  unsigned __int64 v30; // rax
  __int64 **v31; // rsi
  __int64 ***v32; // rcx
  __int64 **i; // rax
  __int64 **v34; // rsi
  __int64 ***v35; // rcx
  __int64 **j; // rax
  int v37; // r14d
  void *v38; // rsi
  __int64 v39; // rsi
  char v40; // r9
  _QWORD *v41; // rdx
  wchar_t *v42; // rcx
  __int64 **v43; // r15
  char v44; // al
  wchar_t *v45; // rax
  char v46; // si
  __int64 **v47; // r13
  __int64 v48; // r8
  unsigned __int64 v49; // rbx
  char v50; // al
  char v51; // al
  _QWORD *v52; // rax
  _QWORD *v53; // rax
  __int64 v54; // r10
  _QWORD *v55; // r11
  wchar_t *v56; // rcx
  __int64 **v57; // r12
  __int64 **v58; // rsi
  unsigned __int64 v59; // r13
  char v60; // r15
  const wchar_t *v61; // rax
  char v62; // al
  char v63; // al
  int v64; // [rsp+50h] [rbp-B0h] BYREF
  char v65; // [rsp+54h] [rbp-ACh]
  FILETIME ftCreationTime; // [rsp+58h] [rbp-A8h]
  __int64 *v67; // [rsp+60h] [rbp-A0h]
  __int64 **v68; // [rsp+68h] [rbp-98h] BYREF
  __int64 *v69; // [rsp+70h] [rbp-90h]
  wchar_t *v70; // [rsp+78h] [rbp-88h] BYREF
  unsigned __int64 v71; // [rsp+80h] [rbp-80h] BYREF
  __int64 **v72; // [rsp+88h] [rbp-78h]
  __int64 **v73; // [rsp+90h] [rbp-70h]
  _QWORD *v74; // [rsp+98h] [rbp-68h]
  __int64 **v75; // [rsp+A0h] [rbp-60h] BYREF
  unsigned __int64 v76; // [rsp+A8h] [rbp-58h] BYREF
  unsigned __int64 *v77; // [rsp+B0h] [rbp-50h]
  HANDLE v78; // [rsp+B8h] [rbp-48h] BYREF
  _QWORD *v79; // [rsp+C0h] [rbp-40h]
  __int64 *v80; // [rsp+C8h] [rbp-38h] BYREF
  wchar_t *v81; // [rsp+D0h] [rbp-30h]
  struct _FILETIME v82; // [rsp+D8h] [rbp-28h] BYREF
  unsigned __int64 *v83; // [rsp+E0h] [rbp-20h]
  _QWORD *v84; // [rsp+E8h] [rbp-18h]
  struct _FILETIME SystemTimeAsFileTime; // [rsp+F0h] [rbp-10h] BYREF
  struct _FILETIME *v86; // [rsp+F8h] [rbp-8h]
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+100h] [rbp+0h] BYREF
  __int16 v88[264]; // [rsp+350h] [rbp+250h] BYREF

  v6 = 0i64;
  v81 = a5;
  v7 = a3;
  v70 = a5;
  v82 = a6;
  v65 = a4;
  v77 = a3;
  v64 = 0;
  if ( !a1 )
  {
    *a3 = 0i64;
    return 0i64;
  }
  if ( (*(_BYTE *)(a1 + 17) & 1) != 0 )
    sub_140003898(0, 0x42Fu, *(_QWORD *)(a1 + 8));
  v11 = *(__int64 ***)(a1 + 40);
  if ( v11 )
  {
    v12 = sub_1400030D8(*v11);
    sub_140003278(v11);
    v13 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 40) = 0i64;
    *v7 = v13;
    return v12;
  }
  v14 = *(_BYTE *)(a1 + 17);
  if ( (v14 & 2) != 0 )
  {
    if ( (a2 & 1) != 0 )
      sub_14000C33C(2 * dword_1400157E8, *(_QWORD *)(a1 + 8), *(FILETIME *)(a1 + 24));
    *v7 = *(_QWORD *)(a1 + 24);
    if ( (byte_1400157EC & 8) == 0 && dword_1400157E8 == 1 && (*(_BYTE *)(a1 + 17) & 4) == 0 )
    {
      if ( sub_140005CA8(*(wchar_t **)(a1 + 8), &FindFileData, &v78) )
        sub_1400039C0(2u, *(_QWORD *)(a1 + 8));
    }
    return (*(unsigned __int8 *)(a1 + 17) >> 2) & 1;
  }
  v15 = *(_QWORD **)(a1 + 32);
  v72 = 0i64;
  v75 = 0i64;
  ftLastWriteTime = 0i64;
  v17 = *(wchar_t **)(a1 + 8);
  v18 = 0i64;
  qword_140026470 = v17;
  qword_140026478 = (__int64)v17;
  v73 = 0i64;
  v68 = 0i64;
  v79 = 0i64;
  v67 = 0i64;
  v69 = 0i64;
  ftCreationTime = 0i64;
  v71 = 0i64;
  v76 = 0i64;
  v83 = 0i64;
  v80 = 0i64;
  *(_BYTE *)(a1 + 17) = v14 | 1;
  v74 = v15;
  if ( v15 )
  {
    if ( (*(_BYTE *)(v15[1] + 32i64) & 0x20) != 0 )
    {
      if ( sub_140005CA8(v17, &FindFileData, &v78) )
      {
        if ( (FindFileData.dwFileAttributes & 0x10) == 0 || (ftLastWriteTime = FindFileData.ftCreationTime) == 0i64 )
          ftLastWriteTime = FindFileData.ftLastWriteTime;
      }
      v15 = v74;
    }
    while ( 1 )
    {
      v19 = (__int64 *)v15[1];
      v69 = v19;
      v20 = (FILETIME *)(v19 + 5);
      v21 = v19[5] == 0;
      v86 = (struct _FILETIME *)(v19 + 5);
      if ( v21 )
      {
        v22 = *(_QWORD *)(a1 + 8);
        v83 = (unsigned __int64 *)(v19 + 5);
        v84 = sub_140002B20(v19, v22);
        v23 = (__int64)v84;
        v24 = (__int64)v84;
        if ( v84 )
        {
          v25 = v64;
          v26 = v19;
          do
          {
            v71 = *(_QWORD *)(v23 + 16);
            v27 = sub_14000209C(*(wchar_t **)(v23 + 8), *((_BYTE *)v26 + 32), &v71, 0i64, (struct _FILETIME)&v80);
            v25 += v27;
            if ( byte_140025C3B && v27 )
            {
              if ( (*((_BYTE *)sub_14000DDE0(*(wchar_t **)(v23 + 8)) + 17) & 8) == 0 )
              {
                v28 = *(_QWORD *)(v23 + 8);
                byte_140015040 = 0;
                sub_140003898(0, 0xFAAu, v28);
              }
              *(_BYTE *)(a1 + 17) |= 8u;
            }
            v29 = v71;
            v30 = v71;
            if ( v6 > v71 )
              v30 = v6;
            v6 = v30;
            if ( !*(_QWORD *)&ftLastWriteTime && (v26[4] & 0x20) == 0 )
            {
              if ( sub_140005CA8(*(wchar_t **)(a1 + 8), &FindFileData, &v78) )
              {
                if ( (FindFileData.dwFileAttributes & 0x10) == 0
                  || (ftLastWriteTime = FindFileData.ftCreationTime) == 0i64 )
                {
                  ftLastWriteTime = FindFileData.ftLastWriteTime;
                }
                *(FILETIME *)(a1 + 24) = ftLastWriteTime;
              }
              v29 = v71;
            }
            if ( (*(_BYTE *)(a1 + 16) & 0x10) != 0
              || *(_QWORD *)&ftLastWriteTime < v29
              || byte_140025C3A && ftLastWriteTime == v29 )
            {
              v31 = (__int64 **)sub_14000DC58();
              v31[1] = (__int64 *)sub_14000DCC4(*(_WORD **)(v23 + 8));
              v32 = &v75;
              for ( i = v72; i; i = (__int64 **)*i )
                v32 = (__int64 ***)i;
              *v32 = v31;
              v72 = v75;
            }
            v34 = (__int64 **)sub_14000DC58();
            v34[1] = (__int64 *)sub_14000DCC4(*(_WORD **)(v23 + 8));
            v35 = &v68;
            for ( j = v73; j; j = (__int64 **)*j )
              v35 = (__int64 ***)j;
            *v35 = v34;
            v23 = *(_QWORD *)v23;
            v73 = v68;
          }
          while ( v23 );
          v24 = (__int64)v84;
          v64 = v25;
          v18 = ftCreationTime;
        }
        if ( v80 )
        {
          v37 = sub_1400030D8(v80) + v64;
          v64 = v37;
          sub_140003278(&v80);
        }
        else
        {
          v37 = v64;
        }
        while ( 1 )
        {
          v38 = (void *)v24;
          if ( !v24 )
            break;
          free(*(void **)(v24 + 8));
          v24 = *(_QWORD *)v24;
          free(v38);
        }
        v39 = (__int64)v69;
        v40 = *((_BYTE *)v69 + 32);
        if ( (v40 & 0x20) != 0 )
        {
          v41 = (_QWORD *)v69[2];
          if ( v41 )
          {
            v42 = *(wchar_t **)(a1 + 8);
            qword_140026458 = 0i64;
            qword_140026460 = 0i64;
            v43 = v73;
            qword_140026468 = (__int64)v72;
            v44 = byte_140025C3B;
            qword_140026470 = v42;
            qword_140026478 = (__int64)v42;
            qword_140026450 = (__int64)v73;
            if ( (byte_140025C3B && (*(_BYTE *)(a1 + 17) & 8) == 0 || !v37) && *(_QWORD *)&ftLastWriteTime < v6
              || byte_140025C3A && ftLastWriteTime == v6
              || !*(_QWORD *)&ftLastWriteTime && !v6
              || !*v69 )
            {
              v45 = v81;
              v46 = byte_140036CEC;
              byte_140036CEC = 1;
              if ( !v81 )
              {
                if ( v73 )
                  v45 = (wchar_t *)v73[1];
                else
                  v45 = 0i64;
                v70 = v45;
                v81 = v45;
              }
              v37 += sub_140003C94(v42, v41, v69[3], v40, v45);
              v21 = (*(_BYTE *)(a1 + 16) & 4) == 0;
              v64 = v37;
              if ( v21 && sub_140005CA8(*(wchar_t **)(a1 + 8), &FindFileData, &v78) )
              {
                if ( (FindFileData.dwFileAttributes & 0x10) == 0
                  || (ftCreationTime = FindFileData.ftCreationTime, !FindFileData.ftCreationTime.dwLowDateTime)
                  && !FindFileData.ftCreationTime.dwHighDateTime )
                {
                  ftCreationTime = FindFileData.ftLastWriteTime;
                }
                v18 = ftCreationTime;
              }
              else if ( v76 )
              {
                v18 = (struct _FILETIME)v76;
                ftCreationTime = (FILETIME)v76;
              }
              else
              {
                GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
                v18 = SystemTimeAsFileTime;
                ftCreationTime = SystemTimeAsFileTime;
              }
              v47 = v72;
              *v86 = v18;
              sub_140002F98(v43);
              if ( v43 != v47 )
                sub_140002F98(v47);
              byte_140036CEC = v46;
              v39 = (__int64)v69;
              v72 = 0i64;
              v75 = 0i64;
              v44 = byte_140025C3B;
              v73 = 0i64;
              v68 = 0i64;
            }
            if ( v44 )
            {
              if ( (*(_BYTE *)(a1 + 17) & 8) != 0 )
              {
                sub_140003898(0, 0xFABu, *(_QWORD *)(a1 + 8));
                *(_BYTE *)(a1 + 17) &= ~8u;
              }
              if ( v37 )
              {
                v48 = *(_QWORD *)(a1 + 8);
                v37 = 0;
                v64 = 0;
                byte_140015040 = 0;
                sub_140003898(0, 0xFAAu, v48);
              }
            }
          }
        }
        else
        {
          if ( v69[2] )
          {
            if ( v67 )
              sub_140003898(0, 0xFA4u, *(_QWORD *)(a1 + 8));
            else
              v67 = v69;
          }
          if ( v76 > v6 )
            v6 = v76;
          v76 = v6;
        }
        v15 = v74;
        if ( (*(_BYTE *)(v39 + 32) & 0x20) != 0 && !*v74 )
        {
          *(_BYTE *)(a1 + 17) &= ~1u;
          *(_BYTE *)(a1 + 17) |= 2u;
          v50 = *(_BYTE *)(a1 + 17);
          if ( v37 <= 0 )
            v51 = v50 & 0xFB;
          else
            v51 = v50 | 4;
          *(_BYTE *)(a1 + 17) = v51;
          v52 = v77;
          if ( *(_QWORD *)&v18 > *(unsigned __int64 *)&ftLastWriteTime )
            ftLastWriteTime = v18;
          *(FILETIME *)(a1 + 24) = ftLastWriteTime;
          *v52 = ftLastWriteTime;
          return (unsigned int)v37;
        }
      }
      else if ( *(unsigned __int64 *)&ftLastWriteTime <= *(_QWORD *)v20 )
      {
        ftLastWriteTime = *v20;
      }
      v15 = (_QWORD *)*v15;
      v6 = 0i64;
      v74 = v15;
      if ( !v15 )
      {
        v7 = v77;
        break;
      }
    }
  }
  v49 = *v7;
  qword_140026458 = 0i64;
  qword_140026460 = 0i64;
  if ( !v49 )
  {
    if ( *(_QWORD *)(a1 + 24) )
    {
      v49 = *(_QWORD *)(a1 + 24);
    }
    else if ( sub_140005CA8(*(wchar_t **)(a1 + 8), &FindFileData, &v78) )
    {
      if ( (FindFileData.dwFileAttributes & 0x10) == 0 || (v49 = (unsigned __int64)FindFileData.ftCreationTime) == 0 )
        v49 = (unsigned __int64)FindFileData.ftLastWriteTime;
    }
  }
  if ( (*(_BYTE *)(a1 + 16) & 1) != 0 )
    sub_14000C33C(2 * dword_1400157E8, *(_QWORD *)(a1 + 8), (FILETIME)v49);
  v53 = sub_14000DA54(a1, (wchar_t *)v88, (__int64)a3, v49, &v75, &v68, &v64, (FILETIME *)&v76, &v70);
  v54 = (__int64)v67;
  if ( !v53 || v67 )
  {
    v55 = v79;
  }
  else
  {
    v55 = (_QWORD *)v53[3];
    qword_140026460 = v88;
    v79 = v55;
  }
  v56 = *(wchar_t **)(a1 + 8);
  v57 = v75;
  v58 = v68;
  v37 = v64;
  qword_140026470 = v56;
  qword_140026478 = (__int64)v56;
  qword_140026468 = (__int64)v75;
  qword_140026450 = (__int64)v68;
  if ( (!byte_140025C3B || (*(_BYTE *)(a1 + 17) & 8) != 0) && v64
    || (v59 = v76, v49 >= v76) && (!byte_140025C3A || v49 != v76) && (v49 || v76) && (*(_BYTE *)(a1 + 16) & 0x10) == 0 )
  {
    if ( (byte_1400157EC & 8) == 0 && dword_1400157E8 == 1 && (*(_BYTE *)(a1 + 17) & 8) == 0 )
      sub_1400039C0(2u, v56);
    v59 = (unsigned __int64)ftCreationTime;
    goto LABEL_168;
  }
  v60 = byte_140036CEC;
  byte_140036CEC = 1;
  if ( v67 )
  {
    v61 = v70;
    if ( !v70 )
    {
      if ( v68 )
        v61 = (const wchar_t *)v68[1];
      else
        v61 = 0i64;
    }
    v37 += sub_140003C94(v56, (_QWORD *)v67[2], v67[3], *((_BYTE *)v67 + 32), v61);
    goto LABEL_155;
  }
  if ( v55 )
  {
    if ( !*((_BYTE *)v53 + 40) || (byte_1400157EC & 0x40) != 0 )
      v37 += sub_140003C94(v56, v55, v53[4], *(_BYTE *)(a1 + 16), v70);
    else
      sub_140002FE0(*(_QWORD **)&v82, (__int64)v53, a1);
    byte_140036CEC = v60;
    goto LABEL_157;
  }
  if ( (byte_1400157EC & 0x10) != 0 )
  {
    if ( v69 )
      v37 += sub_140003C94(v56, (_QWORD *)v69[2], v69[3], *((_BYTE *)v69 + 32), v70);
    goto LABEL_149;
  }
  if ( !v65 && !v49 )
  {
    if ( !byte_140025C3B )
    {
      sub_140003898(0, 0x431u, v56);
LABEL_155:
      v54 = (__int64)v67;
      goto LABEL_156;
    }
    v37 = 1;
LABEL_149:
    byte_140036CEC = v60;
    goto LABEL_158;
  }
LABEL_156:
  byte_140036CEC = v60;
  if ( v54 )
  {
LABEL_159:
    GetSystemTimeAsFileTime(&v82);
    v59 = *(_QWORD *)&v82 + 2i64;
    goto LABEL_160;
  }
LABEL_157:
  if ( v79 )
    goto LABEL_159;
LABEL_158:
  if ( !qword_140026450 )
    goto LABEL_159;
LABEL_160:
  v7 = v77;
  if ( v83 && v67 )
    *v83 = v59;
LABEL_168:
  if ( byte_140025C3B && v37 )
  {
    v21 = (*(_BYTE *)(a1 + 17) & 8) == 0;
    byte_140015040 = 0;
    if ( v21 )
    {
      if ( dword_1400157E8 == 1 )
        sub_140003898(0, 0xFAAu, *(_QWORD *)(a1 + 8));
    }
    else
    {
      sub_140003898(0, 0xFABu, *(_QWORD *)(a1 + 8));
    }
  }
  if ( (byte_1400157EC & 8) == 0 || dword_1400157E8 != 1 )
  {
    *(_BYTE *)(a1 + 17) &= ~1u;
    if ( !*(_QWORD *)(a1 + 40) )
    {
      v62 = *(_BYTE *)(a1 + 17) | 2;
      *(_BYTE *)(a1 + 17) = v62;
      if ( v37 <= 0 )
        v63 = v62 & 0xFB;
      else
        v63 = v62 | 4;
      *(_BYTE *)(a1 + 17) = v63;
    }
    if ( v59 > v49 )
      v49 = v59;
    *(_QWORD *)(a1 + 24) = v49;
    *v7 = v49;
    sub_140002F98(v58);
    if ( v58 != v57 )
      sub_140002F98(v57);
    return (unsigned int)v37;
  }
  sub_140002F98(v58);
  if ( v58 != v57 )
    sub_140002F98(v57);
  return (unsigned int)-(dword_140025C3C != 0);
}
// 14000282C: variable 'a3' is possibly undefined
// 140015040: using guessed type char byte_140015040;
// 1400157E8: using guessed type int dword_1400157E8;
// 1400157EC: using guessed type char byte_1400157EC;
// 140025C3A: using guessed type char byte_140025C3A;
// 140025C3B: using guessed type char byte_140025C3B;
// 140025C3C: using guessed type int dword_140025C3C;
// 140026450: using guessed type __int64 qword_140026450;
// 140026458: using guessed type __int64 qword_140026458;
// 140026468: using guessed type __int64 qword_140026468;
// 140026478: using guessed type __int64 qword_140026478;
// 140036CEC: using guessed type char byte_140036CEC;
// 140002160: using guessed type wchar_t var_250[264];

//----- (0000000140002B20) ----------------------------------------------------
_QWORD *__fastcall sub_140002B20(__int64 *a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rax
  _QWORD *v4; // r12
  __int16 *v5; // r14
  __int16 *v6; // rax
  __int16 v7; // cx
  wchar_t *v8; // rbx
  wchar_t v9; // ax
  wchar_t v10; // ax
  wchar_t *v11; // rsi
  wchar_t v12; // ax
  wchar_t *v13; // rdi
  char v14; // r13
  _WORD *v15; // r14
  const wchar_t *v16; // rsi
  void *v17; // rsi
  __int64 v18; // r15
  unsigned __int64 v19; // r15
  wchar_t *v20; // rax
  __int64 v21; // rax
  _QWORD *v22; // rcx
  _QWORD *v23; // rax
  __int64 *v24; // rax
  __int64 *v25; // rsi
  _QWORD *v27; // [rsp+28h] [rbp-E0h] BYREF
  HANDLE hFindFile; // [rsp+30h] [rbp-D8h] BYREF
  void *Block; // [rsp+38h] [rbp-D0h]
  __int64 v30; // [rsp+40h] [rbp-C8h]
  __int64 v31; // [rsp+48h] [rbp-C0h] BYREF
  void *v32; // [rsp+50h] [rbp-B8h]
  __int64 v33; // [rsp+58h] [rbp-B0h]
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+64h] [rbp-A4h] BYREF

  v2 = *a1;
  v3 = a1[1];
  v4 = 0i64;
  v33 = a2;
  v27 = 0i64;
  hFindFile = 0i64;
  v31 = v3;
  v30 = v2;
  if ( !v2 )
    return v4;
  do
  {
    v5 = *(__int16 **)(v2 + 8);
    Block = v5;
    v6 = v5;
    v7 = *v5;
    if ( *v5 )
    {
      do
      {
        if ( v7 == 36 )
          break;
        if ( v7 == 94 )
          ++v6;
        v7 = *++v6;
      }
      while ( *v6 );
      if ( *v6 )
      {
        qword_140026458 = a2;
        v5 = (__int16 *)sub_14000E740((const wchar_t *)v5, 1, &v31);
        Block = v5;
      }
    }
    v32 = sub_14000DCC4(v5);
    v8 = (wchar_t *)v32;
    while ( 1 )
    {
      while ( 1 )
      {
        v9 = *v8;
        if ( !*v8 || v9 != 32 && v9 != 9 )
          break;
        ++v8;
      }
      v10 = *v8;
      if ( !*v8 )
        break;
      v11 = v8;
      if ( v10 == 34 )
      {
        while ( v10 )
        {
          v10 = *++v8;
          if ( *v8 == 34 )
            goto LABEL_18;
        }
      }
      else
      {
        if ( v10 != 123 )
          goto LABEL_34;
        do
        {
          if ( *++v8 == 34 )
          {
            ++v8;
            do
            {
              v12 = *v8;
              if ( !*v8 )
                break;
              ++v8;
            }
            while ( v12 != 34 );
          }
        }
        while ( *v8 != 125 && *v8 );
        if ( !*v8 )
          sub_140003898(0, 0x423u);
        v10 = *++v8;
        if ( *v8 != 34 )
        {
LABEL_34:
          if ( v10 )
          {
            do
            {
              if ( *v8 == 32 )
                break;
              if ( *v8 == 9 )
                break;
              ++v8;
            }
            while ( *v8 );
          }
          goto LABEL_38;
        }
        while ( v10 )
        {
          v10 = *++v8;
          if ( *v8 == 34 )
          {
LABEL_18:
            if ( *v8 )
              goto LABEL_20;
            break;
          }
        }
      }
      sub_140003898(0, 0x40Eu);
LABEL_20:
      ++v8;
LABEL_38:
      if ( *v8 )
        *v8++ = 0;
      v13 = v11;
      if ( *v11 == 123 )
      {
        do
        {
          if ( *v13 == 125 )
            break;
          if ( *v13 == 94 )
            ++v13;
          ++v13;
        }
        while ( *v13 );
        if ( *v13 )
        {
          *v13++ = 0;
          ++v11;
        }
      }
      else
      {
        v11 = 0i64;
      }
      *(_QWORD *)&FindFileData.ftCreationTime.dwHighDateTime = 0i64;
      v14 = 0;
      *(_QWORD *)&FindFileData.ftLastWriteTime.dwHighDateTime = 0i64;
      v15 = sub_14000DCC4(v13);
      if ( wcspbrk(v13, L"*?") || v11 )
      {
        v16 = (const wchar_t *)sub_140005E6C(
                                 v11,
                                 v13,
                                 (struct _WIN32_FIND_DATAW *)&FindFileData.ftCreationTime,
                                 &hFindFile);
        if ( v16 )
        {
          v14 = 1;
          free(v15);
          v13 = (wchar_t *)v16;
          v15 = sub_14000F570(v16, &FindFileData.cFileName[2]);
        }
      }
      do
      {
        v17 = sub_140009244(0x18ui64);
        if ( !wcschr(v15, 0x20u) || wcschr(v15, 0x22u) )
        {
          *((_QWORD *)v17 + 1) = sub_14000DCC4(v15);
        }
        else
        {
          v18 = -1i64;
          do
            ++v18;
          while ( v15[v18] );
          v19 = v18 + 3;
          v20 = (wchar_t *)sub_140009214(saturated_mul(v19, 2ui64));
          *((_QWORD *)v17 + 1) = v20;
          wcscpy_s(v20, v19, L"\"");
          wcscat_s(*((wchar_t **)v17 + 1), v19, v15);
          wcscat_s(*((wchar_t **)v17 + 1), v19, L"\"");
        }
        if ( !byte_140025C39 || sub_140005CA8(v15, (LPWIN32_FIND_DATAW)&FindFileData.ftCreationTime, &hFindFile) )
        {
          if ( (FindFileData.ftCreationTime.dwLowDateTime & 0x10) == 0
            || (v21 = *(_QWORD *)&FindFileData.ftCreationTime.dwHighDateTime) == 0 )
          {
            v21 = *(_QWORD *)&FindFileData.ftLastWriteTime.dwHighDateTime;
          }
          *((_QWORD *)v17 + 2) = v21;
        }
        else
        {
          *((_QWORD *)v17 + 2) = 0i64;
        }
        if ( byte_140025C39 )
        {
          v22 = v4;
          v23 = v4;
          if ( !v4 )
            goto LABEL_71;
          do
          {
            if ( *((_QWORD *)v17 + 2) > v23[2] )
              break;
            v22 = v23;
            v23 = (_QWORD *)*v23;
          }
          while ( v23 );
          if ( v22 == v23 )
          {
LABEL_71:
            v4 = v17;
            v27 = v17;
          }
          else
          {
            *v22 = v17;
            *(_QWORD *)v17 = v23;
          }
        }
        else
        {
          v24 = (__int64 *)&v27;
          while ( v4 )
          {
            v24 = v4;
            v4 = (_QWORD *)*v4;
          }
          *v24 = (__int64)v17;
          v4 = v27;
        }
        free(v15);
        if ( !v14 )
          break;
        if ( !wcspbrk(v13, L"*?") )
          break;
        if ( !sub_140005E30((LPWIN32_FIND_DATAW)&FindFileData.ftCreationTime, hFindFile) )
          break;
        v15 = sub_14000F570(v13, &FindFileData.cFileName[2]);
      }
      while ( v15 );
    }
    v25 = (__int64 *)v30;
    if ( Block != *(void **)(v30 + 8) )
      free(Block);
    free(v32);
    v2 = *v25;
    a2 = v33;
    v30 = v2;
  }
  while ( v2 );
  return v4;
}
// 140025C39: using guessed type char byte_140025C39;
// 140026458: using guessed type __int64 qword_140026458;

//----- (0000000140002F98) ----------------------------------------------------
__int64 __fastcall sub_140002F98(_QWORD *a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rdi
  __int64 result; // rax

  if ( a1 )
  {
    v1 = a1;
    v2 = (__int64)a1;
    do
    {
      v1 = (_QWORD *)*v1;
      free(*(void **)(v2 + 8));
      result = qword_14003D0E0;
      *(_QWORD *)v2 = qword_14003D0E0;
      qword_14003D0E0 = v2;
      v2 = (__int64)v1;
    }
    while ( v1 );
  }
  return result;
}
// 14003D0E0: using guessed type __int64 qword_14003D0E0;

//----- (0000000140002FE0) ----------------------------------------------------
void *__fastcall sub_140002FE0(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rbx
  _QWORD *v4; // rsi
  _QWORD *v8; // rax
  _QWORD *v9; // rsi
  void *v10; // rax
  _QWORD *v11; // rdx
  _QWORD *i; // rcx
  _QWORD *v13; // rsi
  void *result; // rax
  _QWORD **v15; // rbx
  _QWORD *j; // rcx

  v3 = (_QWORD *)*a1;
  v4 = 0i64;
  if ( !*a1 )
    goto LABEL_6;
  do
  {
    if ( v3[1] == a2 && *((_BYTE *)v3 + 16) == *(_BYTE *)(a3 + 16) )
      break;
    v4 = v3;
    v3 = (_QWORD *)*v3;
  }
  while ( v3 );
  if ( !v3 )
  {
LABEL_6:
    v8 = sub_140009244(0x28ui64);
    v3 = v8;
    v8[1] = a2;
    *((_BYTE *)v8 + 16) = *(_BYTE *)(a3 + 16);
    if ( v4 )
    {
      *v4 = v8;
    }
    else if ( *a1 )
    {
      *(_QWORD *)*a1 = v8;
    }
    else
    {
      *a1 = v8;
    }
  }
  v9 = sub_14000DC58();
  v10 = sub_14000DCC4(*(_WORD **)(a3 + 8));
  v11 = v3 + 3;
  v9[1] = v10;
  for ( i = (_QWORD *)v3[3]; i; i = (_QWORD *)*i )
    v11 = i;
  *v11 = v9;
  v13 = sub_14000DC58();
  result = sub_14000DCC4(qword_140026460);
  v15 = (_QWORD **)(v3 + 4);
  v13[1] = result;
  for ( j = *v15; j; j = (_QWORD *)*j )
    v15 = (_QWORD **)j;
  *v15 = v13;
  *(_QWORD *)(a3 + 40) = a1;
  return result;
}

//----- (00000001400030D8) ----------------------------------------------------
__int64 __fastcall sub_1400030D8(__int64 *a1)
{
  __int64 *v1; // rbx
  unsigned int i; // ebp
  _QWORD *v3; // rdi
  __int64 v4; // rsi
  const wchar_t *v5; // rcx
  __int64 v6; // rax
  rsize_t v7; // r15
  wchar_t *v8; // rsi
  __int64 **j; // rdi
  const wchar_t *v10; // rcx
  char v11; // r14
  const wchar_t *v12; // r8
  __int64 v13; // rdx
  char v14; // r9
  __int64 **v15; // rcx
  int v16; // r14d
  __int64 **k; // rdi
  _QWORD *v18; // rax
  char v19; // cl

  v1 = a1;
  for ( i = 0; v1; i += v16 )
  {
    v3 = (_QWORD *)v1[4];
    v4 = 0i64;
    while ( v3 )
    {
      v5 = (const wchar_t *)v3[1];
      v6 = -1i64;
      do
        ++v6;
      while ( v5[v6] );
      v4 += v6 + 1;
      if ( *v5 != 34 && wcschr(v5, 0x20u) )
        v4 += 2i64;
      v3 = (_QWORD *)*v3;
    }
    v7 = v4 + 1;
    v8 = (wchar_t *)sub_140009214(saturated_mul(v4 + 1, 2ui64));
    *v8 = 0;
    for ( j = (__int64 **)v1[4]; j; j = (__int64 **)*j )
    {
      v10 = (const wchar_t *)j[1];
      if ( *v10 == 34 || !wcschr(v10, 0x20u) )
      {
        v11 = 0;
      }
      else
      {
        v11 = 1;
        wcscat_s(v8, v7, L"\"");
      }
      wcscat_s(v8, v7, (const wchar_t *)j[1]);
      v12 = L" ";
      if ( v11 )
        v12 = L"\" ";
      wcscat_s(v8, v7, v12);
    }
    v13 = v1[1];
    v14 = *((_BYTE *)v1 + 16);
    v15 = (__int64 **)v1[3];
    qword_140026460 = v8;
    v16 = sub_140003D14(v15, *(_QWORD **)(v13 + 24), *(_QWORD *)(v13 + 32), v14, 0i64);
    if ( !v16 )
    {
      for ( k = (__int64 **)v1[3]; k; k = (__int64 **)*k )
      {
        v18 = sub_14000DDE0((wchar_t *)k[1]);
        v19 = *((_BYTE *)v18 + 17) & 0xFB;
        v18[5] = 0i64;
        *((_BYTE *)v18 + 17) = v19 | 2;
      }
    }
    free(v8);
    v1 = (__int64 *)*v1;
  }
  return i;
}

//----- (0000000140003278) ----------------------------------------------------
void __fastcall sub_140003278(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *v3; // rdx
  void *v4; // rcx

  v1 = (_QWORD *)*a1;
  while ( v1 )
  {
    v3 = (_QWORD *)v1[3];
    v4 = v1;
    *v3 = qword_14003D0E0;
    qword_14003D0E0 = v1[4];
    *(_QWORD *)qword_14003D0E0 = v3;
    v1 = (_QWORD *)*v1;
    free(v4);
  }
  *a1 = 0i64;
}
// 14003D0E0: using guessed type __int64 qword_14003D0E0;

//----- (00000001400032C8) ----------------------------------------------------
wchar_t *__fastcall sub_1400032C8(void **a1, __int64 *a2)
{
  wchar_t *result; // rax
  __int64 v5; // rax
  __int64 v6; // rbp
  __int64 v7; // rax
  void *v8; // rsi
  __int64 v9; // rdx

  for ( result = (wchar_t *)*a1; *((_WORD *)*a1 + *a2 - 1) != 10; result = (wchar_t *)*a1 )
  {
    result = fgetws(&Src, 1024, Stream);
    if ( !result )
      break;
    v5 = -1i64;
    do
      ++v5;
    while ( *(&Src + v5) );
    if ( *(&Src + v5 - 2) == 92 && *(&Src + v5 - 1) == 10 )
      *(_DWORD *)(&Src + v5 - 2) = 32;
    v6 = *a2;
    v7 = -1i64;
    do
      ++v7;
    while ( *(&Src + v7) );
    *a2 += v7;
    v8 = sub_140009274(*a1, 2 * *a2 + 2);
    if ( !v8 )
      sub_140003898(dword_140025C20, 0x419u);
    v9 = *a2 - v6;
    *a1 = v8;
    wcscpy_s((wchar_t *)v8 + v6, v9 + 1, &Src);
  }
  return result;
}
// 140025C20: using guessed type int dword_140025C20;

//----- (00000001400033D0) ----------------------------------------------------
void *__fastcall sub_1400033D0(_WORD *Src, unsigned int a2, void **a3)
{
  __int64 v4; // rsi
  __int64 v6; // rdx
  void *v7; // rdi
  void *result; // rax

  v4 = a2;
  if ( *a3 )
  {
    if ( (a2 & 7) == 0 )
    {
      v6 = a2 + 8i64;
      v7 = 0i64;
      if ( (unsigned __int64)(v4 + 8) > 0x1FFFFFFFFFFFFFFEi64 || (v7 = realloc(*a3, 8 * v6)) == 0i64 )
        sub_140003898(dword_140025C24, 0x41Bu);
      *a3 = v7;
    }
  }
  else
  {
    *a3 = sub_140009214(0x40ui64);
  }
  result = sub_14000DCC4(Src);
  *((_QWORD *)*a3 + v4) = result;
  return result;
}
// 140025C24: using guessed type int dword_140025C24;

//----- (0000000140003468) ----------------------------------------------------
int __fastcall sub_140003468(const wchar_t *a1, unsigned int *a2, void **a3)
{
  wchar_t *v6; // rax
  wchar_t *i; // rcx
  wchar_t *v8; // rax
  wchar_t *Context; // [rsp+48h] [rbp+20h] BYREF

  v6 = wcschr(a1, 0x5Cu);
  if ( v6 && (*(v6 - 1) == 32 || *(v6 - 1) == 9) && v6[1] == 10 )
    *v6 = 0;
  Context = 0i64;
  for ( i = (wchar_t *)a1; ; i = 0i64 )
  {
    v8 = wcstok_s(i, L" \t\n", &Context);
    if ( !v8 )
      break;
    if ( *v8 == 64 )
    {
      LODWORD(v8) = sub_140003898(0, 0xFA1u, v8 + 1);
      return (int)v8;
    }
    sub_1400033D0(v8, *a2, a3);
    ++*a2;
  }
  return (int)v8;
}

//----- (0000000140003510) ----------------------------------------------------
void __fastcall sub_140003510(const wchar_t *a1, unsigned int *a2, void **a3)
{
  wchar_t *v6; // rax
  wchar_t *v7; // rbx
  __int64 v8; // r8
  wchar_t *v9; // rax
  wchar_t *i; // rbx
  __int64 v11; // rsi
  char *v12; // rdi
  char *v13; // rcx
  __int16 v14; // ax
  __int64 v15; // rsi
  wchar_t *v16; // [rsp+20h] [rbp-28h] BYREF
  __int64 v17[4]; // [rsp+28h] [rbp-20h] BYREF
  char v19; // [rsp+68h] [rbp+20h]

  v19 = 0;
  v6 = wcschr(a1, 0x22u);
  v7 = v6;
  if ( v6 )
  {
    v8 = 1i64;
    if ( v6 == a1 || (v9 = v6 - 1, *v9 != 61) )
    {
      *v7 = 0;
      i = v7 + 1;
      v16 = i;
      sub_140003468(a1, a2, a3);
    }
    else
    {
      *v7 = 32;
      for ( i = v9; i > a1; --i )
      {
        if ( *i == 32 )
          break;
        if ( (unsigned __int16)(*i - 9) <= 1u )
          break;
      }
      if ( i != a1 )
      {
        *i++ = 0;
        sub_140003468(a1, a2, a3);
      }
      v16 = i;
    }
    v11 = -1i64;
    do
      ++v11;
    while ( i[v11] );
    v12 = (char *)i;
    if ( *i )
    {
      do
      {
        if ( *(_WORD *)v12 == 34 )
        {
          if ( *((_WORD *)v12 + 1) != 34 )
          {
            *(_WORD *)v12 = 0;
            v12 += 2;
            sub_1400033D0(i, *a2, a3);
            ++*a2;
            sub_140003510(v12 + 2, a2, a3);
            break;
          }
          v13 = v12;
          *(_WORD *)v12 = 34;
          do
          {
            v13 += 2;
            v14 = *((_WORD *)v13 + 1);
            *(_WORD *)v13 = v14;
          }
          while ( v14 );
        }
        else if ( *(_WORD *)v12 == 92
               && (*((_WORD *)v12 - 1) == 32 || *((_WORD *)v12 - 1) == 9)
               && *((_WORD *)v12 + 1) == 10 )
        {
          v15 = v11 - 2;
          *(_WORD *)v12 = 0;
          v17[0] = v15;
          if ( !v19 )
          {
            v19 = 1;
            v16 = (wchar_t *)sub_14000DCC4(i);
          }
          sub_1400032C8((void **)&v16, v17);
          i = v16;
          v12 = (char *)&v16[v15];
          v11 = v17[0];
        }
        v12 += 2;
      }
      while ( *(_WORD *)v12 );
    }
    if ( v12 == (char *)&i[v11] )
      sub_140003898(0, 0x3EEu, v8);
    if ( v19 )
      free(i);
  }
  else
  {
    sub_140003468(a1, a2, a3);
  }
}
// 1400036C6: variable 'v8' is possibly undefined
// 140003510: using guessed type __int64 var_20[4];

//----- (00000001400036EC) ----------------------------------------------------
void __fastcall sub_1400036EC(const wchar_t *a1)
{
  unsigned int v1; // ebx
  FILE *v3; // rax
  char *v4; // rdi
  __int64 v5; // rax
  unsigned __int64 v6; // rdx
  wchar_t *v7; // rbx
  void **v8; // rdi
  char *v9; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v10; // [rsp+78h] [rbp+48h] BYREF
  __int64 v11; // [rsp+80h] [rbp+50h] BYREF
  void *Block; // [rsp+88h] [rbp+58h] BYREF

  v1 = 0;
  v10 = 0;
  v3 = wfsopen(a1, L"rt,ccs=unicode", 32);
  Stream = v3;
  if ( !v3 )
  {
    sub_140003898(0, 0x41Cu, a1);
    __debugbreak();
  }
  v9 = 0i64;
  v4 = 0i64;
  if ( fgetws(&Src, 1024, v3) )
  {
    do
    {
      v5 = -1i64;
      do
        ++v5;
      while ( *(&Src + v5) );
      v11 = v5;
      if ( v5 == 1023 && word_14002644C != 10 || *(&Src + v5 - 1) == 10 && *(&Src + v5 - 2) == 92 )
      {
        if ( *(&Src + v5 - 1) == 10 && *(&Src + v5 - 2) == 92 )
        {
          v6 = 2 * (v5 - 1);
          if ( v6 >= 0x800 )
            _report_rangecheckfailure(v5 - 1);
          *(wchar_t *)((char *)&Src + v6) = 0;
          *(&Src + v5 - 2) = 32;
          v11 = v5 - 1;
        }
        Block = sub_14000DCC4(&Src);
        sub_1400032C8(&Block, &v11);
        v7 = (wchar_t *)Block;
      }
      else
      {
        v7 = &Src;
      }
      sub_140003510(v7, &v10, (void **)&v9);
      if ( v7 != &Src )
        free(v7);
    }
    while ( fgetws(&Src, 1024, Stream) );
    v1 = v10;
    v4 = v9;
  }
  if ( fclose(Stream) == -1 )
    sub_140003898(0, 0x424u, a1);
  sub_14000B43C(v1, (__int64)v4);
  if ( v1 )
  {
    v8 = (void **)&v4[8 * v1];
    do
    {
      --v8;
      --v1;
      if ( *v8 )
        free(*v8);
    }
    while ( v1 );
  }
}
// 14001025C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD);
// 14002644C: using guessed type __int16 word_14002644C;

//----- (0000000140003898) ----------------------------------------------------
int sub_140003898(unsigned int a1, unsigned int a2, ...)
{
  int v2; // ebx
  int result; // eax
  wchar_t *v5; // rax
  FILE *v6; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, a2);
  v2 = 2;
  if ( (byte_1400157EC & 0x20) == 0 || (result = 274877907 * a2, a2 / 0x3E8 != 4) )
  {
    sub_140003A8C();
    if ( a1 )
      sub_14000BE7C(L"%s(%u) : ", qword_140026490, a1);
    else
      sub_14000BE7C(L"NMAKE : ");
    switch ( a2 / 0x3E8 )
    {
      case 1u:
        sub_1400039C0(0x14u);
        if ( a2 == 1051 )
          v2 = 4;
        break;
      case 2u:
        sub_1400039C0(0x15u);
        break;
      case 4u:
        sub_1400039C0(0x16u);
        break;
    }
    sub_14000BE7C(L" U%04d: ", a2);
    v5 = (wchar_t *)sub_14000BBEC(a2);
    sub_14000BF3C(v5, va);
    result = sub_14000BEA4();
    if ( !byte_140037093 )
    {
      v6 = _acrt_iob_func(2u);
      result = fflush(v6);
    }
    if ( a2 / 0x3E8 == 1 )
    {
      sub_14000BE7C(L"Stop.\n");
      sub_14000BB48();
      exit(v2);
    }
  }
  return result;
}
// 140011D48: using guessed type wchar_t aSU[10];
// 140011D60: using guessed type wchar_t aNmake[9];
// 140011D78: using guessed type wchar_t aU04d[9];
// 140011D90: using guessed type wchar_t aStop[7];
// 1400157EC: using guessed type char byte_1400157EC;
// 140037093: using guessed type char byte_140037093;

//----- (00000001400039C0) ----------------------------------------------------
int sub_1400039C0(unsigned int a1, ...)
{
  void **v1; // rax
  char v2; // bl
  unsigned int v3; // ecx
  wchar_t *v4; // rcx
  FILE *v5; // rax
  void *retaddr; // [rsp+38h] [rbp+0h] BYREF
  va_list va; // [rsp+48h] [rbp+10h] BYREF

  va_start(va, a1);
  v1 = &retaddr;
  v2 = 1;
  if ( a1 == 13 || (byte_1400157EC & 0x20) == 0 )
  {
    sub_140003A8C();
    v3 = a1;
    if ( a1 - 20 <= 5 )
      v2 = 0;
    if ( a1 == 24 )
    {
      if ( v2 )
        sub_14000C008();
      else
        sub_14000BEA4();
      v3 = a1;
    }
    v4 = (wchar_t *)sub_14000BBEC(v3);
    if ( v2 )
      sub_14000C044(v4, va);
    else
      sub_14000BF3C(v4, va);
    LODWORD(v1) = a1 - 10;
    if ( a1 - 10 > 0xD && a1 != 124 )
    {
      if ( v2 )
        LODWORD(v1) = sub_14000C008();
      else
        LODWORD(v1) = sub_14000BEA4();
    }
    if ( v2 )
    {
      LODWORD(v1) = sub_14000BFB0();
    }
    else if ( !byte_140037093 )
    {
      v5 = _acrt_iob_func(2u);
      LODWORD(v1) = fflush(v5);
    }
  }
  return (int)v1;
}
// 1400157EC: using guessed type char byte_1400157EC;
// 140037093: using guessed type char byte_140037093;

//----- (0000000140003A8C) ----------------------------------------------------
void sub_140003A8C()
{
  FILE *v0; // rax

  if ( !byte_140026488 )
  {
    byte_140026488 = 1;
    sub_1400039C0(0x18u, L"14.00.23506.0");
    sub_1400039C0(0x19u);
    if ( !byte_140037093 )
    {
      v0 = _acrt_iob_func(2u);
      fflush(v0);
    }
  }
}
// 140011DA0: using guessed type wchar_t a1400235060[14];
// 140026488: using guessed type char byte_140026488;
// 140037093: using guessed type char byte_140037093;

//----- (0000000140003AE0) ----------------------------------------------------
size_t __fastcall sub_140003AE0(_DWORD *a1, const wchar_t **a2, wchar_t *a3)
{
  size_t result; // rax
  wchar_t *v4; // rbx
  char v7; // bp
  wchar_t *i; // rdi
  const wchar_t *v9; // rbx
  void *retaddr; // [rsp+38h] [rbp+0h] BYREF

  result = (size_t)&retaddr;
  v4 = a3;
  v7 = 1;
  for ( i = a3; *i; ++i )
    ;
  *a1 = 0;
  if ( a3 < i )
  {
    while ( 1 )
    {
      result = wcsspn(v4, L" \t");
      v9 = &v4[result];
      if ( v9 >= i )
        goto LABEL_36;
      if ( a2 )
        *a2++ = v9;
      if ( *v9 == 34 )
        break;
      result = (size_t)wcspbrk(v9, L" \t\"/");
      v4 = (wchar_t *)result;
      if ( result )
      {
        do
        {
          if ( v4 >= i )
            break;
          if ( *v4 != 47 )
            break;
          if ( v7 )
            break;
          result = (size_t)wcspbrk(v4 + 1, L" \t\"/");
          v4 = (wchar_t *)result;
        }
        while ( result );
        if ( v4 && *v4 == 34 )
        {
          do
            ++v4;
          while ( v4 < i && *v4 != 34 );
          result = (size_t)wcspbrk(v4, L" \t");
          v4 = (wchar_t *)result;
        }
      }
      if ( !v7 )
        goto LABEL_31;
      v7 = 0;
      if ( v4 )
      {
        if ( *v4 == 47 && a2 )
        {
          *v4 = 0;
          result = (size_t)sub_14000DCC4(*(a2 - 1));
          *(a2 - 1) = (const wchar_t *)result;
          *v4-- = 47;
        }
        goto LABEL_31;
      }
LABEL_32:
      v4 = i;
LABEL_33:
      if ( a2 )
        *v4++ = 0;
LABEL_35:
      ++*a1;
      if ( v4 >= i )
        goto LABEL_36;
    }
    v4 = (wchar_t *)(v9 + 1);
    if ( v4 >= i )
      goto LABEL_35;
    do
    {
      if ( *v4 == 92 )
      {
        ++v4;
      }
      else if ( *v4 == 34 )
      {
        break;
      }
      ++v4;
    }
    while ( v4 < i );
    if ( v4 >= i )
      goto LABEL_35;
    result = (size_t)wcspbrk(v4 + 1, L" \t");
    v4 = (wchar_t *)result;
LABEL_31:
    if ( v4 )
      goto LABEL_33;
    goto LABEL_32;
  }
LABEL_36:
  if ( a2 )
    *a2 = 0i64;
  return result;
}

//----- (0000000140003C94) ----------------------------------------------------
__int64 __fastcall sub_140003C94(_WORD *Src, _QWORD *a2, __int64 a3, char a4, const wchar_t *a5)
{
  __int64 **v9; // r14
  __int64 result; // rax

  v9 = (__int64 **)sub_14000DC58();
  v9[1] = (__int64 *)sub_14000DCC4(Src);
  result = sub_140003D14(v9, a2, a3, a4, a5);
  *v9 = (__int64 *)qword_14003D0E0;
  qword_14003D0E0 = (__int64)v9;
  return result;
}
// 14003D0E0: using guessed type __int64 qword_14003D0E0;

//----- (0000000140003D14) ----------------------------------------------------
__int64 __fastcall sub_140003D14(__int64 **a1, _QWORD *a2, __int64 a3, char a4, const wchar_t *a5)
{
  unsigned int v5; // ebx
  _QWORD *v7; // r10
  __int64 **v8; // rdi
  bool v9; // si
  __int64 v10; // rbx
  wchar_t *v11; // rax
  __int16 *v12; // rdx
  __int16 v13; // ax
  __int16 *v14; // rcx
  HANDLE FileW; // rax
  void *v16; // rbx
  bool v18; // al
  char v19; // r15
  char v20; // di
  wchar_t *v21; // rcx
  _WORD *v22; // rdx
  int v23; // ebx
  __int64 v24; // rdx
  const wchar_t *v25; // r12
  wchar_t *v26; // rbx
  wchar_t *v27; // rax
  wchar_t *v28; // r14
  unsigned int v29; // ecx
  wchar_t *i; // rax
  wchar_t *v31; // rax
  __int64 v32; // rax
  unsigned __int64 v33; // rax
  unsigned __int64 v34; // rbx
  wchar_t *v35; // r13
  char v36; // r15
  char v37; // r12
  bool v38; // r8
  bool v39; // dl
  unsigned int v40; // eax
  bool v41; // [rsp+40h] [rbp-30h]
  unsigned int v42; // [rsp+44h] [rbp-2Ch] BYREF
  unsigned int v43; // [rsp+48h] [rbp-28h]
  wchar_t *Str; // [rsp+50h] [rbp-20h] BYREF
  __int64 v45; // [rsp+58h] [rbp-18h] BYREF
  struct _FILETIME SystemTimeAsFileTime; // [rsp+60h] [rbp-10h] BYREF
  wchar_t *v47; // [rsp+68h] [rbp-8h]
  _QWORD *v48; // [rsp+B8h] [rbp+48h]
  __int64 v49; // [rsp+C0h] [rbp+50h] BYREF

  v49 = a3;
  v48 = a2;
  ++dword_140025C3C;
  v5 = 0;
  v42 = 0;
  v43 = 0;
  v7 = a2;
  v8 = a1;
  if ( (byte_1400157EC & 8) != 0 )
    return 0i64;
  if ( (byte_1400157EC & 0x10) != 0 )
  {
    if ( a1 )
    {
      v9 = (a4 & 4) != 0;
      do
      {
        v10 = (__int64)v8[1];
        if ( *(_WORD *)v10 == 34 )
        {
          v11 = wcsrchr((const wchar_t *)v8[1], 0x22u);
          v12 = (__int16 *)(v10 + 2);
          *v11 = 0;
          v13 = *(_WORD *)(v10 + 2);
          *(_WORD *)v10 = v13;
          while ( v13 )
          {
            v14 = v12++;
            v13 = *v12;
            *v14 = *v12;
          }
        }
        sub_1400039C0(5u, v10);
        if ( !v9 )
        {
          GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
          FileW = CreateFileW((LPCWSTR)v10, 0x100u, 0, 0i64, 3u, 0x80u, 0i64);
          v16 = FileW;
          if ( FileW != (HANDLE)-1i64 )
          {
            SetFileTime(FileW, 0i64, 0i64, &SystemTimeAsFileTime);
            CloseHandle(v16);
          }
        }
        v8 = (__int64 **)*v8;
      }
      while ( v8 );
    }
    return 0i64;
  }
  if ( !a2 )
    goto LABEL_92;
  v18 = (a4 & 0x40) != 0;
  v41 = v18;
  while ( 2 )
  {
    v19 = sub_1400077D0((wchar_t *)v7[1], (void **)&SystemTimeAsFileTime, &v49, v18);
    dword_14002648C = 0;
    v20 = 0;
    Str = (wchar_t *)SystemTimeAsFileTime;
    v21 = (wchar_t *)SystemTimeAsFileTime;
    v22 = (_WORD *)SystemTimeAsFileTime;
    v23 = *(unsigned __int16 *)SystemTimeAsFileTime.dwLowDateTime;
    if ( (_WORD)v23 )
    {
      do
      {
        if ( *v22 == 94 || *v22 == 36 )
          ++v22;
        ++v22;
      }
      while ( *v22 );
    }
    while ( 1 )
    {
      if ( (unsigned __int16)(v23 - 9) > 0x37u
        || (v24 = 0x80001001800001i64, !_bittest64(&v24, (unsigned int)(v23 - 9))) )
      {
        if ( (_WORD)v23 != 94 )
          break;
      }
      switch ( (unsigned __int16)v23 )
      {
        case '!':
          v20 |= 4u;
          goto LABEL_45;
        case '-':
          v20 |= 2u;
          Str = v21 + 1;
          if ( iswdigit(v21[1]) )
          {
            v28 = Str;
            dword_14002648C = wcstoul(Str, &Str, 10);
            if ( *errno() == 34 )
            {
              v29 = dword_140025C20;
              *Str = 0;
              sub_140003898(v29, 0x436u, v28);
            }
            for ( i = Str; iswspace(*i); i = ++Str )
              ;
          }
          else
          {
            dword_14002648C = -1;
          }
          v21 = --Str;
LABEL_45:
          if ( (_WORD)v23 == 94 )
            goto LABEL_30;
          goto LABEL_46;
        case '@':
          if ( (byte_1400157EE & 4) == 0 )
            v20 |= 1u;
          goto LABEL_45;
      }
      if ( (unsigned __int16)v23 != 94 )
        goto LABEL_45;
      Str = ++v21;
      if ( *v21 != 32 && *v21 != 9 )
        break;
LABEL_46:
      Str = ++v21;
      v23 = *v21;
    }
LABEL_30:
    v25 = a5;
    if ( (v20 & 4) != 0 )
    {
      if ( sub_1400059E0(v21, v49, a4, v20, a5, &v42) )
      {
        v26 = Str;
        if ( wcschr(Str, 0x24u) )
        {
          v27 = (wchar_t *)sub_14000E740(Str, 255, &v49);
          Str = v27;
        }
        else
        {
          v27 = Str;
        }
        if ( v26 != v27 )
          free(v27);
        v5 = v42;
        if ( (a4 & 2) != 0 || !byte_140025C3B || !v42 || v42 <= dword_14002648C )
          goto LABEL_91;
        break;
      }
      v21 = Str;
    }
    v47 = v21;
    if ( !v19 )
    {
      v31 = wcschr(v21, 0x24u);
      v21 = Str;
      if ( v31 )
      {
        v21 = (wchar_t *)sub_14000E740(Str, 255, &v49);
        Str = v21;
      }
    }
    v32 = -1i64;
    do
      ++v32;
    while ( v21[v32] );
    v33 = v32 + 1;
    v34 = 0x8000i64;
    if ( v33 > 0x8000 )
      v34 = v33;
    v35 = (wchar_t *)sub_140009214(saturated_mul(v34, 2ui64));
    wcscpy_s(v35, v34, Str);
    if ( sub_14000F778((char *)v35, v34, Str, v25) )
      sub_140003898(0, 0x447u, Str);
    v36 = a4 & 4;
    v37 = a4 & 2;
    while ( 1 )
    {
      v38 = !v36 || (v20 & 8) != 0;
      v39 = v36 || (a4 & 8) == 0 && (v20 & 1) == 0;
      v40 = sub_140005114(v35, v39, v38, (v20 & 2) != 0, (void **)&v45);
      v42 = v40;
      v5 = v40;
      if ( v37 )
        break;
      if ( v40 != 259 )
        goto LABEL_81;
      if ( !byte_140036CED )
      {
        sub_140003898(0, 0xFACu, v45);
        v5 = 0;
        v42 = 0;
LABEL_81:
        if ( !v5 )
          break;
LABEL_82:
        if ( v5 > dword_14002648C && !byte_140025C3B )
          sub_140003898(0, 0x435u, v45, v5);
        break;
      }
      if ( v43 >= 0xA )
        goto LABEL_82;
      sub_140003898(0, 0xFADu, v45);
      ++v43;
    }
    if ( v47 != Str )
      free(Str);
    free(*(void **)&SystemTimeAsFileTime);
    free(v35);
    if ( v37 || !byte_140025C3B || !v5 || v5 <= dword_14002648C )
    {
LABEL_91:
      v18 = v41;
      v7 = (_QWORD *)*v48;
      v48 = v7;
      if ( !v7 )
        break;
      continue;
    }
    break;
  }
LABEL_92:
  if ( (a4 & 2) != 0 || !byte_140025C3B || v5 <= dword_14002648C )
    return 0i64;
  return v5;
}
// 1400157EC: using guessed type char byte_1400157EC;
// 1400157EE: using guessed type char byte_1400157EE;
// 140025C20: using guessed type int dword_140025C20;
// 140025C3B: using guessed type char byte_140025C3B;
// 140025C3C: using guessed type int dword_140025C3C;
// 14002648C: using guessed type int dword_14002648C;
// 140036CED: using guessed type char byte_140036CED;

//----- (0000000140004288) ----------------------------------------------------
wchar_t *sub_140004288()
{
  wchar_t *v0; // rbx
  wchar_t *v1; // rdi
  wchar_t v3; // ax
  __int64 v4; // rsi
  char *v5; // rcx
  wchar_t v6; // ax
  wchar_t v7; // ax
  __int64 v8; // rax
  wchar_t *v9; // r14
  wchar_t *v10; // r14
  __int64 v11; // rax
  wchar_t *v12; // rbx
  wchar_t *Source; // [rsp+20h] [rbp-E0h] BYREF
  __int16 v14[257]; // [rsp+30h] [rbp-D0h] BYREF
  char v15; // [rsp+232h] [rbp+132h] BYREF
  wchar_t Destination[4]; // [rsp+240h] [rbp+140h] BYREF
  wchar_t v17; // [rsp+248h] [rbp+148h] BYREF
  __int16 v18[8]; // [rsp+10240h] [rbp+10140h] BYREF

  Source = 0i64;
  wcscpy_s(Destination, 0x8000ui64, L"set ");
  v0 = &Str;
  v1 = &v17;
  while ( *v0 == 32 || *v0 == 9 )
    ++v0;
  if ( !wcschr(v0, 0x3Du) )
    return word_140011DEC;
  while ( 1 )
  {
    v3 = *v0;
    if ( *v0 == 61 )
      break;
    *v1++ = v3;
    if ( v1 >= (wchar_t *)v18 )
      return 0i64;
    ++v0;
  }
  v4 = -1i64;
  while ( 1 )
  {
    if ( v3 == 94 )
    {
      v3 = v0[1];
      if ( !v3 )
        goto LABEL_36;
      v0 += 2;
      goto LABEL_14;
    }
    ++v0;
    if ( v3 == 37 )
      break;
LABEL_14:
    *v1++ = v3;
    if ( v1 >= (wchar_t *)v18 )
      return 0i64;
LABEL_15:
    v3 = *v0;
    if ( !*v0 )
      goto LABEL_36;
  }
  v5 = (char *)v14;
  while ( 1 )
  {
    v6 = *v0;
    if ( *v0 == 37 || !v6 )
      break;
    *(_WORD *)v5 = v6;
    v5 += 2;
    if ( v5 == &v15 )
      return 0i64;
    ++v0;
  }
  v7 = *v0++;
  *(_WORD *)v5 = 0;
  if ( v7 )
  {
    wdupenv_s(&Source, 0i64, (const wchar_t *)v14);
    v8 = -1i64;
    if ( Source )
    {
      do
        ++v8;
      while ( Source[v8] );
      v9 = &v1[v8];
      if ( v9 >= (wchar_t *)v18 )
        return 0i64;
      wcscpy_s(v1, ((char *)v18 - (char *)v1) >> 1, Source);
      v1 = v9;
      free(Source);
      Source = 0i64;
    }
    else
    {
      do
        ++v8;
      while ( v14[v8] );
      v10 = &v1[v8 + 2];
      if ( v10 >= (wchar_t *)v18 )
        return 0i64;
      *v1 = 37;
      wcscpy_s(v1 + 1, ((char *)v18 - (char *)(v1 + 1)) >> 1, (const wchar_t *)v14);
      *(v10 - 1) = 37;
      v1 = v10;
    }
    goto LABEL_15;
  }
  v11 = -1i64;
  do
    ++v11;
  while ( v14[v11] );
  v12 = &v1[v11 + 1];
  if ( v12 < (wchar_t *)v18 )
  {
    *v1 = 37;
    wcscpy_s(v1 + 1, ((char *)v18 - (char *)(v1 + 1)) >> 1, (const wchar_t *)v14);
    v1 = v12;
LABEL_36:
    *v1 = 0;
    wcscpy_s(&::Destination, 0x8000ui64, Destination);
    v17 = 0;
    do
      ++v4;
    while ( Destination[v4] );
    return &::Destination + v4;
  }
  return 0i64;
}
// 140011DEC: using guessed type _WORD word_140011DEC[2];
// 140004288: using guessed type wchar_t var_20[8];
// 140004288: using guessed type wchar_t var_10230[257];

//----- (0000000140004564) ----------------------------------------------------
_WORD *__fastcall sub_140004564(wchar_t *Str)
{
  _WORD *v2; // rsi
  wchar_t *v3; // rax
  wchar_t *v4; // rdi
  wchar_t *v5; // rax
  wchar_t *v6; // r14
  wchar_t *v7; // rbx
  wchar_t *v8; // rax
  __int64 v9; // rax
  wchar_t *Buffer; // [rsp+50h] [rbp+8h] BYREF

  v2 = sub_14000DCC4(word_140011DEC);
  while ( *Str )
  {
    v3 = wcschr(Str, 0x25u);
    v4 = v3;
    if ( v3 && (v5 = wcschr(v3 + 1, 0x25u), (v6 = v5) != 0i64) )
    {
      *v4 = 0;
      *v5 = 0;
      Buffer = 0i64;
      v7 = sub_14000DD24(v2, Str);
      wdupenv_s(&Buffer, 0i64, v4 + 1);
      if ( Buffer )
      {
        v2 = sub_14000DD24(v7, Buffer);
        free(Buffer);
        Buffer = 0i64;
      }
      else
      {
        *v4 = 37;
        v8 = sub_14000DD24(v7, v4);
        v2 = sub_14000DD24(v8, L"%");
      }
      *v4 = 37;
      Str = v6 + 1;
      *v6 = 37;
    }
    else
    {
      v2 = sub_14000DD24(v2, Str);
      v9 = -1i64;
      do
        ++v9;
      while ( Str[v9] );
      Str += v9;
    }
  }
  return v2;
}
// 140011DEC: using guessed type _WORD word_140011DEC[2];
// 140011DF0: using guessed type wchar_t asc_140011DF0[2];

//----- (0000000140004690) ----------------------------------------------------
char __fastcall sub_140004690(int a1, wint_t **a2, int *a3)
{
  wint_t *v3; // rbx
  wint_t *v5; // r14
  wint_t **v7; // r15
  wint_t v8; // ax
  char result; // al
  wchar_t *v10; // rax
  const wchar_t *v11; // rax
  int v12; // eax
  wchar_t *v13; // rbx
  wint_t *v14; // rcx
  wint_t *v15; // rdx
  wint_t v16; // r8
  wchar_t *v17; // rcx
  wchar_t *v18; // rbx

  v3 = *a2;
  v5 = a2[1];
  v7 = a2;
  if ( iswalpha(**a2) && v3[1] == 58 && !v3[2] )
  {
    v8 = towupper(*v3);
    chdrive(v8 - 64);
    result = 1;
    *a3 = 0;
    return result;
  }
  if ( !wcsicmp(v3, L"set") )
  {
    if ( a1 != 1 )
    {
      if ( Destination )
      {
        v10 = sub_140004288();
        if ( v10 )
        {
          if ( *v10 )
          {
            v11 = (const wchar_t *)sub_14000DCC4(v10);
            v12 = wputenv(v11);
            *a3 = v12;
            if ( v12 == -1 )
              sub_140003898(dword_140025C24, 0x41Fu);
            goto LABEL_39;
          }
        }
      }
    }
    return 0;
  }
  if ( wcsnicmp(v3, L"cd", 2ui64) )
  {
    if ( wcsnicmp(v3, L"chdir", 5ui64) )
      return 0;
    v13 = v3 + 5;
  }
  else
  {
    v13 = v3 + 2;
  }
  if ( a1 > 2 )
    return 0;
  while ( a1 )
  {
    v14 = *v7;
    --a1;
    v15 = *v7;
    if ( **v7 )
    {
      while ( 1 )
      {
        v16 = *v15;
        if ( ((*v15 - 92) & 0xFFFD) == 0 )
          break;
        if ( v16 != 34 )
        {
          *v14 = v16;
LABEL_25:
          ++v14;
        }
        if ( !*++v15 )
          goto LABEL_27;
      }
      if ( v15[1] == 34 )
      {
        *v14 = v16;
        ++v15;
        ++v14;
      }
      *v14 = *v15;
      goto LABEL_25;
    }
LABEL_27:
    *v14 = 0;
    ++v7;
  }
  if ( *v13 || !v5 )
  {
    if ( (unsigned __int16)(*v13 - 46) > 1u && *v13 != 92 )
      return 0;
    v17 = v13;
  }
  else
  {
    if ( iswalpha(*v5) && v5[1] == 58 && !v5[2] )
      return 0;
    v17 = v5;
  }
  v18 = sub_140004564(v17);
  *a3 = wchdir(v18);
  free(v18);
LABEL_39:
  if ( *a3 )
    *a3 = 1;
  return 1;
}
// 140025C24: using guessed type int dword_140025C24;

//----- (00000001400048B4) ----------------------------------------------------
bool __fastcall sub_1400048B4(wchar_t *FileName, int a2)
{
  wchar_t v4; // r14
  wchar_t *v5; // rax
  wchar_t *v6; // rdi
  FILE *v7; // rbp
  int v8; // r8d
  FILE *v9; // rax
  errno_t v10; // eax
  bool v11; // r15
  int v12; // eax
  int v13; // eax
  int FileHandle; // [rsp+68h] [rbp+10h] BYREF

  while ( *FileName == 32 || *FileName == 9 )
    ++FileName;
  v4 = 0;
  v5 = wcspbrk(FileName, L" \t<>\r");
  v6 = v5;
  if ( v5 )
  {
    v4 = *v5;
    *v5 = 0;
  }
  if ( a2 == 4 )
  {
    v7 = _acrt_iob_func(0);
    v8 = 0;
  }
  else
  {
    v9 = _acrt_iob_func(1u);
    v8 = 265;
    v7 = v9;
    if ( a2 == 2 )
      v8 = 769;
  }
  FileHandle = 0;
  v10 = wsopen_s(&FileHandle, FileName, v8, 64, 384);
  v11 = v10 == 0;
  if ( !v10 )
  {
    v12 = fileno(v7);
    if ( dup2(FileHandle, v12) == -1 )
      sub_140003898(0, 0x411u);
    close(FileHandle);
    if ( a2 == 3 )
    {
      v13 = fileno(v7);
      lseek(v13, 0, 2);
    }
  }
  while ( *FileName )
    *FileName++ = 32;
  if ( v6 )
    *v6 = v4;
  return v11;
}

//----- (00000001400049FC) ----------------------------------------------------
char __fastcall sub_1400049FC(const wchar_t *Src, __int64 a2, int *a3, int *a4)
{
  char v4; // bp
  char v5; // r13
  char v6; // di
  wchar_t *v7; // rsi
  wchar_t *i; // r12
  wchar_t *v11; // rax
  wchar_t *v12; // rbx
  int v13; // eax
  wchar_t *v14; // rbx
  int v15; // ebp
  FILE *v16; // rax
  int v17; // eax
  int v18; // eax
  FILE *v19; // rax
  int v20; // eax
  int v21; // eax
  FILE *v22; // rax
  int v23; // eax
  FILE *v24; // rax
  int v25; // eax
  wchar_t *Destination; // [rsp+60h] [rbp+8h]
  char v28; // [rsp+68h] [rbp+10h]

  Destination = (wchar_t *)Src;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v28 = 0;
  v7 = 0i64;
  for ( i = (wchar_t *)Src; ; Src = i )
  {
    v11 = wcspbrk(Src, L"<>|");
    v12 = v11;
    if ( !v11 )
      break;
    v13 = *v11;
    switch ( v13 )
    {
      case '<':
        if ( v4 )
          goto LABEL_23;
        if ( !v7 )
          v7 = (wchar_t *)sub_14000DCC4(i);
        *v12 = 32;
        i = v12 + 1;
        v4 = 1;
        v28 = 1;
        v19 = _acrt_iob_func(0);
        v20 = fileno(v19);
        v21 = dup(v20);
        *a3 = v21;
        if ( v21 == -1 || !sub_1400048B4(v12 + 1, 4) )
          goto LABEL_23;
        break;
      case '>':
        if ( v5 )
          goto LABEL_23;
        if ( !v7 )
          v7 = (wchar_t *)sub_14000DCC4(i);
        *v12 = 32;
        v5 = 1;
        v14 = v12 + 1;
        i = v14;
        if ( *v14 == 62 )
        {
          *v14 = 32;
          v15 = 3;
          ++v14;
        }
        else
        {
          v15 = 2;
        }
        v16 = _acrt_iob_func(1u);
        v17 = fileno(v16);
        v18 = dup(v17);
        *a4 = v18;
        if ( v18 == -1 || !sub_1400048B4(v14, v15) )
        {
          v4 = v28;
LABEL_23:
          v6 = 1;
          if ( v7 )
          {
            wcscpy_s(Destination, 0xFFFFFFFFFFFFFFFFui64, v7);
            free(v7);
          }
          if ( v4 && *a3 != -1 )
          {
            v22 = _acrt_iob_func(0);
            v23 = fileno(v22);
            if ( dup2(*a3, v23) == -1 )
              sub_140003898(0, 0x411u);
            close(*a3);
            *a3 = -1;
          }
          if ( v5 && *a4 != -1 )
          {
            v24 = _acrt_iob_func(1u);
            v25 = fileno(v24);
            if ( dup2(*a4, v25) == -1 )
              sub_140003898(0, 0x411u);
            close(*a4);
            *a4 = -1;
          }
          return v6;
        }
        v4 = v28;
        break;
      case '|':
        goto LABEL_23;
      default:
        sub_140003898(0, 0x411u);
        break;
    }
  }
  return v6;
}

//----- (0000000140004C30) ----------------------------------------------------
bool __fastcall sub_140004C30(_WORD *a1, unsigned __int64 *a2)
{
  _WORD *v3; // r9
  __int16 *i; // r8
  __int16 v5; // cx
  __int16 v6; // cx
  __int16 v7; // cx

  v3 = a1;
  for ( i = a1; *i == 59; ++i )
    ;
  while ( 1 )
  {
    v6 = *i;
    if ( !*i || v6 == 59 )
      break;
    if ( v6 == 34 )
    {
      v5 = *++i;
      if ( !*i )
        break;
      do
      {
        if ( v5 == 34 )
          break;
        ++i;
        *v3++ = v5;
        v5 = *i;
      }
      while ( *i );
      if ( !*i )
        break;
    }
    else
    {
      *v3++ = v6;
    }
    ++i;
  }
  v7 = *i;
  *v3 = 0;
  *a2 = (unsigned __int64)(i + 1) & -(__int64)(v7 != 0);
  return v3 != a1;
}

//----- (0000000140004CC4) ----------------------------------------------------
char __fastcall sub_140004CC4(const wchar_t *a1, wchar_t *a2)
{
  wchar_t *v2; // r12
  __int64 v3; // r14
  wchar_t *v4; // r13
  __int64 v5; // rax
  const wchar_t *v6; // rax
  __int64 v7; // rax
  wchar_t *v8; // rdi
  BOOL v9; // eax
  unsigned __int64 v10; // rcx
  BOOL v11; // r15d
  wchar_t *v12; // rax
  void *v13; // rsi
  wchar_t *v14; // rbx
  size_t v15; // r8
  __int64 v16; // rcx
  __int64 v17; // rax
  unsigned __int64 v18; // rbx
  wchar_t *v19; // rbx
  wchar_t *i; // r15
  wchar_t *v21; // r15
  wchar_t *Filename; // [rsp+28h] [rbp-D8h]
  char v24; // [rsp+50h] [rbp-B0h]
  size_t SizeInWords; // [rsp+58h] [rbp-A8h] BYREF
  size_t RequiredCount; // [rsp+60h] [rbp-A0h] BYREF
  wchar_t *Buffer; // [rsp+68h] [rbp-98h]
  wchar_t *v28; // [rsp+70h] [rbp-90h] BYREF
  wchar_t *v29; // [rsp+78h] [rbp-88h] BYREF
  wchar_t Drive[8]; // [rsp+80h] [rbp-80h] BYREF
  wchar_t Source[256]; // [rsp+90h] [rbp-70h] BYREF
  wchar_t Dir[256]; // [rsp+290h] [rbp+190h] BYREF
  wchar_t ExeName[256]; // [rsp+490h] [rbp+390h] BYREF

  v2 = 0i64;
  Buffer = a2;
  v3 = -1i64;
  v24 = 0;
  v4 = 0i64;
  if ( *a1 == 34 )
  {
    v5 = -1i64;
    do
      ++v5;
    while ( a1[v5] );
    v4 = (wchar_t *)&a1[v5 - 1];
    if ( *v4 == 34 )
    {
      v24 = 1;
      do
        ++a1;
      while ( *a1 == 34 );
      if ( v4 > a1 )
      {
        do
        {
          v6 = v4 - 1;
          if ( *(v4 - 1) != 34 )
            break;
          --v4;
        }
        while ( v6 > a1 );
      }
      *v4 = 0;
    }
  }
  wsplitpath_s(a1, Drive, 3ui64, Dir, 0x100ui64, ExeName, 0x100ui64, Source, 0x100ui64);
  if ( Source[0] )
  {
    v7 = -1i64;
    do
      ++v7;
    while ( Source[v7] );
    v8 = Source;
    RequiredCount = v7 + 1;
  }
  else
  {
    if ( wgetenv_s(&RequiredCount, 0i64, 0i64, L"PATHEXT") || !RequiredCount )
      goto LABEL_20;
    v8 = (wchar_t *)sub_140009214(saturated_mul(RequiredCount, 2ui64));
    if ( wgetenv_s(&RequiredCount, v8, RequiredCount, L"PATHEXT") )
    {
      free(v8);
      v8 = 0i64;
    }
    if ( !v8 )
    {
LABEL_20:
      RequiredCount = 33i64;
      v8 = (wchar_t *)sub_140009214(saturated_mul(0x21ui64, 2ui64));
      wcscpy_s(v8, RequiredCount, L".COM;.EXE;.BAT;.CMD;.VBS;.JS;.WS");
    }
  }
  if ( Drive[0] || Dir[0] )
  {
    v16 = -1i64;
    do
      ++v16;
    while ( Drive[v16] );
    v17 = -1i64;
    do
      ++v17;
    while ( Dir[v17] );
    v18 = v16 + v17 + 1;
    v13 = sub_140009214(saturated_mul(v18, 2ui64));
    if ( wmakepath_s((wchar_t *)v13, v18, Drive, Dir, 0i64, 0i64) )
    {
      free(v13);
      v13 = 0i64;
    }
  }
  else
  {
    if ( wgetenv_s(&SizeInWords, 0i64, 0i64, L"PATH") || !SizeInWords )
      SizeInWords = 1i64;
    v9 = NeedCurrentDirectoryForExePathW(ExeName);
    v10 = SizeInWords;
    v11 = v9;
    if ( v9 )
    {
      v10 = SizeInWords + 2;
      SizeInWords += 2i64;
    }
    v12 = (wchar_t *)sub_140009214(saturated_mul(v10, 2ui64));
    v13 = v12;
    v14 = v12;
    if ( v11 )
    {
      wcscpy_s(v12, SizeInWords, L".;");
      v14 += 2;
      v15 = SizeInWords - 2;
      SizeInWords -= 2i64;
    }
    else
    {
      v15 = SizeInWords;
    }
    if ( wgetenv_s(&SizeInWords, v14, v15, L"PATH") || !SizeInWords )
      *v14 = 0;
  }
  v19 = (wchar_t *)v13;
LABEL_41:
  if ( v19 && sub_140004C30(v19, (unsigned __int64 *)&v29) )
  {
    v2 = (wchar_t *)sub_140009214(saturated_mul(RequiredCount, 2ui64));
    wcscpy_s(v2, RequiredCount, v8);
    for ( i = v2; ; i = v28 )
    {
      if ( !i || !sub_140004C30(i, (unsigned __int64 *)&v28) )
      {
        v19 = v29;
        goto LABEL_41;
      }
      Filename = i;
      v21 = Buffer;
      if ( !wmakepath_s(Buffer, 0x104ui64, 0i64, v19, ExeName, Filename) && !waccess_s(v21, 0) )
        break;
    }
    if ( v24 )
    {
      do
        ++v3;
      while ( v21[v3] );
      memmove(v21 + 1, v21, 2 * v3);
      *v21 = 34;
      v21[v3 + 1] = 34;
      v21[v3 + 2] = 0;
      *v4 = 34;
    }
    free(v2);
    free(v13);
    if ( v8 != Source )
      free(v8);
    return 1;
  }
  else
  {
    free(v2);
    free(v13);
    if ( v8 != Source )
      free(v8);
    return 0;
  }
}
// 140004CC4: using guessed type wchar_t Source[256];
// 140004CC4: using guessed type wchar_t Dir[256];
// 140004CC4: using guessed type wchar_t Drive[8];

//----- (0000000140005114) ----------------------------------------------------
__int64 __fastcall sub_140005114(wchar_t *Source, char a2, char a3, char a4, void **a5)
{
  void **v5; // r15
  unsigned __int64 v6; // rsi
  void *v9; // rax
  int v10; // eax
  char v11; // r14
  wchar_t *v12; // rbx
  wchar_t *i; // rax
  unsigned __int64 v15; // rax
  void *v16; // rax
  wchar_t *v17; // r13
  const wchar_t **v18; // rbx
  __int64 v19; // rdi
  wchar_t *v20; // r15
  __int64 v21; // rsi
  bool v22; // si
  __int64 v23; // rdx
  unsigned __int64 v24; // r12
  bool v25; // r13
  wchar_t *v26; // rax
  __int64 v27; // rdi
  unsigned __int64 v28; // rcx
  char v29; // al
  int v30; // r15d
  int v31; // r12d
  unsigned __int64 v32; // rcx
  FILE *v33; // rax
  int v34; // eax
  FILE *v35; // rax
  int v36; // eax
  char v37; // r15
  unsigned __int64 v38; // r8
  __int64 v39; // rcx
  unsigned __int64 v40; // rdi
  const wchar_t *v41; // rcx
  __int64 v42; // rax
  __int64 j; // rsi
  __int64 k; // rcx
  const wchar_t *v45; // rax
  void *v46; // r15
  int *v47; // rax
  int *v48; // rax
  const wchar_t *v49; // r8
  void **v50; // r15
  wchar_t *v51; // rcx
  unsigned int v52; // ecx
  unsigned int v53; // edi
  wchar_t **v54; // rax
  char v55; // [rsp+28h] [rbp-E0h]
  unsigned int v56; // [rsp+2Ch] [rbp-DCh] BYREF
  wchar_t *String; // [rsp+30h] [rbp-D8h] BYREF
  int FileHandle[2]; // [rsp+38h] [rbp-D0h] BYREF
  void *Block; // [rsp+40h] [rbp-C8h]
  int FileHandleSrc[2]; // [rsp+48h] [rbp-C0h] BYREF
  void **v61; // [rsp+50h] [rbp-B8h]
  wchar_t Str; // [rsp+58h] [rbp-B0h] BYREF
  char Src[526]; // [rsp+5Ah] [rbp-AEh] BYREF
  wchar_t Buffer; // [rsp+268h] [rbp+160h] BYREF
  __int16 Destination[263]; // [rsp+26Ah] [rbp+162h] BYREF

  v5 = a5;
  LODWORD(v6) = 0;
  v55 = a4;
  String = Source;
  v61 = a5;
  if ( !qword_1400364A0 )
  {
    v9 = sub_140005938();
    Source = String;
    qword_1400364A0 = (__int64)v9;
  }
  v10 = *Source;
  v11 = 1;
  if ( v10 == 45 )
  {
    v55 = 1;
    String = Source + 1;
    if ( iswdigit(Source[1]) )
    {
      v12 = String;
      dword_14002648C = wcstoul(String, &String, 10);
      if ( *errno() == 34 )
      {
        *String = 0;
        sub_140003898(0, 0x436u, v12);
      }
      for ( i = String; iswspace(*i); i = ++String )
        ;
    }
    else
    {
      dword_14002648C = -1;
    }
    Source = String;
  }
  else if ( v10 == 64 )
  {
    String = ++Source;
    if ( a3 )
      a2 = 0;
  }
  if ( !*Source )
    return 0i64;
  v15 = -1i64;
  do
    ++v15;
  while ( Source[v15] );
  if ( v15 >= 0x8000 )
  {
    ::Destination = 0;
  }
  else
  {
    wcscpy_s(&::Destination, 0x8000ui64, Source);
    Source = String;
  }
  v16 = sub_14000DCC4(Source);
  Block = v16;
  v17 = (wchar_t *)v16;
  if ( a2 )
  {
    sub_14000BFE0(L"\t%s\n", v16);
    sub_14000BFB0();
  }
  v18 = 0i64;
  sub_140003AE0(&v56, 0i64, v17);
  LODWORD(v19) = v56;
  if ( v56 )
  {
    v18 = (const wchar_t **)sub_140009214(saturated_mul(v56 + 5, 8ui64));
    sub_140003AE0(&v56, v18, v17);
    if ( *v18 && qword_140026498 && !wcsicmp(*v18, qword_140026498) )
    {
      if ( !qword_1400157F0 )
      {
        v20 = *_p__wpgmptr();
        qword_1400157F0 = v20;
        if ( wcspbrk(v20, L" ") )
        {
          v21 = -1i64;
          do
            ++v21;
          while ( qword_1400157F0[v21] );
          v6 = v21 + 3;
          qword_1400157F0 = (wchar_t *)sub_140009214(saturated_mul(v6, 2ui64));
          wcscpy_s(qword_1400157F0, v6, L"\"");
          wcscat_s(qword_1400157F0, v6, v20);
          wcscat_s(qword_1400157F0, v6, L"\"");
          LODWORD(v6) = 0;
        }
        v5 = v61;
      }
      *v18 = qword_1400157F0;
    }
    if ( !a3 )
    {
      if ( sub_140004690(v19, (wint_t **)v18, FileHandle) )
      {
        LODWORD(v6) = FileHandle[0];
        if ( FileHandle[0] )
        {
          if ( v5 )
            *v5 = sub_14000DCC4(*v18);
        }
      }
      LODWORD(v19) = v56;
      goto LABEL_126;
    }
    v22 = wcspbrk(String, L"<>|&%") == 0i64;
    v24 = 0i64;
    if ( sub_140004690(v19, (wint_t **)v18, FileHandle) )
    {
      LODWORD(v6) = FileHandle[0];
      v25 = 0;
LABEL_44:
      LODWORD(v19) = v56;
      goto LABEL_45;
    }
    v26 = String;
    v27 = -1i64;
    v28 = -1i64;
    do
      ++v28;
    while ( String[v28] );
    if ( v28 < 0x1000 && !v22 )
    {
      v25 = 1;
      goto LABEL_74;
    }
    FileHandleSrc[0] = -1;
    FileHandle[1] = -1;
    v29 = sub_1400049FC(String, v23, FileHandleSrc, &FileHandle[1]);
    v30 = FileHandleSrc[0];
    v31 = FileHandle[1];
    v25 = v29;
    if ( !v29 )
    {
      v32 = -1i64;
      do
        ++v32;
      while ( String[v32] );
      if ( v32 >= 0x8000 )
        sub_140003898(0, 0x447u, String);
      if ( v30 != -1 || v31 != -1 )
      {
        free(Block);
        Block = sub_14000DCC4(String);
        sub_140003AE0(&v56, v18, (wchar_t *)Block);
      }
      if ( sub_140004CC4(*v18, &Str) )
      {
        if ( Str == 34 )
        {
          do
            ++v27;
          while ( *(_WORD *)&Src[2 * v27 - 2] );
          if ( *((_WORD *)&v61 + v27 + 3) == 34 )
          {
            memmove(&Str, Src, 2 * v27);
            v40 = 2 * v27 - 4;
            if ( v40 >= 0x208 )
              _report_rangecheckfailure(v39);
            *(_WORD *)&Src[v40 - 2] = 0;
          }
        }
        *v18 = &Str;
        if ( wcschr(&Str, 0x20u) )
        {
          Buffer = 34;
          wcscpy_s((wchar_t *)Destination, 0x103ui64, &Str);
          wcscat_s(&Buffer, 0x104ui64, L"\"");
          *v18 = &Buffer;
        }
        *errno() = 0;
        v6 = wspawnvp(0, &Str, v18);
        if ( v6 == -1i64 && *errno() != 12 )
          v25 = *_doserrno() == 193;
        goto LABEL_64;
      }
      v25 = 1;
    }
    LODWORD(v6) = FileHandle[0];
LABEL_64:
    if ( v30 != -1 )
    {
      v33 = _acrt_iob_func(0);
      v34 = fileno(v33);
      if ( dup2(v30, v34) == -1 )
        sub_140003898(0, 0x411u);
      close(v30);
    }
    if ( v31 != -1 )
    {
      v35 = _acrt_iob_func(1u);
      v36 = fileno(v35);
      if ( dup2(v31, v36) == -1 )
        sub_140003898(0, 0x411u);
      close(v31);
    }
    v24 = 0i64;
    if ( !v25 )
      goto LABEL_44;
    v26 = String;
LABEL_74:
    v37 = 0;
    v38 = -1i64;
    do
      ++v38;
    while ( v26[v38] );
    if ( v38 >= 0x1000 )
      sub_140003898(0, 0x447u, v26);
    else
      wcscpy_s(&::Destination, 0x8000ui64, v26);
    v41 = *v18;
    if ( **v18 != 34 )
      goto LABEL_99;
    v42 = -1i64;
    do
      ++v42;
    while ( v41[v42] );
    if ( v41[v42 - 1] == 34 )
    {
      v19 = v56;
      for ( j = (int)(v56 - 1); j >= 1; --j )
      {
        if ( wcspbrk(v18[j], L"\"") )
        {
          v37 = 1;
          v18[v19] = L"\"";
          v19 = (unsigned int)(v19 + 1);
          v18[v19] = 0i64;
          break;
        }
      }
    }
    else
    {
LABEL_99:
      LODWORD(v19) = v56;
    }
    for ( k = (int)v19; k >= 0; --k )
      v18[k + 2] = v18[k];
    *v18 = (const wchar_t *)qword_1400364A0;
    v45 = L"/c";
    if ( v37 )
      v45 = L"/c \"";
    v18[1] = v45;
    *errno() = 0;
    v46 = (void *)wspawnvp(1, *v18, v18);
    if ( v46 == (void *)-1i64 )
    {
      LODWORD(v6) = -1;
LABEL_46:
      if ( v55 )
      {
        LODWORD(v6) = 0;
LABEL_125:
        v17 = (wchar_t *)Block;
        goto LABEL_126;
      }
      v47 = errno();
      if ( !*v47 )
      {
LABEL_120:
        v50 = v61;
        if ( v61 )
        {
          if ( v25 )
            v51 = (wchar_t *)v18[2];
          else
            v51 = (wchar_t *)*v18;
          *v50 = sub_14000DCC4(v51);
        }
        goto LABEL_125;
      }
      if ( *v47 != 2 )
      {
        if ( *v47 == 12 )
        {
          if ( v25 )
            v49 = v18[2];
          else
            v49 = *v18;
          sub_140003898(0, 0x43Au, v49);
        }
        else
        {
          v48 = errno();
          wcserror_s(&Buffer, 0xC8ui64, *v48);
          sub_140003898(0, 0x415u, &Buffer);
        }
        goto LABEL_120;
      }
      sub_140003898(0, 0x439u, *v18);
LABEL_119:
      if ( !(_DWORD)v6 )
        goto LABEL_125;
      goto LABEL_120;
    }
    WaitForSingleObject(v46, 0xFFFFFFFF);
    do
    {
      GetExitCodeProcess(v46, (LPDWORD)&FileHandle[1]);
      LODWORD(v6) = FileHandle[1];
      if ( FileHandle[1] != 259 )
        break;
      Sleep(0x3E8u);
      ++v24;
    }
    while ( v24 < 0xA );
    CloseHandle(v46);
LABEL_45:
    if ( (_DWORD)v6 != -1 )
      goto LABEL_119;
    goto LABEL_46;
  }
LABEL_126:
  v52 = 0;
  v53 = v19 + 5;
  if ( v53 )
  {
    v54 = (wchar_t **)v18;
    while ( *v54 )
    {
      if ( *v54 == v17 )
      {
        v11 = 0;
        break;
      }
      ++v52;
      ++v54;
      if ( v52 >= v53 )
        break;
    }
  }
  if ( v18 )
    free(v18);
  if ( v17 )
  {
    if ( v11 )
      free(v17);
  }
  return (unsigned int)v6;
}
// 1400054B6: variable 'v23' is possibly undefined
// 140005930: variable 'v39' is possibly undefined
// 14001025C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD);
// 140011E58: using guessed type wchar_t aS[5];
// 140011E78: using guessed type wchar_t aC[5];
// 140011E84: using guessed type wchar_t aC_0[3];
// 14002648C: using guessed type int dword_14002648C;
// 1400364A0: using guessed type __int64 qword_1400364A0;
// 140005114: using guessed type wchar_t Destination[263];
// 140005114: using guessed type char Src[526];

//----- (0000000140005938) ----------------------------------------------------
void *sub_140005938()
{
  void *v0; // rbx
  wchar_t *Buffer; // [rsp+20h] [rbp-238h] BYREF
  wchar_t ResultPath[264]; // [rsp+30h] [rbp-228h] BYREF

  Buffer = 0i64;
  wdupenv_s(&Buffer, 0i64, L"COMSPEC");
  if ( Buffer )
  {
    v0 = sub_14000DCC4(Buffer);
    free(Buffer);
    return v0;
  }
  else
  {
    wsearchenv(L"CMD.EXE", L"PATH", ResultPath);
    if ( !ResultPath[0] )
      sub_140003898(0, 0x420u);
    return sub_14000DCC4(ResultPath);
  }
}

//----- (00000001400059E0) ----------------------------------------------------
char __fastcall sub_1400059E0(const wchar_t *a1, __int64 a2, char a3, char a4, const wchar_t *a5, unsigned int *a6)
{
  char v6; // al
  __int16 v8; // si
  __int64 v9; // rdi
  const wchar_t *v10; // rbx
  char v11; // al
  _WORD *v12; // rcx
  char v14; // bp
  bool v15; // r14
  char v16; // r12
  __int64 *v17; // rax
  __int64 v18; // rbx
  unsigned __int16 *v19; // r15
  bool v20; // r8
  bool v21; // dl
  unsigned int v22; // eax
  __int64 *v23; // rax
  __int64 v24; // [rsp+30h] [rbp-58h]
  __int64 v25[10]; // [rsp+38h] [rbp-50h] BYREF
  const wchar_t *v26; // [rsp+90h] [rbp+8h]

  v26 = a1;
  v6 = a4;
  v8 = 0;
  v9 = 0i64;
  v10 = a1;
  v24 = 0i64;
  if ( !*a1 )
    goto LABEL_22;
  while ( 1 )
  {
    v11 = 0;
    if ( *v10 != 36 )
      goto LABEL_17;
    if ( v10[1] == 40 )
    {
      ++v10;
      v11 = 1;
    }
    v12 = v10 + 1;
    if ( v10[1] != 63 )
      break;
    if ( !v11 || wcschr(L"DFBR", v10[2]) && v10[3] == 41 || v10[2] == 41 )
    {
      v9 = qword_140026468;
      v8 = 63;
      goto LABEL_20;
    }
LABEL_17:
    if ( !*++v10 )
      goto LABEL_21;
  }
  ++v10;
  if ( *v12 != 42 || v12[1] != 42 || v11 && (!wcschr(L"DFBR", v12[2]) || v10[3] != 41) && v10[2] != 41 )
    goto LABEL_17;
  v9 = qword_140026450;
  v8 = 42;
LABEL_20:
  v24 = v9;
LABEL_21:
  v6 = a4;
  a1 = v26;
LABEL_22:
  if ( !*v10 )
    return 0;
  if ( v9 )
  {
    v14 = a3 & 4;
    v15 = (v6 & 2) != 0;
    v16 = a3 & 2;
    do
    {
      qword_140025C48 = a2;
      v17 = (__int64 *)qword_140026450;
      if ( v8 != 42 )
        v17 = (__int64 *)qword_140026468;
      v18 = *v17;
      *v17 = 0i64;
      v19 = (unsigned __int16 *)sub_14000E740(a1, 255, &qword_140025C48);
      if ( sub_14000F778((char *)word_1400264A0, 0x8000i64, v19, a5) )
        sub_140003898(0, 0x447u, v19);
      v20 = !v14 || (a4 & 8) != 0;
      v21 = v14 || (a3 & 8) == 0 && (a4 & 1) == 0;
      v22 = sub_140005114(word_1400264A0, v21, v20, v15, (void **)v25);
      *a6 = v22;
      if ( !v16 && v22 && v22 > dword_14002648C && !byte_140025C3B )
        sub_140003898(0, 0x435u, v25[0], v22);
      if ( v8 == 42 )
      {
        v23 = (__int64 *)qword_140026450;
        qword_140026450 = v18;
      }
      else
      {
        v23 = (__int64 *)qword_140026468;
        qword_140026468 = v18;
      }
      *v23 = v18;
      free(v19);
      if ( !v16 && byte_140025C3B && *a6 && *a6 > dword_14002648C )
        break;
      a1 = v26;
    }
    while ( v18 );
    v9 = v24;
  }
  if ( v8 == 42 )
    qword_140026450 = v9;
  else
    qword_140026468 = v9;
  return 1;
}
// 140025C3B: using guessed type char byte_140025C3B;
// 140025C48: using guessed type __int64 qword_140025C48;
// 140026450: using guessed type __int64 qword_140026450;
// 140026468: using guessed type __int64 qword_140026468;
// 14002648C: using guessed type int dword_14002648C;
// 1400264A0: using guessed type wchar_t word_1400264A0[32768];
// 1400059E0: using guessed type __int64 var_50[10];

//----- (0000000140005CA8) ----------------------------------------------------
WCHAR *__fastcall sub_140005CA8(wchar_t *Str, LPWIN32_FIND_DATAW lpFindFileData, HANDLE *a3)
{
  char *v4; // rdi
  wchar_t *v6; // rbx
  wchar_t *v7; // rax
  bool v8; // bp
  __int64 v9; // rax
  WCHAR *v10; // rcx
  WCHAR v11; // ax
  HANDLE FirstFileW; // rax
  char Block[528]; // [rsp+20h] [rbp-258h] BYREF

  v4 = Block;
  v6 = Str;
  v7 = wcspbrk(Str, L"\"^*?");
  v8 = v7 != 0i64;
  if ( v7 )
  {
    v9 = -1i64;
    do
      ++v9;
    while ( v6[v9] );
    if ( (unsigned __int64)(v9 + 1) > 0x104 )
    {
      v4 = (char *)sub_140009214(saturated_mul(v9 + 1, 2ui64));
      if ( !v4 )
        sub_140003898(dword_140025C24, 0x41Bu);
    }
    v10 = (WCHAR *)v4;
    while ( 1 )
    {
      v11 = *v6;
      if ( !*v6 )
        break;
      if ( v11 != 94 && v11 != 34 )
        *v10++ = v11;
      ++v6;
    }
    *v10 = 0;
    v6 = (wchar_t *)v4;
  }
  FirstFileW = FindFirstFileW(v6, lpFindFileData);
  *a3 = FirstFileW;
  if ( FirstFileW == (HANDLE)-1i64 || !sub_140005F9C(v6, (__int64)lpFindFileData) )
  {
    if ( v4 != Block )
      free(v4);
    return 0i64;
  }
  else
  {
    if ( !v8 || !wcschr(v6, 0x2Au) && !wcschr(v6, 0x3Fu) )
    {
      FindClose(*a3);
      *a3 = (HANDLE)-1i64;
    }
    if ( v4 != Block )
      free(v4);
    if ( (lpFindFileData->dwFileAttributes & 0x10) == 0
      && !lpFindFileData->ftLastWriteTime.dwLowDateTime
      && !lpFindFileData->ftLastWriteTime.dwHighDateTime )
    {
      lpFindFileData->ftLastWriteTime.dwLowDateTime = -1;
      lpFindFileData->ftLastWriteTime.dwHighDateTime = -1;
    }
    return lpFindFileData->cFileName;
  }
}
// 140025C24: using guessed type int dword_140025C24;

//----- (0000000140005E30) ----------------------------------------------------
WCHAR *__fastcall sub_140005E30(LPWIN32_FIND_DATAW lpFindFileData, HANDLE hFindFile)
{
  if ( FindNextFileW(hFindFile, lpFindFileData) )
    return lpFindFileData->cFileName;
  FindClose(hFindFile);
  return 0i64;
}

//----- (0000000140005E6C) ----------------------------------------------------
void *__fastcall sub_140005E6C(wchar_t *a1, wchar_t *a2, struct _WIN32_FIND_DATAW *a3, HANDLE *a4)
{
  wchar_t *v8; // rcx
  wchar_t *v10; // rbx
  wchar_t v11; // ax
  wchar_t v12; // ax

  if ( sub_140005CA8(a2, a3, a4) )
  {
    v8 = a2;
  }
  else
  {
    if ( !a1 )
      return 0i64;
    while ( 1 )
    {
      v10 = &Src;
      while ( 1 )
      {
        while ( 1 )
        {
          v11 = *a1;
          if ( !*a1 )
            break;
          do
          {
            if ( v11 != 34 )
              break;
            v11 = *++a1;
          }
          while ( *a1 );
          v12 = *a1;
          if ( !*a1 )
            break;
          ++a1;
          *v10 = v12;
          if ( v12 == 59 )
            break;
          ++v10;
        }
        if ( v10 != &Src )
          break;
        if ( !*a1 )
          return 0i64;
      }
      if ( *(v10 - 1) != 92 && *(v10 - 1) != 47 )
        *v10++ = 92;
      *v10 = 0;
      if ( !wcspbrk(&Src, L"*?") )
      {
        wcscpy_s(v10, 1024 - (v10 - &Src), a2);
        if ( sub_140005CA8(&Src, a3, a4) )
          break;
      }
    }
    v8 = &Src;
  }
  return sub_14000DCC4(v8);
}

//----- (0000000140005F9C) ----------------------------------------------------
char __fastcall sub_140005F9C(const wchar_t *a1, __int64 a2)
{
  WCHAR *v4; // rbx
  wchar_t *v5; // rax
  wchar_t *v6; // rbp
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rax
  WCHAR *v11; // r14
  WCHAR *v12; // rcx
  __int64 v13; // r8
  unsigned __int64 v14; // rdx
  signed __int64 v15; // rdi
  WCHAR v16; // ax
  HANDLE FileW; // rdi

  if ( (*(_DWORD *)a2 & 0x400) != 0 && *(_DWORD *)(a2 + 36) == -1610612724 )
  {
    v4 = (WCHAR *)(a2 + 44);
    v5 = wcsrchr(a1, 0x5Cu);
    v6 = v5;
    if ( v5 )
    {
      v7 = -1i64;
      do
        ++v7;
      while ( v5[v7] );
      v8 = -1i64;
      do
        ++v8;
      while ( v4[v8] );
      v9 = v8 + 2 - v7;
      v10 = -1i64;
      do
        ++v10;
      while ( a1[v10] );
      v11 = (WCHAR *)sub_140009214(saturated_mul(v10 + v9, 2ui64));
      if ( !v11 )
        sub_140003898(dword_140025C24, 0x41Bu);
      v12 = v11;
      v13 = 0i64;
      v14 = (unsigned __int64)((char *)v6 - (char *)a1 + 1) >> 1;
      if ( a1 > v6 )
        v14 = 0i64;
      if ( v14 )
      {
        v15 = (char *)a1 - (char *)v11;
        do
        {
          ++v13;
          *v12 = *(WCHAR *)((char *)v12 + v15);
          ++v12;
        }
        while ( v13 != v14 );
      }
      v16 = 92;
      while ( 1 )
      {
        *v12++ = v16;
        v16 = *v4;
        if ( !*v4 )
          break;
        ++v4;
      }
      *v12 = 0;
      v4 = v11;
    }
    FileW = CreateFileW(v4, 0x80000000, 1u, 0i64, 3u, 0, 0i64);
    if ( v6 )
      free(v4);
    if ( FileW == (HANDLE)-1i64 )
      return 0;
    if ( !GetFileTime(FileW, (LPFILETIME)(a2 + 4), (LPFILETIME)(a2 + 12), (LPFILETIME)(a2 + 20)) )
    {
      CloseHandle(FileW);
      return 0;
    }
    CloseHandle(FileW);
  }
  return 1;
}
// 140025C24: using guessed type int dword_140025C24;

//----- (000000014000613C) ----------------------------------------------------
wint_t sub_14000613C()
{
  wint_t result; // ax
  wchar_t *v1; // rdi
  bool v2; // si
  wchar_t *v3; // rax
  wchar_t *v4; // rbx
  int v5; // eax
  wint_t v6; // ax
  wchar_t v7; // ax
  wchar_t v8; // ax
  wint_t v9; // ax
  wchar_t v10; // ax
  wchar_t v11; // ax
  __int16 *v12; // rbx
  char *v13; // rax
  char v14; // [rsp+50h] [rbp+8h] BYREF
  wchar_t *Context; // [rsp+58h] [rbp+10h] BYREF

  for ( result = getwc(Stream); qword_1400364B0 || byte_140015041 && result == 33; result = getwc(Stream) )
  {
    byte_140015041 = 0;
    if ( qword_1400364B0 )
    {
      ungetwc(result, Stream);
      v1 = (wchar_t *)qword_1400364B0;
      qword_1400364B0 = 0i64;
    }
    else
    {
      v1 = sub_140006490();
    }
    v2 = v1 != qword_1400364B8;
    v3 = (wchar_t *)sub_1400065F8(v1, &v14);
    v4 = v3;
    switch ( v14 )
    {
      case 9:
        if ( byte_140026489 )
          sub_140003898(dword_140025C20, 0x409u, v1);
        if ( sub_140008BCC(v4) == 18 )
          return 32;
        break;
      case 10:
        if ( !*v3 )
          break;
LABEL_16:
        v5 = *v4;
        if ( v5 == 43 )
        {
          v6 = *++v4;
          if ( !*v4 )
            break;
          do
          {
            if ( v6 == 45 )
              break;
            v7 = towupper(v6);
            if ( wcschr(L"DINSU", v7) || byte_140026489 && (v8 = towupper(*v4), wcschr(L"ABCEKLPQRTY", v8)) )
              sub_14000B804(*v4, 1);
            else
              sub_140003898(dword_140025C20, 0x400u);
            v6 = *++v4;
          }
          while ( *v4 );
          if ( !*v4 )
            break;
        }
        else if ( v5 != 45 )
        {
          if ( (_WORD)v5 != 32 && v5 != 9 )
            sub_140003898(dword_140025C20, 0x400u);
          goto LABEL_38;
        }
        v9 = *++v4;
        if ( !*v4 )
          break;
        do
        {
          if ( v9 == 43 )
            break;
          v10 = towupper(v9);
          if ( wcschr(L"DINSU", v10) || byte_140026489 && (v11 = towupper(*v4), wcschr(L"ABCEKLMPQRTV", v11)) )
            sub_14000B804(*v4, 0);
          else
            sub_140003898(dword_140025C20, 0x400u);
          v9 = *++v4;
        }
        while ( *v4 );
LABEL_38:
        if ( !*v4 )
          break;
        if ( !*++v4 )
          break;
        goto LABEL_16;
      case 11:
        sub_140003898(dword_140025C20, 0x41Au, v3);
        break;
      case 12:
        if ( !wcsnicmp(v3, L"\\t", 2ui64) )
        {
          sub_14000BFE0(L"\t");
          v4 += 2;
        }
        sub_1400039C0(0xDu, v4);
        break;
      case 13:
        Context = 0i64;
        v12 = (__int16 *)wcstok_s(v3, L" \t", &Context);
        if ( wcstok_s(0i64, L" \t", &Context) )
          sub_140003898(dword_140025C20, 0x409u, v12);
        v13 = sub_14000918C(v12);
        if ( v13 )
          v13[24] |= 0x10u;
        break;
      default:
        sub_1400069A4(v3, v14);
        break;
    }
    byte_140015041 = 1;
    if ( v2 )
      free(v1);
    ++dword_140025C20;
  }
  return result;
}
// 140011ED4: using guessed type wchar_t asc_140011ED4[2];
// 140015041: using guessed type char byte_140015041;
// 140025C20: using guessed type int dword_140025C20;
// 140026489: using guessed type char byte_140026489;

//----- (0000000140006490) ----------------------------------------------------
wchar_t *sub_140006490()
{
  wint_t v0; // ax
  wint_t v1; // bx
  wint_t v2; // cx
  unsigned int i; // edi
  _WORD *v4; // rcx
  __int64 v5; // rdx
  void *v6; // rax
  __int64 v7; // rax
  wint_t v8; // bx

  v0 = sub_140008044(1);
  v1 = v0;
  if ( v0 == 10 || v0 == 0xFFFF )
    sub_140003898(dword_140025C20, 0x3FAu);
  v2 = v1;
  for ( i = 0; ; ++i )
  {
    v8 = sub_140008128(v2, 1);
    if ( v8 == 35 || v8 == 10 || v8 == 0xFFFF )
      break;
    if ( (unsigned __int64)qword_1400364A8 < 2 || i > (unsigned __int64)(qword_1400364A8 - 2) )
    {
      v5 = qword_1400364A8 + 1024;
      qword_1400364A8 += 1024i64;
      if ( qword_1400364B8 )
        v6 = sub_140009274(qword_1400364B8, 2 * v5 + 2);
      else
        v6 = sub_140009214(saturated_mul(v5 + 1, 2ui64));
      qword_1400364B8 = v6;
      v4 = v6;
    }
    else
    {
      v4 = qword_1400364B8;
    }
    v7 = i;
    v4[v7] = v8;
    v2 = getwc(Stream);
  }
  *((_WORD *)qword_1400364B8 + i) = 0;
  if ( v8 == 35 )
  {
    while ( 1 )
    {
      v8 = getwc(Stream);
      if ( v8 == 10 )
        break;
      if ( v8 == 0xFFFF )
        goto LABEL_21;
    }
  }
  if ( v8 == 0xFFFF )
LABEL_21:
    ungetwc(v8, Stream);
  return sub_14000E6A4((const wchar_t *)qword_1400364B8);
}
// 140025C20: using guessed type int dword_140025C20;
// 1400364A8: using guessed type __int64 qword_1400364A8;

//----- (00000001400065F8) ----------------------------------------------------
const wchar_t *__fastcall sub_1400065F8(wchar_t *String1, char *a2)
{
  wchar_t v2; // ax
  wchar_t *v5; // rbx
  wchar_t v6; // ax
  __int64 v7; // rdi
  char v8; // al
  wchar_t *v10; // [rsp+40h] [rbp+8h] BYREF

  v2 = *String1;
  *a2 = 0;
  v10 = String1;
  v5 = String1;
  if ( v2 )
  {
    do
    {
      if ( v2 == 32 )
        break;
      if ( v2 == 9 )
        break;
      v2 = *++v5;
    }
    while ( *v5 );
    v10 = v5;
  }
  v6 = *v5;
  v7 = v5 - String1;
  if ( *v5 )
  {
    do
    {
      if ( v6 != 32 && v6 != 9 )
        break;
      v6 = *++v5;
    }
    while ( *v5 );
    v10 = v5;
  }
  if ( wcsnicmp(String1, L"INCLUDE", 7ui64) || v7 != 7 )
  {
    if ( wcsnicmp(String1, L"CMDSWITCHES", 0xBui64) || v7 != 11 )
    {
      if ( wcsnicmp(String1, L"ERROR", 5ui64) || v7 != 5 )
      {
        if ( wcsnicmp(String1, L"MESSAGE", 7ui64) || v7 != 7 )
        {
          if ( wcsnicmp(String1, L"UNDEF", 5ui64) || v7 != 5 )
          {
            v8 = sub_140006774(String1, v7, (const wchar_t **)&v10);
            *a2 = v8;
            if ( !v8 )
              sub_140003898(dword_140025C20, 0x3F9u, qword_1400364B8);
            return v10;
          }
          else
          {
            *a2 = 13;
          }
        }
        else
        {
          *a2 = 12;
        }
      }
      else
      {
        *a2 = 11;
      }
    }
    else
    {
      *a2 = 10;
    }
  }
  else
  {
    *a2 = 9;
  }
  return v5;
}
// 140025C20: using guessed type int dword_140025C20;

//----- (0000000140006774) ----------------------------------------------------
char __fastcall sub_140006774(wchar_t *String1, __int64 a2, const wchar_t **a3)
{
  char v5; // bl
  const wchar_t *v7; // rcx
  wchar_t v8; // ax
  const wchar_t *v9; // rbp
  __int64 v10; // rdi
  wchar_t v11; // ax

  v5 = 0;
  if ( !wcsnicmp(String1, L"IF", 2ui64) && a2 == 2 )
    return 1;
  if ( !wcsnicmp(String1, L"IFDEF", 5ui64) && a2 == 5 )
    return 6;
  if ( !wcsnicmp(String1, L"IFNDEF", 6ui64) && a2 == 6 )
    return 7;
  if ( wcsnicmp(String1, L"ELSE", 4ui64) || a2 != 4 )
  {
    if ( wcsnicmp(String1, L"ELSEIF", 6ui64) || a2 != 6 )
    {
      if ( wcsnicmp(String1, L"ELSEIFDEF", 9ui64) || a2 != 9 )
      {
        if ( !wcsnicmp(String1, L"ELSEIFNDEF", 0xAui64) && a2 == 10 )
          return 5;
        if ( !wcsnicmp(String1, L"ENDIF", 5ui64) )
        {
          v5 = 0;
          if ( a2 == 5 )
            return 8;
        }
        return v5;
      }
      return 4;
    }
    return 3;
  }
  v7 = *a3;
  v8 = **a3;
  if ( !v8 )
    return 2;
  v9 = *a3;
  do
  {
    if ( v8 == 32 )
      break;
    if ( v8 == 9 )
      break;
    v8 = *++v7;
  }
  while ( *v7 );
  v10 = (unsigned int)(v7 - v9);
  while ( 1 )
  {
    v11 = *v7;
    if ( !*v7 || v11 != 32 && v11 != 9 )
      break;
    ++v7;
  }
  *a3 = v7;
  if ( !wcsnicmp(v9, L"IF", 2ui64) && v10 == 2 )
    return 3;
  if ( !wcsnicmp(v9, L"IFDEF", 5ui64) && v10 == 5 )
    return 4;
  if ( !wcsnicmp(v9, L"IFNDEF", 6ui64) && v10 == 6 )
    return 5;
  return v5;
}

//----- (00000001400069A4) ----------------------------------------------------
void __fastcall sub_1400069A4(wchar_t *a1, char a2)
{
  int v3; // eax
  bool v4; // zf
  __int64 v5; // rcx
  char v6; // al
  char v7; // al
  __int64 v8; // rcx
  char v9; // al
  char v10; // al
  char v11; // al
  int v12; // eax

  if ( a2 == 1 )
  {
LABEL_28:
    if ( dword_140015044 == 15 )
    {
      sub_140003898(dword_140025C20, 0x3FBu, a1);
      __debugbreak();
    }
    v4 = dword_140015044 == -1;
    v12 = dword_140015044 + 1;
    dword_140015044 = v12;
    byte_1400364C0[v12] = 1;
    if ( !v4 && (byte_1400364C0[v12 - 1] & 2) == 0 )
    {
      byte_1400364C0[v12] = 5;
      goto LABEL_12;
    }
LABEL_33:
    if ( sub_14000D1F8(a1, a2) )
    {
      byte_1400364C0[dword_140015044] |= 2u;
      return;
    }
    goto LABEL_12;
  }
  if ( a2 == 2 )
  {
    if ( dword_140015044 < 0 || (v8 = dword_140015044, v9 = byte_1400364C0[dword_140015044], (v9 & 9) == 0) )
    {
      sub_140003898(dword_140025C20, 0x3FDu, a1);
      __debugbreak();
    }
    v10 = v9 & 0xF6;
    byte_1400364C0[dword_140015044] = v10;
    if ( (v10 & 4) == 0 )
    {
      if ( (v10 & 2) != 0 )
        v11 = v10 & 0xFD;
      else
        v11 = v10 | 2;
      byte_1400364C0[v8] = v11;
      v4 = (v11 & 2) == 0;
LABEL_11:
      if ( !v4 )
        return;
      goto LABEL_12;
    }
    goto LABEL_12;
  }
  if ( (unsigned __int8)a2 <= 2u )
    return;
  if ( (unsigned __int8)a2 <= 5u )
  {
    if ( dword_140015044 < 0 || (v5 = dword_140015044, v6 = byte_1400364C0[dword_140015044], (v6 & 9) == 0) )
    {
      sub_140003898(dword_140025C20, 0x3FDu, a1);
      __debugbreak();
    }
    v7 = v6 & 0xF6 | 8;
    byte_1400364C0[dword_140015044] = v7;
    if ( (v7 & 4) != 0 )
      goto LABEL_12;
    if ( (v7 & 2) == 0 )
      goto LABEL_33;
    byte_1400364C0[v5] = v7 & 0xF9 | 4;
LABEL_12:
    sub_140006B10();
    return;
  }
  if ( (unsigned __int8)a2 <= 7u )
    goto LABEL_28;
  if ( a2 == 8 )
  {
    if ( dword_140015044 < 0 )
    {
      sub_140003898(dword_140025C20, 0x401u, a1);
      __debugbreak();
    }
    v3 = dword_140015044 - 1;
    dword_140015044 = v3;
    if ( v3 >= 0 )
    {
      v4 = (byte_1400364C0[v3] & 2) == 0;
      goto LABEL_11;
    }
  }
}
// 140015044: using guessed type int dword_140015044;
// 140025C20: using guessed type int dword_140025C20;
// 1400364C0: using guessed type _BYTE byte_1400364C0[16];

//----- (0000000140006B10) ----------------------------------------------------
unsigned __int16 sub_140006B10()
{
  __int16 v0; // ax
  unsigned __int16 result; // ax
  unsigned __int8 v2; // [rsp+30h] [rbp+8h] BYREF

  while ( 1 )
  {
    v0 = getwc(Stream);
    if ( v0 != 33 )
    {
      do
      {
        if ( v0 == -1 )
          break;
        ++dword_140025C20;
        while ( 1 )
        {
          if ( v0 == 92 )
          {
            v0 = sub_140008128(0x5Cu, 1);
            if ( v0 == 33 && byte_140015041 )
              goto LABEL_16;
            byte_140015041 = 0;
          }
          if ( v0 == 35 )
            break;
          if ( v0 == 10 )
            goto LABEL_14;
          if ( v0 == -1 )
            goto LABEL_15;
          v0 = getwc(Stream);
        }
        while ( 1 )
        {
          v0 = getwc(Stream);
          if ( v0 == 10 )
            break;
          if ( v0 == -1 )
            goto LABEL_15;
        }
LABEL_14:
        v0 = getwc(Stream);
      }
      while ( v0 != 33 );
LABEL_15:
      if ( v0 != 33 )
        return sub_140003898(dword_140025C20, 0x3FCu);
    }
LABEL_16:
    if ( qword_1400364B0 )
    {
      if ( qword_1400364B0 != qword_1400364B8 )
        free(qword_1400364B0);
    }
    qword_1400364B0 = sub_140006490();
    result = (unsigned __int16)sub_1400065F8((wchar_t *)qword_1400364B0, (char *)&v2);
    if ( v2 <= 8u )
      return result;
    ++dword_140025C20;
  }
}
// 140006BA9: conditional instruction was optimized away because ax.2==A
// 140006BAF: conditional instruction was optimized away because ax.2==A
// 140006C17: conditional instruction was optimized away because ax.2==FFFF
// 140015041: using guessed type char byte_140015041;
// 140025C20: using guessed type int dword_140025C20;

//----- (0000000140006C34) ----------------------------------------------------
char __fastcall sub_140006C34(wchar_t *a1)
{
  wchar_t *v1; // rcx
  char v2; // bl
  __int64 v3; // rcx
  wchar_t *v4; // rax
  wchar_t *Context; // [rsp+30h] [rbp+8h] BYREF

  Context = a1;
  dword_140025C20 = 0;
  while ( fgetws(&Src, 1024, Stream) )
  {
    if ( Src == 91 )
    {
      Context = 0i64;
      v1 = &word_140025C52;
      v2 = 0;
      while ( 1 )
      {
        v4 = wcstok_s(v1, L" \t\n", &Context);
        if ( !v4 || v2 )
          break;
        v3 = -1i64;
        do
          ++v3;
        while ( v4[v3] );
        if ( v4[v3 - 1] == 93 )
        {
          v2 = 1;
          v4[v3 - 1] = 0;
        }
        if ( !wcsicmp(v4, L"nmake") )
          return 1;
        v1 = 0i64;
      }
    }
    ++dword_140025C20;
  }
  if ( !feof(Stream) )
  {
    dword_140025C24 = dword_140025C20;
    sub_140003898(0, 0x41Du);
  }
  return 0;
}
// 140025C20: using guessed type int dword_140025C20;
// 140025C24: using guessed type int dword_140025C24;

//----- (0000000140006D18) ----------------------------------------------------
wint_t *__fastcall sub_140006D18(wint_t *a1, int a2)
{
  wint_t *v2; // rbx
  wint_t *v3; // rdi
  wint_t i; // ax
  FILE *v6; // rdx

  v2 = a1;
  v3 = &a1[a2];
  for ( i = sub_14000613C(); ; i = sub_14000613C() )
  {
    if ( !i )
      return v2;
    if ( i == 0xFFFF )
      break;
    *v2++ = i;
    if ( v2 == v3 )
    {
      v6 = Stream;
      *(v2 - 1) = 0;
      ungetwc(i, v6);
      return v2;
    }
    if ( i == 10 )
    {
      ++dword_140025C20;
      byte_140015041 = 1;
      *v2 = 0;
      return v2;
    }
    byte_140015041 = 0;
  }
  *v2 = 0;
  return 0i64;
}
// 140015041: using guessed type char byte_140015041;
// 140025C20: using guessed type int dword_140025C20;

//----- (0000000140006DAC) ----------------------------------------------------
wchar_t *__fastcall sub_140006DAC(const wchar_t **a1)
{
  wchar_t *v1; // rbx
  char v3; // di
  const wchar_t *v4; // rcx
  bool v5; // si
  wchar_t *result; // rax
  wchar_t *v7; // rcx
  unsigned __int64 i; // rdx
  __int64 v9; // r8
  wchar_t *v10; // rax
  wchar_t v11; // ax

  v1 = (wchar_t *)&unk_140036E90;
  v3 = 0;
  v4 = *a1;
  v5 = 0;
  while ( 1 )
  {
    result = wcschr(v4, 0x3Cu);
    if ( !result )
      return result;
    v4 = result + 1;
    if ( result[1] == 60 )
      v3 = 1;
    if ( v3 )
    {
      v7 = result + 2;
      for ( i = result[2]; (_WORD)i; i = *v7 )
      {
        if ( (unsigned __int16)i <= 0x3Eu )
        {
          v9 = 0x5000100000000600i64;
          if ( _bittest64(&v9, i) )
            break;
        }
        if ( (_WORD)i == 94 )
          break;
        if ( (_WORD)i == 34 )
          v5 = !v5;
        if ( (_WORD)i == 32 && !v5 )
          break;
        if ( (_WORD)i == 36 && (v10 = v7 + 1, v7[1] == 40) )
        {
          *v1 = 36;
          ++v7;
          *++v1 = 40;
          v11 = *v10;
          if ( v11 == 10 )
            break;
          do
          {
            if ( v11 == 41 )
              break;
            ++v7;
            *v1++ = v11;
            v11 = *v7;
          }
          while ( *v7 != 10 );
          if ( *v7 == 10 )
            break;
        }
        else
        {
          *v1++ = i;
          ++v7;
        }
      }
      *v1 = 0;
      result = (wchar_t *)&unk_140036E90;
      *a1 = v7;
      return result;
    }
  }
}

//----- (0000000140006EE0) ----------------------------------------------------
char *__fastcall sub_140006EE0(char *a1, __int64 a2, char **a3)
{
  const wchar_t **v4; // rdi
  char *v6; // r12
  unsigned __int64 v7; // r15
  char *v8; // r14
  wchar_t *i; // rcx
  wchar_t *v10; // rbx
  wchar_t *v11; // rbx
  wchar_t *v12; // rbx
  _QWORD *v13; // rdi
  __int64 *v14; // rcx
  __int64 *j; // rax
  bool k; // zf
  wchar_t *v17; // rbx
  __int16 v18; // ax
  char *v19; // rax
  unsigned __int64 v20; // rdi
  char v22; // [rsp+20h] [rbp-E0h]
  wchar_t *v23; // [rsp+28h] [rbp-D8h] BYREF
  const wchar_t **v24; // [rsp+30h] [rbp-D0h]
  wchar_t Destination[2]; // [rsp+40h] [rbp-C0h] BYREF
  wint_t v26[1022]; // [rsp+44h] [rbp-BCh] BYREF

  v24 = (const wchar_t **)a2;
  v22 = 0;
  v4 = (const wchar_t **)a2;
  v6 = 0i64;
  v7 = 0i64;
  v8 = 0i64;
  wcscpy_s(Destination, 0x400ui64, L"<<");
  if ( !sub_140006D18(v26, 1022) )
  {
    if ( feof(Stream) )
      sub_140003898(dword_140025C20, 0x409u, L"EOF");
    sub_140003898(dword_140025C20, 0x41Du);
  }
  v23 = Destination;
  for ( i = Destination; ; i = v10 )
  {
    v11 = wcschr(i, 0xAu);
    if ( !v11 || v11 > Destination && *(v11 - 1) != 94 )
      break;
    v10 = v11 + 1;
    if ( !fgetws(v10, 1024 - (unsigned int)(v10 - Destination), Stream) )
    {
      if ( feof(Stream) )
        sub_140003898(dword_140025C20, 0x409u, L"EOF");
      sub_140003898(dword_140025C20, 0x41Du);
    }
    ++dword_140025C20;
  }
  v12 = sub_140006DAC((const wchar_t **)&v23);
  if ( v12 )
  {
    do
    {
      v13 = sub_140009244(0x18ui64);
      v13[1] = sub_14000DCC4(v12);
      v14 = &qword_140036CE0;
      for ( j = (__int64 *)qword_140036CE0; j; j = (__int64 *)*j )
        v14 = j;
      *v14 = (__int64)v13;
      v12 = sub_140006DAC((const wchar_t **)&v23);
    }
    while ( v12 );
    v4 = v24;
  }
  for ( k = qword_140036CE0 == 0; !k; k = qword_140036CE0 == 0 )
  {
    while ( 1 )
    {
      v17 = Destination;
      do
      {
        v18 = *v17++;
        *(_WORD *)a1 = v18;
        a1 += 2;
        if ( a1 == *a3 )
        {
          if ( v8 )
          {
            v20 = v7 + 1024;
            if ( v7 + 1024 < v7 || (v6 = (char *)sub_140009274(v8, 2 * v20)) == 0i64 )
              sub_140003898(dword_140025C20, 0x419u);
            a1 = &v6[2 * v7];
            v8 = v6;
            v7 += 1024i64;
            v19 = &v6[2 * v20];
            v4 = v24;
          }
          else
          {
            v8 = (char *)sub_140009214(saturated_mul(0x800ui64, 2ui64));
            wcsncpy_s((wchar_t *)v8, 0x800ui64, *v4, 0x400ui64);
            a1 = v8 + 2048;
            v7 = 2048i64;
            v19 = v8 + 4096;
          }
          *a3 = v19;
          *v4 = (const wchar_t *)v8;
        }
      }
      while ( *v17 );
      if ( v22 && Destination[0] == 60 && Destination[1] == 60 )
        break;
      v22 = 1;
      if ( !sub_140006D18(Destination, 1024) )
      {
        if ( feof(Stream) )
          sub_140003898(dword_140025C20, 0x409u, L"EOF");
        sub_140003898(dword_140025C20, 0x41Du);
      }
    }
    if ( *(_QWORD *)qword_140036CE0 && !sub_140006D18(Destination, 1024) )
    {
      if ( feof(Stream) )
        sub_140003898(dword_140025C20, 0x409u, L"EOF");
      sub_140003898(dword_140025C20, 0x41Du);
    }
    qword_140036CE0 = *(_QWORD *)qword_140036CE0;
  }
  *(_WORD *)a1 = 0;
  return a1;
}
// 140012000: using guessed type wchar_t aEof[4];
// 140025C20: using guessed type int dword_140025C20;
// 140036CE0: using guessed type __int64 qword_140036CE0;
// 140006EE0: using guessed type wint_t var_83C[1022];

//----- (0000000140007294) ----------------------------------------------------
errno_t __fastcall sub_140007294(void **a1, const wchar_t *a2)
{
  char *v2; // rdi
  __int64 v3; // rbx
  __int64 v4; // r8
  __int64 v6; // rax
  rsize_t v7; // r15
  unsigned __int64 v8; // rcx
  signed __int64 v9; // rcx
  void *v10; // rsp
  void *v11; // rsp
  wchar_t *i; // rax
  rsize_t v13; // rbx
  wchar_t *v14; // rax
  wchar_t Destination[4]; // [rsp+20h] [rbp+0h] BYREF

  v2 = (char *)*a1;
  v3 = -1i64;
  v4 = -1i64;
  do
    ++v4;
  while ( *(_WORD *)&v2[2 * v4] );
  v6 = -1i64;
  do
    ++v6;
  while ( a2[v6] );
  v7 = v4 + v6 - 1;
  v8 = 2 * v7 + 15;
  if ( v8 <= 2 * v7 )
    v8 = 0xFFFFFFFFFFFFFF0i64;
  v9 = v8 & 0xFFFFFFFFFFFFFFF0ui64;
  v10 = alloca(v9);
  v11 = alloca(v9);
  for ( i = Destination; ; ++i )
  {
    if ( *(_WORD *)v2 != 60 )
    {
      *i = *(_WORD *)v2;
      goto LABEL_12;
    }
    if ( *((_WORD *)v2 + 1) == 60 )
      break;
    *i = 60;
LABEL_12:
    v2 += 2;
  }
  *i = 0;
  wcscat_s(Destination, v7, a2);
  wcscat_s(Destination, v7, (const wchar_t *)v2 + 2);
  do
    ++v3;
  while ( Destination[v3] );
  v13 = v3 + 1;
  v14 = (wchar_t *)sub_140009274(*a1, 2 * v13);
  *a1 = v14;
  return wcscpy_s(v14, v13, Destination);
}

//----- (00000001400073BC) ----------------------------------------------------
int __fastcall sub_1400073BC(FILE *Stream, __int64 a2, const wchar_t **a3, char a4, _BYTE *a5)
{
  __int64 v5; // rdi
  FILE *v6; // r12
  char v7; // bl
  const wchar_t **v8; // rsi
  char v9; // r14
  wchar_t *v10; // rax
  char v11; // r15
  _WORD *v12; // rdi
  wchar_t *v13; // rax
  wchar_t *v14; // rbx
  wchar_t *v15; // rbp
  wchar_t *v16; // rbx
  wchar_t *v17; // rax
  wchar_t *v18; // r15
  const wchar_t *v19; // rbp
  wint_t *v20; // rbx
  bool v21; // r13
  const wchar_t *v22; // rdx
  __int64 v23; // rax
  rsize_t v24; // r12
  unsigned __int64 v25; // rax
  __int64 v26; // rbx
  wint_t *v27; // rdi
  unsigned __int64 v28; // rbx
  const wchar_t *v29; // r8
  size_t v30; // rdx
  const char *v31; // rcx
  const WCHAR *i; // rbx
  int v33; // eax
  char v35; // [rsp+40h] [rbp-58h]
  wchar_t *Context[10]; // [rsp+48h] [rbp-50h] BYREF

  v5 = a2;
  v6 = Stream;
  v7 = a4;
  v8 = a3;
  v9 = 1;
  v10 = wcsstr(*a3, L"<<");
  v35 = 0;
  v11 = 0;
  if ( v10 && (v10 == *v8 || *(v10 - 1) == 10) )
  {
    v12 = v10 + 2;
    v13 = wcschr(v10 + 2, 0xAu);
    v14 = v13;
    if ( v13 )
      *v13 = 0;
    v15 = (wchar_t *)sub_14000DCC4(v12);
    if ( v14 )
      *v14 = 10;
    Context[0] = 0i64;
    v16 = wcstok_s(v15, L", \t", Context);
    if ( v16 )
    {
      do
      {
        if ( wcsicmp(v16, L"keep") )
        {
          if ( wcsicmp(v16, L"nokeep") )
          {
            if ( wcsicmp(v16, L"unicode") )
              sub_140003898(dword_140025C20, 0x446u);
            else
              v11 = 1;
          }
          else
          {
            *a5 = 0;
          }
        }
        else
        {
          *a5 = 1;
        }
        v16 = wcstok_s(0i64, L", \t", Context);
      }
      while ( v16 );
      v35 = v11;
    }
    free(v15);
    if ( v11 )
      fwrite(&unk_1400120B4, 2ui64, 1ui64, v6);
    v7 = a4;
    v5 = a2;
  }
  LODWORD(v17) = wcsncmp(*v8, L"<<", 2ui64);
  if ( (_DWORD)v17 )
  {
    while ( 1 )
    {
      v17 = wcschr(*v8, 0xAu);
      v18 = v17;
      if ( !v17 )
        break;
      if ( v7 )
      {
        v19 = *v8;
        *v17 = 0;
        v20 = (wint_t *)v19;
        v21 = v9 == 0;
        if ( *v19 )
        {
          while ( iswspace(*v20) )
          {
            if ( !*++v20 )
              goto LABEL_27;
          }
          v23 = -1i64;
          do
            ++v23;
          while ( *(_WORD *)(v5 + 2 * v23) );
          v24 = 1024 - (v23 + 12);
          while ( *v19 )
          {
            wcsncpy_s(word_14003D150, 0x400ui64, v19, v24);
            v25 = -1i64;
            v26 = -1i64;
            do
              ++v26;
            while ( word_14003D150[v26] );
            do
              ++v25;
            while ( v19[v25] );
            if ( v24 < v25 )
            {
              v27 = word_14003D150;
              if ( word_14003D150[0] )
              {
                do
                {
                  if ( iswspace(*v27) )
                    v26 = v27 - word_14003D150 + 1;
                  ++v27;
                }
                while ( *v27 );
                v8 = a3;
              }
              v5 = a2;
            }
            v28 = v26;
            if ( v28 >= 1024 )
              _report_rangecheckfailure(word_14003D150);
            word_14003D150[v28] = 0;
            v29 = L">";
            if ( v21 )
              v29 = L">>";
            sub_14000BFE0(L"\techo %s %s %s\n", word_14003D150, v29, v5);
            v19 = (const wchar_t *)((char *)v19 + v28 * 2);
            v21 = 1;
          }
          v6 = Stream;
        }
        else
        {
LABEL_27:
          v22 = L">";
          if ( !v9 )
            v22 = L">>";
          sub_14000BFE0(L"\techo. %s %s\n", v22, v5);
        }
        *v18 = 10;
      }
      if ( v35 )
      {
        fwrite(*v8, v18 - *v8, 2ui64, v6);
        v30 = 4i64;
        v31 = "\r";
      }
      else
      {
        for ( i = *v8; i < v18; ++i )
        {
          v33 = WideCharToMultiByte(0, 0, i, 1, (LPSTR)Context, 4, 0i64, 0i64);
          if ( v33 )
            fwrite(Context, v33, 1ui64, v6);
        }
        v30 = 2i64;
        v31 = "\r\n";
      }
      fwrite(v31, v30, 1ui64, v6);
      *v8 = v18 + 1;
      v9 = 0;
      LODWORD(v17) = wcsncmp(v18 + 1, L"<<", 2ui64);
      if ( !(_DWORD)v17 )
        goto LABEL_60;
      v7 = a4;
    }
  }
  else
  {
LABEL_60:
    *v8 += 2;
  }
  return (int)v17;
}
// 14001025C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD);
// 140012020: using guessed type wchar_t asc_140012020[3];
// 140012028: using guessed type wchar_t asc_140012028[2];
// 140012030: using guessed type wchar_t aEchoSS[14];
// 140012050: using guessed type wchar_t aEchoSSS[16];
// 140025C20: using guessed type int dword_140025C20;
// 14003D150: using guessed type wchar_t word_14003D150[1024];

//----- (00000001400077D0) ----------------------------------------------------
char __fastcall sub_1400077D0(wchar_t *Src, void **a2, _QWORD *a3, char a4)
{
  wchar_t *v7; // r14
  const wchar_t *v9; // r14
  wchar_t *v10; // r13
  wchar_t *i; // rax
  _WORD *v12; // rax
  _WORD *v13; // r12
  FILE *v14; // r15
  __int64 v15; // rdi
  __int64 v16; // rbx
  __int64 v17; // rcx
  unsigned __int64 v18; // rdi
  const wchar_t *v19; // rcx
  wchar_t *v20; // rax
  _WORD *v21; // rdx
  __int64 v22; // r8
  wchar_t *v23; // rbx
  wchar_t *v24; // rax
  wchar_t *v25; // rax
  __int64 v26; // rax
  _QWORD *v27; // rbx
  __int64 *v28; // rdx
  __int64 *j; // rcx
  char v30; // [rsp+30h] [rbp-D0h] BYREF
  char v31; // [rsp+31h] [rbp-CFh]
  wchar_t *Str; // [rsp+38h] [rbp-C8h] BYREF
  const wchar_t *v33; // [rsp+40h] [rbp-C0h] BYREF
  size_t RequiredCount; // [rsp+48h] [rbp-B8h] BYREF
  wchar_t Buffer; // [rsp+50h] [rbp-B0h] BYREF
  __int16 v36[263]; // [rsp+52h] [rbp-AEh] BYREF
  WCHAR TempFileName[264]; // [rsp+260h] [rbp+160h] BYREF

  v31 = a4;
  v7 = wcschr(Src, 0xAu);
  if ( v7 )
  {
    *v7 = 0;
    *a2 = sub_14000E740(Src, 255, a3);
    *v7 = 10;
    v9 = v7 + 1;
    if ( *a2 == Src )
      *a2 = sub_14000DCC4(Src);
    v33 = (const wchar_t *)*a2;
    Str = (wchar_t *)sub_14000E740(v9, 255, a3);
    v10 = Str;
    for ( i = sub_140006DAC(&v33); i; i = sub_140006DAC(&v33) )
    {
      v30 = 0;
      v12 = sub_14000DCC4(i);
      v13 = v12;
      if ( *v12 )
      {
        v14 = sub_14000FD2C((__int64)v12, L"wb");
        if ( v14 )
        {
          v19 = (const wchar_t *)*a2;
          do
          {
            v20 = wcschr(v19, 0x3Cu);
            v19 = v20 + 1;
          }
          while ( v20[1] != 60 );
          v21 = v20 + 2;
          v22 = -1i64;
          do
            ++v22;
          while ( v21[v22] );
          memmove(v20, v21, 2 * v22 + 2);
        }
        else
        {
          sub_140003898(dword_140025C20, 0x41Eu, v13);
        }
      }
      else
      {
        RequiredCount = 0i64;
        if ( wgetenv_s(&RequiredCount, &Buffer, 0x103ui64, L"TMP") || !RequiredCount )
          wcscpy_s(&Buffer, 0x103ui64, L".");
        v14 = 0i64;
        if ( GetTempFileNameW(&Buffer, L"nm", 0, TempFileName) )
        {
          wcscpy_s(&Buffer, 0x103ui64, TempFileName);
          v14 = wfsopen(&Buffer, L"wb", 32);
        }
        if ( !v14 )
          sub_140003898(dword_140025C20, 0x41Eu, &Buffer);
        if ( wcschr(&Buffer, 0x20u) && !wcschr(&Buffer, 0x22u) )
        {
          v15 = -1i64;
          do
            ++v15;
          while ( v36[v15 - 1] );
          v16 = v15;
          memmove(v36, &Buffer, 2 * v15);
          v18 = 2 * v15 + 4;
          Buffer = 34;
          v36[v16] = 34;
          if ( v18 >= 0x206 )
            _report_rangecheckfailure(v17);
          *(__int16 *)((char *)&v36[-1] + v18) = 0;
        }
        sub_140007294(a2, &Buffer);
        free(v13);
        v13 = sub_14000DCC4(&Buffer);
      }
      v33 = (const wchar_t *)*a2;
      sub_1400073BC(v14, (__int64)v13, (const wchar_t **)&Str, v31, &v30);
      v23 = Str;
      v24 = wcschr(Str, 0xAu);
      if ( v24 )
      {
        v25 = v24 + 1;
      }
      else
      {
        v26 = -1i64;
        do
          ++v26;
        while ( v23[v26] );
        v25 = &v23[v26];
      }
      Str = v25;
      fclose(v14);
      if ( !v30 )
      {
        v27 = sub_14000DC58();
        v27[1] = sub_14000DCC4(v13);
        v28 = &qword_140036E88;
        for ( j = (__int64 *)qword_140036E88; j; j = (__int64 *)*j )
          v28 = j;
        *v28 = (__int64)v27;
      }
      free(v13);
    }
    if ( v10 != v9 )
      free(v10);
    return 1;
  }
  else
  {
    *a2 = sub_14000DCC4(Src);
    return 0;
  }
}
// 140007B5C: variable 'v17' is possibly undefined
// 14001025C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD);
// 140025C20: using guessed type int dword_140025C20;
// 140036E88: using guessed type __int64 qword_140036E88;

//----- (0000000140007B64) ----------------------------------------------------
wint_t __fastcall sub_140007B64(char a1)
{
  wint_t result; // ax
  wint_t v3; // ax

LABEL_1:
  byte_140015041 = 0;
  while ( 1 )
  {
    result = a1 ? getwc(Stream) : sub_14000613C();
    if ( result == 0xFFFF )
      return result;
    if ( result == 10 )
    {
      byte_140015041 = 1;
      if ( a1 )
        v3 = getwc(Stream);
      else
        v3 = sub_14000613C();
      if ( v3 == 59 && byte_140026489 || v3 == 35 )
      {
        ++dword_140025C20;
        goto LABEL_1;
      }
      return ungetwc(v3, Stream);
    }
  }
}
// 140015041: using guessed type char byte_140015041;
// 140025C20: using guessed type int dword_140025C20;
// 140026489: using guessed type char byte_140026489;

//----- (0000000140007BF0) ----------------------------------------------------
char __fastcall sub_140007BF0(wchar_t a1)
{
  wchar_t *v2; // rcx
  __int64 v3; // rax
  unsigned __int64 v4; // rax

  if ( a1 == 10 || a1 == 0xFFFF )
    sub_140003898(dword_140025C20, 0x407u);
  Src = a1;
  if ( !fgetws(&word_140025C52, 1023, Stream) )
  {
    if ( feof(Stream) )
      sub_140003898(dword_140025C20, 0x409u, L"EOF");
    sub_140003898(dword_140025C20, 0x41Du);
  }
  v2 = &Src;
  v3 = -1i64;
  do
    ++v3;
  while ( *(&Src + v3) );
  v4 = 2 * (v3 - 1);
  if ( *(wchar_t *)((char *)&Src + v4) == 10 )
  {
    if ( v4 >= 0x800 )
      _report_rangecheckfailure(&Src);
    *(wchar_t *)((char *)&Src + v4) = 0;
  }
  while ( *v2 == 32 || *v2 == 9 )
    ++v2;
  return sub_140008BCC(v2);
}
// 14001025C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD);
// 140012000: using guessed type wchar_t aEof[4];
// 140025C20: using guessed type int dword_140025C20;

//----- (0000000140007CC8) ----------------------------------------------------
char __fastcall sub_140007CC8(wint_t a1, _DWORD *a2, unsigned __int64 a3)
{
  char v4; // dl
  int v6; // eax
  char v7; // bl
  char result; // al
  wint_t v9; // bx

  v4 = byte_140015041;
  while ( 1 )
  {
    switch ( a1 )
    {
      case 0xAu:
        goto LABEL_17;
      case 0x3Au:
        byte_140015041 = 0;
        a1 = sub_14000613C();
        if ( a1 == 58 )
        {
          *a2 = 58;
          return 21;
        }
        v7 = 20;
LABEL_26:
        ungetwc(a1, Stream);
        return v7;
      case 0x3Bu:
        result = 19;
LABEL_47:
        byte_140015041 = 0;
        return result;
      case 0x3Du:
        result = 22;
        goto LABEL_47;
    }
    if ( a1 == 91 )
      break;
    if ( a1 == 94 )
      goto LABEL_30;
    if ( a1 != 0xFFFF )
      goto LABEL_31;
    if ( !feof(Stream) )
      sub_140003898(dword_140025C20, 0x40Eu);
    if ( !dword_140036CE8 )
    {
      if ( dword_140015044 < 0 )
        return 23;
      sub_140003898(dword_140025C20, 0x3FCu);
LABEL_17:
      v6 = dword_140025C20;
      goto LABEL_18;
    }
    if ( fclose(Stream) == 0xFFFF )
      sub_140003898(0, 0x424u, qword_140026490);
    free(qword_140026490);
    Stream = (FILE *)*((_QWORD *)&unk_140036CF0 + 3 * --dword_140036CE8 + 2);
    qword_140026490 = (void *)*((_QWORD *)&unk_140036CF0 + 3 * dword_140036CE8 + 1);
    v6 = *((_DWORD *)&unk_140036CF0 + 6 * dword_140036CE8);
LABEL_18:
    byte_140015041 = 1;
    dword_140025C20 = v6 + 1;
    a1 = sub_14000613C();
    if ( a1 == 59 && byte_140026489 || a1 == 35 )
    {
      sub_140007B64(0);
      ++dword_140025C20;
      byte_140015041 = 1;
      a1 = sub_14000613C();
    }
    if ( a1 == 32 || a1 == 9 )
    {
      result = 18;
      goto LABEL_47;
    }
    v4 = 1;
    byte_140015041 = 1;
    if ( a1 != 0xFFFF )
    {
      v7 = 17;
      goto LABEL_26;
    }
  }
  if ( byte_140026489 && v4 )
    return 23;
LABEL_30:
  ungetwc(a1, Stream);
  a2 = (_DWORD *)((char *)a2 - 2);
LABEL_31:
  sub_140008874((_WORD *)a2 - 1, a3);
  if ( !byte_140015041 || wcsicmp(&Src, L"include") )
  {
    byte_140015041 = 0;
    return 16;
  }
  byte_140015041 = 0;
  v9 = sub_140008044(0);
  if ( v9 == 58 || v9 == 61 )
  {
    ungetwc(v9, Stream);
    return 16;
  }
  if ( byte_140026489 )
    sub_140003898(dword_140025C20, 0x409u, a2);
  return sub_140007BF0(v9);
}
// 140015041: using guessed type char byte_140015041;
// 140015044: using guessed type int dword_140015044;
// 140025C20: using guessed type int dword_140025C20;
// 140026489: using guessed type char byte_140026489;
// 140036CE8: using guessed type int dword_140036CE8;

//----- (0000000140007F84) ----------------------------------------------------
char __fastcall sub_140007F84(__int64 a1, __int64 a2)
{
  char v2; // bl
  wint_t v3; // ax
  wint_t v4; // cx
  wchar_t *v5; // rdx

  v2 = a2;
  if ( byte_14002648A )
  {
    ++dword_140025C20;
    byte_14002648A = 0;
    v3 = sub_14000613C();
    if ( v3 == 32 || v3 == 9 )
    {
      byte_140015041 = 0;
      return 18;
    }
    else
    {
      v4 = -1;
      byte_140015041 = 1;
      if ( v3 == 0xFFFF )
      {
        v5 = &Src;
        return sub_140007CC8(v4, v5, (unsigned __int64)&qword_140026450);
      }
      ungetwc(v3, Stream);
      return 17;
    }
  }
  else
  {
    if ( (unsigned __int8)(a2 - 24) > 1u )
    {
      Src = sub_140008044(0);
      v5 = &word_140025C52;
      v4 = Src;
      word_140025C52 = 0;
      return sub_140007CC8(v4, v5, (unsigned __int64)&qword_140026450);
    }
    sub_1400081F0(a2, a2, (char *)&qword_140026450);
    return v2;
  }
}
// 140015041: using guessed type char byte_140015041;
// 140025C20: using guessed type int dword_140025C20;
// 140026450: using guessed type __int64 qword_140026450;
// 14002648A: using guessed type char byte_14002648A;

//----- (0000000140008044) ----------------------------------------------------
wint_t __fastcall sub_140008044(char a1)
{
  wint_t result; // ax

  while ( 1 )
  {
    result = a1 ? getwc(Stream) : sub_14000613C();
    if ( result == 32 || result == 9 || result == 94 )
      break;
LABEL_14:
    if ( result == 92 )
      result = sub_140008128(0x5Cu, a1);
    if ( result != 32 && result != 9 )
      goto LABEL_20;
  }
  if ( result != 94 || (!a1 ? (result = sub_14000613C()) : (result = getwc(Stream)), result == 32 || result == 9) )
  {
    byte_140015041 = 0;
    goto LABEL_14;
  }
  ungetwc(result, Stream);
  result = 94;
LABEL_20:
  if ( result == 59 )
  {
    if ( byte_140015041 )
    {
      if ( !byte_140026489 )
        goto LABEL_23;
LABEL_24:
      sub_140007B64(a1);
      result = 10;
      byte_140015041 = 1;
    }
  }
  else
  {
LABEL_23:
    if ( result == 35 )
      goto LABEL_24;
  }
  return result;
}
// 140015041: using guessed type char byte_140015041;
// 140026489: using guessed type char byte_140026489;

//----- (0000000140008128) ----------------------------------------------------
__int64 __fastcall sub_140008128(wint_t a1, char a2)
{
  wint_t v3; // ax
  wint_t v4; // ax
  wint_t v5; // ax

  while ( 1 )
  {
    if ( a1 != 92 )
      return a1;
    v3 = a2 ? getwc(Stream) : sub_14000613C();
    if ( v3 != 10 )
      break;
    ++dword_140025C20;
    byte_140015041 = 1;
    if ( a2 )
      v4 = getwc(Stream);
    else
      v4 = sub_14000613C();
    a1 = v4;
    if ( v4 == 59 && byte_140026489 || v4 == 35 )
    {
      sub_140007B64(a2);
      ++dword_140025C20;
      if ( a2 )
        v5 = getwc(Stream);
      else
        v5 = sub_14000613C();
      a1 = v5;
    }
  }
  ungetwc(v3, Stream);
  return 92i64;
}
// 140015041: using guessed type char byte_140015041;
// 140025C20: using guessed type int dword_140025C20;
// 140026489: using guessed type char byte_140026489;

//----- (00000001400081F0) ----------------------------------------------------
wchar_t *__fastcall sub_1400081F0(char a1, __int64 a2, char *a3)
{
  wchar_t *v3; // rbx
  wchar_t *v4; // r12
  unsigned __int64 v5; // r13
  wchar_t *v6; // r14
  char *v7; // r15
  char v8; // di
  wint_t v9; // si
  unsigned __int8 v10; // bp
  wint_t v11; // ax
  wint_t v12; // ax
  bool v13; // al
  wint_t v14; // ax
  unsigned int v15; // ecx
  int v16; // eax
  __int64 v17; // rdi
  unsigned __int8 v18; // di
  wint_t v19; // ax
  wint_t v20; // ax
  wint_t v21; // ax
  char *v22; // rax
  char v23; // cl
  __int64 v24; // rdi
  wchar_t *v25; // rax
  wchar_t *v26; // rdi
  wchar_t *v27; // rcx
  wchar_t *result; // rax
  bool v30; // [rsp+78h] [rbp+10h]
  char *v31; // [rsp+80h] [rbp+18h] BYREF
  wchar_t *v32; // [rsp+88h] [rbp+20h] BYREF

  v31 = a3;
  v3 = &Src;
  v4 = 0i64;
  v30 = 0;
  v5 = 0i64;
  v32 = &Src;
  v6 = &Src;
  v7 = a3;
  v8 = a1;
  v9 = sub_14000613C();
  if ( v8 == 24 )
  {
    v10 = 2;
    goto LABEL_12;
  }
  if ( v9 == 32 || v9 == 9 )
    goto LABEL_10;
  if ( v9 == 94 )
  {
    v11 = sub_14000613C();
    if ( v11 != 32 && v11 != 9 )
    {
      ungetwc(v11, Stream);
      v9 = 94;
      goto LABEL_9;
    }
LABEL_10:
    v10 = 2;
    v12 = sub_140008044(0);
    goto LABEL_11;
  }
LABEL_9:
  v10 = 1;
  while ( 1 )
  {
LABEL_12:
    if ( v9 == 34 )
    {
      v13 = !v30;
      v30 = !v30;
    }
    else
    {
      v13 = v30;
    }
    if ( v9 == 94 )
    {
      if ( v13 || v8 != 25 )
      {
        v20 = sub_14000613C();
        ungetwc(v20, Stream);
        v9 = 94;
      }
      else
      {
        v14 = sub_14000613C();
        v9 = v14;
        if ( v14 > 0x2Du )
        {
          if ( v14 == 64 )
            goto LABEL_31;
          if ( v14 == 92 )
            goto LABEL_39;
          v15 = v14 - 94;
          if ( v15 <= 0x1F )
          {
            v16 = -1610612735;
            if ( _bittest(&v16, v15) )
              goto LABEL_31;
          }
        }
        else
        {
          switch ( v14 )
          {
            case 0x2Du:
              goto LABEL_31;
            case 0xAu:
              goto LABEL_39;
            case 0x21u:
              goto LABEL_31;
          }
          if ( v14 > 0x21u )
          {
            if ( v14 <= 0x23u )
              goto LABEL_39;
            if ( ((v14 - 36) & 0xFFFFFFFA) == 0 && v14 != 37 )
            {
LABEL_31:
              *v3++ = 94;
              if ( v3 == (wchar_t *)v7 )
              {
                if ( qword_140025C30 )
                {
                  v17 = v5 + 1024;
                  if ( v5 + 1024 < v5 || (v4 = (wchar_t *)sub_140009274(qword_140025C30, 2 * v17)) == 0i64 )
                    sub_140003898(dword_140025C20, 0x419u);
                  qword_140025C30 = v4;
                  v3 = &v4[v5];
                  v7 = (char *)&v4[v17];
                }
                else
                {
                  v17 = 2048i64;
                  qword_140025C30 = (wchar_t *)sub_140009214(saturated_mul(0x800ui64, 2ui64));
                  wcsncpy_s(qword_140025C30, 0x800ui64, v6, 0x400ui64);
                  v3 = qword_140025C30 + 1024;
                  v7 = (char *)(qword_140025C30 + 2048);
                }
                v6 = qword_140025C30;
                v5 = v17;
                v32 = qword_140025C30;
                v31 = v7;
              }
LABEL_39:
              v18 = 0;
              goto LABEL_40;
            }
          }
        }
      }
    }
    if ( v9 > 0x3Bu )
      break;
    switch ( v9 )
    {
      case 0x3Bu:
        v18 = 0;
        if ( !v10 && byte_140026489 )
        {
LABEL_101:
          v30 = 0;
          sub_140007B64(0);
          ++dword_140025C20;
          goto LABEL_111;
        }
        break;
      case 9u:
        goto LABEL_68;
      case 0xAu:
        goto LABEL_94;
      case 0x20u:
LABEL_68:
        v18 = 5;
        break;
      case 0x23u:
        goto LABEL_100;
      case 0x24u:
        v18 = 7;
        break;
      case 0x28u:
        v18 = 8;
        break;
      case 0x29u:
        v18 = 9;
        break;
      case 0x2Au:
        v18 = 11;
        break;
      case 0x3Au:
        v18 = 4;
        break;
      default:
        goto LABEL_90;
    }
LABEL_40:
    v10 = byte_140011970[14 * v10 + 288 + v18];
LABEL_41:
    if ( v10 == 64 )
      goto LABEL_113;
    if ( (v10 & 0x20) != 0 )
      sub_140003898(dword_140025C20, (v10 & 0xDF) + 1000, v9);
    if ( v10 )
    {
      *v3++ = v9;
      if ( v3 == (wchar_t *)v7 )
      {
        if ( qword_140025C30 )
        {
          v24 = v5 + 1024;
          if ( v5 + 1024 < v5 || (v25 = (wchar_t *)sub_140009274(qword_140025C30, 2 * v24), (v4 = v25) == 0i64) )
          {
            sub_140003898(dword_140025C20, 0x419u);
            __debugbreak();
          }
          qword_140025C30 = v25;
          v3 = &v25[v5];
          v7 = (char *)&v25[v24];
        }
        else
        {
          v24 = 2048i64;
          qword_140025C30 = (wchar_t *)sub_140009214(saturated_mul(0x800ui64, 2ui64));
          wcsncpy_s(qword_140025C30, 0x800ui64, v6, 0x400ui64);
          v3 = qword_140025C30 + 1024;
          v7 = (char *)(qword_140025C30 + 2048);
        }
        v31 = v7;
        v5 = v24;
      }
    }
    else
    {
      ++dword_140025C20;
      *(v3 - 1) = 32;
      byte_140015041 = 1;
      v19 = sub_14000613C();
      byte_140015041 = 0;
      if ( v19 == 32 || v19 == 9 )
      {
        v10 = 2;
        do
        {
          do
            v19 = sub_14000613C();
          while ( v19 == 32 );
        }
        while ( v19 == 9 );
      }
      ungetwc(v19, Stream);
    }
LABEL_111:
    v12 = sub_14000613C();
    v8 = a1;
LABEL_11:
    v9 = v12;
  }
  if ( v9 > 0x44u )
  {
    if ( v9 == 70 || v9 == 82 )
      goto LABEL_79;
    if ( v9 == 92 )
    {
      v18 = 3;
      goto LABEL_40;
    }
    if ( v9 != 0xFFFF )
      goto LABEL_90;
LABEL_94:
    v18 = 6;
    goto LABEL_40;
  }
  switch ( v9 )
  {
    case 'D':
      goto LABEL_79;
    case '<':
      goto LABEL_85;
    case '=':
      v18 = 2;
      goto LABEL_40;
  }
  if ( v9 > 0x3Eu )
  {
    if ( v9 <= 0x40u )
    {
LABEL_85:
      v18 = 12;
      if ( a1 == 24 && v9 == 60 )
      {
        v21 = sub_14000613C();
        if ( v21 == 60 )
        {
          v22 = sub_140006EE0((char *)v3, (__int64)&v32, &v31);
          --dword_140025C20;
          v3 = (wchar_t *)v22;
          v7 = v31;
          v18 = 6;
          v6 = v32;
          v9 = 10;
        }
        else
        {
          ungetwc(v21, Stream);
        }
        v10 = byte_140011970[14 * v10 + 288 + v18];
        goto LABEL_41;
      }
      goto LABEL_40;
    }
    if ( v9 == 66 )
    {
LABEL_79:
      v18 = 13;
      goto LABEL_98;
    }
  }
LABEL_90:
  if ( v9 >= 0x80u )
    v23 = iswspace(v9) == 0;
  else
    v23 = byte_140011640[v9] & 1;
  v18 = v23 != 0 ? 0xA : 0;
LABEL_98:
  if ( v18 != 1 )
    goto LABEL_40;
  v8 = a1;
LABEL_100:
  if ( !v10 )
    goto LABEL_101;
  if ( v8 != 25 )
  {
    v10 = byte_140011970[14 * v10 + 289];
    goto LABEL_41;
  }
LABEL_113:
  ungetwc(v9, Stream);
  if ( v3 > v6 )
  {
    do
    {
      v26 = v3 - 1;
      if ( !iswspace(*(v3 - 1)) )
        break;
      --v3;
    }
    while ( v26 > v6 );
  }
  v27 = qword_140025C30;
  *v3 = 0;
  if ( !v27 )
  {
    result = (wchar_t *)sub_14000DCC4(v6);
    goto LABEL_120;
  }
  result = (wchar_t *)sub_140009274(v27, 2 * (v3 - v27) + 2);
  if ( result )
LABEL_120:
    qword_140025C30 = result;
  return result;
}
// 1400085C7: conditional instruction was optimized away because di.1 is in (<Bu|==D)
// 140011640: using guessed type _BYTE byte_140011640[128];
// 140011970: using guessed type _BYTE byte_140011970[472];
// 140015041: using guessed type char byte_140015041;
// 140025C20: using guessed type int dword_140025C20;
// 140026489: using guessed type char byte_140026489;

//----- (0000000140008874) ----------------------------------------------------
_WORD *__fastcall sub_140008874(_WORD *a1, unsigned __int64 a2)
{
  int v2; // eax
  wchar_t *v3; // rsi
  char v5; // bp
  char v6; // r15
  unsigned __int8 v7; // di
  wint_t v8; // bx
  wint_t v9; // ax
  unsigned int v10; // eax
  int v11; // ecx
  unsigned __int8 v12; // dl
  char v13; // cl
  bool v14; // cl
  char v15; // al
  wint_t v16; // ax
  wint_t v17; // ax

  v2 = (unsigned __int16)*a1;
  v3 = a1 + 1;
  v5 = 0;
  v6 = 0;
  if ( v2 == 34 )
  {
    v6 = 1;
    v7 = 16;
  }
  else if ( v2 == 36 )
  {
    v7 = 2;
  }
  else
  {
    v7 = v2 != 123 ? 0 : 8;
  }
  while ( 1 )
  {
    v8 = sub_14000613C();
    if ( v8 == 94 )
    {
      v9 = sub_14000613C();
      v8 = v9;
      if ( v9 == 10 || v9 == 35 )
        goto LABEL_16;
      if ( v9 == 36 )
        goto LABEL_15;
      if ( v9 > 0x27u )
      {
        if ( v9 <= 0x29u )
          goto LABEL_15;
        if ( v9 == 92 )
          goto LABEL_16;
        v10 = v9 - 94;
        if ( v10 <= 0x1F )
        {
          v11 = -1610612735;
          if ( _bittest(&v11, v10) )
          {
LABEL_15:
            *v3++ = 94;
LABEL_16:
            v12 = 0;
            goto LABEL_59;
          }
        }
      }
    }
    if ( v8 > 0x29u )
    {
      switch ( v8 )
      {
        case 0x3Au:
          v12 = 4;
          goto LABEL_59;
        case 0x3Bu:
          v12 = 3;
          goto LABEL_59;
        case 0x3Du:
          v12 = 2;
          goto LABEL_59;
        case 0x5Cu:
          v12 = 13;
          goto LABEL_59;
        case 0x7Bu:
          v12 = 11;
          goto LABEL_59;
        case 0x7Du:
          v12 = 12;
          goto LABEL_59;
        case 0xFFFFu:
          goto LABEL_52;
      }
    }
    else
    {
      switch ( v8 )
      {
        case 0x29u:
          v12 = 9;
          goto LABEL_59;
        case 9u:
          goto LABEL_31;
        case 0xAu:
LABEL_52:
          v12 = 6;
          goto LABEL_59;
        case 0x20u:
LABEL_31:
          v12 = v6 == 0 ? 5 : 0;
          goto LABEL_59;
        case 0x22u:
          v12 = 14;
          if ( v7 == 18 )
            v6 = 1;
          goto LABEL_59;
        case 0x23u:
          v12 = 1;
          goto LABEL_59;
        case 0x24u:
          v12 = 7;
          goto LABEL_59;
        case 0x28u:
          v12 = 8;
          goto LABEL_59;
      }
    }
    if ( byte_140025C38 >= 0 )
    {
      v14 = v8 >= 0x80u ? iswspace(v8) == 0 : byte_140011640[v8] & 1;
      v12 = v14 ? 0xA : 0;
    }
    else
    {
      if ( v8 >= 0x80u )
        v13 = iswspace(v8) == 0;
      else
        v13 = byte_140011640[v8] & 1;
      if ( !v13 && v8 != 42 && v8 != 64 )
        goto LABEL_16;
      v12 = 10;
    }
LABEL_59:
    v7 = byte_140011970[15 * v7 + v12];
    if ( v6 )
    {
      v15 = v7;
      if ( v7 == 1 )
        v15 = 16;
      v7 = v15;
    }
    if ( v5 )
    {
      if ( v12 == 6 )
      {
        ++dword_140025C20;
        byte_140015041 = 1;
        v16 = sub_14000613C();
        byte_140015041 = 0;
        v8 = v16;
        if ( v16 == 32 || v16 == 9 )
        {
          v7 = 64;
          do
          {
            do
            {
              v17 = sub_14000613C();
              v8 = v17;
            }
            while ( v17 == 32 );
          }
          while ( v17 == 9 );
        }
        else
        {
          v7 = v3 != &word_140025C52;
        }
      }
      else
      {
        *v3++ = 92;
      }
    }
    v5 = 0;
    if ( (unsigned __int64)v3 >= a2 )
      sub_140003898(dword_140025C20, 0x434u);
    if ( v7 == 64 )
      break;
    if ( (v7 & 0x20) != 0 )
      sub_140003898(dword_140025C20, (v7 & 0xDF) + 1000, v8);
    if ( v7 == 15 )
      v5 = 1;
    else
      *v3++ = v8;
  }
  ungetwc(v8, Stream);
  *v3 = 0;
  return sub_14000BB94(a1);
}
// 140011640: using guessed type _BYTE byte_140011640[128];
// 140011970: using guessed type _BYTE[472];
// 140015041: using guessed type char byte_140015041;
// 140025C20: using guessed type int dword_140025C20;
// 140025C38: using guessed type char byte_140025C38;

//----- (0000000140008BCC) ----------------------------------------------------
char __fastcall sub_140008BCC(wchar_t *Src)
{
  wchar_t *v1; // rdi
  __int16 v2; // si
  wchar_t *v3; // rbx
  __int64 v4; // rax
  __int16 *i; // rsi
  __int16 v6; // ax
  wchar_t *v7; // rax
  wchar_t *v8; // rdi
  wchar_t *v9; // rsi
  char *v10; // rax
  _WORD *v11; // rcx
  wchar_t *v12; // rdi
  wchar_t *v13; // rbx
  wchar_t *v14; // rsi
  int v15; // ecx
  int v16; // ebp
  __int64 v17; // r14
  const wchar_t **v18; // r13
  bool v19; // zf
  const wchar_t *v20; // rcx
  wchar_t *v21; // r15
  __int64 v22; // rcx
  __int64 v23; // rax
  unsigned __int64 v24; // rbx
  wchar_t *v25; // r8
  int v26; // edx
  int v27; // ebx
  const wchar_t **v28; // rsi
  __int64 v29; // rcx
  wint_t v30; // ax
  wchar_t *Destination; // [rsp+20h] [rbp-298h]
  HANDLE v33; // [rsp+28h] [rbp-290h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+30h] [rbp-288h] BYREF

  v1 = Src;
  v2 = 0;
  if ( !*Src || *Src == 35 )
  {
    sub_140003898(dword_140025C20, 0x407u);
    JUMPOUT(0x140009074i64);
  }
  v3 = wcspbrk(Src, L"\t#");
  v4 = -1i64;
  if ( v3 )
  {
    if ( *v3 == 35 )
      v2 = 35;
    *v3 = 0;
    if ( !v2 )
    {
      for ( i = (__int16 *)(v3 + 1); ; ++i )
      {
        v6 = *i;
        if ( !*i || v6 == 35 )
          break;
        if ( v6 != 32 && v6 != 9 )
          sub_140003898(dword_140025C20, 0x409u, i);
      }
    }
  }
  else
  {
    do
      ++v4;
    while ( v1[v4] );
    v3 = &v1[v4];
  }
  if ( v3 > v1 )
  {
    do
    {
      v7 = v3 - 1;
      if ( *(v3 - 1) != 32 && *v7 != 9 )
        break;
      --v3;
    }
    while ( v7 > v1 );
  }
  *v3 = 0;
  if ( *v1 == 60 && *(v3 - 1) == 62 )
  {
    v8 = v1 + 1;
    *(v3 - 1) = 0;
    v9 = sub_14000E6A4(v8);
    if ( v9 == v8 )
      v9 = (wchar_t *)sub_14000DCC4(v8);
    v10 = sub_14000918C(L"INCLUDE");
    if ( v10 )
      v11 = *(_WORD **)(*((_QWORD *)v10 + 2) + 8i64);
    else
      v11 = 0i64;
    if ( v11 )
    {
      v12 = (wchar_t *)sub_14000DCC4(v11);
      v13 = sub_14000E6A4(v12);
      if ( v13 != v12 )
        free(v12);
    }
    else
    {
      v13 = 0i64;
    }
    v1 = (wchar_t *)sub_140005E6C(v13, v9, &FindFileData, &v33);
    if ( !v1 )
    {
      sub_140003898(dword_140025C20, 0x41Cu, v9);
      __debugbreak();
    }
    if ( v13 )
      free(v13);
    free(v9);
    goto LABEL_62;
  }
  if ( *v1 == 34 && *(v3 - 1) == 34 )
  {
    *(v3 - 1) = 0;
    ++v1;
  }
  v14 = sub_14000E6A4(v1);
  if ( v14 == v1 )
    v14 = (wchar_t *)sub_14000DCC4(v1);
  if ( !sub_140005CA8(v14, &FindFileData, &v33) )
  {
    if ( !wcspbrk(v14, L"\\/:") )
    {
      v15 = dword_140036CE8;
      v16 = dword_140036CE8;
      v17 = dword_140036CE8;
      if ( dword_140036CE8 < 0 )
        goto LABEL_58;
      v18 = (const wchar_t **)((char *)&unk_140036CF0 + 24 * dword_140036CE8 + 8);
      while ( 1 )
      {
        v19 = v16 == v15;
        v20 = (const wchar_t *)qword_140026490;
        if ( !v19 )
          v20 = *v18;
        v21 = sub_140009078(v20);
        if ( v21 )
        {
          v22 = -1i64;
          do
            ++v22;
          while ( v14[v22] );
          v23 = -1i64;
          do
            ++v23;
          while ( v21[v23] );
          v24 = v22 + v23 + 2;
          Destination = (wchar_t *)sub_140009214(saturated_mul(v24, 2ui64));
          wcscpy_s(Destination, v24, v21);
          wcscat_s(Destination, v24, L"\\");
          wcscat_s(Destination, v24, v14);
          if ( sub_140005CA8(Destination, &FindFileData, &v33) )
          {
            v1 = Destination;
            free(v21);
LABEL_58:
            free(v14);
            if ( v16 < 0 )
            {
              v25 = v1;
              goto LABEL_61;
            }
            goto LABEL_62;
          }
          free(v21);
          free(Destination);
        }
        --v16;
        v18 -= 3;
        if ( --v17 < 0 )
          goto LABEL_58;
        v15 = dword_140036CE8;
      }
    }
    v25 = v14;
LABEL_61:
    sub_140003898(dword_140025C20, 0x41Cu, v25);
  }
LABEL_62:
  v26 = dword_140036CE8;
  v27 = 0;
  if ( dword_140036CE8 > 0 )
  {
    v28 = (const wchar_t **)&unk_140036CF8;
    do
    {
      if ( !wcsicmp(v1, *v28) )
        sub_140003898(dword_140025C20, 0x430u, v1);
      v26 = dword_140036CE8;
      ++v27;
      v28 += 3;
    }
    while ( v27 < dword_140036CE8 );
  }
  v19 = byte_14002648B == 0;
  dword_140036CE8 = v26 + 1;
  dword_140025C24 = 0;
  v29 = 3i64 * v26;
  *((_QWORD *)&unk_140036CF0 + v29 + 2) = Stream;
  *((_DWORD *)&unk_140036CF0 + 2 * v29) = dword_140025C20;
  *((_QWORD *)&unk_140036CF0 + v29 + 1) = qword_140026490;
  if ( !v19 )
    sub_14000BFE0(L"Included: %s\n", v1);
  Stream = sub_14000FD2C((__int64)v1, L"rt,ccs=unicode");
  if ( !Stream )
    sub_140003898(dword_140025C20, 0x41Cu, v1);
  qword_140026490 = sub_14000DCC4(v1);
  dword_140025C20 = 1;
  byte_140015041 = 1;
  v30 = sub_14000613C();
  if ( v30 == 32 || v30 == 9 )
  {
    byte_140015041 = 0;
    return 18;
  }
  else
  {
    byte_140015041 = 1;
    ungetwc(v30, Stream);
    --dword_140025C20;
    return 17;
  }
}
// 14000906F: control flows out of bounds to 140009074
// 1400120E8: using guessed type wchar_t aIncludedS[14];
// 140015041: using guessed type char byte_140015041;
// 140025C20: using guessed type int dword_140025C20;
// 140025C24: using guessed type int dword_140025C24;
// 14002648B: using guessed type char byte_14002648B;
// 140036CE8: using guessed type int dword_140036CE8;

//----- (0000000140009078) ----------------------------------------------------
wchar_t *__fastcall sub_140009078(const wchar_t *a1)
{
  __int64 v1; // rdi
  __int64 v2; // rcx
  __int64 v3; // rax
  unsigned __int64 v4; // rbx
  wchar_t *v5; // rsi
  wchar_t Drive[8]; // [rsp+50h] [rbp-228h] BYREF
  wchar_t Dir[256]; // [rsp+60h] [rbp-218h] BYREF

  wsplitpath_s(a1, Drive, 3ui64, Dir, 0x100ui64, 0i64, 0i64, 0i64, 0i64);
  v1 = -1i64;
  v2 = -1i64;
  do
    ++v2;
  while ( Drive[v2] );
  v3 = -1i64;
  do
    ++v3;
  while ( Dir[v3] );
  v4 = v2 + v3 + 1;
  v5 = (wchar_t *)sub_140009214(saturated_mul(v4, 2ui64));
  wmakepath_s(v5, v4, Drive, Dir, 0i64, 0i64);
  do
    ++v1;
  while ( v5[v1] );
  if ( v5[v1 - 1] == 92 || v5[v1 - 1] == 47 )
    v5[v1 - 1] = 0;
  return v5;
}
// 140009078: using guessed type wchar_t Dir[256];
// 140009078: using guessed type wchar_t Drive[8];

//----- (000000014000918C) ----------------------------------------------------
char *__fastcall sub_14000918C(__int16 *a1)
{
  __int16 v1; // ax
  __int16 *v3; // rdx
  unsigned __int8 v4; // cl
  char *result; // rax
  char *v6; // rcx
  char *v7; // r9
  int v8; // r10d
  int v9; // edx

  v1 = *a1;
  v3 = a1;
  if ( *a1 )
  {
    v4 = 0;
    do
    {
      ++v3;
      v4 += v1;
      v1 = *v3;
    }
    while ( *v3 );
    result = (char *)&qword_1400364D0[v4];
    qword_140037098 = (__int64)result;
    while ( 1 )
    {
      result = *(char **)result;
      if ( !result )
        break;
      v6 = (char *)*((_QWORD *)result + 1);
      v7 = (char *)((char *)a1 - v6);
      do
      {
        v8 = *(unsigned __int16 *)&v7[(_QWORD)v6];
        v9 = *(unsigned __int16 *)v6 - v8;
        if ( v9 )
          break;
        v6 += 2;
      }
      while ( v8 );
      if ( !v9 )
      {
        if ( (result[24] & 0x10) != 0 )
          return 0i64;
        return result;
      }
    }
  }
  else
  {
    qword_140037098 = (__int64)qword_1400364D0;
  }
  return 0i64;
}
// 1400364D0: using guessed type _QWORD qword_1400364D0[256];
// 140037098: using guessed type __int64 qword_140037098;

//----- (0000000140009214) ----------------------------------------------------
void *__fastcall sub_140009214(size_t a1)
{
  void *v1; // rbx

  v1 = malloc(a1);
  if ( !v1 )
    sub_140003898(dword_140025C24, 0x41Bu);
  return v1;
}
// 140025C24: using guessed type int dword_140025C24;

//----- (0000000140009244) ----------------------------------------------------
void *__fastcall sub_140009244(size_t Size)
{
  void *v2; // rdi

  v2 = sub_140009214(Size);
  memset(v2, 0, Size);
  return v2;
}

//----- (0000000140009274) ----------------------------------------------------
void *__fastcall sub_140009274(void *a1, size_t a2)
{
  void *v2; // rbx

  if ( !a1 )
    return sub_140009214(a2);
  v2 = realloc(a1, a2);
  if ( !v2 )
    sub_140003898(dword_140025C24, 0x41Bu);
  return v2;
}
// 140025C24: using guessed type int dword_140025C24;

//----- (00000001400092B4) ----------------------------------------------------
__int64 __fastcall sub_1400092B4(wchar_t *Source, wchar_t *a2)
{
  __int64 result; // rax
  __int64 v3; // rax
  HMODULE ModuleHandleW; // rax
  BOOL (__stdcall *SetThreadPreferredUILanguages)(DWORD, PCZZWSTR, PULONG); // rbx
  HMODULE v6; // rax
  BOOL (__stdcall *GetThreadPreferredUILanguages)(DWORD, PULONG, PZZWSTR, PULONG); // rdi
  SIZE_T v8; // rbx
  HANDLE ProcessHeap; // rax
  wchar_t *v10; // rax
  wchar_t *v11; // rsi
  const wchar_t *i; // rbx
  HANDLE v13; // rax
  unsigned int v14; // esi
  HANDLE FirstFileW; // rbx
  signed int LastError; // ecx
  LANGID UserDefaultUILanguage; // ax
  __int16 *v18; // rdi
  unsigned int v19; // ebx
  __int64 v20; // rdi
  __int64 v21; // rcx
  HMODULE Library; // rcx
  __int64 v23; // [rsp+20h] [rbp-E0h]
  unsigned int v24; // [rsp+30h] [rbp-D0h] BYREF
  __int16 v25; // [rsp+34h] [rbp-CCh] BYREF
  unsigned int v26; // [rsp+38h] [rbp-C8h] BYREF
  int v27; // [rsp+3Ch] [rbp-C4h] BYREF
  DWORD dwFlags; // [rsp+40h] [rbp-C0h] BYREF
  char v29[8]; // [rsp+48h] [rbp-B8h] BYREF
  wchar_t *Sourcea; // [rsp+50h] [rbp-B0h] BYREF
  __int64 *v31; // [rsp+60h] [rbp-A0h] BYREF
  __int16 *v32; // [rsp+68h] [rbp-98h] BYREF
  wchar_t *v33; // [rsp+70h] [rbp-90h] BYREF
  rsize_t SizeInWords; // [rsp+78h] [rbp-88h] BYREF
  __int64 v35[8]; // [rsp+80h] [rbp-80h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+C0h] [rbp-40h] BYREF
  __int16 v37[4]; // [rsp+310h] [rbp+210h] BYREF
  WCHAR Buffer; // [rsp+318h] [rbp+218h] BYREF
  __int64 v39; // [rsp+31Ah] [rbp+21Ah]
  __int16 v40; // [rsp+322h] [rbp+222h]
  wchar_t v41[12]; // [rsp+328h] [rbp+228h] BYREF
  wchar_t FileName[264]; // [rsp+340h] [rbp+240h] BYREF
  __int16 Destination[264]; // [rsp+550h] [rbp+450h] BYREF

  Sourcea = a2;
  SizeInWords = 0i64;
  v32 = &word_14003DE00;
  v31 = &qword_14003DDF8;
  v33 = 0i64;
  dwFlags = 96;
  if ( !*Source || !a2 || !*a2 )
    return 2147942487i64;
  qword_14003DDF8 = 0i64;
  if ( wcsncpy_s((wchar_t *)Destination, 0x104ui64, Source, 0xFFFFFFFFFFFFFFFFui64) )
    return 2147500037i64;
  v3 = -1i64;
  do
    ++v3;
  while ( Destination[v3] );
  if ( FileName[v3 + 263] != 92 && wcsncat_s((wchar_t *)Destination, 0x104ui64, L"\\", 0xFFFFFFFFFFFFFFFFui64) )
    return 2147500037i64;
  v24 = -2147024894;
  v35[0] = (__int64)Destination;
  Buffer = 0;
  v35[1] = (__int64)&Sourcea;
  v35[2] = (__int64)&dwFlags;
  v35[3] = (__int64)&v31;
  v35[4] = (__int64)&v32;
  v35[5] = (__int64)&v33;
  v35[6] = (__int64)&SizeInWords;
  v39 = 0i64;
  v40 = 0;
  if ( GetEnvironmentVariableW(L"VSLANG", &Buffer, 6u) - 1 <= 4 )
  {
    if ( Buffer )
    {
      sub_1400098FC((__int64)v35, &Buffer, 10, &v24);
      if ( !v24 )
        return 0i64;
    }
  }
  if ( Ptr )
  {
    SetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PCZZWSTR, PULONG))DecodePointer(Ptr);
  }
  else
  {
    ModuleHandleW = GetModuleHandleW(L"kernel32.dll");
    if ( !ModuleHandleW )
    {
LABEL_41:
      UserDefaultUILanguage = GetUserDefaultUILanguage();
      if ( (UserDefaultUILanguage & 0x3FF) == 1 || (UserDefaultUILanguage & 0x3FF) == 13 )
        UserDefaultUILanguage = 1033;
      v37[0] = UserDefaultUILanguage;
      v18 = v37;
      v37[2] = 1033;
      v19 = 0;
      v37[1] = UserDefaultUILanguage & 0x3FF | 0x400;
      while ( 1 )
      {
        itow_s((unsigned __int16)*v18, v41, 6ui64, 10);
        if ( v41[0] )
          sub_1400098FC((__int64)v35, v41, 10, &v24);
        if ( !v24 )
          return 0i64;
        ++v19;
        ++v18;
        if ( v19 >= 3 )
          goto LABEL_34;
      }
    }
    SetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PCZZWSTR, PULONG))GetProcAddress(
                                                                                   ModuleHandleW,
                                                                                   "SetThreadPreferredUILanguages");
    Ptr = EncodePointer(SetThreadPreferredUILanguages);
  }
  if ( !SetThreadPreferredUILanguages )
    goto LABEL_41;
  if ( !GetEnvironmentVariableW(L"VS_UNICODE_OUTPUT", 0i64, 0)
    && !((unsigned int (__fastcall *)(__int64, _QWORD, _QWORD))SetThreadPreferredUILanguages)(256i64, 0i64, 0i64) )
  {
    return 2147500037i64;
  }
  v26 = 0;
  v27 = 0;
  if ( qword_14003D138 )
  {
    GetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PULONG, PZZWSTR, PULONG))DecodePointer(qword_14003D138);
  }
  else
  {
    v6 = GetModuleHandleW(L"kernel32.dll");
    if ( !v6 )
      goto LABEL_34;
    GetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PULONG, PZZWSTR, PULONG))GetProcAddress(
                                                                                          v6,
                                                                                          "GetThreadPreferredUILanguages");
    qword_14003D138 = EncodePointer(GetThreadPreferredUILanguages);
  }
  if ( GetThreadPreferredUILanguages )
  {
    if ( ((unsigned int (__fastcall *)(__int64, int *, _QWORD, unsigned int *))GetThreadPreferredUILanguages)(
           52i64,
           &v27,
           0i64,
           &v26) )
    {
      v8 = 2i64 * v26;
      ProcessHeap = GetProcessHeap();
      v10 = (wchar_t *)HeapAlloc(ProcessHeap, 0, v8);
      v11 = v10;
      if ( !v10 )
        return 2147942414i64;
      if ( ((unsigned int (__fastcall *)(__int64, int *, wchar_t *, unsigned int *))GetThreadPreferredUILanguages)(
             52i64,
             &v27,
             v10,
             &v26) )
      {
        for ( i = v11; *i; i += 5 )
        {
          sub_1400098FC((__int64)v35, i, 16, &v24);
          if ( !v24 )
            break;
        }
        v13 = GetProcessHeap();
        HeapFree(v13, 0, v11);
        if ( !v24 )
          return 0i64;
        goto LABEL_34;
      }
    }
    return 2147500037i64;
  }
LABEL_34:
  sub_1400098FC((__int64)v35, L"1033", 10, &v24);
  v14 = v24;
  if ( !v24 )
    return 0i64;
  if ( wcsncpy_s(FileName, 0x104ui64, (const wchar_t *)Destination, 0xFFFFFFFFFFFFFFFFui64)
    || wcsncat_s(FileName, 0x104ui64, L"*", 0xFFFFFFFFFFFFFFFFui64) )
  {
    return 2147942403i64;
  }
  FirstFileW = FindFirstFileW(FileName, &FindFileData);
  if ( FirstFileW == (HANDLE)-1i64 )
  {
    LastError = GetLastError();
    result = (unsigned __int16)LastError | 0x80070000;
    if ( LastError <= 0 )
      return (unsigned int)LastError;
  }
  else
  {
    v20 = -1i64;
    do
      ++v20;
    while ( Destination[v20] );
    while ( FindNextFileW(FirstFileW, &FindFileData) )
    {
      if ( (FindFileData.dwFileAttributes & 0x10) != 0
        && (FindFileData.cFileName[0] != asc_1400120A8[0] || FindFileData.cFileName[1] != asc_1400120A8[1])
        && (FindFileData.cFileName[0] != 46 || FindFileData.cFileName[1] != 46 || FindFileData.cFileName[2]) )
      {
        LODWORD(v23) = 1;
        if ( sub_14000BDE4(FindFileData.cFileName, (wchar_t *)L"%hu%c", &v25, v29, v23) != -1 )
        {
          if ( (unsigned __int64)(2 * v20) >= 0x208 )
            _report_rangecheckfailure(v21);
          FileName[v20] = 0;
          if ( !wcsncat_s(FileName, 0x104ui64, FindFileData.cFileName, 0xFFFFFFFFFFFFFFFFui64)
            && !wcsncat_s(FileName, 0x104ui64, L"\\", 0xFFFFFFFFFFFFFFFFui64)
            && !wcsncat_s(FileName, 0x104ui64, Sourcea, 0xFFFFFFFFFFFFFFFFui64) )
          {
            Library = LoadLibraryExW(FileName, 0i64, dwFlags);
            if ( Library )
            {
              *v31 = (__int64)Library;
              if ( v32 )
                *v32 = v25;
              if ( v33 )
                wcscpy_s(v33, SizeInWords, FileName);
              v14 = 0;
              break;
            }
          }
        }
      }
    }
    FindClose(FirstFileW);
    return v14;
  }
  return result;
}
// 1400097D5: variable 'v23' is possibly undefined
// 1400098F6: variable 'v21' is possibly undefined
// 14001025C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD);
// 1400121A0: using guessed type wchar_t a1033[5];
// 14003DDF8: using guessed type __int64 qword_14003DDF8;
// 14003DE00: using guessed type __int16 word_14003DE00;
// 1400092B4: using guessed type wchar_t Destination[264];
// 1400092B4: using guessed type char var_748[8];

//----- (00000001400098FC) ----------------------------------------------------
int __fastcall sub_1400098FC(__int64 a1, const wchar_t *a2, int a3, unsigned int *a4)
{
  wchar_t **Library; // rax
  __int16 v7; // si
  _WORD **v8; // rax
  unsigned int v9; // ecx
  wchar_t *EndPtr; // [rsp+20h] [rbp-278h] BYREF
  wchar_t Buffer[12]; // [rsp+28h] [rbp-270h] BYREF
  wchar_t Destination[264]; // [rsp+40h] [rbp-258h] BYREF

  LODWORD(Library) = wcstoul(a2, &EndPtr, a3);
  v7 = (__int16)Library;
  if ( !*EndPtr )
  {
    itow_s((unsigned __int16)Library, Buffer, 6ui64, 10);
    LODWORD(Library) = wcsncpy_s(Destination, 0x104ui64, *(const wchar_t **)a1, 0xFFFFFFFFFFFFFFFFui64);
    if ( !(_DWORD)Library )
    {
      LODWORD(Library) = wcsncat_s(Destination, 0x104ui64, Buffer, 0xFFFFFFFFFFFFFFFFui64);
      if ( !(_DWORD)Library )
      {
        LODWORD(Library) = wcsncat_s(Destination, 0x104ui64, L"\\", 0xFFFFFFFFFFFFFFFFui64);
        if ( !(_DWORD)Library )
        {
          LODWORD(Library) = wcsncat_s(Destination, 0x104ui64, **(const wchar_t ***)(a1 + 8), 0xFFFFFFFFFFFFFFFFui64);
          if ( !(_DWORD)Library )
          {
            Library = (wchar_t **)LoadLibraryExW(Destination, 0i64, **(_DWORD **)(a1 + 16));
            if ( Library )
            {
              ***(_QWORD ***)(a1 + 24) = Library;
              v8 = *(_WORD ***)(a1 + 32);
              if ( *v8 )
                **v8 = v7;
              Library = *(wchar_t ***)(a1 + 40);
              if ( *Library )
                LODWORD(Library) = wcscpy_s(*Library, **(_QWORD **)(a1 + 48), Destination);
              *a4 = 0;
            }
            else if ( *a4 == -2147024894 )
            {
              LODWORD(Library) = GetLastError();
              v9 = (unsigned __int16)Library | 0x80070000;
              if ( (int)Library <= 0 )
                v9 = (unsigned int)Library;
              *a4 = v9;
            }
          }
        }
      }
    }
  }
  return (int)Library;
}

//----- (0000000140009A74) ----------------------------------------------------
bool sub_140009A74()
{
  if ( dword_140037094 > 0 )
  {
    if ( dword_140037094 <= 2 )
      return 0;
    if ( dword_140037094 == 3 )
      return !sub_140009AA8();
  }
  return 1;
}
// 140037094: using guessed type int dword_140037094;

//----- (0000000140009AA8) ----------------------------------------------------
bool sub_140009AA8()
{
  LSTATUS v1; // ebx
  DWORD cbData; // [rsp+50h] [rbp+8h] BYREF
  DWORD Type; // [rsp+58h] [rbp+10h] BYREF
  int Data; // [rsp+60h] [rbp+18h] BYREF
  HKEY hKey; // [rsp+68h] [rbp+20h] BYREF

  if ( (unsigned __int8)GetVersion() >= 6u )
    return 1;
  if ( RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Microsoft\\VisualStudio\\9.0\\General", 0, 0x20019u, &hKey) )
    return 0;
  cbData = 4;
  v1 = RegQueryValueExW(hKey, L"UserCanAutoSendErrorReport", 0i64, &Type, (LPBYTE)&Data, &cbData);
  RegCloseKey(hKey);
  if ( v1 || Type != 4 || cbData != 4 )
    return 0;
  return Data == 1;
}

//----- (0000000140009B54) ----------------------------------------------------
char __fastcall sub_140009B54(BYTE *lpDst)
{
  LSTATUS v3; // ebx
  DWORD Type; // [rsp+58h] [rbp+10h] BYREF
  DWORD cbData; // [rsp+60h] [rbp+18h] BYREF
  HKEY hKey; // [rsp+68h] [rbp+20h] BYREF

  if ( RegOpenKeyExW(
         HKEY_LOCAL_MACHINE,
         L"Software\\Wow6432node\\Microsoft\\PCHealth\\ErrorReporting\\DW\\Installed",
         0,
         0x20019u,
         &hKey) )
  {
    return 0;
  }
  cbData = 520;
  v3 = RegQueryValueExW(hKey, L"DW0201", 0i64, &Type, lpDst, &cbData);
  RegCloseKey(hKey);
  *((_WORD *)lpDst + 259) = 0;
  if ( v3 )
    return 0;
  if ( Type == 2 )
  {
    if ( ExpandEnvironmentStringsW((LPCWSTR)lpDst, (LPWSTR)lpDst, 0x104u) - 1 > 0x103 )
      return 0;
  }
  else if ( Type != 1 )
  {
    return 0;
  }
  return 1;
}

//----- (0000000140009C10) ----------------------------------------------------
char sub_140009C10()
{
  HANDLE FileMappingW; // rax

  FileMappingW = CreateFileMappingW((HANDLE)0xFFFFFFFFFFFFFFFFi64, &MutexAttributes, 4u, 0, 0x9CB8u, 0i64);
  hObject = FileMappingW;
  if ( !FileMappingW )
    return 0;
  lpBaseAddress = MapViewOfFileEx(FileMappingW, 6u, 0, 0, 0i64, 0i64);
  if ( !lpBaseAddress )
  {
    CloseHandle(hObject);
    hObject = 0i64;
    return 0;
  }
  return 1;
}

//----- (0000000140009C94) ----------------------------------------------------
__int64 __fastcall sub_140009C94(__int64 a1)
{
  unsigned int v2; // ebp
  bool v4; // al
  HANDLE EventW; // rsi
  HANDLE MutexW; // rdi
  HANDLE CurrentProcess; // rax
  _QWORD *v9; // rbx
  DWORD CurrentThreadId; // eax
  _QWORD *v11; // rdx
  bool v12; // dl
  LPCVOID v13; // r8
  char v14; // dl
  char v15; // al
  wchar_t **v16; // rax
  wchar_t *v17; // rcx
  char v18; // bl
  DWORD v19; // eax
  HANDLE TargetHandle; // [rsp+88h] [rbp+10h] BYREF

  TargetHandle = 0i64;
  v2 = 1;
  if ( hHandle )
    return 1i64;
  if ( dword_140037094 <= 0 )
    goto LABEL_7;
  if ( dword_140037094 > 2 )
  {
    if ( dword_140037094 == 3 )
    {
      v4 = !sub_140009AA8();
      goto LABEL_8;
    }
LABEL_7:
    v4 = 1;
LABEL_8:
    if ( v4 )
      return 1i64;
  }
  MutexAttributes.nLength = 24;
  MutexAttributes.lpSecurityDescriptor = 0i64;
  MutexAttributes.bInheritHandle = 1;
  if ( !lpBaseAddress && !sub_140009C10() )
    return 1i64;
  if ( !(Dst ? sub_140009B54((BYTE *)Dst) : 0) )
    return 1i64;
  hHandle = CreateEventW(&MutexAttributes, 0, 0, 0i64);
  EventW = CreateEventW(&MutexAttributes, 0, 0, 0i64);
  MutexW = CreateMutexW(&MutexAttributes, 0, 0i64);
  CurrentProcess = GetCurrentProcess();
  if ( !DuplicateHandle(CurrentProcess, CurrentProcess, CurrentProcess, &TargetHandle, 0x1FFFFFu, 1, 0) || !hHandle )
    goto LABEL_46;
  if ( !EventW )
    goto LABEL_48;
  if ( !MutexW || !TargetHandle )
    goto LABEL_46;
  v9 = lpBaseAddress;
  memset((void *)lpBaseAddress, 0, 0x9CB8ui64);
  v9[8] = TargetHandle;
  *((_DWORD *)lpBaseAddress + 2) = GetCurrentProcessId();
  CurrentThreadId = GetCurrentThreadId();
  v11 = lpBaseAddress;
  *((_DWORD *)lpBaseAddress + 3) = CurrentThreadId;
  v11[6] = hHandle;
  v11[4] = EventW;
  v11[7] = MutexW;
  *(_DWORD *)v11 = 40120;
  *((_DWORD *)v11 + 1) = 0x20000;
  v11[3] = a1;
  v11[2] = *(_QWORD *)(*(_QWORD *)a1 + 16i64);
  v12 = (unsigned __int8)GetVersion() >= 6u;
  if ( dword_140037094 == 1 )
  {
    v13 = lpBaseAddress;
    *((_QWORD *)lpBaseAddress + 9) = 0i64;
  }
  else
  {
    if ( dword_140037094 == 2 )
    {
      v13 = lpBaseAddress;
      *((_DWORD *)lpBaseAddress + 18) = 8;
    }
    else
    {
      if ( dword_140037094 != 3 )
        goto LABEL_46;
      v13 = lpBaseAddress;
      *((_DWORD *)lpBaseAddress + 18) = 0;
    }
    *((_DWORD *)v13 + 19) = !v12;
  }
  v14 = byte_140036CEF;
  v15 = byte_140036CEF;
  *((_DWORD *)v13 + 20) = 0;
  *((_DWORD *)v13 + 22) = 0;
  *((_DWORD *)v13 + 24) = 1;
  *((_DWORD *)v13 + 21) = (v15 == 0 ? 0x10 : 0) | 4;
  *((_DWORD *)v13 + 26) = (v14 != 0 ? 0x10 : 0) | 1;
  wcsncpy_s((wchar_t *)v13 + 4324, 0x38ui64, off_140015090, 0xFFFFFFFFFFFFFFFFui64);
  v16 = _p__wpgmptr();
  wcsncpy_s((wchar_t *)lpBaseAddress + 314, 0x104ui64, *v16, 0xFFFFFFFFFFFFFFFFui64);
  v17 = (wchar_t *)lpBaseAddress;
  if ( lpBaseAddress == (LPCVOID)-1148i64 )
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    v17 = (wchar_t *)lpBaseAddress;
  }
  else
  {
    strcpy((char *)lpBaseAddress + 1148, "HKLM\\Software\\Microsoft\\Internet Explorer\\Registration\\DigitalProductID");
  }
  wcsncpy_s(v17 + 992, 0x104ui64, off_140015098, 0xFFFFFFFFFFFFFFFFui64);
  swprintf(Buffer, 0x104ui64, L"dw20.exe -x -s %I64u", hObject);
  memset(&StartupInfo, 0, sizeof(StartupInfo));
  StartupInfo.cb = 104;
  if ( !CreateProcessW(
          Dst,
          Buffer,
          0i64,
          0i64,
          1,
          0x4000020u,
          0i64,
          0i64,
          &StartupInfo,
          (LPPROCESS_INFORMATION)&ProcessInformation) )
    goto LABEL_46;
  CloseHandle(ProcessInformation);
  CloseHandle(*(&ProcessInformation + 1));
  v18 = 1;
  while ( 1 )
  {
    if ( !WaitForSingleObject(hHandle, 0x4E20u) )
    {
      if ( !WaitForSingleObject(EventW, 1u) )
        v18 = 0;
      goto LABEL_41;
    }
    v19 = WaitForSingleObject(MutexW, 0x4E20u);
    if ( v19 == 258 )
      goto LABEL_44;
    if ( v19 == 128 )
      break;
    if ( WaitForSingleObject(hHandle, 1u) )
    {
      SetEvent(EventW);
      v18 = 0;
    }
    else
    {
      v18 = WaitForSingleObject(EventW, 1u) != 0 ? v18 : 0;
    }
    ReleaseMutex(MutexW);
LABEL_41:
    if ( !v18 )
      goto LABEL_44;
  }
  ReleaseMutex(MutexW);
LABEL_44:
  if ( (*((_BYTE *)lpBaseAddress + 39584) & 0x10) != 0 )
    v2 = 0;
LABEL_46:
  if ( EventW )
    CloseHandle(EventW);
LABEL_48:
  if ( MutexW )
    CloseHandle(MutexW);
  if ( TargetHandle )
    CloseHandle(TargetHandle);
  if ( hHandle )
  {
    CloseHandle(hHandle);
    hHandle = 0i64;
  }
  if ( lpBaseAddress )
  {
    UnmapViewOfFile(lpBaseAddress);
    lpBaseAddress = 0i64;
  }
  if ( hObject )
  {
    CloseHandle(hObject);
    hObject = 0i64;
  }
  if ( byte_140015042 )
    exit(1);
  return v2;
}
// 140015042: using guessed type char byte_140015042;
// 140036CEF: using guessed type char byte_140036CEF;
// 140037094: using guessed type int dword_140037094;
// 14003D950: using guessed type WCHAR Dst[264];
// 14003DB60: using guessed type wchar_t Buffer[264];

//----- (000000014000A198) ----------------------------------------------------
__int64 __fastcall TopLevelExceptionFilter(__int64 ExceptionInfo)
{
  if ( **(_DWORD **)ExceptionInfo == -2147483645 || byte_140037092 )
    return 0i64;
  byte_140037092 = 1;
  off_140015098 = L"msvcr140.dll";
  off_140015090 = L"Microsoft® Program Maintenance Utility";
  byte_140015042 = 0;
  return sub_140009C94(ExceptionInfo);
}
// 140012EA0: using guessed type wchar_t aMicrosoftProgr[39];
// 140012EF0: using guessed type wchar_t aMsvcr140Dll[13];
// 140015042: using guessed type char byte_140015042;
// 140037092: using guessed type char byte_140037092;

//----- (000000014000A1E0) ----------------------------------------------------
__int64 __fastcall sub_14000A1E0(struct _EXCEPTION_POINTERS *ExceptionInfo, __int64 a2, _OWORD *a3)
{
  unsigned int v3; // edi
  PEXCEPTION_RECORD ExceptionRecord; // rax
  PCONTEXT ContextRecord; // rax
  __int64 v9; // rcx
  __int128 v10; // xmm1
  bool v11; // al

  v3 = 0;
  if ( !byte_140026488 )
    sub_140003A8C();
  sub_14000BFE0(L"\nNMAKE : fatal error U1038: Internal error\n");
  sub_14000BFB0();
  ExceptionRecord = ExceptionInfo->ExceptionRecord;
  *(_OWORD *)a2 = *(_OWORD *)&ExceptionInfo->ExceptionRecord->ExceptionCode;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)&ExceptionRecord->ExceptionAddress;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)ExceptionRecord->ExceptionInformation;
  *(_OWORD *)(a2 + 48) = *(_OWORD *)&ExceptionRecord->ExceptionInformation[2];
  *(_OWORD *)(a2 + 64) = *(_OWORD *)&ExceptionRecord->ExceptionInformation[4];
  *(_OWORD *)(a2 + 80) = *(_OWORD *)&ExceptionRecord->ExceptionInformation[6];
  *(_OWORD *)(a2 + 96) = *(_OWORD *)&ExceptionRecord->ExceptionInformation[8];
  *(_OWORD *)(a2 + 112) = *(_OWORD *)&ExceptionRecord->ExceptionInformation[10];
  *(_OWORD *)(a2 + 128) = *(_OWORD *)&ExceptionRecord->ExceptionInformation[12];
  *(_QWORD *)(a2 + 144) = ExceptionRecord->ExceptionInformation[14];
  if ( a3 )
  {
    ContextRecord = ExceptionInfo->ContextRecord;
    v9 = 9i64;
    do
    {
      *a3 = *(_OWORD *)&ContextRecord->P1Home;
      a3[1] = *(_OWORD *)&ContextRecord->P3Home;
      a3[2] = *(_OWORD *)&ContextRecord->P5Home;
      a3[3] = *(_OWORD *)&ContextRecord->ContextFlags;
      a3[4] = *(_OWORD *)&ContextRecord->SegGs;
      a3[5] = *(_OWORD *)&ContextRecord->Dr1;
      a3[6] = *(_OWORD *)&ContextRecord->Dr3;
      a3 += 8;
      v10 = *(_OWORD *)&ContextRecord->Dr7;
      ContextRecord = (PCONTEXT)((char *)ContextRecord + 128);
      *(a3 - 1) = v10;
      --v9;
    }
    while ( v9 );
    *a3 = *(_OWORD *)&ContextRecord->P1Home;
    a3[1] = *(_OWORD *)&ContextRecord->P3Home;
    a3[2] = *(_OWORD *)&ContextRecord->P5Home;
    a3[3] = *(_OWORD *)&ContextRecord->ContextFlags;
    a3[4] = *(_OWORD *)&ContextRecord->SegGs;
  }
  if ( dword_140037094 <= 0 )
    goto LABEL_11;
  if ( dword_140037094 <= 2 )
    return TopLevelExceptionFilter((__int64)ExceptionInfo);
  if ( dword_140037094 == 3 )
    v11 = !sub_140009AA8();
  else
LABEL_11:
    v11 = 1;
  if ( !v11 )
    return TopLevelExceptionFilter((__int64)ExceptionInfo);
  LOBYTE(v3) = byte_140037092 == 0;
  return v3;
}
// 1400126B0: using guessed type wchar_t aNmakeFatalErro[44];
// 140026488: using guessed type char byte_140026488;
// 140037092: using guessed type char byte_140037092;
// 140037094: using guessed type int dword_140037094;

//----- (000000014000A348) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v5; // rax
  FILE *v6; // rax
  int i; // ebx
  const char **v8; // rsi
  unsigned int j; // ecx
  wchar_t *v10; // r15
  __int64 v11; // rsi
  unsigned __int64 v12; // rsi
  wchar_t *v13; // rbx
  int v14; // ebx
  __int64 v16[172]; // [rsp+158h] [rbp-7B0h] BYREF

  SetErrorMode(1u);
  memset(v16, 0, sizeof(v16));
  setlocale(2, ".ACP");
  v5 = _acrt_iob_func(1u);
  byte_1400370B0 = sub_14000BE34(v5);
  v6 = _acrt_iob_func(2u);
  byte_140037093 = sub_14000BE34(v6);
  set_invalid_parameter_handler(guard_check_icall_nop);
  MutexAttributes.nLength = 24;
  MutexAttributes.lpSecurityDescriptor = 0i64;
  MutexAttributes.bInheritHandle = 1;
  sub_140009C10();
  dword_140037094 = 2;
  for ( i = 1; ; ++i )
  {
    if ( i >= argc )
    {
      if ( dword_140037094 == 3 && !sub_140009AA8() )
        sub_140003898(0, 0xFAEu, L"http://go.microsoft.com/fwlink/?LinkId=79513");
      if ( !sub_140009A74() )
        SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)TopLevelExceptionFilter);
      if ( byte_140036CEE )
        MEMORY[0] = 0;
      for ( j = 0; j < 0x100; ++j )
        qword_1400364D0[j] = 0i64;
      if ( !qword_140026498 )
      {
        v10 = *_p__wpgmptr();
        if ( wcschr(v10, 0x20u) )
        {
          v11 = -1i64;
          do
            ++v11;
          while ( v10[v11] );
          v12 = v11 + 3;
          v13 = (wchar_t *)sub_140009214(saturated_mul(v12, 2ui64));
          wcscpy_s(v13, v12, L"\"");
          wcscat_s(v13, v12, v10);
          wcscat_s(v13, v12, L"\"");
          v10 = v13;
        }
        qword_140026498 = (wchar_t *)sub_14000DCC4(v10);
      }
      signal(2, (_crt_signal_t)Function);
      signal(15, (_crt_signal_t)Function);
      v14 = sub_14000AB18(argc, (__int64)argv);
      sub_14000BB48();
      if ( !byte_140015040 )
        v14 = 1;
      exit(v14);
    }
    v8 = &argv[i];
    if ( ((*(_WORD *)*v8 - 45) & 0xFFFD) == 0 )
    {
      if ( !wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:none") )
      {
        dword_140037094 = 0;
LABEL_6:
        memmove(&argv[i], &argv[i + 1], 8i64 * (argc - i - 1));
        --argc;
        --i;
        continue;
      }
      if ( !wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:prompt") )
      {
        dword_140037094 = 1;
        goto LABEL_6;
      }
      if ( !wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:queue") )
      {
        dword_140037094 = 2;
        goto LABEL_6;
      }
      if ( !wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:send") )
      {
        dword_140037094 = 3;
        goto LABEL_6;
      }
      if ( !wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:test") )
      {
        byte_140036CEE = 1;
        goto LABEL_6;
      }
    }
  }
}
// 1400127E0: using guessed type wchar_t aHttpGoMicrosof[45];
// 140015040: using guessed type char byte_140015040;
// 1400364D0: using guessed type _QWORD qword_1400364D0[256];
// 140036CEE: using guessed type char byte_140036CEE;
// 140037093: using guessed type char byte_140037093;
// 140037094: using guessed type int dword_140037094;
// 1400370B0: using guessed type char byte_1400370B0;

//----- (000000014000A944) ----------------------------------------------------
wchar_t *sub_14000A944()
{
  wchar_t *v0; // rbx
  wchar_t *v1; // rax
  wchar_t *v2; // rbx
  wchar_t *v3; // rax
  wchar_t *v4; // rbx
  wchar_t *v5; // rax
  wchar_t *v6; // rbx
  wchar_t *v7; // rax
  wchar_t *v8; // rbx
  wchar_t *v9; // rax
  wchar_t *v10; // rbx
  wchar_t *v11; // rax
  wchar_t *v12; // rbx
  wchar_t *v13; // rax
  wchar_t *result; // rax
  int v15; // edi
  __int64 v16; // rbx
  wchar_t *v17; // rax
  const wchar_t **v18; // rbx
  wchar_t *v19; // rdx
  __int64 v20; // rcx
  const wchar_t **i; // rbx

  v0 = (wchar_t *)sub_14000DCC4(L"CC");
  v1 = (wchar_t *)sub_14000DCC4(L"cl");
  sub_140001AC8(v0, v1, 0);
  v2 = (wchar_t *)sub_14000DCC4(L"CXX");
  v3 = (wchar_t *)sub_14000DCC4(L"cl");
  sub_140001AC8(v2, v3, 0);
  v4 = (wchar_t *)sub_14000DCC4(L"CPP");
  v5 = (wchar_t *)sub_14000DCC4(L"cl");
  sub_140001AC8(v4, v5, 0);
  v6 = (wchar_t *)sub_14000DCC4(L"AS");
  v7 = (wchar_t *)sub_14000DCC4(L"ml64");
  sub_140001AC8(v6, v7, 0);
  v8 = (wchar_t *)sub_14000DCC4(L"RC");
  v9 = (wchar_t *)sub_14000DCC4(L"rc");
  sub_140001AC8(v8, v9, 0);
  v10 = (wchar_t *)sub_14000DCC4(L"_NMAKE_VER");
  v11 = (wchar_t *)sub_14000DCC4(L"14.00.23506.0");
  sub_140001AC8(v10, v11, 2);
  v12 = (wchar_t *)sub_14000DCC4(L"MAKE");
  v13 = (wchar_t *)sub_14000DCC4(qword_140026498);
  sub_140001AC8(v12, v13, 76);
  result = L".SUFFIXES";
  v15 = 0;
  if ( L".SUFFIXES" )
  {
    v16 = 0i64;
    do
    {
      v17 = (wchar_t *)sub_14000DCC4(result);
      v18 = (const wchar_t **)off_140011770[v16];
      Block = v17;
      wcscpy_s(&Src, 0x400ui64, *v18);
      sub_1400012A0();
      for ( i = v18 + 1; *i; ++i )
      {
        wcscpy_s(&Src, 0x400ui64, *i);
        sub_140001044();
      }
      if ( !v15 )
        sub_14000169C(v20, v19);
      sub_1400017F0();
      v16 = (unsigned int)++v15;
      result = *(wchar_t **)((char *)&off_140011900 + v16 * 8);
    }
    while ( result );
  }
  return result;
}
// 14000AAE9: variable 'v20' is possibly undefined
// 14000AAE9: variable 'v19' is possibly undefined
// 140011770: using guessed type wchar_t **[12];
// 140011DA0: using guessed type wchar_t a1400235060[14];
// 1400121C8: using guessed type wchar_t aSuffixes_0[10];
// 140012D40: using guessed type wchar_t aCc[3];
// 140012D48: using guessed type wchar_t aCl[3];
// 140012D50: using guessed type wchar_t aCxx[4];
// 140012D58: using guessed type wchar_t aCpp[4];
// 140012D60: using guessed type wchar_t aAs[3];
// 140012D68: using guessed type wchar_t aMl64[5];
// 140012D74: using guessed type wchar_t aRc[3];
// 140012D7C: using guessed type wchar_t aRc_0[3];
// 140012D88: using guessed type wchar_t aNmakeVer[11];
// 140012DA0: using guessed type wchar_t aMake[5];

//----- (000000014000AB18) ----------------------------------------------------
__int64 __fastcall sub_14000AB18(int a1, __int64 a2)
{
  wchar_t *v4; // rbx
  const wchar_t *v5; // r12
  wchar_t *v6; // rdi
  __int64 v7; // rdx
  wchar_t *v8; // rbx
  wchar_t *v9; // rax
  char v10; // al
  wchar_t *v11; // rcx
  struct _WIN32_FIND_DATAW *p_FindFileData; // r8
  const wchar_t *v13; // rax
  _QWORD *v14; // rbx
  wchar_t *v15; // rbx
  char *v16; // rax
  __int64 v17; // rcx
  const wchar_t ***v18; // rax
  const wchar_t **v19; // rbx
  const wchar_t *v20; // rax
  wchar_t *v21; // rsi
  wchar_t *v22; // rax
  wchar_t *v23; // rdi
  __int64 v24; // rdx
  void *v25; // r14
  _QWORD *v26; // rbx
  _WORD *v27; // rcx
  _QWORD *v28; // rsi
  _QWORD *i; // rbx
  __int64 v30; // rax
  _QWORD *j; // rdi
  _BYTE *k; // rbx
  wchar_t *v33; // rcx
  _QWORD *v34; // rdi
  _QWORD *m; // rbx
  _QWORD *v36; // r12
  __int64 v37; // r13
  _QWORD *v38; // rdi
  _QWORD *v39; // r14
  __int64 v40; // rsi
  __int64 v41; // r15
  unsigned int n; // ebx
  _QWORD *v43; // rbx
  __int64 *v44; // rdi
  wchar_t *v45; // rax
  wchar_t *v46; // rcx
  WCHAR *v47; // rax
  wchar_t *v48; // rax
  wchar_t *v49; // rsi
  wchar_t *ftLastWriteTime; // rcx
  int v51; // ebx
  unsigned int v52; // ebx
  wchar_t *v54; // [rsp+38h] [rbp-D0h] BYREF
  wchar_t *Buffer; // [rsp+40h] [rbp-C8h] BYREF
  size_t RequiredCount; // [rsp+48h] [rbp-C0h] BYREF
  HANDLE hFindFile; // [rsp+50h] [rbp-B8h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+58h] [rbp-B0h] BYREF
  struct _WIN32_FIND_DATAW lpFindFileData; // [rsp+2A8h] [rbp+1A0h] BYREF

  Buffer = 0i64;
  v4 = (wchar_t *)sub_14000DCC4(L"MAKEDIR");
  v54 = wgetcwd(0i64, 0);
  v5 = v54;
  sub_140001AC8(v4, v54, 66);
  wdupenv_s(&Buffer, 0i64, L"MAKEFLAGS");
  v6 = Buffer;
  if ( Buffer )
  {
    v7 = -1i64;
    do
      ++v7;
    while ( aMakeflags_0[v7] );
    wcsncpy_s(&aMakeflags_0[10], v7 - 9, Buffer, 0xFFFFFFFFFFFFFFFFui64);
  }
  byte_1400157ED = 1;
  v8 = (wchar_t *)sub_14000DCC4(&aMakeflags_0[10]);
  v9 = (wchar_t *)sub_14000DCC4(L"MAKEFLAGS");
  sub_140001AC8(v9, v8, 6);
  for ( ; v6; ++v6 )
  {
    if ( !*v6 )
      break;
    sub_14000B804(*v6, 1);
  }
  free(Buffer);
  Buffer = 0i64;
  if ( !wgetenv_s(&RequiredCount, 0i64, 0i64, L"NTMAKEENV") )
  {
    v10 = byte_140036CED;
    if ( RequiredCount )
      v10 = 1;
    byte_140036CED = v10;
  }
  sub_14000B43C(a1 - 1, a2 + 8);
  if ( !byte_140026488 )
    sub_140003A8C();
  if ( (byte_1400157EC & 2) != 0 )
    goto LABEL_24;
  sub_14000A944();
  qword_140026490 = (void *)L"tools.ini";
  wsearchenv(L"tools.ini", L"INIT", (wchar_t *)&FindFileData);
  if ( !LOWORD(FindFileData.dwFileAttributes) )
    goto LABEL_24;
  Stream = wfsopen((const wchar_t *)&FindFileData, L"rt,ccs=unicode", 32);
  if ( !Stream )
  {
    sub_140003898(0, 0x41Du, &FindFileData);
    __debugbreak();
  }
  if ( sub_140006C34(v11) )
  {
    ++dword_140025C20;
    byte_140026489 = 1;
    sub_14000C0B8();
    if ( fclose(Stream) == -1 )
    {
      p_FindFileData = (struct _WIN32_FIND_DATAW *)qword_140026490;
      goto LABEL_23;
    }
  }
  else if ( fclose(Stream) == -1 )
  {
    p_FindFileData = &FindFileData;
LABEL_23:
    sub_140003898(0, 0x424u, p_FindFileData);
  }
LABEL_24:
  v13 = (const wchar_t *)sub_14000DCC4(&aMakeflags_0[10]);
  if ( wputenv_s(L"MAKEFLAGS", v13) )
    sub_140003898(0, 0x41Fu);
  if ( !qword_140036E80 )
  {
    if ( waccess(L"makefile", 4) )
    {
      if ( qword_1400157F8 )
      {
        v15 = *(wchar_t **)(qword_1400157F8 + 8);
        if ( !waccess(v15, 4) )
        {
          v16 = (char *)wcsrchr(v15, 0x2Eu);
          if ( !v16 || !sub_14000D274((wchar_t *)&FindFileData, 0x101ui64, v15, v16, &lpFindFileData) )
          {
            v17 = qword_1400157F8;
            qword_1400157F8 = *(_QWORD *)qword_1400157F8;
            qword_140036E80 = v17;
          }
        }
      }
      else if ( (byte_1400157EC & 1) == 0 )
      {
        sub_140003898(0, 0x428u);
      }
    }
    else
    {
      v14 = sub_14000DC58();
      v14[1] = sub_14000DCC4(L"makefile");
      qword_140036E80 = (__int64)v14;
    }
  }
  v18 = (const wchar_t ***)_p__wenviron();
  v19 = *v18;
  v20 = **v18;
  if ( v20 )
  {
    do
    {
      v21 = wcschr(v20, 0x3Du);
      if ( v21 )
      {
        if ( wcsnicmp(*v19, L"MAKEFLAGS", 8ui64) )
        {
          *v21 = 0;
          if ( **v19 )
          {
            v22 = (wchar_t *)sub_14000DCC4(*v19);
            v23 = v22;
            v24 = -1i64;
            do
              ++v24;
            while ( v22[v24] );
            wcsupr_s(v22, v24 + 1);
            v25 = sub_14000DCC4(v21 + 1);
            byte_1400157ED = 0;
            *v21 = 61;
            if ( !sub_140001AC8(v23, (wchar_t *)v25, 4) )
            {
              free(v23);
              free(v25);
            }
          }
        }
      }
      v20 = *++v19;
    }
    while ( *v19 );
    v5 = v54;
  }
  v26 = (_QWORD *)qword_140036E80;
  if ( qword_140036E80 )
  {
    do
    {
      v27 = (_WORD *)v26[1];
      if ( *v27 != 45 || v27[1] )
      {
        qword_140026490 = sub_14000DCC4(v27);
        Stream = wfsopen((const wchar_t *)qword_140026490, L"rt,ccs=unicode", 32);
        if ( !Stream )
          sub_140003898(0, 0x41Cu, qword_140026490);
      }
      else
      {
        qword_140026490 = sub_14000DCC4(L"STDIN");
        Stream = _acrt_iob_func(0);
      }
      dword_140025C20 = 0;
      byte_140026489 = 0;
      sub_14000C0B8();
      if ( Stream != _acrt_iob_func(0) && fclose(Stream) == -1 )
        sub_140003898(0, 0x424u, qword_140026490);
      v26 = (_QWORD *)*v26;
    }
    while ( v26 );
    v26 = (_QWORD *)qword_140036E80;
  }
  sub_140002F98(v26);
  dword_140025C24 = 0;
  sub_14000D80C();
  if ( (byte_1400157EC & 1) != 0 )
  {
    sub_1400039C0(8u);
    v28 = qword_1400364D0;
    do
    {
      for ( i = (_QWORD *)*v28; i; i = (_QWORD *)*i )
      {
        v30 = i[2];
        if ( v30 && *(_QWORD *)(v30 + 8) )
        {
          sub_1400039C0(0xEu, i[1]);
          for ( j = *(_QWORD **)i[2]; j; j = (_QWORD *)*j )
          {
            if ( j[1] )
              sub_14000BFE0(L"\t\t%s\n");
          }
        }
      }
      ++v28;
    }
    while ( (__int64)v28 < (__int64)byte_140036CD0 );
    sub_14000C008();
    sub_14000BFB0();
    sub_1400039C0(7u);
    for ( k = qword_140025C00; k; k = *(_BYTE **)k )
    {
      v33 = L"%s:";
      if ( k[40] )
        v33 = L"%s::";
      sub_14000BFE0(v33, *((_QWORD *)k + 2));
      sub_1400039C0(0xAu);
      v34 = (_QWORD *)*((_QWORD *)k + 3);
      if ( v34 )
      {
        sub_14000BFE0(L"%s\n", v34[1]);
        while ( 1 )
        {
          v34 = (_QWORD *)*v34;
          if ( !v34 )
            break;
          sub_14000BFE0(L"\t\t\t%s\n", v34[1]);
        }
      }
      sub_14000C008();
    }
    sub_14000BFE0(L"%s: ", L".SUFFIXES");
    for ( m = (_QWORD *)qword_140025C18; m; m = (_QWORD *)*m )
      sub_14000BFE0(L"%s ", m[1]);
    sub_14000C008();
    sub_14000BFB0();
    sub_1400039C0(9u);
    v36 = qword_140025800;
    v37 = 128i64;
    do
    {
      v38 = (_QWORD *)*v36;
      if ( *v36 )
      {
        do
        {
          sub_14000BFE0(L"%s:%c", v38[1], (*(_BYTE *)(*(_QWORD *)(v38[4] + 8i64) + 32i64) & 0x20) != 0 ? 58 : 32);
          v39 = (_QWORD *)v38[4];
          qword_140026458 = v38[1];
          qword_140026470 = (wchar_t *)qword_140026458;
          qword_140026478 = qword_140026458;
          while ( v39 )
          {
            v40 = v39[1];
            sub_1400039C0(0xBu);
            v41 = 0i64;
            for ( n = 1; n < 0x10; n *= 2 )
            {
              if ( ((unsigned __int8)n & *(_BYTE *)(v40 + 32)) != 0 )
                sub_14000BFE0(L"-%c ", aDinsb[v41]);
              v41 = (unsigned int)(v41 + 1);
            }
            sub_14000C458(*(__int64 ***)v40, *(_QWORD *)(v40 + 8));
            sub_1400039C0(0xAu);
            v43 = *(_QWORD **)(v40 + 16);
            if ( v43 )
            {
              if ( v43[1] )
                sub_14000BFE0(L"%s\n");
              while ( 1 )
              {
                v43 = (_QWORD *)*v43;
                if ( !v43 )
                  break;
                if ( v43[1] )
                  sub_14000BFE0(L"\t\t\t%s\n");
              }
            }
            else
            {
              sub_14000C008();
            }
            v39 = (_QWORD *)*v39;
          }
          v38 = (_QWORD *)*v38;
          sub_14000C008();
        }
        while ( v38 );
      }
      ++v36;
      --v37;
    }
    while ( v37 );
    sub_14000C008();
    sub_14000BFB0();
    v5 = v54;
    qword_140026458 = 0i64;
    qword_140026470 = 0i64;
    qword_140026478 = 0i64;
  }
  if ( qword_1400364B8 )
    free(qword_1400364B8);
  while ( 1 )
  {
    v44 = (__int64 *)qword_1400157F8;
    if ( !qword_1400157F8 )
    {
      v52 = 0;
      goto LABEL_121;
    }
    v45 = wcspbrk(*(const wchar_t **)(qword_1400157F8 + 8), L"*?");
    v46 = *(wchar_t **)(qword_1400157F8 + 8);
    if ( v45 )
      break;
    v54 = 0i64;
    if ( (int)sub_140002054(v46, byte_1400157EE, (unsigned __int64 *)&v54) < 0 && (byte_1400157EC & 8) != 0 )
    {
      sub_140002F98(v44);
      v52 = 255;
      goto LABEL_121;
    }
LABEL_117:
    qword_1400157F8 = *v44;
    *v44 = qword_14003D0E0;
    qword_14003D0E0 = (__int64)v44;
  }
  v47 = sub_140005CA8(v46, &FindFileData, &hFindFile);
  if ( !v47 )
  {
    sub_140003898(0, 0x42Du, *(_QWORD *)(qword_1400157F8 + 8));
    goto LABEL_117;
  }
  while ( 1 )
  {
    v48 = (wchar_t *)sub_14000F570(*(const wchar_t **)(qword_1400157F8 + 8), v47);
    v49 = v48;
    if ( (FindFileData.dwFileAttributes & 0x10) == 0
      || (ftLastWriteTime = (wchar_t *)FindFileData.ftCreationTime) == 0i64 )
    {
      ftLastWriteTime = (wchar_t *)FindFileData.ftLastWriteTime;
    }
    v54 = ftLastWriteTime;
    v51 = sub_140002054(v48, byte_1400157EE, (unsigned __int64 *)&v54);
    free(v49);
    if ( v51 < 0 && (byte_1400157EC & 8) != 0 )
      break;
    v47 = sub_140005E30(&FindFileData, hFindFile);
    if ( !v47 )
      goto LABEL_117;
  }
  sub_140002F98(v44);
  v52 = -1;
LABEL_121:
  wchdir(v5);
  return v52;
}
// 14000ACF9: variable 'v11' is possibly undefined
// 140011720: using guessed type wchar_t aSuffixes[10];
// 140012DB0: using guessed type wchar_t aMakedir[8];
// 140012E28: using guessed type wchar_t aStdin[6];
// 140012F60: using guessed type wchar_t aS_6[4];
// 140012F68: using guessed type wchar_t aS_0[6];
// 140012F78: using guessed type wchar_t aS_1[5];
// 140012F88: using guessed type wchar_t aS_2[4];
// 140012F90: using guessed type wchar_t aS_3[4];
// 140012F98: using guessed type wchar_t aS_4[7];
// 140012FA8: using guessed type wchar_t aS_5[5];
// 140012FB8: using guessed type wchar_t aSC[6];
// 140012FC8: using guessed type wchar_t aC_1[5];
// 140012FD8: using guessed type wchar_t aDinsb[6];
// 140015050: using guessed type wchar_t aMakeflags_0[29];
// 1400157EC: using guessed type char byte_1400157EC;
// 1400157ED: using guessed type char byte_1400157ED;
// 1400157EE: using guessed type char byte_1400157EE;
// 1400157F8: using guessed type __int64 qword_1400157F8;
// 140025800: using guessed type _QWORD qword_140025800[128];
// 140025C18: using guessed type __int64 qword_140025C18;
// 140025C20: using guessed type int dword_140025C20;
// 140025C24: using guessed type int dword_140025C24;
// 140026458: using guessed type __int64 qword_140026458;
// 140026478: using guessed type __int64 qword_140026478;
// 140026488: using guessed type char byte_140026488;
// 140026489: using guessed type char byte_140026489;
// 1400364D0: using guessed type _QWORD qword_1400364D0[256];
// 140036CED: using guessed type char byte_140036CED;
// 140036E80: using guessed type __int64 qword_140036E80;
// 14003D0E0: using guessed type __int64 qword_14003D0E0;

//----- (000000014000B43C) ----------------------------------------------------
void __fastcall sub_14000B43C(unsigned int a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v4; // rbp
  wchar_t *v5; // rsi
  wchar_t *v6; // rax
  wchar_t *v7; // rbx
  wchar_t *v8; // rax
  const wchar_t *v9; // rbx
  size_t v10; // rax
  wchar_t *v11; // rbx
  size_t v12; // rax
  wchar_t *v13; // rax
  _QWORD *v14; // r15
  __int64 v15; // r14
  _WORD *v16; // rdi
  __int64 *v17; // rax
  __int64 *v18; // rcx
  wchar_t *v19; // rbx
  char v20; // cl
  unsigned int v21; // edi
  unsigned int v22; // ebx
  wchar_t *v23; // rbx
  FILE *v24; // rax
  _WORD *v25; // rbx
  _QWORD *v26; // rdi
  __int64 *v27; // rdx
  __int64 *i; // rcx
  char v29; // [rsp+60h] [rbp+8h]
  FILE *Stream; // [rsp+70h] [rbp+18h] BYREF

  if ( !a1 )
    return;
  v2 = a2;
  v29 = 0;
  LODWORD(v4) = 0;
  while ( 1 )
  {
    v5 = *(wchar_t **)(v2 + 8i64 * (unsigned int)v4);
    if ( *v5 == 64 )
    {
      sub_1400036EC(v5 + 1);
      goto LABEL_64;
    }
    if ( ((*v5 - 45) & 0xFFFD) == 0 )
      break;
    v6 = wcschr(*(const wchar_t **)(v2 + 8i64 * (unsigned int)v4), 0x3Du);
    v7 = v6;
    if ( v6 )
    {
      if ( v6 == v5 )
        sub_140003898(0, 0x427u);
      *v7 = 0;
      v8 = v7 - 1;
      v9 = v7 + 1;
      while ( *v8 == 32 || *v8 == 9 )
        --v8;
      v8[1] = 0;
      byte_1400157ED = 1;
      v10 = wcsspn(v9, L" \t");
      v11 = (wchar_t *)sub_14000DCC4(&v9[v10]);
      v12 = wcsspn(v5, L" \t");
      v13 = (wchar_t *)sub_14000DCC4(&v5[v12]);
      sub_140001AC8(v13, v11, 2);
    }
    else
    {
      sub_14000BB94(v5);
      if ( *v5 )
      {
        v14 = sub_14000DC58();
        if ( wcschr(v5, 0x20u) )
        {
          v15 = -1i64;
          do
            ++v15;
          while ( v5[v15] );
          v16 = sub_140009214(saturated_mul(v15 + 3, 2ui64));
          *v16 = 34;
          memcpy(v16 + 1, v5, 2 * v15);
          v16[v15 + 1] = 34;
          v16[v15 + 2] = 0;
          v14[1] = v16;
          v2 = a2;
        }
        else
        {
          v14[1] = sub_14000DCC4(v5);
        }
        v17 = (__int64 *)qword_1400157F8;
        v18 = &qword_1400157F8;
        while ( v17 )
        {
          v18 = v17;
          v17 = (__int64 *)*v17;
        }
        *v18 = (__int64)v14;
      }
    }
    *(_QWORD *)(v2 + 8i64 * (unsigned int)v4) = 0i64;
LABEL_64:
    v20 = v29;
LABEL_65:
    LODWORD(v4) = v4 + 1;
    if ( (unsigned int)v4 >= a1 )
      goto LABEL_27;
  }
  v19 = v5 + 1;
  if ( wcsicmp(v5 + 1, L"help") )
  {
    while ( *v19 )
    {
      if ( !wcsicmp(v19, L"nologo") )
      {
        sub_14000B804(v19[2], 1);
        goto LABEL_64;
      }
      if ( *v19 == 63 )
      {
        v20 = 1;
        v29 = 1;
        goto LABEL_65;
      }
      if ( *v19 == 102 || *v19 == 70 )
      {
        v25 = v19 + 1;
        if ( !*v25 )
        {
          v4 = (unsigned int)(v4 + 1);
          if ( (unsigned int)v4 >= a1 || (v25 = *(_WORD **)(v2 + 8 * v4), !*v25) )
            sub_140003898(0, 0x425u);
        }
        v26 = sub_14000DC58();
        v26[1] = sub_14000DCC4(v25);
        v27 = &qword_140036E80;
        for ( i = (__int64 *)qword_140036E80; i; i = (__int64 *)*i )
          v27 = i;
        *v27 = (__int64)v26;
        v2 = a2;
        goto LABEL_64;
      }
      if ( ((*v19 - 88) & 0xFFDF) == 0 )
      {
        v23 = v19 + 1;
        if ( !*v23 )
        {
          v4 = (unsigned int)(v4 + 1);
          if ( (unsigned int)v4 >= a1 || (v23 = *(wchar_t **)(v2 + 8 * v4), !*v23) )
            sub_140003898(0, 0x426u);
        }
        if ( *v23 != 45 || v23[1] )
        {
          if ( wfopen_s(&Stream, v23, L"wt") )
            sub_140003898(0, 0x418u, v23);
          sub_14000BEE0(Stream);
          fclose(Stream);
        }
        else
        {
          v24 = _acrt_iob_func(1u);
          sub_14000BEE0(v24);
        }
        goto LABEL_64;
      }
      sub_14000B804(*v19++, 1);
    }
    goto LABEL_64;
  }
  v20 = 1;
LABEL_27:
  if ( v20 )
  {
    v21 = 100;
    v22 = 103;
    do
      sub_1400039C0(v21++, L"NMAKE");
    while ( v21 < 0x67 );
    while ( 1 )
    {
      if ( v22 == 113 )
        v22 = 114;
      if ( v22 == 121 )
        v22 = 122;
      sub_1400039C0(v22++);
      if ( v22 > 0x7C )
        exit(0);
    }
  }
}
// 140011DC0: using guessed type wchar_t aNmake_1[6];
// 1400157ED: using guessed type char byte_1400157ED;
// 1400157F8: using guessed type __int64 qword_1400157F8;
// 140036E80: using guessed type __int64 qword_140036E80;

//----- (000000014000B804) ----------------------------------------------------
__int16 __fastcall sub_14000B804(wint_t a1, char a2)
{
  char v2; // di
  char *v3; // rbx
  char *v6; // rax
  wchar_t v7; // si
  __int64 v8; // rcx
  wchar_t *v9; // rax
  wchar_t *v10; // rax
  wchar_t v11; // cx
  const wchar_t *v12; // rax

  v2 = 0;
  v3 = &byte_1400157EE;
  LOWORD(v6) = towupper(a1);
  v7 = (unsigned __int16)v6;
  if ( (unsigned __int16)v6 > 0x4Cu )
  {
    if ( (unsigned __int16)v6 != 78 )
    {
      switch ( (unsigned __int16)v6 )
      {
        case 'O':
          byte_140025C39 = 1;
          return (__int16)v6;
        case 'P':
          v2 = 1;
          break;
        case 'Q':
          v2 = 8;
          break;
        case 'R':
          v2 = 2;
          break;
        case 'S':
          v2 = 8;
          goto LABEL_17;
        case 'T':
          v2 = 16;
          break;
        case 'U':
          v2 = 64;
          goto LABEL_17;
        case 'Y':
          v2 = 64;
          break;
        default:
          goto LABEL_34;
      }
      v3 = &byte_1400157EC;
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  switch ( (unsigned __int16)v6 )
  {
    case 'L':
      v2 = 0x80;
      goto LABEL_21;
    case ' ':
      return (__int16)v6;
    case 'A':
      v2 = 16;
      goto LABEL_17;
    case 'B':
      byte_140025C3A = 1;
      return (__int16)v6;
    case 'C':
      v2 = 32;
LABEL_21:
      v3 = &byte_1400157EC;
      byte_140026488 = 1;
      goto LABEL_17;
    case 'D':
      v2 = 1;
      goto LABEL_17;
    case 'E':
      v3 = &byte_1400157EC;
LABEL_16:
      v2 = 4;
      goto LABEL_17;
    case 'G':
      byte_14002648B = 1;
      return (__int16)v6;
  }
  if ( (unsigned __int16)v6 != 73 )
  {
    if ( (unsigned __int16)v6 == 75 )
    {
      byte_140025C3B = 1;
      return (__int16)v6;
    }
LABEL_34:
    LOWORD(v6) = sub_140003898(0, 0x429u, a1);
    goto LABEL_17;
  }
  v2 = 2;
LABEL_17:
  if ( qword_140036E78 )
  {
    v8 = qword_140036E70;
  }
  else
  {
    v6 = sub_14000918C(L"MAKEFLAGS");
    qword_140036E78 = (__int64)v6;
    v8 = *((_QWORD *)v6 + 2);
    qword_140036E70 = v8;
  }
  if ( a2 )
  {
    *v3 |= v2;
    if ( v7 == 81 )
      *v3 |= 0x20u;
    if ( !wcschr(*(const wchar_t **)(v8 + 8), v7) )
    {
      v9 = wcschr(*(const wchar_t **)(qword_140036E70 + 8), 0x20u);
      if ( v9 )
        *v9 = v7;
    }
  }
  else
  {
    if ( v3 != &byte_1400157EE )
      return (__int16)v6;
    *v3 &= ~v2;
    v10 = wcschr(*(const wchar_t **)(v8 + 8), v7);
    if ( v10 )
    {
      do
      {
        v11 = v10[1];
        *v10++ = v11;
      }
      while ( v11 );
    }
  }
  v12 = (const wchar_t *)sub_14000DCC4(&aMakeflags_0[10]);
  LODWORD(v6) = wputenv_s(L"MAKEFLAGS", v12);
  if ( (_DWORD)v6 )
    LOWORD(v6) = sub_140003898(dword_140025C20, 0x41Fu);
  return (__int16)v6;
}
// 140015050: using guessed type wchar_t aMakeflags_0[29];
// 1400157EC: using guessed type char byte_1400157EC;
// 1400157EE: using guessed type char byte_1400157EE;
// 140025C20: using guessed type int dword_140025C20;
// 140025C39: using guessed type char byte_140025C39;
// 140025C3A: using guessed type char byte_140025C3A;
// 140025C3B: using guessed type char byte_140025C3B;
// 140026488: using guessed type char byte_140026488;
// 14002648B: using guessed type char byte_14002648B;
// 140036E70: using guessed type __int64 qword_140036E70;
// 140036E78: using guessed type __int64 qword_140036E78;

//----- (000000014000BA78) ----------------------------------------------------
void __fastcall Function()
{
  __int64 v0; // rbx
  const wchar_t *v1; // rdi

  signal(2, (_crt_signal_t)1);
  signal(15, (_crt_signal_t)1);
  if ( byte_140036CEC
    && (byte_1400157EE & 4) == 0
    && (byte_1400157EC & 0x10) == 0
    && qword_140026470
    && waccess(qword_140026470, 0) )
  {
    v0 = qword_140025C10;
    v1 = qword_140026470;
    if ( qword_140025C10 )
    {
      while ( wcsicmp(*(const wchar_t **)(v0 + 8), v1) )
      {
        v0 = *(_QWORD *)v0;
        if ( !v0 )
        {
          v1 = qword_140026470;
          goto LABEL_10;
        }
      }
    }
    else
    {
LABEL_10:
      if ( !wunlink(v1) )
        sub_140003898(dword_140025C20, 0xFA8u, qword_140026470);
    }
  }
  sub_140003898(0, 0x422u);
  sub_14000BB48();
}
// 1400157EC: using guessed type char byte_1400157EC;
// 1400157EE: using guessed type char byte_1400157EE;
// 140025C10: using guessed type __int64 qword_140025C10;
// 140025C20: using guessed type int dword_140025C20;
// 140036CEC: using guessed type char byte_140036CEC;

//----- (000000014000BB48) ----------------------------------------------------
int sub_14000BB48()
{
  int result; // eax
  __int64 i; // rbx

  result = fcloseall();
  for ( i = qword_140036E88; i; i = *(_QWORD *)i )
  {
    result = wunlink(*(const wchar_t **)(i + 8));
    if ( (byte_1400157EE & 4) != 0 )
    {
      sub_14000BFE0(L"\tdel %s\n", *(_QWORD *)(i + 8));
      result = sub_14000BFB0();
    }
  }
  return result;
}
// 140012E78: using guessed type wchar_t aDelS[9];
// 1400157EE: using guessed type char byte_1400157EE;
// 140036E88: using guessed type __int64 qword_140036E88;

//----- (000000014000BB94) ----------------------------------------------------
_WORD *__fastcall sub_14000BB94(_WORD *a1)
{
  __int64 v1; // rax
  char v2; // dl
  _WORD *result; // rax

  v1 = -1i64;
  do
    ++v1;
  while ( a1[v1] );
  v2 = 0;
  result = &a1[v1 - 1];
  if ( *a1 != 34 || *result != 34 )
    goto LABEL_9;
  v2 = 1;
  do
  {
    --result;
LABEL_9:
    ;
  }
  while ( result > a1 && (*result == 32 || *result == 46) );
  if ( v2 )
    *++result = 34;
  result[1] = 0;
  return result;
}

//----- (000000014000BBEC) ----------------------------------------------------
__int64 __fastcall sub_14000BBEC(unsigned int a1)
{
  __int64 v1; // rbx
  wchar_t **v3; // rax
  HMODULE v4; // rdi
  int v5; // eax
  HRSRC Resource; // rax
  _WORD *v7; // rcx
  int i; // esi
  wchar_t Drive[8]; // [rsp+50h] [rbp-638h] BYREF
  wchar_t Destination[256]; // [rsp+60h] [rbp-628h] BYREF
  wchar_t Dir[256]; // [rsp+260h] [rbp-428h] BYREF
  wchar_t Buffer[264]; // [rsp+460h] [rbp-228h] BYREF

  v1 = 0i64;
  if ( byte_14003DDF0 )
  {
    v4 = (HMODULE)qword_14003DDF8;
  }
  else
  {
    v3 = _p__wpgmptr();
    wsplitpath_s(*v3, Drive, 3ui64, Dir, 0x100ui64, Destination, 0x100ui64, 0i64, 0i64);
    wmakepath_s(Buffer, 0x104ui64, Drive, Dir, 0i64, 0i64);
    if ( wcsncat_s(Destination, 0x100ui64, L"UI.DLL", 0xFFFFFFFFFFFFFFFFui64) )
    {
      v4 = 0i64;
      qword_14003DDF8 = 0i64;
    }
    else
    {
      v5 = sub_1400092B4(Buffer, Destination);
      v4 = (HMODULE)qword_14003DDF8;
      if ( v5 < 0 )
        v4 = 0i64;
      qword_14003DDF8 = (__int64)v4;
    }
    byte_14003DDF0 = 1;
  }
  Resource = FindResourceExW(v4, (LPCWSTR)6, (LPCWSTR)(unsigned __int16)((a1 >> 4) + 1), word_14003DE00);
  if ( Resource )
  {
    v7 = LoadResource(v4, Resource);
    if ( v7 )
    {
      for ( i = a1 & 0xF; i; --i )
        v7 += (unsigned __int16)*v7 + 1;
      return (unsigned __int64)(v7 + 1) & -(__int64)(*v7 != 0);
    }
  }
  return v1;
}
// 14003DDF0: using guessed type char byte_14003DDF0;
// 14003DDF8: using guessed type __int64 qword_14003DDF8;
// 14003DE00: using guessed type __int16 word_14003DE00;

//----- (000000014000BD80) ----------------------------------------------------
void *sub_14000BD80()
{
  return &unk_14003D120;
}

//----- (000000014000BDDC) ----------------------------------------------------
void *sub_14000BDDC()
{
  return &unk_14003D130;
}

//----- (000000014000BDE4) ----------------------------------------------------
int sub_14000BDE4(wchar_t *Buffer, wchar_t *Format, ...)
{
  _QWORD *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = sub_14000BDDC();
  return _stdio_common_vswscanf(*v4 | 1i64, Buffer, 0xFFFFFFFFFFFFFFFFui64, Format, 0i64, va);
}

//----- (000000014000BE34) ----------------------------------------------------
bool __fastcall sub_14000BE34(FILE *a1)
{
  int v1; // eax
  void *osfhandle; // rbx
  DWORD Mode; // [rsp+38h] [rbp+10h] BYREF

  v1 = fileno(a1);
  osfhandle = (void *)get_osfhandle(v1);
  return (GetFileType(osfhandle) & 0xFFFF7FFF) == 2 && GetConsoleMode(osfhandle, &Mode);
}

//----- (000000014000BE7C) ----------------------------------------------------
int sub_14000BE7C(wchar_t *a1, ...)
{
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, a1);
  return sub_14000BF3C(a1, va);
}

//----- (000000014000BEA4) ----------------------------------------------------
__int64 sub_14000BEA4()
{
  __int64 result; // rax
  FILE *v1; // rax

  if ( byte_140037093 )
  {
    LOWORD(result) = putwch(0xAu);
  }
  else
  {
    v1 = _acrt_iob_func(2u);
    LOWORD(result) = fputwc(0xAu, v1);
  }
  return (unsigned __int16)result;
}
// 140037093: using guessed type char byte_140037093;

//----- (000000014000BEE0) ----------------------------------------------------
bool __fastcall sub_14000BEE0(FILE *Stream)
{
  FILE *v2; // rax
  int v3; // ebx
  int v4; // eax
  FILE *v5; // rax
  bool result; // al

  v2 = _acrt_iob_func(2u);
  v3 = fileno(v2);
  v4 = fileno(Stream);
  dup2(v4, v3);
  v5 = _acrt_iob_func(2u);
  result = sub_14000BE34(v5);
  byte_140037093 = result;
  return result;
}
// 140037093: using guessed type char byte_140037093;

//----- (000000014000BF3C) ----------------------------------------------------
int __fastcall sub_14000BF3C(wchar_t *Format, va_list ArgList)
{
  unsigned __int64 *v4; // rax
  FILE *v6; // rbx
  unsigned __int64 *v7; // rax

  if ( byte_140037093 )
  {
    v4 = (unsigned __int64 *)sub_14000BD80();
    return _conio_common_vcwprintf(*v4, Format, 0i64, ArgList);
  }
  else
  {
    v6 = _acrt_iob_func(2u);
    v7 = (unsigned __int64 *)sub_14000BD80();
    return _stdio_common_vfwprintf(*v7, v6, Format, 0i64, ArgList);
  }
}
// 140037093: using guessed type char byte_140037093;

//----- (000000014000BFB0) ----------------------------------------------------
int sub_14000BFB0()
{
  FILE *v1; // rax

  if ( byte_1400370B0 )
    return 0;
  v1 = _acrt_iob_func(1u);
  return fflush(v1);
}
// 1400370B0: using guessed type char byte_1400370B0;

//----- (000000014000BFE0) ----------------------------------------------------
int sub_14000BFE0(wchar_t *a1, ...)
{
  va_list va; // [rsp+38h] [rbp+10h] BYREF

  va_start(va, a1);
  return sub_14000C044(a1, va);
}

//----- (000000014000C008) ----------------------------------------------------
__int64 sub_14000C008()
{
  __int64 result; // rax
  FILE *v1; // rax

  if ( byte_1400370B0 )
  {
    LOWORD(result) = putwch(0xAu);
  }
  else
  {
    v1 = _acrt_iob_func(1u);
    LOWORD(result) = fputwc(0xAu, v1);
  }
  return (unsigned __int16)result;
}
// 1400370B0: using guessed type char byte_1400370B0;

//----- (000000014000C044) ----------------------------------------------------
int __fastcall sub_14000C044(wchar_t *Format, va_list ArgList)
{
  unsigned __int64 *v4; // rax
  FILE *v6; // rbx
  unsigned __int64 *v7; // rax

  if ( byte_1400370B0 )
  {
    v4 = (unsigned __int64 *)sub_14000BD80();
    return _conio_common_vcwprintf(*v4, Format, 0i64, ArgList);
  }
  else
  {
    v6 = _acrt_iob_func(1u);
    v7 = (unsigned __int64 *)sub_14000BD80();
    return _stdio_common_vfwprintf(*v7, v6, Format, 0i64, ArgList);
  }
}
// 1400370B0: using guessed type char byte_1400370B0;

//----- (000000014000C0B8) ----------------------------------------------------
char sub_14000C0B8()
{
  __int64 v0; // rax
  __int64 v1; // rcx
  char result; // al
  __int64 v3; // rdx
  char v4; // r14
  char v5; // si
  __int64 v6; // rcx
  unsigned __int8 i; // r8
  __int64 v8; // rbp
  __int64 v9; // rdi
  int v10; // edi
  char v11; // al
  _BYTE *v12; // r9
  __int64 v13; // r8
  bool v14; // zf
  unsigned __int8 v15; // bl

  byte_14002648A = 1;
  v0 = dword_140015048 + 1;
  dword_140015048 += 2;
  v1 = (unsigned int)dword_140015048;
  byte_140036CD0[v0] = 23;
  if ( (unsigned __int64)(int)v1 >= 0x10 )
    _report_rangecheckfailure(v1);
  byte_140036CD0[(int)v1] = 0;
  dword_140025C24 = dword_140025C20;
  result = sub_140007F84(v1, 0i64);
  LODWORD(v3) = dword_140015048;
  v4 = result;
  v5 = 0;
  v6 = dword_140015048;
  for ( i = byte_140036CD0[dword_140015048]; ; i = byte_140036CD0[(int)v3] )
  {
    v15 = i;
    if ( i == 23 )
      break;
    if ( (i & 0x40) != 0 )
    {
      dword_140015048 = v3 - 1;
      off_140011B50[i & 0xF]();
LABEL_15:
      LODWORD(v3) = dword_140015048;
      goto LABEL_25;
    }
    if ( (i & 0x10) != 0 )
    {
      if ( i != v4 )
      {
        sub_140003898(dword_140025C24, 0x409u, &Src);
        goto LABEL_15;
      }
      v3 = (unsigned int)(v3 - 1);
      dword_140015048 = v3;
      LOBYTE(v6) = byte_140036CD0[(int)v3];
      if ( (v6 & 0x40) != 0 )
      {
        dword_140015048 = v3 - 1;
        off_140011B50[v6 & 0xF]();
        v3 = (unsigned int)dword_140015048;
      }
      dword_140025C24 = dword_140025C20;
      if ( !v5 )
      {
        LOBYTE(v3) = byte_140036CD0[(int)v3];
        v4 = sub_140007F84(v6, v3);
        dword_140025C24 = dword_140025C20;
        goto LABEL_15;
      }
      if ( Src == 10 )
        dword_140025C24 = dword_140025C20 - 1;
      v4 = v5;
      v5 = 0;
    }
    else
    {
      v8 = 8i64 * i;
      v9 = byte_140011BA0[v8 + (v4 & 0xF)];
      if ( (v9 & 0x20) != 0 )
      {
        sub_140003898(dword_140025C24, v9 + 1000, &Src);
        LODWORD(v3) = dword_140015048;
      }
      v3 = (unsigned int)(v3 - 1);
      dword_140015048 = v3;
      if ( (v9 & 0x80u) != 0i64 )
      {
        v10 = v9 & 0xF;
        if ( !v5 )
        {
          LOBYTE(v3) = v15;
          v11 = sub_140007F84(v6, v3);
          LODWORD(v3) = dword_140015048;
          v5 = v11;
        }
        v9 = (unsigned int)byte_140011B80[v8 + (v5 & 0xF)] + v10;
      }
      v12 = *(&off_140011BE0 + v9);
      v6 = (unsigned int)v9;
      v13 = (unsigned __int8)*v12;
      if ( *v12 )
      {
        do
        {
          LODWORD(v3) = v3 + 1;
          v6 = (int)v3;
          byte_140036CD0[(int)v3] = v12[v13];
          v14 = (_DWORD)v13 == 1;
          v13 = (unsigned int)(v13 - 1);
        }
        while ( !v14 );
        dword_140015048 = v3;
      }
    }
LABEL_25:
    result = v3;
  }
  dword_140015048 = v3 - 1;
  return result;
}
// 14000C1FC: variable 'v6' is possibly undefined
// 14001025C: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD);
// 140011B50: using guessed type __int64 (__fastcall *off_140011B50[6])();
// 140011B80: using guessed type unsigned __int8[24];
// 140011BA0: using guessed type unsigned __int8[64];
// 140011BE0: using guessed type void *off_140011BE0;
// 140015048: using guessed type int dword_140015048;
// 140025C20: using guessed type int dword_140025C20;
// 140025C24: using guessed type int dword_140025C24;
// 14002648A: using guessed type char byte_14002648A;

//----- (000000014000C304) ----------------------------------------------------
unsigned __int64 __fastcall sub_14000C304(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  unsigned __int64 v3; // rcx

  v2 = -1i64;
  do
    ++v2;
  while ( *(_WORD *)(a2 + 2 * v2) );
  v3 = v2 + a1;
  if ( v3 > 0x28 )
  {
    sub_14000BFE0(L"\n\t\t\t");
    return 0i64;
  }
  return v3;
}
// 140012F10: using guessed type wchar_t asc_140012F10[5];

//----- (000000014000C33C) ----------------------------------------------------
int __fastcall sub_14000C33C(unsigned int a1, __int64 a2, FILETIME a3)
{
  int result; // eax
  LPWSTR lpDateStr; // [rsp+20h] [rbp-88h]
  FILETIME FileTime; // [rsp+30h] [rbp-78h] BYREF
  struct _FILETIME LocalFileTime; // [rsp+38h] [rbp-70h] BYREF
  struct _SYSTEMTIME SystemTime; // [rsp+40h] [rbp-68h] BYREF
  WCHAR TimeStr[12]; // [rsp+50h] [rbp-58h] BYREF
  WCHAR DateStr[20]; // [rsp+68h] [rbp-40h] BYREF

  FileTime = a3;
  if ( a3 )
  {
    result = FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
    if ( result )
    {
      result = FileTimeToSystemTime(&LocalFileTime, &SystemTime);
      if ( result )
      {
        result = GetDateFormatW(0x400u, 0, &SystemTime, L"ddd, MMM dd yyyy", DateStr, 20);
        if ( result )
        {
          result = GetTimeFormatW(0x400u, 0, &SystemTime, L"HH:mm:ss", TimeStr, 12);
          if ( result )
          {
            LODWORD(lpDateStr) = 32;
            return sub_1400039C0(4u, DateStr, TimeStr, a1, lpDateStr, a2, FileTime);
          }
        }
      }
    }
  }
  else
  {
    return sub_1400039C0(6u, a1 + 26, 32i64, a2);
  }
  return result;
}
// 14000C42F: variable 'lpDateStr' is possibly undefined

//----- (000000014000C458) ----------------------------------------------------
void __fastcall sub_14000C458(__int64 **a1, __int64 a2)
{
  __int64 v3; // r14
  wchar_t *v4; // rax
  const wchar_t *v5; // rcx
  wchar_t *v6; // r15
  wchar_t *i; // rcx
  WCHAR *j; // rax
  void *v9; // rbx
  wchar_t *v10; // rax
  wchar_t *v11; // rsi
  WCHAR *k; // rax
  void *v13; // rbx
  HANDLE hFindFile; // [rsp+20h] [rbp-E0h] BYREF
  wchar_t *Context; // [rsp+28h] [rbp-D8h] BYREF
  __int64 v16; // [rsp+30h] [rbp-D0h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+40h] [rbp-C0h] BYREF

  v16 = a2;
  sub_1400039C0(0xCu);
  v3 = 0i64;
  while ( a1 )
  {
    v4 = wcschr((const wchar_t *)a1[1], 0x24u);
    v5 = (const wchar_t *)a1[1];
    if ( v4 )
    {
      Context = 0i64;
      v6 = (wchar_t *)sub_14000E740(v5, 1, &v16);
      for ( i = v6; ; i = 0i64 )
      {
        v10 = wcstok_s(i, L" \t", &Context);
        v11 = v10;
        if ( !v10 )
          break;
        if ( wcspbrk(v10, L"*?") )
        {
          for ( j = sub_140005CA8(v11, &FindFileData, &hFindFile); j; j = sub_140005E30(&FindFileData, hFindFile) )
          {
            v9 = sub_14000F570(v11, j);
            sub_14000BFE0(L"%s ", v9);
            v3 = sub_14000C304(v3, (__int64)v9);
            free(v9);
          }
        }
        else
        {
          sub_14000BFE0(L"%s ", v11);
          v3 = sub_14000C304(v3, (__int64)v11);
        }
      }
      free(v6);
    }
    else if ( wcspbrk(v5, L"*?") )
    {
      for ( k = sub_140005CA8((wchar_t *)a1[1], &FindFileData, &hFindFile); k; k = sub_140005E30(
                                                                                     &FindFileData,
                                                                                     hFindFile) )
      {
        v13 = sub_14000F570((const wchar_t *)a1[1], k);
        sub_14000BFE0(L"%s ", v13);
        v3 = sub_14000C304(v3, (__int64)v13);
        free(v13);
      }
    }
    else
    {
      sub_14000BFE0(L"%s ", a1[1]);
      v3 = sub_14000C304(v3, (__int64)a1[1]);
    }
    a1 = (__int64 **)*a1;
  }
}
// 140012F60: using guessed type wchar_t aS_6[4];

//----- (000000014000C658) ----------------------------------------------------
char __fastcall sub_14000C658(unsigned __int8 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  __int64 v5; // rbx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  _BOOL8 v14; // rcx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  __int64 v22; // rax
  unsigned __int16 *v23; // rax
  __int64 v24; // r8
  unsigned __int16 v25; // dx
  __int64 v26; // rcx
  int v27; // r8d

  LOBYTE(a4) = a1;
  v4 = qword_1400370D0;
  v5 = qword_1400370D0 - 16;
  qword_1400370D0 -= 16i64;
  if ( *(_BYTE *)v4 != 22 || *(_BYTE *)v5 != 22 )
  {
    if ( *(_BYTE *)v4 != 23 || *(_BYTE *)v5 != 23 )
      return 0;
    v23 = *(unsigned __int16 **)(v5 + 8);
    v24 = *(_QWORD *)(v4 + 8) - (_QWORD)v23;
    while ( 1 )
    {
      v25 = *v23;
      v26 = 0i64;
      if ( *v23 != *(unsigned __int16 *)((char *)v23 + v24) )
        break;
      ++v23;
      if ( !v25 )
      {
        v27 = 0;
        goto LABEL_56;
      }
    }
    v27 = v25 < *(unsigned __int16 *)((char *)v23 + v24) ? -1 : 1;
LABEL_56:
    switch ( (unsigned __int8)a4 )
    {
      case 6u:
        LOBYTE(v26) = v27 != 0;
        break;
      case 7u:
        LOBYTE(v26) = v27 == 0;
        break;
      case 8u:
        LOBYTE(v26) = v27 > 0;
        break;
      case 9u:
        LOBYTE(v26) = v27 < 0;
        break;
      case 0xAu:
        LOBYTE(v26) = v27 >= 0;
        break;
      case 0xBu:
        LOBYTE(v26) = v27 <= 0;
        break;
      default:
        return 0;
    }
    *(_QWORD *)(v5 + 8) = v26;
    *(_BYTE *)v5 = 22;
    return 1;
  }
  if ( a1 > 0xAu )
  {
    v15 = a1 - 11;
    if ( !v15 )
    {
      v14 = *(_QWORD *)(v5 + 8) <= *(_QWORD *)(v4 + 8);
      goto LABEL_48;
    }
    v16 = v15 - 1;
    if ( v16 )
    {
      v17 = v16 - 1;
      if ( v17 )
      {
        v18 = v17 - 1;
        if ( v18 )
        {
          v19 = v18 - 1;
          if ( v19 )
          {
            v20 = v19 - 1;
            if ( !v20 )
            {
              if ( !*(_QWORD *)(v4 + 8) )
                sub_140003898(dword_140025C20, 0x437u, a3, a4);
              *(__int64 *)(v5 + 8) %= *(_QWORD *)(v4 + 8);
              return 1;
            }
            v21 = v20 - 1;
            if ( v21 )
            {
              if ( v21 != 1 )
                return 0;
              v22 = *(_QWORD *)(v4 + 8) * *(_QWORD *)(v5 + 8);
            }
            else
            {
              if ( !*(_QWORD *)(v4 + 8) )
                sub_140003898(dword_140025C20, 0x437u, a3, a4);
              v22 = *(_QWORD *)(v5 + 8) / *(__int64 *)(v4 + 8);
            }
            *(_QWORD *)(v5 + 8) = v22;
          }
          else
          {
            *(_QWORD *)(v5 + 8) += *(_QWORD *)(v4 + 8);
          }
        }
        else
        {
          *(_QWORD *)(v5 + 8) -= *(_QWORD *)(v4 + 8);
        }
      }
      else
      {
        *(_QWORD *)(v5 + 8) <<= *(_QWORD *)(v4 + 8);
      }
    }
    else
    {
      *(__int64 *)(v5 + 8) >>= *(_QWORD *)(v4 + 8);
    }
    return 1;
  }
  if ( a1 == 10 )
  {
    v14 = *(_QWORD *)(v5 + 8) >= *(_QWORD *)(v4 + 8);
    goto LABEL_48;
  }
  v6 = a1 - 1;
  if ( !v6 )
  {
    v14 = 0i64;
    if ( *(_QWORD *)(v5 + 8) )
      goto LABEL_25;
    goto LABEL_24;
  }
  v7 = v6 - 1;
  if ( !v7 )
  {
    v14 = 0i64;
    if ( !*(_QWORD *)(v5 + 8) )
      goto LABEL_48;
LABEL_24:
    if ( !*(_QWORD *)(v4 + 8) )
      goto LABEL_48;
LABEL_25:
    v14 = 1i64;
    goto LABEL_48;
  }
  v8 = v7 - 1;
  if ( !v8 )
  {
    *(_QWORD *)(v5 + 8) |= *(_QWORD *)(v4 + 8);
    return 1;
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
    *(_QWORD *)(v5 + 8) ^= *(_QWORD *)(v4 + 8);
    return 1;
  }
  v10 = v9 - 1;
  if ( !v10 )
  {
    *(_QWORD *)(v5 + 8) &= *(_QWORD *)(v4 + 8);
    return 1;
  }
  v11 = v10 - 1;
  if ( !v11 )
  {
    v14 = *(_QWORD *)(v4 + 8) != *(_QWORD *)(v5 + 8);
    goto LABEL_48;
  }
  v12 = v11 - 1;
  if ( !v12 )
  {
    v14 = *(_QWORD *)(v4 + 8) == *(_QWORD *)(v5 + 8);
    goto LABEL_48;
  }
  v13 = v12 - 1;
  if ( !v13 )
  {
    v14 = *(_QWORD *)(v5 + 8) > *(_QWORD *)(v4 + 8);
    goto LABEL_48;
  }
  if ( v13 == 1 )
  {
    v14 = *(_QWORD *)(v5 + 8) < *(_QWORD *)(v4 + 8);
LABEL_48:
    *(_QWORD *)(v5 + 8) = v14;
    return 1;
  }
  return 0;
}
// 140025C20: using guessed type int dword_140025C20;
// 1400370D0: using guessed type __int64 qword_1400370D0;

//----- (000000014000C914) ----------------------------------------------------
char __fastcall sub_14000C914(unsigned __int8 a1)
{
  int v1; // ecx
  int v2; // ecx
  __int64 v3; // rax

  if ( *(_BYTE *)qword_1400370D0 == 22 )
  {
    v1 = a1 - 19;
    if ( !v1 )
    {
      v3 = -*(_QWORD *)(qword_1400370D0 + 8);
      goto LABEL_8;
    }
    v2 = v1 - 1;
    if ( !v2 )
    {
      v3 = ~*(_QWORD *)(qword_1400370D0 + 8);
      goto LABEL_8;
    }
    if ( v2 == 1 )
    {
      v3 = *(_QWORD *)(qword_1400370D0 + 8) == 0i64;
LABEL_8:
      *(_QWORD *)(qword_1400370D0 + 8) = v3;
      return 1;
    }
  }
  return 0;
}
// 1400370D0: using guessed type __int64 qword_1400370D0;

//----- (000000014000C958) ----------------------------------------------------
wchar_t *sub_14000C958()
{
  wchar_t *v0; // rax
  wchar_t *v1; // rbx
  wchar_t v2; // cx
  wchar_t *result; // rax

  v0 = EndPtr + 1;
  EndPtr = v0;
  v1 = v0;
  v2 = *v0;
  if ( !*v0 )
    goto LABEL_7;
  do
  {
    if ( v2 == 34 )
    {
      if ( v0[1] != 34 )
        break;
      ++v0;
    }
    EndPtr = ++v0;
    v2 = *v0;
  }
  while ( *v0 );
  if ( !*v0 )
  {
LABEL_7:
    sub_140003898(dword_140025C20, 0x3FEu, 34i64);
    v0 = EndPtr;
  }
  *v0 = 0;
  result = v1;
  ++EndPtr;
  return result;
}
// 140025C20: using guessed type int dword_140025C20;

//----- (000000014000C9E0) ----------------------------------------------------
wchar_t *sub_14000C9E0()
{
  wchar_t *v0; // rax
  wchar_t *v1; // rbx
  wchar_t v2; // cx
  _WORD *v3; // rdx
  __int64 v4; // r8
  wchar_t *result; // rax

  v0 = EndPtr + 1;
  EndPtr = v0;
  v1 = v0;
  v2 = *v0;
  if ( !*v0 )
    goto LABEL_10;
  do
  {
    if ( v2 == 94 && (v3 = v0 + 1, v0[1] == 93) )
    {
      v4 = -1i64;
      do
        ++v4;
      while ( v3[v4] );
      memmove(v0, v3, 2 * v4 + 2);
      v0 = EndPtr;
    }
    else if ( v2 == 93 )
    {
      break;
    }
    EndPtr = ++v0;
    v2 = *v0;
  }
  while ( *v0 );
  if ( !*v0 )
  {
LABEL_10:
    sub_140003898(dword_140025C20, 0x3FEu, 93i64);
    v0 = EndPtr;
  }
  *v0 = 0;
  result = v1;
  ++EndPtr;
  return result;
}
// 140025C20: using guessed type int dword_140025C20;

//----- (000000014000CAA0) ----------------------------------------------------
int __fastcall sub_14000CAA0(char a1, __int64 a2)
{
  unsigned __int8 v4; // bl
  _BYTE *v5; // rax

  if ( a1 == 25 )
  {
    v4 = 3;
  }
  else if ( a1 )
  {
    if ( (unsigned __int8)a1 <= 0x15u )
      v4 = ((unsigned __int8)a1 > 0x12u) + 1;
    else
      v4 = 0;
  }
  else
  {
    v4 = 4;
  }
  v5 = byte_140011CC0;
  if ( !byte_140011CC0[5 * (unsigned __int8)byte_1400370B1 + v4] )
    LODWORD(v5) = sub_140003898(dword_140025C20, 0x3FFu);
  byte_1400370B1 = v4;
  *((_QWORD *)&xmmword_1400370B8 + 1) = a2;
  byte_1400370B3 = a1;
  LOBYTE(xmmword_1400370B8) = a1;
  return (int)v5;
}
// 140011CC0: using guessed type _BYTE byte_140011CC0[32];
// 140025C20: using guessed type int dword_140025C20;
// 1400370B1: using guessed type char byte_1400370B1;
// 1400370B3: using guessed type char byte_1400370B3;
// 1400370B8: using guessed type __int128 xmmword_1400370B8;

//----- (000000014000CB34) ----------------------------------------------------
wchar_t *sub_14000CB34()
{
  wchar_t *i; // rax
  wchar_t v1; // cx
  wchar_t v2; // cx
  wchar_t *v3; // rax
  wchar_t *v4; // rcx
  wchar_t *v5; // rsi
  wchar_t v6; // dx
  wchar_t *v7; // rdi
  wchar_t v8; // bx

  for ( i = EndPtr; ; EndPtr = i )
  {
    v1 = *i;
    if ( *i != 32 && v1 != 9 )
      break;
    ++i;
  }
  if ( v1 != 40 )
  {
    sub_140003898(dword_140025C20, 0x3FFu);
    i = EndPtr;
  }
  do
  {
    do
    {
      EndPtr = ++i;
      v2 = *i;
    }
    while ( *i == 32 );
  }
  while ( v2 == 9 );
  if ( v2 == 34 )
  {
    v3 = sub_14000C958();
    v4 = EndPtr;
    v5 = v3;
    while ( 1 )
    {
      v6 = *v4;
      if ( *v4 != 32 && v6 != 9 )
        break;
      EndPtr = ++v4;
    }
    if ( v6 != 41 )
    {
      sub_140003898(dword_140025C20, 0x3FFu);
      v4 = EndPtr;
    }
    EndPtr = v4 + 1;
  }
  else
  {
    v5 = i;
LABEL_18:
    v7 = i;
    while ( 1 )
    {
      v8 = *i++;
      EndPtr = i;
      if ( !v8 )
      {
        sub_140003898(dword_140025C20, 0x3FFu);
        i = EndPtr;
      }
      if ( v8 == 41 )
        break;
      if ( v8 != 32 && v8 != 9 )
        goto LABEL_18;
    }
    *v7 = 0;
  }
  return v5;
}
// 140025C20: using guessed type int dword_140025C20;

//----- (000000014000CC64) ----------------------------------------------------
int sub_14000CC64()
{
  wchar_t *i; // rcx
  wint_t v1; // bx
  wchar_t *v2; // rax
  wchar_t **v3; // r8
  wchar_t v4; // r9
  wchar_t *v5; // rdx
  __int64 v6; // rdx
  char v7; // cl
  wchar_t *v8; // rdi
  __int64 v9; // rbx
  wchar_t *v10; // rax
  bool v11; // al
  wchar_t *v12; // rax

  for ( i = EndPtr; ; EndPtr = i )
  {
    v1 = *i;
    if ( *i != 32 && v1 != 9 )
      break;
    ++i;
  }
  if ( v1 < 0x80u && (byte_140011640[v1] & 2) != 0 )
  {
    v2 = off_1400150A0;
    v3 = &off_1400150A0;
    if ( off_1400150A0 )
    {
      while ( 1 )
      {
        v4 = *v2;
        v5 = i;
        if ( !*v2 )
          break;
        do
        {
          if ( *v5 != v4 )
            break;
          ++v2;
          ++v5;
          v4 = *v2;
        }
        while ( *v2 );
        if ( !*v2 )
          break;
        v3 += 2;
        v2 = *v3;
        if ( !*v3 )
          goto LABEL_13;
      }
      i = v5;
      EndPtr = v5;
    }
  }
  else
  {
    v3 = (wchar_t **)&unk_1400151F0;
  }
  if ( *v3 )
  {
    v7 = *((_BYTE *)v3 + 8);
    v6 = 0i64;
    return sub_14000CAA0(v7, v6);
  }
LABEL_13:
  switch ( v1 )
  {
    case '-':
      v6 = 0i64;
      EndPtr = i + 1;
      if ( byte_1400370B3 == 22 )
        v7 = 14;
      else
        v7 = 19;
      return sub_14000CAA0(v7, v6);
    case '"':
      v6 = (__int64)sub_14000C958();
      v7 = 23;
      return sub_14000CAA0(v7, v6);
    case '[':
      v6 = (__int64)sub_14000C9E0();
      v7 = 24;
      return sub_14000CAA0(v7, v6);
  }
  if ( iswdigit(v1) )
  {
    v8 = EndPtr;
    *errno() = 0;
    v9 = wcstol(EndPtr, &EndPtr, 0);
    if ( *errno() == 34 )
    {
      *EndPtr = 0;
      sub_140003898(dword_140025C20, 0x436u, v8);
    }
    if ( towupper(*EndPtr) == 76 )
      ++EndPtr;
    v6 = v9;
    goto LABEL_41;
  }
  if ( !v1 )
  {
    v6 = 0i64;
    byte_1400370B2 = 1;
    v7 = 0;
    return sub_14000CAA0(v7, v6);
  }
  if ( !wcsnicmp(EndPtr, L"DEFINED", 7ui64) )
  {
    EndPtr += 7;
    v10 = sub_14000CB34();
    v11 = sub_14000D180(v10);
LABEL_40:
    v6 = v11;
LABEL_41:
    v7 = 22;
    return sub_14000CAA0(v7, v6);
  }
  if ( !wcsnicmp(EndPtr, L"EXISTS", 6ui64) )
  {
    EndPtr += 6;
LABEL_39:
    v12 = sub_14000CB34();
    v11 = waccess(v12, 0) == 0;
    goto LABEL_40;
  }
  if ( !wcsnicmp(EndPtr, L"EXIST", 5ui64) )
  {
    EndPtr += 5;
    goto LABEL_39;
  }
  return sub_140003898(dword_140025C20, 0x3FFu);
}
// 140011640: using guessed type _BYTE byte_140011640[128];
// 1400150A0: using guessed type wchar_t *off_1400150A0;
// 140025C20: using guessed type int dword_140025C20;
// 1400370B2: using guessed type char byte_1400370B2;
// 1400370B3: using guessed type char byte_1400370B3;

//----- (000000014000CEE0) ----------------------------------------------------
_OWORD *sub_14000CEE0()
{
  _OWORD *v0; // rax
  _OWORD *v1; // rcx
  _OWORD *result; // rax

  v0 = (_OWORD *)qword_1400370D0;
  if ( qword_1400370D0 < (unsigned __int64)byte_14003B0E0 )
  {
    sub_140003898(dword_140025C20, 0x3FFu);
    v0 = (_OWORD *)qword_1400370D0;
  }
  v1 = (_OWORD *)qword_1400370C8;
  if ( qword_1400370C8 > (unsigned __int64)&unk_14003B0D0 )
  {
    sub_140003898(dword_140025C20, 0x412u);
    v0 = (_OWORD *)qword_1400370D0;
    v1 = (_OWORD *)qword_1400370C8;
  }
  *v1 = *v0;
  result = v0 - 1;
  qword_1400370C8 = (__int64)(v1 + 1);
  qword_1400370D0 = (__int64)result;
  return result;
}
// 140025C20: using guessed type int dword_140025C20;
// 1400370C8: using guessed type __int64 qword_1400370C8;
// 1400370D0: using guessed type __int64 qword_1400370D0;
// 14003B0E0: using guessed type unsigned __int8 byte_14003B0E0[8176];

//----- (000000014000CF64) ----------------------------------------------------
char sub_14000CF64()
{
  wchar_t **v0; // rdi
  char v1; // bl
  bool v2; // zf
  __int64 v3; // rdx
  unsigned __int8 *v4; // rdx
  __int64 v5; // rax
  unsigned __int8 v6; // cl
  int v7; // eax
  char (__fastcall *v8)(unsigned __int8); // rcx
  unsigned __int8 (__fastcall *v9)(_QWORD); // rax

  byte_1400370B1 = 3;
  v0 = (wchar_t **)&unk_1400370E0;
  qword_1400370D0 = (__int64)byte_14003B0E0;
  v1 = 0;
  qword_1400370C8 = (__int64)&unk_1400370E0;
  byte_1400370B2 = 0;
  byte_1400370B3 = 25;
  sub_14000CAA0(25, 0i64);
  v2 = byte_1400370B2 == 0;
  v3 = qword_1400370D0;
  *(_OWORD *)qword_1400370D0 = xmmword_1400370B8;
  if ( v2 )
  {
    do
    {
      sub_14000CC64();
      v4 = (unsigned __int8 *)qword_1400370D0;
      if ( (_BYTE)xmmword_1400370B8 != 25 )
      {
        v5 = (unsigned __int8)xmmword_1400370B8;
        while ( 1 )
        {
          v6 = byte_140011CE0[v5];
          if ( v6 > byte_140011CE0[*v4] )
            break;
          if ( !v6 )
          {
            while ( *v4 != 25 )
            {
              sub_14000CEE0();
              v4 = (unsigned __int8 *)qword_1400370D0;
            }
            if ( v4 < byte_14003B0E0 )
            {
              sub_140003898(dword_140025C20, 0x3FFu);
              v4 = (unsigned __int8 *)qword_1400370D0;
            }
            v3 = (__int64)(v4 - 16);
            goto LABEL_15;
          }
          sub_14000CEE0();
          v5 = (unsigned __int8)xmmword_1400370B8;
          v4 = (unsigned __int8 *)qword_1400370D0;
        }
      }
      if ( v4 == (unsigned __int8 *)&unk_14003D0D0 )
      {
        sub_140003898(dword_140025C20, 0x412u);
        v3 = qword_1400370D0;
      }
      else
      {
        v3 = (__int64)(v4 + 16);
        *(_OWORD *)v3 = xmmword_1400370B8;
LABEL_15:
        qword_1400370D0 = v3;
      }
    }
    while ( !byte_1400370B2 );
  }
  if ( (unsigned __int8 *)v3 != &byte_14003B0E0[-16] )
  {
    sub_140003898(dword_140025C20, 0x3FFu);
    v3 = qword_1400370D0;
  }
  while ( (unsigned __int64)v0 < qword_1400370C8 )
  {
    if ( *(_BYTE *)v0 <= 0x15u )
    {
      v8 = sub_14000C914;
      v9 = (unsigned __int8 (__fastcall *)(_QWORD))sub_14000C658;
      if ( *(_BYTE *)v0 > 0x12u )
        v9 = (unsigned __int8 (__fastcall *)(_QWORD))sub_14000C914;
      LOBYTE(v8) = *(_BYTE *)v0;
      if ( !v9(v8) )
        sub_140003898(dword_140025C20, 0x438u);
      v3 = qword_1400370D0;
    }
    else
    {
      v3 += 16i64;
      v2 = *(_BYTE *)v0 == 24;
      qword_1400370D0 = v3;
      if ( v2 )
      {
        v7 = sub_140005114(v0[1], 0, 1, 0, 0i64);
        v3 = qword_1400370D0;
        *(_QWORD *)(qword_1400370D0 + 8) = v7;
        *(_BYTE *)v3 = 22;
      }
      else
      {
        *(_OWORD *)v3 = *(_OWORD *)v0;
      }
    }
    v0 += 2;
  }
  if ( (unsigned __int8 *)v3 == byte_14003B0E0 && *(_BYTE *)v3 == 22 )
    return *(_QWORD *)(v3 + 8) != 0i64;
  sub_140003898(dword_140025C20, 0x3FFu);
  return v1;
}
// 140011CE0: using guessed type _BYTE byte_140011CE0[32];
// 140025C20: using guessed type int dword_140025C20;
// 1400370B1: using guessed type char byte_1400370B1;
// 1400370B2: using guessed type char byte_1400370B2;
// 1400370B3: using guessed type char byte_1400370B3;
// 1400370B8: using guessed type __int128 xmmword_1400370B8;
// 1400370C8: using guessed type __int64 qword_1400370C8;
// 1400370D0: using guessed type __int64 qword_1400370D0;
// 14003B0E0: using guessed type unsigned __int8 byte_14003B0E0[8176];

//----- (000000014000D180) ----------------------------------------------------
bool __fastcall sub_14000D180(wchar_t *a1)
{
  __int16 *v1; // rbx
  wchar_t *Context; // [rsp+38h] [rbp+10h] BYREF

  Context = 0i64;
  v1 = (__int16 *)wcstok_s(a1, L" \t", &Context);
  if ( wcstok_s(0i64, L" \t", &Context) )
    sub_140003898(dword_140025C20, 0x409u, v1);
  if ( !v1 )
    sub_140003898(dword_140025C20, 0x417u);
  return sub_14000918C(v1) != 0i64;
}
// 140025C20: using guessed type int dword_140025C20;

//----- (000000014000D1F8) ----------------------------------------------------
char __fastcall sub_14000D1F8(wchar_t *a1, char a2)
{
  if ( !*a1 )
    sub_140003898(dword_140025C20, 0x3FAu);
  if ( a2 != 4 )
  {
    if ( a2 == 5 )
      return !sub_14000D180(a1);
    if ( a2 != 6 )
    {
      if ( a2 != 7 )
      {
        EndPtr = a1;
        return sub_14000CF64();
      }
      return !sub_14000D180(a1);
    }
  }
  return sub_14000D180(a1);
}
// 140025C20: using guessed type int dword_140025C20;

//----- (000000014000D274) ----------------------------------------------------
_QWORD *__fastcall sub_14000D274(wchar_t *Block, rsize_t a2, wchar_t *a3, char *a4, LPWIN32_FIND_DATAW lpFindFileData)
{
  _QWORD *v5; // r15
  char *v6; // rdi
  const wchar_t *v7; // rsi
  const wchar_t *v9; // r14
  char *v10; // rbp
  const wchar_t *v11; // rcx
  wchar_t v12; // ax
  _WORD *v13; // rbx
  char *v14; // rdi
  const wchar_t *v15; // r14
  __int64 v16; // r15
  int v17; // ebp
  const wchar_t *v18; // rsi
  signed __int64 v19; // r14
  const wchar_t *v20; // rsi
  wchar_t *v21; // rax
  bool v22; // zf
  const wchar_t *v23; // rdi
  const wchar_t *i; // r14
  __int64 v25; // rdi
  rsize_t v26; // rax
  const wchar_t *v27; // r8
  wchar_t *v28; // rbx
  wchar_t *v29; // rax
  __int64 v30; // rax
  const wchar_t *v31; // rbx
  int v32; // edi
  wchar_t *v33; // rbx
  wchar_t v34; // ax
  unsigned __int64 v35; // rax
  __int64 v36; // rcx
  rsize_t v37; // rdi
  int v38; // esi
  __int64 v39; // rbp
  __int64 v40; // rsi
  _QWORD *v41; // rax
  WCHAR *v42; // rbx
  char v43; // si
  __int64 v44; // rax
  HANDLE FirstFileW; // rdi
  FILETIME v47; // rcx
  _QWORD *v48; // [rsp+20h] [rbp-58h]
  const wchar_t *v49; // [rsp+28h] [rbp-50h]
  const wchar_t *v50; // [rsp+30h] [rbp-48h]

  v5 = qword_140025C00;
  v6 = a4;
  v48 = qword_140025C00;
  v7 = a3;
  if ( !qword_140025C00 )
    return 0i64;
  while ( 1 )
  {
    v9 = (const wchar_t *)v5[2];
    v49 = v9;
    v10 = (char *)wcsrchr(v9, 0x2Eu);
    if ( sub_14000FB60(v10, v6) )
      goto LABEL_98;
    v11 = v9 + 1;
    *Block = 0;
    v12 = v9[1];
    v13 = v9 + 1;
    v50 = v9 + 1;
    if ( !v12 )
      goto LABEL_38;
    do
    {
      if ( v12 == 123 )
        break;
      if ( v12 == 94 )
      {
        ++v13;
      }
      else if ( v12 == 34 )
      {
        do
          ++v13;
        while ( *v13 != 34 );
      }
      v12 = *++v13;
    }
    while ( *v13 );
    if ( !*v13 )
      goto LABEL_38;
    v14 = (char *)v13;
    do
    {
      if ( *(_WORD *)v14 == 125 )
        break;
      if ( *(_WORD *)v14 == 94 )
        v14 += 2;
      v14 += 2;
    }
    while ( *(_WORD *)v14 );
    v15 = v7;
    v16 = (v14 - (char *)v13 - 2) >> 1;
    v17 = v16;
    if ( *v7 == 34 )
      v15 = v7 + 1;
    v18 = v13 + 1;
    if ( (_DWORD)v16 )
    {
      v19 = (char *)v15 - (char *)v18;
      while ( 1 )
      {
        if ( *v18 == 92 || *v18 == 47 )
        {
          if ( *(const wchar_t *)((char *)v18 + v19) != 92 && *(const wchar_t *)((char *)v18 + v19) != 47 )
          {
            v17 = -1;
            break;
          }
        }
        else if ( wcsnicmp(v18, (const wchar_t *)((char *)v18 + v19), 1ui64) )
        {
          goto LABEL_96;
        }
        ++v18;
        if ( !--v17 )
          goto LABEL_30;
      }
    }
    if ( v17 == -1 )
    {
LABEL_96:
      v5 = v48;
LABEL_97:
      v6 = a4;
      v7 = a3;
      goto LABEL_98;
    }
LABEL_30:
    v10 = (char *)v13;
    v20 = &a3[(int)v16 + 1];
    v21 = wcschr(v20, 0x5Cu);
    if ( !v21 )
    {
      v21 = wcschr(v20, 0x2Fu);
      if ( !v21 )
        break;
    }
    if ( v21 != v20 || *((_WORD *)v14 - 1) == 92 )
      goto LABEL_96;
    v22 = *((_WORD *)v14 - 1) == 47;
    v6 = a4;
    v7 = a3;
    v5 = v48;
    if ( !v22 )
      goto LABEL_37;
LABEL_98:
    v5 = (_QWORD *)*v5;
    v48 = v5;
    if ( !v5 )
      return 0i64;
  }
  v7 = a3;
  v5 = v48;
  v6 = a4;
LABEL_37:
  v11 = v50;
  v9 = v49;
LABEL_38:
  if ( *v9 == 123 )
  {
    v23 = v11;
    for ( i = v11; *v23; ++v23 )
    {
      if ( *v23 == 125 )
        break;
      if ( *v23 == 94 )
        ++v23;
    }
    v25 = v23 - v11;
    if ( (_DWORD)v25 )
    {
      wcsncpy_s(Block, a2, v11, (int)v25);
      v9 = &i[(int)v25 + 1];
      if ( *(v9 - 2) != 92 )
      {
        Block[(int)v25] = 92;
        LODWORD(v25) = v25 + 1;
      }
    }
    else
    {
      if ( *v7 == 34 )
      {
        v26 = 3i64;
        v27 = L"\".\\";
      }
      else
      {
        v26 = 2i64;
        v27 = L".\\";
      }
      LODWORD(v25) = v26;
      wcsncpy_s(Block, a2, v27, v26);
      v9 = i + 1;
    }
    v28 = wcsrchr(v7, 0x5Cu);
    v29 = wcsrchr(v7, 0x2Fu);
    if ( v29 > v28 )
      v28 = v29;
    if ( v28 )
    {
      wcscpy_s(&Block[(int)v25], a2 - (int)v25, v28 + 1);
      v30 = a4 - (char *)v28 - 2;
    }
    else
    {
      v31 = v7;
      if ( *v7 == 34 )
        v31 = v7 + 1;
      wcscpy_s(&Block[(int)v25], a2 - (int)v25, v31);
      v30 = a4 - (char *)v31;
    }
    v32 = (v30 >> 1) + v25;
  }
  else
  {
    if ( *v13 )
    {
      v33 = wcsrchr(v7, 0x2Eu);
      v34 = *v33;
      if ( *v33 == 58 )
        goto LABEL_67;
      do
      {
        if ( v34 == 92 )
          break;
        if ( v34 == 47 )
          break;
        if ( v33 <= v7 )
          break;
        v34 = *--v33;
      }
      while ( *v33 != 58 );
      v35 = *v33;
      LOWORD(v35) = v35 - 47;
      if ( (unsigned __int16)v35 <= 0x2Du )
      {
        v36 = 0x200000000801i64;
        if ( _bittest64(&v36, v35) )
LABEL_67:
          ++v33;
      }
    }
    else
    {
      v33 = (wchar_t *)v7;
    }
    v37 = (int)((v6 - (char *)v33) >> 1);
    v38 = 0;
    if ( v33 != a3 && *a3 == 34 )
    {
      *Block = 34;
      v38 = 1;
    }
    if ( (int)v37 >= (int)a2 - v38 )
      sub_140003898(0, 0x434u);
    wcsncpy_s(&Block[v38], a2 - v38, v33, v37);
    v32 = v38 + v37;
  }
  v39 = (v10 - (char *)v9) >> 1;
  if ( (int)v39 >= (int)a2 - v32 )
    sub_140003898(0, 0x434u);
  wcsncpy_s(&Block[v32], a2 - v32, v9, (int)v39);
  if ( *Block == 34 )
  {
    v40 = v32 + (__int64)(int)v39;
    if ( Block[v40 - 1] != 34 )
    {
      if ( (int)a2 - (int)v39 - v32 <= 1 )
        sub_140003898(0, 0x434u);
      Block[v40] = 34;
      LODWORD(v39) = v39 + 1;
    }
  }
  Block[v32 + (__int64)(int)v39] = 0;
  v41 = sub_14000DDE0(Block);
  if ( v41 )
  {
    v47 = (FILETIME)v41[3];
    lpFindFileData->ftCreationTime = v47;
    lpFindFileData->ftLastWriteTime = v47;
    return v5;
  }
  v42 = Block;
  v43 = 0;
  if ( *Block == 34 )
  {
    v44 = -1i64;
    do
      ++v44;
    while ( Block[v44] );
    if ( Block[v44 - 1] == 34 )
    {
      v42 = sub_14000FCAC((char *)Block);
      v43 = 1;
    }
  }
  FirstFileW = FindFirstFileW(v42, lpFindFileData);
  if ( FirstFileW == (HANDLE)-1i64 || !sub_140005F9C(v42, (__int64)lpFindFileData) )
  {
    if ( v43 )
      free(v42);
    goto LABEL_97;
  }
  FindClose(FirstFileW);
  if ( (lpFindFileData->dwFileAttributes & 0x10) == 0
    && !lpFindFileData->ftLastWriteTime.dwLowDateTime
    && !lpFindFileData->ftLastWriteTime.dwHighDateTime )
  {
    lpFindFileData->ftLastWriteTime.dwLowDateTime = -1;
    lpFindFileData->ftLastWriteTime.dwHighDateTime = -1;
  }
  return v5;
}
// 140013070: using guessed type wchar_t asc_140013070[4];

//----- (000000014000D80C) ----------------------------------------------------
void sub_14000D80C()
{
  void *v0; // rbx
  _QWORD *v1; // r15
  const wchar_t *v2; // r12
  size_t v3; // rbp
  _QWORD *v4; // rsi
  const wchar_t *v5; // rdi
  wchar_t v6; // ax
  _QWORD *v7; // rcx
  _QWORD *v8; // rdi
  const wchar_t *i; // r14
  __int64 **v10; // r14
  __int64 v11; // r14
  void **v12; // rcx
  void **v13; // rax
  void *v14; // rdi
  __int64 *v15; // [rsp+70h] [rbp+8h] BYREF

  v0 = qword_140025C00;
  v1 = (_QWORD *)qword_140025C18;
  v15 = 0i64;
  qword_140025C00 = 0i64;
  while ( v1 )
  {
    v2 = (const wchar_t *)v1[1];
    v3 = -1i64;
    do
      ++v3;
    while ( v2[v3] );
    v4 = v0;
    if ( v0 )
    {
      do
      {
        v5 = (const wchar_t *)v4[2];
        v6 = *v5;
        if ( *v5 == 123 )
        {
          do
          {
            if ( v6 == 94 )
              ++v5;
            v6 = *++v5;
          }
          while ( *v5 != 125 );
          ++v5;
        }
        if ( !wcsnicmp(v2, v5, v3) && (v5[v3] == 46 || v5[v3] == 123) )
        {
          v7 = (_QWORD *)v4[1];
          v8 = v4;
          if ( v7 )
            *v7 = *v4;
          else
            v0 = (void *)*v4;
          if ( *v4 )
            *(_QWORD *)(*v4 + 8i64) = v4[1];
          v4 = (_QWORD *)*v4;
          *v8 = 0i64;
          for ( i = (const wchar_t *)qword_140025C00; i; i = *(const wchar_t **)i )
          {
            if ( !wcsicmp(*((const wchar_t **)i + 2), (const wchar_t *)v8[2]) )
            {
              free((void *)v8[2]);
              while ( 1 )
              {
                v11 = v8[3];
                if ( !v11 )
                  break;
                v8[3] = *(_QWORD *)v11;
                free(*(void **)(v11 + 8));
                *(_QWORD *)v11 = qword_14003D0E0;
                qword_14003D0E0 = v11;
              }
              free(v8);
              goto LABEL_36;
            }
          }
          v10 = (__int64 **)v8[3];
          while ( v10 )
          {
            byte_14003D110 = *((_BYTE *)v8 + 40);
            if ( byte_14003D110 )
              qword_14003D118 = v8[2];
            sub_14000DFD0(v10[1], &v15, 0i64, 0i64, 0, 0, 0);
            v10 = (__int64 **)*v10;
            byte_14003D110 = 0;
          }
          v12 = &qword_140025C00;
          v8[4] = v15;
          v13 = (void **)qword_140025C00;
          v15 = 0i64;
          while ( v13 )
          {
            v12 = v13;
            v13 = (void **)*v13;
          }
          *v12 = v8;
        }
        else
        {
          v4 = (_QWORD *)*v4;
        }
LABEL_36:
        ;
      }
      while ( v4 );
    }
    v1 = (_QWORD *)*v1;
  }
  if ( v0 )
  {
    v14 = v0;
    do
    {
      if ( (byte_1400157EC & 1) != 0 )
        sub_140003898(0, 0xFA5u, *((_QWORD *)v0 + 2));
      free(*((void **)v0 + 2));
      sub_140002F98(*((_QWORD **)v0 + 3));
      sub_140002F98(*((_QWORD **)v0 + 4));
      v0 = *(void **)v0;
      free(v14);
      v14 = v0;
    }
    while ( v0 );
  }
}
// 1400157EC: using guessed type char byte_1400157EC;
// 140025C18: using guessed type __int64 qword_140025C18;
// 14003D0E0: using guessed type __int64 qword_14003D0E0;
// 14003D110: using guessed type char byte_14003D110;
// 14003D118: using guessed type __int64 qword_14003D118;

//----- (000000014000DA54) ----------------------------------------------------
_QWORD *__fastcall sub_14000DA54(
        __int64 a1,
        wchar_t *a2,
        __int64 a3,
        unsigned __int64 a4,
        __int64 ***a5,
        __int64 ***a6,
        _DWORD *a7,
        FILETIME *a8,
        wchar_t **a9)
{
  const wchar_t *v12; // rcx
  char *v13; // rax
  FILETIME ftLastWriteTime; // rax
  __int64 **v16; // rbx
  char v17; // dl
  int v18; // r14d
  unsigned __int64 v19; // rcx
  _QWORD *v20; // rbx
  _QWORD *v21; // rdx
  __int64 **i; // rcx
  unsigned __int64 v23; // [rsp+30h] [rbp-D0h] BYREF
  __int64 *v24; // [rsp+38h] [rbp-C8h] BYREF
  _DWORD *v25; // [rsp+40h] [rbp-C0h]
  FILETIME *v26; // [rsp+48h] [rbp-B8h]
  _QWORD *v27; // [rsp+50h] [rbp-B0h]
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+60h] [rbp-A0h] BYREF

  v26 = a8;
  v12 = *(const wchar_t **)(a1 + 8);
  v25 = a7;
  v13 = (char *)wcsrchr(v12, 0x2Eu);
  if ( !v13 )
    return 0i64;
  v27 = sub_14000D274(a2, 0x101ui64, *(wchar_t **)(a1 + 8), v13, &FindFileData);
  if ( !v27 )
    return 0i64;
  if ( (FindFileData.dwFileAttributes & 0x10) == 0 || (ftLastWriteTime = FindFileData.ftCreationTime) == 0i64 )
    ftLastWriteTime = FindFileData.ftLastWriteTime;
  *a9 = a2;
  v16 = *a6;
  v23 = (unsigned __int64)ftLastWriteTime;
  if ( v16 )
  {
    do
    {
      if ( !wcsicmp((const wchar_t *)v16[1], a2) )
        break;
      v16 = (__int64 **)*v16;
    }
    while ( v16 );
    if ( v16 )
      *(_BYTE *)(a1 + 16) &= ~1u;
  }
  v17 = *(_BYTE *)(a1 + 16);
  v24 = 0i64;
  v18 = sub_14000209C(a2, v17, &v23, 0i64, (struct _FILETIME)&v24);
  if ( v24 )
  {
    v18 += sub_1400030D8(v24);
    sub_140003278(&v24);
  }
  v19 = v23;
  *v25 += v18;
  if ( (*(_BYTE *)(a1 + 16) & 0x10) != 0 || a4 < v19 || byte_140025C3A && a4 == v19 )
  {
    if ( !v16 )
    {
      v20 = sub_14000DC58();
      v20[1] = sub_14000DCC4(a2);
      v21 = a5;
      for ( i = *a5; i; i = (__int64 **)*i )
        v21 = i;
      *v21 = v20;
      v19 = v23;
      if ( !*a6 )
        *a6 = *a5;
    }
    if ( (*(_BYTE *)(a1 + 16) & 0x11) == 1 )
    {
      sub_1400039C0(3u, a2, *(_QWORD *)(a1 + 8));
      v19 = v23;
    }
  }
  if ( *(_QWORD *)v26 > v19 )
    v19 = (unsigned __int64)*v26;
  *v26 = (FILETIME)v19;
  return v27;
}
// 140025C3A: using guessed type char byte_140025C3A;

//----- (000000014000DC58) ----------------------------------------------------
_QWORD *sub_14000DC58()
{
  _QWORD *v0; // rcx
  __int64 v1; // rbx
  _QWORD *v2; // rax
  _QWORD *result; // rax

  v0 = (_QWORD *)qword_14003D0E0;
  if ( qword_14003D0E0 )
  {
    qword_14003D0E0 = *(_QWORD *)qword_14003D0E0;
  }
  else
  {
    v1 = qword_14003D0F0;
    if ( (unsigned __int64)qword_14003D0F0 >= 0x10 )
    {
      v2 = (_QWORD *)qword_14003D0E8;
    }
    else
    {
      v1 = 0x8000i64;
      v2 = sub_140009214(0x8000ui64);
    }
    v0 = v2;
    qword_14003D0E8 = (__int64)(v2 + 2);
    qword_14003D0F0 = v1 - 16;
  }
  *v0 = 0i64;
  result = v0;
  v0[1] = 0i64;
  return result;
}
// 14003D0E0: using guessed type __int64 qword_14003D0E0;
// 14003D0E8: using guessed type __int64 qword_14003D0E8;
// 14003D0F0: using guessed type __int64 qword_14003D0F0;

//----- (000000014000DCC4) ----------------------------------------------------
void *__fastcall sub_14000DCC4(_WORD *Src)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // rdi
  void *v4; // rbx

  v2 = -1i64;
  do
    ++v2;
  while ( Src[v2] );
  v3 = v2 + 1;
  v4 = sub_140009214(saturated_mul(v3, 2ui64));
  memcpy(v4, Src, 2 * v3);
  return v4;
}

//----- (000000014000DD24) ----------------------------------------------------
wchar_t *__fastcall sub_14000DD24(_WORD *a1, const wchar_t *a2)
{
  __int64 v2; // rax
  __int64 v4; // r8
  __int64 v5; // rdi
  wchar_t *v6; // rbx

  v2 = -1i64;
  v4 = -1i64;
  do
    ++v4;
  while ( a1[v4] );
  do
    ++v2;
  while ( a2[v2] );
  v5 = v4 + v2;
  v6 = (wchar_t *)sub_14000FD90(a1, v4 + v2 + 1);
  wcscat_s(v6, v5 + 1, a2);
  return v6;
}

//----- (000000014000DD88) ----------------------------------------------------
__int64 __fastcall sub_14000DD88(wint_t *a1)
{
  wint_t v1; // ax
  char v2; // bl
  wint_t *v3; // rdi
  char v4; // al

  v1 = *a1;
  v2 = 0;
  v3 = a1;
  while ( v1 )
  {
    if ( v1 == 47 )
      v4 = 92;
    else
      v4 = towupper(v1);
    v2 += v4;
    v1 = *++v3;
  }
  return v2 & 0x7F;
}

//----- (000000014000DDE0) ----------------------------------------------------
_QWORD *__fastcall sub_14000DDE0(wchar_t *Source)
{
  char v2; // bp
  int v3; // eax
  __int64 v4; // rdx
  _QWORD *result; // rax
  __int64 v6; // rsi
  unsigned __int64 v7; // rsi
  wchar_t *v8; // rdi
  int v9; // eax
  __int64 v10; // rdx
  _QWORD *v11; // rsi
  int v12; // eax
  __int64 v13; // rdx
  wchar_t *v14; // rsi
  __int64 v15; // rdi
  unsigned __int64 v16; // rdi
  int v17; // eax
  __int64 v18; // rdx
  _QWORD *v19; // rbx

  v2 = 0;
  if ( !*Source )
    return 0i64;
  v3 = sub_14000DD88(Source);
  result = sub_14000FAA4(Source, v4, v3);
  if ( result )
    return result;
  if ( !wcsncmp(Source, L".\\", 2ui64) || !wcsncmp(Source, L"./", 2ui64) )
  {
    v8 = Source + 2;
  }
  else
  {
    v6 = -1i64;
    do
      ++v6;
    while ( Source[v6] );
    v7 = v6 + 3;
    v8 = (wchar_t *)sub_140009214(saturated_mul(v7, 2ui64));
    wcscpy_s(v8, v7, L".\\");
    wcscat_s(v8, v7, Source);
    v2 = 1;
  }
  v9 = sub_14000DD88(v8);
  v11 = sub_14000FAA4(v8, v10, v9);
  if ( v11 )
  {
    if ( v2 )
      free(v8);
    return v11;
  }
  if ( v8 != Source + 2 )
    v8[1] = 47;
  v12 = sub_14000DD88(v8);
  v11 = sub_14000FAA4(v8, v13, v12);
  if ( v2 )
    free(v8);
  if ( v11 )
    return v11;
  if ( *Source == 34 )
  {
    v14 = sub_14000FCAC((char *)Source);
  }
  else
  {
    v15 = -1i64;
    do
      ++v15;
    while ( Source[v15] );
    v16 = v15 + 3;
    v14 = (wchar_t *)sub_140009214(saturated_mul(v16, 2ui64));
    wcscpy_s(v14, v16, L"\"");
    wcscat_s(v14, v16, Source);
    wcscat_s(v14, v16, L"\"");
  }
  v17 = sub_14000DD88(v14);
  v19 = sub_14000FAA4(v14, v18, v17);
  free(v14);
  return v19;
}
// 14000DE1B: variable 'v4' is possibly undefined
// 14000DEBE: variable 'v10' is possibly undefined
// 14000DF01: variable 'v13' is possibly undefined
// 14000DF98: variable 'v18' is possibly undefined

//----- (000000014000DFD0) ----------------------------------------------------
char __fastcall sub_14000DFD0(_WORD *a1, __int64 **a2, _QWORD *a3, __int64 a4, int a5, int a6, char a7)
{
  _WORD *v7; // rdi
  _QWORD *v8; // rbx
  __int64 v9; // rsi
  __int64 *v10; // rax
  __int16 v11; // ax
  unsigned __int16 *v12; // rdi
  char v13; // cl
  _WORD *v14; // rax
  wchar_t *v15; // rbx
  __int16 *i; // rbx
  wint_t v18; // ax
  wint_t v19; // ax
  __int64 v20; // rdx
  size_t v21; // rdx
  unsigned __int64 v22; // rcx
  signed __int64 v23; // rcx
  void *v24; // rsp
  void *v25; // rsp
  __int64 v26; // r8
  __int16 v27; // ax
  char v28; // cl
  __int64 *v29; // rbx
  char *v30; // rsi
  unsigned __int16 *v31; // rcx
  int v32; // eax
  int v33; // edx
  int v34; // ecx
  _QWORD *v35; // rax
  void *v36; // rax
  char v37; // al
  __int64 **v38; // rcx
  void *v39; // rax
  unsigned __int16 *v40; // rax
  int v41; // ecx
  int v42; // edx
  int v43; // eax
  int v44; // ecx
  wchar_t Buffer[4]; // [rsp+40h] [rbp+0h] BYREF
  int v47; // [rsp+48h] [rbp+8h]
  _QWORD *v48; // [rsp+50h] [rbp+10h]
  __int64 **v49; // [rsp+58h] [rbp+18h]
  char *v50; // [rsp+60h] [rbp+20h]
  __int64 v51[2]; // [rsp+68h] [rbp+28h] BYREF
  __int16 v52[4]; // [rsp+78h] [rbp+38h] BYREF
  __int16 v53[264]; // [rsp+80h] [rbp+40h] BYREF

  v50 = (char *)a4;
  v7 = a1;
  v49 = a2;
  LOBYTE(a1) = 0;
  v8 = a3;
  v47 = (int)a1;
  v9 = (__int64)a2;
  v48 = a3;
  if ( a2 )
  {
    if ( a3 )
    {
      *(_QWORD *)Buffer = *a3;
    }
    else
    {
      v10 = *a2;
      *(_QWORD *)Buffer = v10;
      if ( v10 )
      {
        while ( *v10 )
        {
          v10 = **(__int64 ***)Buffer;
          *(_QWORD *)Buffer = **(_QWORD **)Buffer;
        }
      }
    }
  }
  else
  {
    *(_QWORD *)Buffer = 0i64;
  }
  if ( !*v7 )
    goto LABEL_135;
  while ( 1 )
  {
    v11 = *v7;
    if ( !*v7 )
      break;
    do
    {
      if ( v11 == 36 )
        break;
      if ( v11 == 34 )
        LOBYTE(a1) = (_BYTE)a1 == 0;
      if ( !(_BYTE)a1 && v11 == 94 )
        LODWORD(a1) = *++v7 == 34;
      v11 = *++v7;
    }
    while ( *v7 );
    v47 = (int)a1;
    if ( !*v7 )
      break;
    v12 = v7 + 1;
    if ( !*v12 )
    {
      if ( (a7 & 4) != 0 )
        goto LABEL_129;
      sub_140003898(dword_140025C24, 0x3EAu);
      LOBYTE(a1) = v47;
    }
    if ( !(_BYTE)a1 && *v12 == 94 )
    {
      if ( *++v12 >= 0x80u )
        v13 = iswspace(*v12) == 0;
      else
        v13 = byte_140011640[*v12] & 1;
      if ( !v13 && (a7 & 4) != 0 )
      {
LABEL_129:
        if ( v48 )
          *v48 = *(_QWORD *)Buffer;
        return 0;
      }
      sub_140003898(dword_140025C24, 0x3E9u, *v12);
    }
    if ( *v12 != 36 )
    {
      if ( *v12 == 40 )
      {
        for ( i = v53; ; ++i )
        {
          v18 = *++v12;
          if ( !*v12 )
            break;
          if ( v18 == 41 )
            goto LABEL_66;
          if ( v18 == 58 )
            break;
          if ( v18 == 94 && !(*++v12 >= 0x80u ? iswspace(*v12) == 0 : byte_140011640[*v12] & 1) )
            sub_140003898(dword_140025C24, 0x3E9u, *v12, 0i64);
          *i = *v12;
        }
        v19 = *v12;
        if ( *v12 != 41 )
        {
          do
          {
            if ( v19 == 94 )
              ++v12;
            if ( !*v12 )
              break;
            v19 = *++v12;
          }
          while ( *v12 != 41 );
          if ( *v12 != 41 )
            sub_140003898(dword_140025C24, 0x3E8u);
        }
LABEL_66:
        *i = 0;
        if ( (__int64)(((char *)i - (char *)v53) & 0xFFFFFFFFFFFFFFFEui64) > 514 )
          sub_140003898(dword_140025C24, 0x434u);
        if ( wcschr(L"*@<?", v53[0]) )
        {
          if ( !byte_14003D110 || (byte_1400157EC & 0x40) != 0 )
            goto LABEL_127;
          v20 = -1i64;
          do
            ++v20;
          while ( v53[v20] );
          v21 = v20 + 4;
          v22 = 2 * v21 + 15;
          if ( v22 <= 2 * v21 )
            v22 = 0xFFFFFFFFFFFFFF0i64;
          v23 = v22 & 0xFFFFFFFFFFFFFFF0ui64;
          v24 = alloca(v23);
          v25 = alloca(v23);
          swprintf(Buffer, v21, L"$(%s)", v53);
          sub_140003898(0, 0x44Cu, Buffer, qword_14003D118);
        }
      }
      else
      {
        if ( wcschr(L"*@<?", *v12) )
        {
          if ( !byte_14003D110 )
            goto LABEL_127;
          if ( (byte_1400157EC & 0x40) != 0 )
            goto LABEL_127;
          v27 = *v12;
          if ( *v12 == 60 )
            goto LABEL_127;
          v52[2] = 0;
          v52[0] = 36;
          v52[1] = v27;
          sub_140003898(0, 0x44Cu, v52, qword_14003D118);
        }
        if ( *v12 >= 0x80u )
          v28 = iswspace(*v12) == 0;
        else
          v28 = byte_140011640[*v12] & 1;
        if ( !v28 )
        {
          if ( (a7 & 4) != 0 )
            goto LABEL_129;
          sub_140003898(dword_140025C24, 0x3EAu, v26, 0i64);
        }
        v53[0] = *v12;
        v53[1] = 0;
      }
      if ( v9 )
      {
        v29 = sub_14000DC58();
      }
      else
      {
        v51[0] = 0i64;
        v51[1] = (__int64)sub_14000DCC4(L" ");
        v29 = v51;
      }
      v30 = sub_14000918C(v53);
      if ( v30 )
      {
        if ( !v50 )
          goto LABEL_102;
        v31 = (unsigned __int16 *)v50;
        do
        {
          v32 = *(unsigned __int16 *)((char *)v31 + (char *)v53 - v50);
          v33 = *v31 - v32;
          if ( v33 )
            break;
          ++v31;
        }
        while ( v32 );
        if ( v33 )
        {
LABEL_102:
          v37 = v30[24];
          if ( (v37 & 1) != 0 )
          {
            if ( (a7 & 4) != 0 )
            {
              if ( v48 )
                *v48 = *(_QWORD *)Buffer;
              return 0;
            }
            sub_140003898(dword_140025C24, 0x42Eu, v53);
          }
          else
          {
            if ( (v37 & 0x10) != 0 )
              goto LABEL_106;
            v29[1] = *(_QWORD *)(*((_QWORD *)v30 + 2) + 8i64);
          }
        }
        else
        {
          v34 = a5;
          v35 = (_QWORD *)*((_QWORD *)v30 + 2);
          if ( a5 == a6 )
          {
LABEL_100:
            if ( !v35 )
              goto LABEL_106;
            v36 = (void *)v35[1];
          }
          else
          {
            while ( v35 )
            {
              v35 = (_QWORD *)*v35;
              if ( --v34 == a6 )
                goto LABEL_100;
            }
LABEL_106:
            v36 = sub_14000DCC4(word_140011DEC);
          }
          v29[1] = (__int64)v36;
        }
      }
      v38 = v49;
      if ( v49 )
      {
        if ( !v30 || (v30[24] & 0x10) != 0 )
        {
          v39 = sub_14000DCC4(word_140011DEC);
          v38 = v49;
          v29[1] = (__int64)v39;
        }
        *v29 = 0i64;
        if ( *(_QWORD *)Buffer )
          **(_QWORD **)Buffer = v29;
        else
          *v38 = v29;
        *(_QWORD *)Buffer = v29;
      }
      if ( v30 && wcschr((const wchar_t *)v29[1], 0x24u) )
      {
        v30[24] |= 1u;
        v40 = (unsigned __int16 *)v50;
        if ( !v50 )
          goto LABEL_124;
        do
        {
          v41 = *(unsigned __int16 *)((char *)v40 + (char *)v53 - v50);
          v42 = *v40 - v41;
          if ( v42 )
            break;
          ++v40;
        }
        while ( v41 );
        if ( v42 )
        {
          v43 = a5;
          v44 = a5;
        }
        else
        {
LABEL_124:
          v44 = a6;
          v43 = a5;
        }
        sub_14000DFD0(v29[1], (_DWORD)v49, (unsigned int)Buffer, (unsigned int)v53, v43 + 1, v44, a7);
        v30[24] &= ~1u;
        v9 = (__int64)v49;
      }
      else
      {
        v9 = (__int64)v49;
      }
      goto LABEL_127;
    }
    v14 = v12 + 1;
    if ( v12[1] == 94 )
    {
      ++v12;
      goto LABEL_127;
    }
    if ( *v14 == 40 )
    {
      v15 = v12 + 2;
      if ( v12[2] == 94 )
        goto LABEL_36;
      if ( *v15 == 64 )
      {
        v15 = v12 + 3;
        if ( v12[3] == 94 )
          goto LABEL_39;
        if ( *v15 == 41 )
          goto LABEL_36;
        if ( wcschr(L"DFBR", *v15) )
        {
          v15 = v12 + 4;
          if ( v12[4] == 94 )
          {
LABEL_39:
            sub_140003898(dword_140025C24, 0x3E9u, v15[1]);
            goto LABEL_127;
          }
          if ( *v15 == 41 )
LABEL_36:
            v12 = v15;
        }
      }
      else
      {
        ++v12;
        if ( *v14 != 94 )
          v12 = v14 + 1;
      }
    }
LABEL_127:
    v7 = v12 + 1;
    if ( !*v7 )
      break;
    LODWORD(a1) = v47;
  }
  v8 = v48;
LABEL_135:
  if ( v8 )
    *v8 = *(_QWORD *)Buffer;
  return 1;
}
// 14000E453: variable 'v26' is possibly undefined
// 140011640: using guessed type _BYTE byte_140011640[128];
// 140011DEC: using guessed type _WORD word_140011DEC[2];
// 1400157EC: using guessed type char byte_1400157EC;
// 140025C24: using guessed type int dword_140025C24;
// 14003D110: using guessed type char byte_14003D110;
// 14003D118: using guessed type __int64 qword_14003D118;

//----- (000000014000E6A4) ----------------------------------------------------
wchar_t *__fastcall sub_14000E6A4(const wchar_t *a1)
{
  wchar_t *v1; // rdi
  __int64 *v2; // rbx
  wchar_t *v3; // rax
  __int64 *v4; // rax
  __int64 v5; // rcx
  __int64 *v7; // [rsp+50h] [rbp+8h] BYREF

  v7 = 0i64;
  v1 = (wchar_t *)a1;
  if ( wcschr(a1, 0x24u) )
  {
    sub_14000DFD0(v1, &v7, 0i64, 0i64, 0, 0, 0);
    v2 = v7;
    v3 = (wchar_t *)sub_14000E740(v1, 255, &v7);
    v7 = v2;
    v1 = v3;
    v4 = v2;
    if ( v2 )
    {
      v5 = qword_14003D0E0;
      do
      {
        v2 = (__int64 *)*v2;
        *v4 = v5;
        v5 = (__int64)v4;
        v7 = v2;
        v4 = v2;
      }
      while ( v2 );
      qword_14003D0E0 = v5;
    }
  }
  return v1;
}
// 14003D0E0: using guessed type __int64 qword_14003D0E0;

//----- (000000014000E740) ----------------------------------------------------
void *__fastcall sub_14000E740(const wchar_t *a1, char a2, _QWORD *a3)
{
  const wchar_t *v3; // rdi
  char *v4; // rsi
  wchar_t v5; // ax
  char *v6; // rbx
  char v7; // si
  wchar_t v8; // ax
  _WORD *v9; // rbx
  unsigned int v10; // eax
  int v11; // ecx
  _QWORD **v12; // rdi
  __int64 v13; // rdx
  _QWORD *v14; // rcx
  wchar_t *v15; // rbx
  __int64 v16; // rbx
  void *v17; // rax
  void *v18; // rdi
  char v20; // [rsp+40h] [rbp-C0h]
  char *v22; // [rsp+48h] [rbp-B8h] BYREF
  char *v23; // [rsp+50h] [rbp-B0h] BYREF
  char *v24; // [rsp+58h] [rbp-A8h] BYREF
  int v25; // [rsp+60h] [rbp-A0h]
  unsigned __int64 v26; // [rsp+68h] [rbp-98h] BYREF
  const wchar_t *v27; // [rsp+70h] [rbp-90h] BYREF
  _QWORD *v28; // [rsp+78h] [rbp-88h]
  char Src[2048]; // [rsp+80h] [rbp-80h] BYREF
  __int64 v30; // [rsp+880h] [rbp+780h] BYREF

  v27 = a1;
  v3 = a1;
  v20 = 0;
  LOBYTE(a1) = 0;
  v28 = a3;
  v23 = (char *)&v30;
  v4 = Src;
  v5 = *v3;
  v6 = Src;
  v25 = (int)a1;
  v26 = 1024i64;
  v24 = Src;
  v22 = Src;
  if ( !v5 )
    goto LABEL_50;
  v7 = 0;
  while ( 1 )
  {
    if ( v5 )
    {
      do
      {
        if ( v5 == 36 )
          break;
        if ( v6 == v23 )
        {
          sub_14000EB78((const void **)&v24, &v22, &v23, &v26, Src);
          v6 = v22;
          LODWORD(a1) = v25;
        }
        v8 = *v3;
        if ( *v3 == 34 )
        {
          LOBYTE(a1) = (_BYTE)a1 == 0;
          v25 = (int)a1;
        }
        if ( !(_BYTE)a1 && v8 == 94 )
        {
          *(_WORD *)v6 = 94;
          v6 += 2;
          v22 = v6;
          if ( v6 == v23 )
          {
            sub_14000EB78((const void **)&v24, &v22, &v23, &v26, Src);
            v6 = v22;
            LOBYTE(a1) = v25;
          }
          ++v3;
          LODWORD(a1) = (unsigned __int8)a1;
          v8 = *v3;
          if ( *v3 == 34 )
            LODWORD(a1) = 1;
          v25 = (int)a1;
        }
        ++v3;
        *(_WORD *)v6 = v8;
        v6 += 2;
        v27 = v3;
        v22 = v6;
        v5 = *v3;
      }
      while ( *v3 );
      v7 = v20;
    }
    if ( v6 == v23 )
    {
      sub_14000EB78((const void **)&v24, &v22, &v23, &v26, Src);
      v6 = v22;
    }
    if ( !*v3 )
      break;
    v9 = v3 + 2;
    if ( v3[1] == 40 && wcschr(L"*@<?", v3[2]) )
    {
      sub_14000EC20((const void **)&v24, &v27, &v22, &v23, &v26, 3, Src);
      goto LABEL_45;
    }
    if ( v3[1] == 36 )
    {
      if ( *v9 == 94 || a2 != 1 )
        goto LABEL_35;
      if ( *v9 == 64 )
      {
        sub_14000EC20((const void **)&v24, &v27, &v22, &v23, &v26, 2, Src);
        goto LABEL_45;
      }
      if ( *v9 == 40 )
        v9 = v3 + 3;
      v10 = (unsigned __int16)v9[1];
      LOWORD(v10) = v10 - 66;
      if ( (unsigned __int16)v10 <= 0x10u && (v11 = 65557, _bittest(&v11, v10)) && v9[2] == 41 )
        sub_14000EC20((const void **)&v24, &v27, &v22, &v23, &v26, 4, Src);
      else
LABEL_35:
        sub_14000EC20((const void **)&v24, &v27, &v22, &v23, &v26, 5, Src);
    }
    else if ( wcschr(L"*@<?", v3[1]) )
    {
      sub_14000EC20((const void **)&v24, &v27, &v22, &v23, &v26, 1, Src);
    }
    else
    {
      v12 = (_QWORD **)v28;
      if ( !*v28 )
        sub_140003898(dword_140025C24, 0x410u);
      if ( wcschr((const wchar_t *)(*v12)[1], 0x24u) )
      {
        v14 = *v12;
        LOBYTE(v13) = a2;
        *v12 = (_QWORD *)**v12;
        v7 = 1;
        v15 = (wchar_t *)sub_14000E740(v14[1], v13, v12);
        v20 = 1;
      }
      else
      {
        v15 = (wchar_t *)(*v12)[1];
        *v12 = (_QWORD *)**v12;
      }
      sub_14000F188((const void **)&v24, &v27, &v22, &v23, v15, &v26, Src);
      if ( v7 )
      {
        free(v15);
        v7 = 0;
        v20 = 0;
      }
    }
LABEL_45:
    v3 = v27;
    v6 = v22;
    v5 = *v27;
    if ( !*v27 )
      break;
    LODWORD(a1) = v25;
  }
  if ( v6 == v23 )
  {
    sub_14000EB78((const void **)&v24, &v22, &v23, &v26, Src);
    v6 = v22;
  }
  v4 = v24;
LABEL_50:
  *(_WORD *)v6 = 0;
  v16 = (v6 + 2 - v4) >> 1;
  v17 = sub_140009214(saturated_mul(v16, 2ui64));
  v18 = v17;
  if ( !v17 )
  {
    sub_140003898(dword_140025C24, 0x419u);
    __debugbreak();
  }
  memcpy(v17, v4, 2 * v16);
  return v18;
}
// 14000EA48: variable 'v13' is possibly undefined
// 140025C24: using guessed type int dword_140025C24;

//----- (000000014000EB78) ----------------------------------------------------
char *__fastcall sub_14000EB78(const void **a1, char **a2, char **a3, unsigned __int64 *a4, const void *a5)
{
  void *v9; // rbx
  unsigned __int64 v10; // rbx
  char *v11; // rax
  unsigned __int64 v12; // rcx
  char *v13; // rdx
  char *result; // rax

  if ( *a1 == a5 )
  {
    v9 = sub_140009214(saturated_mul(*a4, 2ui64));
    memcpy(v9, *a1, 2 * *a4);
    *a1 = v9;
  }
  v10 = *a4 + 1024;
  v11 = (char *)sub_14000FD90((void *)*a1, v10);
  v12 = *a4;
  *a1 = v11;
  *a4 = v10;
  v13 = &v11[2 * v12];
  result = &v11[2 * v10];
  *a2 = v13;
  *a3 = result;
  return result;
}

//----- (000000014000EC20) ----------------------------------------------------
void __fastcall sub_14000EC20(
        const void **a1,
        const wchar_t **a2,
        char **a3,
        char **a4,
        unsigned __int64 *a5,
        int a6,
        const void *a7)
{
  char **v7; // r12
  const wchar_t **v8; // r15
  char *v9; // rbx
  char *v10; // r14
  unsigned int v11; // esi
  char v12; // di
  void *v13; // r13
  char *v14; // rax
  const wchar_t *v15; // rdx
  wchar_t *i; // rdi
  wchar_t v17; // bx
  unsigned int v18; // ecx
  char *v19; // r12
  char *v20; // r15
  wchar_t *v21; // r14
  __int64 v22; // rdi
  unsigned __int64 v23; // rdi
  __int64 v24; // rdi
  unsigned __int64 v25; // rdi
  char v26; // [rsp+40h] [rbp-38h]
  char v27; // [rsp+41h] [rbp-37h]
  char *v28; // [rsp+48h] [rbp-30h] BYREF
  char *v29; // [rsp+50h] [rbp-28h] BYREF
  char *v30; // [rsp+58h] [rbp-20h] BYREF
  rsize_t v31; // [rsp+60h] [rbp-18h]
  unsigned __int64 v32[2]; // [rsp+68h] [rbp-10h] BYREF

  v7 = a3;
  v8 = a2;
  v26 = 0;
  v9 = 0i64;
  v27 = 0;
  v10 = 0i64;
  v31 = 0i64;
  v11 = 1;
  v12 = 0;
  v13 = 0i64;
  if ( a6 == 1 )
    goto LABEL_12;
  if ( a6 != 2 )
  {
    if ( a6 != 3 )
    {
      if ( a6 != 4 )
      {
        if ( a6 == 5 )
        {
          if ( *a3 == *a4 )
            sub_14000EB78(a1, a3, a4, a5, a7);
          v14 = *v7;
          *(_WORD *)v14 = 36;
          *v8 += 2;
          *v7 = v14 + 2;
        }
        return;
      }
      v11 = 4;
      v26 = 1;
      goto LABEL_10;
    }
    v11 = 2;
    v26 = 1;
LABEL_12:
    v15 = *a2;
    if ( v15[v11] == 42 )
    {
      if ( v15[v11 + 1] == 42 )
      {
        v9 = (char *)qword_140026450;
        ++v11;
LABEL_22:
        v12 = 1;
        goto LABEL_23;
      }
      v9 = (char *)qword_140026478;
      v27 = 1;
    }
    else
    {
      if ( v15[v11] != 60 )
      {
        if ( v15[v11] != 63 )
        {
          if ( v15[v11] == 64 )
            v9 = (char *)qword_140026470;
          goto LABEL_23;
        }
        v9 = (char *)qword_140026468;
        goto LABEL_22;
      }
      v9 = (char *)qword_140026460;
    }
LABEL_23:
    ++v11;
    goto LABEL_24;
  }
LABEL_10:
  v9 = (char *)qword_140026458;
LABEL_24:
  if ( !v9 )
  {
    for ( i = (wchar_t *)*v8; *i && *i != 32 && *i != 9; ++i )
      ;
    v17 = *i;
    v18 = dword_140025C24;
    *i = 0;
    sub_140003898(v18, 0xFA6u, *v8);
    *i = v17;
    v12 = 0;
    v9 = (char *)sub_14000DCC4(word_140011DEC);
    v10 = v9;
  }
  if ( v12 )
  {
    v32[0] = 1024i64;
    v19 = v9;
    v30 = (char *)sub_140009214(0x800ui64);
    v28 = v30;
    v9 = v30;
    v20 = v30 + 2048;
    v29 = v30 + 2048;
    if ( v19 )
    {
      do
      {
        v21 = (wchar_t *)*((_QWORD *)v19 + 1);
        if ( v26 )
        {
          v22 = -1i64;
          do
            ++v22;
          while ( v21[v22] );
          v23 = v22 + 1;
          if ( v23 > v31 )
          {
            if ( v13 )
              free(v13);
            v31 = v23;
            v13 = sub_140009214(saturated_mul(v23, 2ui64));
          }
          v21 = sub_14000EFF8((*a2)[v11], (wchar_t *)v13, v31, v21);
        }
        while ( *v21 )
        {
          if ( v9 == v20 )
          {
            sub_14000EB78((const void **)&v30, &v28, &v29, v32, 0i64);
            v9 = v28;
            v20 = v29;
          }
          *(_WORD *)v9 = *v21;
          v9 += 2;
          v28 = v9;
          ++v21;
        }
        if ( v9 == v20 )
        {
          sub_14000EB78((const void **)&v30, &v28, &v29, v32, 0i64);
          v9 = v28;
          v20 = v29;
        }
        *(_WORD *)v9 = 0;
        if ( *(_QWORD *)v19 )
        {
          *(_WORD *)v9 = 32;
          v9 += 2;
          v28 = v9;
          if ( v9 == v20 )
          {
            sub_14000EB78((const void **)&v30, &v28, &v29, v32, 0i64);
            v9 = v28;
            v20 = v29;
          }
          *(_WORD *)v9 = 0;
        }
        v19 = *(char **)v19;
      }
      while ( v19 );
      v9 = v30;
    }
    v8 = a2;
    v10 = v9;
    v7 = a3;
  }
  else
  {
    v24 = -1i64;
    do
      ++v24;
    while ( *(_WORD *)&v9[2 * v24] );
    v25 = v24 + 1;
    if ( v25 == 1 )
      v25 = 2i64;
    v13 = sub_140009214(saturated_mul(v25, 2ui64));
    if ( v27 )
      v9 = (char *)sub_14000EFF8(82, (wchar_t *)v13, v25, (const wchar_t *)v9);
    if ( v26 )
      v9 = (char *)sub_14000EFF8((*v8)[v11], (wchar_t *)v13, v25, (const wchar_t *)v9);
  }
  sub_14000F188(a1, v8, v7, a4, (wchar_t *)v9, a5, a7);
  if ( v10 )
    free(v10);
  if ( v13 )
    free(v13);
}
// 140011DEC: using guessed type _WORD word_140011DEC[2];
// 140025C24: using guessed type int dword_140025C24;
// 140026450: using guessed type __int64 qword_140026450;
// 140026458: using guessed type __int64 qword_140026458;
// 140026468: using guessed type __int64 qword_140026468;
// 140026478: using guessed type __int64 qword_140026478;

//----- (000000014000EFF8) ----------------------------------------------------
wchar_t *__fastcall sub_14000EFF8(__int16 a1, wchar_t *a2, rsize_t a3, const wchar_t *a4)
{
  wchar_t *v5; // rbx
  wchar_t *v8; // rsi
  wchar_t *v9; // rdi
  bool v10; // r15
  __int64 v11; // rax
  wchar_t *i; // rax
  wchar_t *v13; // rax

  v5 = a2;
  v8 = 0i64;
  v9 = 0i64;
  if ( wcscpy_s(a2, a3, a4) )
    sub_140003898(dword_140025C24, 0x410u);
  v10 = *v5 == 34;
  v11 = -1i64;
  do
    ++v11;
  while ( v5[v11] );
  for ( i = &v5[v11 - 1]; i >= v5; --i )
  {
    if ( *i == 92 || *i == 47 )
    {
      v9 = i;
      break;
    }
    if ( *i == 46 && !v8 )
      v8 = i;
  }
  if ( a1 == 66 )
  {
    if ( v8 )
      *v8 = 0;
LABEL_39:
    if ( v9 )
    {
      v5 = v9 + 1;
    }
    else if ( v5[1] == 58 )
    {
      v5 += 2;
    }
    goto LABEL_30;
  }
  if ( a1 != 68 )
  {
    if ( a1 != 70 )
    {
      if ( a1 == 82 && v8 )
        *v8 = 0;
      goto LABEL_30;
    }
    goto LABEL_39;
  }
  if ( v9 )
  {
    if ( v5[1] == 58 && v9 == v5 + 2 )
      ++v9;
    *v9 = 0;
  }
  else if ( v5[1] == 58 )
  {
    v5[2] = 0;
  }
  else if ( wcscpy_s(v5, a3, L".") )
  {
    sub_140003898(dword_140025C24, 0x410u);
  }
LABEL_30:
  if ( v10 )
  {
    if ( *v5 != 34 && v5 > a2 )
      *--v5 = 34;
    v13 = wcschr(v5, 0);
    if ( *(v13 - 1) != 34 )
      *(_DWORD *)v13 = 34;
  }
  return v5;
}
// 140025C24: using guessed type int dword_140025C24;

//----- (000000014000F188) ----------------------------------------------------
wchar_t *__fastcall sub_14000F188(
        const void **a1,
        const wchar_t **a2,
        char **a3,
        char **a4,
        wchar_t *String1,
        unsigned __int64 *a6,
        const void *a7)
{
  wchar_t *v11; // rax
  const wchar_t *v12; // r8
  wchar_t *v13; // rcx
  wchar_t i; // dx
  wchar_t *result; // rax
  wchar_t *v16; // rdi
  const void *v17; // rbp
  char *v18; // rcx
  __int16 v19; // ax
  wchar_t *v20; // [rsp+78h] [rbp+10h] BYREF

  if ( *++*a2 == 94 )
    ++*a2;
  v11 = wcschr(*a2, 0x3Au);
  v12 = *a2;
  v20 = v11;
  v13 = (wchar_t *)v12;
  for ( i = *v12; i && i != 41; i = *v13 )
  {
    if ( i == 94 )
      ++v13;
    ++v13;
  }
  if ( *v12 == 40 && v11 && v11 < v13 )
  {
    sub_14000F300(a1, &v20, a3, a4, String1, a6, a7);
    result = v20;
    *a2 = v20;
  }
  else
  {
    v16 = String1;
    if ( *String1 )
    {
      v17 = a7;
      do
      {
        if ( *a3 == *a4 )
          sub_14000EB78(a1, a3, a4, a6, v17);
        v18 = *a3;
        v19 = *v16++;
        *(_WORD *)v18 = v19;
        *a3 = v18 + 2;
      }
      while ( *v16 );
    }
    if ( **a2 == 36 )
      ++*a2;
    result = (wchar_t *)*a2;
    if ( **a2 == 40 )
    {
      do
        result = (wchar_t *)++*a2;
      while ( **a2 != 41 );
    }
    else if ( *result == 42 && result[1] == 42 )
    {
      ++*a2;
    }
    ++*a2;
  }
  return result;
}

//----- (000000014000F300) ----------------------------------------------------
void __fastcall sub_14000F300(
        const void **a1,
        wchar_t **a2,
        char **a3,
        char **a4,
        wchar_t *String1,
        unsigned __int64 *a6,
        const void *a7)
{
  wchar_t *i; // rbx
  wchar_t v10; // ax
  wchar_t *v11; // rsi
  wchar_t *v12; // rax
  wchar_t *v13; // rdi
  wchar_t *v14; // r13
  wchar_t *v15; // rcx
  size_t v16; // rbp
  wchar_t *v17; // r12
  wchar_t *j; // rcx
  wchar_t *v19; // rbx
  wchar_t k; // ax
  __int16 *v21; // rdi
  char *v22; // rcx
  __int16 v23; // ax
  char *v24; // rcx
  wchar_t v25; // ax
  wchar_t *v27; // [rsp+78h] [rbp+10h]

  for ( i = ++*a2; ; ++i )
  {
    v10 = *i;
    if ( !*i )
      break;
    if ( v10 == 61 )
      goto LABEL_8;
    if ( v10 == 94 )
      ++i;
  }
  sub_140003898(dword_140025C20, 0x3EBu);
LABEL_8:
  if ( i == *a2 )
    sub_140003898(dword_140025C20, 0x3EDu);
  v11 = i;
  if ( *i )
  {
    while ( *v11 != 41 )
    {
      if ( *v11 == 94 )
        ++v11;
      if ( !*++v11 )
        goto LABEL_15;
    }
  }
  else
  {
LABEL_15:
    if ( *v11 != 41 )
      sub_140003898(dword_140025C20, 0x3E8u);
  }
  v12 = (wchar_t *)sub_140009214(saturated_mul(i - *a2 + 1, 2ui64));
  v13 = *a2;
  v14 = v12;
  v27 = v12;
  v15 = v12;
  while ( *v13 != 61 )
  {
    if ( *v13 == 94 )
      ++v13;
    *v15++ = *v13++;
  }
  *v15 = 0;
  v16 = -1i64;
  do
    ++v16;
  while ( v12[v16] );
  v17 = (wchar_t *)sub_140009214(saturated_mul(v11 - i, 2ui64));
  for ( j = v17; *++v13 != 41; ++j )
  {
    if ( *v13 == 94 )
      ++v13;
    *j = *v13;
  }
  v19 = String1;
  *a2 = v11 + 1;
  *j = 0;
  for ( k = *String1; *v19; k = *v19 )
  {
    if ( k == *v14 && !wcsncmp(v19, v14, v16) )
    {
      v21 = (__int16 *)v17;
      if ( *v17 )
      {
        do
        {
          if ( *a3 == *a4 )
            sub_14000EB78(a1, a3, a4, a6, a7);
          v22 = *a3;
          v23 = *v21++;
          *(_WORD *)v22 = v23;
          *a3 = v22 + 2;
        }
        while ( *v21 );
        v14 = v27;
      }
      v19 += v16;
    }
    else
    {
      if ( *a3 == *a4 )
        sub_14000EB78(a1, a3, a4, a6, a7);
      v24 = *a3;
      v25 = *v19++;
      *(_WORD *)v24 = v25;
      *a3 = v24 + 2;
    }
  }
  free(v14);
  free(v17);
}
// 140025C20: using guessed type int dword_140025C20;

//----- (000000014000F570) ----------------------------------------------------
void *__fastcall sub_14000F570(const wchar_t *a1, const wchar_t *a2)
{
  wchar_t Drive[8]; // [rsp+50h] [rbp-438h] BYREF
  wchar_t Dir[256]; // [rsp+60h] [rbp-428h] BYREF
  wchar_t Buffer[264]; // [rsp+260h] [rbp-228h] BYREF

  wsplitpath_s(a1, Drive, 3ui64, Dir, 0x100ui64, 0i64, 0i64, 0i64, 0i64);
  wmakepath_s(Buffer, 0x104ui64, Drive, Dir, a2, 0i64);
  return sub_14000DCC4(Buffer);
}

//----- (000000014000F614) ----------------------------------------------------
char __fastcall sub_14000F614(_WORD *a1)
{
  char v1; // bl
  __int16 v2; // ax
  _WORD *v3; // rax
  _WORD *v4; // rdx
  _WORD *v5; // rax
  __int16 v6; // cx
  const wchar_t *v7; // rdi
  wchar_t *v8; // rax

  v1 = 0;
  if ( *a1 == 123 )
  {
    v2 = *++a1;
    if ( *a1 )
    {
      do
      {
        if ( v2 == 125 )
          break;
        if ( v2 == 94 )
          ++a1;
        v2 = *++a1;
      }
      while ( *a1 );
      if ( *a1 )
        ++a1;
    }
  }
  if ( *a1 == 46 )
  {
    v3 = a1;
    do
    {
      if ( *v3 == 123 )
        break;
      if ( *v3 == 94 )
        ++v3;
      ++v3;
    }
    while ( *v3 );
    v4 = a1;
    while ( a1 < v3 && *a1 != 92 && *a1 != 47 )
      ++a1;
    if ( !*v3 || a1 != v3 )
    {
      v8 = wcspbrk(v4 + 1, L"./\\");
      if ( !v8 || *v8 != 46 )
        return v1;
      v7 = v8 + 1;
      goto LABEL_33;
    }
    v5 = v3 + 1;
    v6 = *v5;
    if ( *v5 )
    {
      do
      {
        if ( v6 == 125 )
          break;
        if ( v6 == 94 )
          ++v5;
        v6 = *++v5;
      }
      while ( *v5 );
      if ( *v5 && v5[1] == 46 )
      {
        v7 = v5 + 2;
LABEL_33:
        if ( !wcschr(v7, 0x2Fu) && !wcschr(v7, 0x5Cu) )
        {
          if ( wcschr(v7, 0x2Eu) )
            sub_140003898(dword_140025C24, 0x444u);
          else
            return 1;
        }
      }
    }
  }
  return v1;
}
// 140025C24: using guessed type int dword_140025C24;

//----- (000000014000F778) ----------------------------------------------------
char __fastcall sub_14000F778(char *a1, __int64 a2, unsigned __int16 *a3, const wchar_t *a4)
{
  unsigned __int16 v4; // ax
  char *v5; // r12
  unsigned __int16 *v7; // rdi
  char *i; // rbx
  int v9; // eax
  unsigned __int16 *v10; // rdx
  char v11; // r15
  char v12; // r14
  char v13; // bp
  char v14; // si
  __int64 v15; // rcx
  __int64 v16; // rax
  __int64 v17; // rax
  signed __int64 v18; // rcx
  const wchar_t *v20; // rax
  wchar_t Drive[264]; // [rsp+50h] [rbp-258h] BYREF

  v4 = *a3;
  v5 = &a1[2 * a2];
  v7 = a3;
  for ( i = a1; *v7; v4 = *v7 )
  {
    if ( i >= v5 )
      return 1;
    if ( v4 == 37 )
    {
      v9 = *++v7;
      if ( !*v7 )
      {
        --v7;
        goto LABEL_46;
      }
      switch ( v9 )
      {
        case '%':
          *(_WORD *)i = 37;
          goto LABEL_11;
        case 's':
          if ( a4 )
          {
            v20 = a4;
            do
            {
              if ( !*v20 )
                break;
              if ( i >= v5 )
                break;
              *(_WORD *)i = *v20;
              i += 2;
              ++v20;
            }
            while ( v20 );
          }
          goto LABEL_46;
        case '|':
          v10 = v7 - 1;
          Drive[0] = 0;
          v11 = 0;
          v12 = 0;
          v13 = 0;
          v14 = 0;
          do
          {
            switch ( *++v7 )
            {
              case 0u:
                --v7;
LABEL_52:
                while ( v10 <= v7 && i < v5 )
                {
                  *(_WORD *)i = *v10;
                  i += 2;
                  ++v10;
                }
                goto LABEL_46;
              case 0x46u:
                if ( *(v7 - 1) == 124 )
                {
                  v14 = 1;
                  v13 = 1;
                  v12 = 1;
                  v11 = 1;
                }
                break;
              case 0x64u:
                v14 = 1;
                break;
              case 0x65u:
                v11 = 1;
                break;
              case 0x66u:
                v12 = 1;
                break;
              case 0x70u:
                v13 = 1;
                break;
              default:
                goto LABEL_52;
            }
          }
          while ( *v7 != 70 );
          if ( !a4 )
            sub_140003898(0, 0x449u);
          if ( v14 )
            wsplitpath_s(a4, Drive, 0x104ui64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64);
          if ( v13 )
          {
            v15 = -1i64;
            do
              ++v15;
            while ( Drive[v15] );
            wsplitpath_s(a4, 0i64, 0i64, &Drive[v15], 260 - v15, 0i64, 0i64, 0i64, 0i64);
          }
          if ( v12 )
          {
            v16 = -1i64;
            do
              ++v16;
            while ( Drive[v16] );
            wsplitpath_s(a4, 0i64, 0i64, 0i64, 0i64, &Drive[v16], 260 - v16, 0i64, 0i64);
          }
          if ( v11 )
          {
            v17 = -1i64;
            do
              ++v17;
            while ( Drive[v17] );
            wsplitpath_s(a4, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, &Drive[v17], 260 - v17);
          }
          if ( Drive[0] )
          {
            v18 = (char *)Drive - i;
            do
            {
              if ( i >= v5 )
                break;
              *(_WORD *)i = *(_WORD *)&i[v18];
              i += 2;
            }
            while ( *(_WORD *)&i[v18] );
          }
          goto LABEL_46;
      }
      *(_WORD *)i = 37;
      i += 2;
      if ( i == v5 )
        return 1;
      v4 = *v7;
    }
    *(_WORD *)i = v4;
LABEL_11:
    i += 2;
LABEL_46:
    ++v7;
  }
  if ( i >= v5 )
    return 1;
  *(_WORD *)i = 0;
  return 0;
}
// 14000F778: using guessed type wchar_t Drive[264];

//----- (000000014000FAA4) ----------------------------------------------------
_QWORD *__fastcall sub_14000FAA4(wint_t *a1, __int64 a2, int a3)
{
  _QWORD *i; // rdi
  wint_t *v5; // rsi
  wint_t *v6; // r14
  wint_t v7; // bx
  bool v8; // zf

  for ( i = (_QWORD *)qword_140025800[a3]; i; i = (_QWORD *)*i )
  {
    v5 = a1;
    v6 = (wint_t *)i[1];
    if ( *a1 )
    {
      while ( 1 )
      {
        if ( !*v6 )
          goto LABEL_12;
        if ( *v5 != 92 && *v5 != 47 )
          break;
        if ( *v6 != 92 )
        {
          v8 = *v6 == 47;
LABEL_10:
          if ( !v8 )
            goto LABEL_12;
        }
        ++v5;
        ++v6;
        if ( !*v5 )
          goto LABEL_12;
      }
      v7 = towupper(*v6);
      v8 = towupper(*v5) == v7;
      goto LABEL_10;
    }
LABEL_12:
    if ( !*v5 && !*v6 )
      return i;
  }
  return 0i64;
}
// 140025800: using guessed type _QWORD qword_140025800[128];

//----- (000000014000FB60) ----------------------------------------------------
int __fastcall sub_14000FB60(char *a1, char *a2)
{
  __int64 v2; // r9
  char *v3; // r8
  __int64 v4; // rax
  unsigned __int64 v5; // rax
  __int64 v6; // rcx
  signed __int64 v7; // rcx
  void *v8; // rsp
  void *v9; // rsp
  unsigned __int64 v10; // rcx
  signed __int64 v11; // rcx
  void *v12; // rsp
  void *v13; // rsp
  wchar_t v14; // ax
  wchar_t *v15; // rcx
  signed __int64 v16; // r8
  wchar_t v17; // ax
  wchar_t *v18; // r8
  signed __int64 v19; // rdx
  wchar_t String1[4]; // [rsp+20h] [rbp+0h] BYREF

  v2 = -1i64;
  v3 = a1;
  v4 = -1i64;
  do
    ++v4;
  while ( *(_WORD *)&a1[2 * v4] );
  v5 = 2 * v4 + 2;
  v6 = v5 + 15;
  if ( v5 + 15 <= v5 )
    v6 = 0xFFFFFFFFFFFFFF0i64;
  v7 = v6 & 0xFFFFFFFFFFFFFFF0ui64;
  v8 = alloca(v7);
  v9 = alloca(v7);
  do
    ++v2;
  while ( *(_WORD *)&a2[2 * v2] );
  v10 = 2 * v2 + 17;
  if ( v10 <= 2 * v2 + 2 )
    v10 = 0xFFFFFFFFFFFFFF0i64;
  v11 = v10 & 0xFFFFFFFFFFFFFFF0ui64;
  v12 = alloca(v11);
  v13 = alloca(v11);
  if ( *(_WORD *)v3 == 34 )
    v3 += 2;
  v14 = *(_WORD *)v3;
  v15 = String1;
  if ( *(_WORD *)v3 )
  {
    v16 = v3 - (char *)String1;
    do
    {
      *v15++ = v14;
      v14 = *(wchar_t *)((char *)v15 + v16);
    }
    while ( v14 );
    if ( v15 != String1 && *(v15 - 1) == 34 )
      --v15;
  }
  *v15 = 0;
  if ( *(_WORD *)a2 == 34 )
    a2 += 2;
  v17 = *(_WORD *)a2;
  v18 = String1;
  if ( *(_WORD *)a2 )
  {
    v19 = a2 - (char *)String1;
    do
    {
      *v18++ = v17;
      v17 = *(wchar_t *)((char *)v18 + v19);
    }
    while ( v17 );
    if ( v18 != String1 && *(v18 - 1) == 34 )
      --v18;
  }
  *v18 = 0;
  return wcsicmp(String1, String1);
}

//----- (000000014000FCAC) ----------------------------------------------------
_WORD *__fastcall sub_14000FCAC(char *a1)
{
  __int64 v2; // rcx
  _WORD *result; // rax
  __int16 v4; // dx
  _WORD *v5; // rcx
  signed __int64 v6; // rbx

  v2 = -1i64;
  do
    ++v2;
  while ( *(_WORD *)&a1[2 * v2] );
  result = sub_140009214(saturated_mul(v2 + 1, 2ui64));
  if ( *(_WORD *)a1 == 34 )
    a1 += 2;
  v4 = *(_WORD *)a1;
  v5 = result;
  if ( *(_WORD *)a1 )
  {
    v6 = a1 - (char *)result;
    do
    {
      *v5++ = v4;
      v4 = *(_WORD *)((char *)v5 + v6);
    }
    while ( v4 );
  }
  if ( *(v5 - 1) == 34 )
    --v5;
  *v5 = 0;
  return result;
}

//----- (000000014000FD2C) ----------------------------------------------------
FILE *__fastcall sub_14000FD2C(__int64 a1, const wchar_t *a2)
{
  wchar_t *v4; // rax
  __int16 *v5; // r8
  __int16 v6; // ax
  __int16 *v7; // rcx

  if ( *(_WORD *)a1 == 34 )
  {
    v4 = wcsrchr((const wchar_t *)a1, 0x22u);
    v5 = (__int16 *)(a1 + 2);
    *v4 = 0;
    v6 = *(_WORD *)(a1 + 2);
    *(_WORD *)a1 = v6;
    while ( v6 )
    {
      v7 = v5++;
      v6 = *v5;
      *v7 = *v5;
    }
  }
  return wfsopen((const wchar_t *)a1, a2, 32);
}

//----- (000000014000FD90) ----------------------------------------------------
void *__fastcall sub_14000FD90(void *a1, unsigned __int64 a2)
{
  void *v2; // rbx
  void *v3; // rax

  v2 = 0i64;
  if ( a1 )
  {
    if ( a2 <= 0x7FFFFFFFFFFFFFF8i64 )
    {
      v3 = realloc(a1, 2 * a2);
      goto LABEL_6;
    }
LABEL_7:
    sub_140003898(dword_140025C24, 0x41Bu);
    return v2;
  }
  if ( a2 > 0x7FFFFFFFFFFFFFF8i64 )
    goto LABEL_7;
  v3 = malloc(2 * a2);
LABEL_6:
  v2 = v3;
  if ( !v3 )
    goto LABEL_7;
  return v2;
}
// 140025C24: using guessed type int dword_140025C24;

//----- (000000014000FDE8) ----------------------------------------------------
WCHAR *__fastcall sub_14000FDE8(wchar_t *a1)
{
  WCHAR *result; // rax
  const wchar_t *v3; // rbx
  _QWORD *v4; // rdi
  _QWORD *v5; // rbx
  void *v6; // rax
  WCHAR *v7; // rbp
  HANDLE hFindFile; // [rsp+20h] [rbp-278h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+30h] [rbp-268h] BYREF

  result = sub_140005CA8(a1, &FindFileData, &hFindFile);
  v3 = result;
  if ( result )
  {
    v4 = sub_14000DC58();
    v4[1] = sub_14000F570(a1, v3);
    while ( 1 )
    {
      v7 = sub_140005E30(&FindFileData, hFindFile);
      if ( !v7 )
        break;
      v5 = sub_14000DC58();
      v6 = sub_14000F570(a1, v7);
      *v5 = v4;
      v4 = v5;
      v5[1] = v6;
    }
    return (WCHAR *)v4;
  }
  return result;
}

//----- (0000000140010754) ----------------------------------------------------
void sub_140010754()
{
  InitializeSListHead(&stru_1400157C0);
}
// 1400157C0: using guessed type union _SLIST_HEADER stru_1400157C0;

//----- (000000014001078C) ----------------------------------------------------
void *sub_14001078C()
{
  return &unk_14003DE10;
}

//----- (0000000140010794) ----------------------------------------------------
void *sub_140010794()
{
  return &unk_14003DE08;
}

//----- (00000001400108E4) ----------------------------------------------------
__int64 __fastcall UserMathErrorFunction(struct _exception *a1)
{
  return 0i64;
}

//----- (0000000140010984) ----------------------------------------------------
__int64 sub_140010984()
{
  _QWORD *i; // rbx
  __int64 result; // rax

  for ( i = qword_140013438; i < qword_140013438; ++i )
  {
    if ( *i )
      result = ((__int64 (__fastcall *)(_QWORD))*i)(*i);
  }
  return result;
}
// 140013438: using guessed type _QWORD qword_140013438[2];

//----- (00000001400109D0) ----------------------------------------------------
void __fastcall sub_1400109D0()
{
  _QWORD *i; // rbx

  for ( i = &qword_140013448; i < &qword_140013448; ++i )
  {
    if ( *i )
      ((void (__fastcall *)(_QWORD))*i)(*i);
  }
}
// 140013448: using guessed type _QWORD qword_140013448;

//----- (0000000140010CA4) ----------------------------------------------------
__int64 sub_140010CA4()
{
  _QWORD *v0; // rax
  _QWORD *v1; // rax

  v0 = sub_14000BD80();
  *v0 |= 4ui64;
  v1 = sub_14000BDDC();
  *v1 |= 2ui64;
  return 0i64;
}

//----- (0000000140010CC8) ----------------------------------------------------
char sub_140010CC8()
{
  return 1;
}

// nfuncs=220 queued=152 decompiled=152 lumina nreq=0 worse=0 better=0
// ALL OK, 152 function(s) have been successfully decompiled
