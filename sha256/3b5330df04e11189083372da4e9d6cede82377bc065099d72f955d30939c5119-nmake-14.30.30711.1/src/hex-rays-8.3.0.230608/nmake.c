/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

wchar_t *sub_402C30();
_DWORD *sub_402C61();
void sub_402D8D();
void sub_402E4C();
char __thiscall sub_402F2B(wchar_t *String1);
void __fastcall sub_403006(wchar_t *Control, int *a2, _DWORD *a3);
_WORD *__thiscall sub_403191(_DWORD *this);
char sub_403257();
void sub_403371();
void sub_4034A8();
char __fastcall sub_4035E0(wchar_t *Name, wchar_t *Block, int a3);
char __fastcall sub_403707(wchar_t *Name, wchar_t *a2, int a3);
void __fastcall sub_40386A(wchar_t *Block, char a2, int a3);
void __thiscall sub_40392B(_DWORD **this);
_DWORD *__thiscall sub_403A45(_DWORD *this);
void *__thiscall sub_403A8F(void *this);
bool __fastcall sub_403A97(wint_t C);
wchar_t *__fastcall sub_403ABC(wchar_t *Str, wchar_t Ch);
__int16 __thiscall sub_403AC7(_DWORD *this, __int16 a2);
int __thiscall sub_403AF7(_DWORD *this, __int16 *a2);
int __thiscall sub_403B28(_DWORD *this, void *Src, int a3);
_DWORD *__thiscall sub_403B67(_DWORD *Src);
_DWORD *__thiscall sub_403BBC(_DWORD *this, _DWORD *a2, char *a3);
void *__thiscall sub_403C06(_DWORD *Src, int a2);
void __noreturn sub_403C75();
void *__fastcall sub_403C81(unsigned int a1);
void *__fastcall sub_403CB3(void *Block, unsigned int a2);
int sub_403CF3();
int __fastcall sub_403E51(wchar_t *a1, char a2, unsigned int *a3, int a4);
int __fastcall sub_403EBD(wchar_t *a1, char a2, unsigned int *a3, wchar_t *a4, _DWORD *a5);
int __fastcall sub_403F13(int a1, char a2, unsigned int *a3, char a4, wchar_t *a5, _DWORD *a6);
_DWORD *__fastcall sub_404D4A(int a1, int a2);
char __fastcall sub_4050C0(__int16 **a1, __int16 **a2);
int __thiscall sub_405208(_DWORD *this);
_DWORD *__fastcall sub_405232(char *Src, char a2);
int __fastcall sub_405279(_DWORD *a1, int a2, int a3, int a4);
unsigned int __thiscall sub_405325(_DWORD *this);
int __thiscall sub_40547A(_DWORD *this);
void __thiscall sub_405498(_DWORD *this);
wchar_t *__fastcall sub_4054C7(wchar_t **a1, int *a2);
void *__fastcall sub_4055CF(char *a1, int a2, void **a3);
char *__fastcall sub_40563D(wchar_t *Str, int *a2, void **a3);
void __fastcall sub_4056C9(wchar_t *a1, int *a2, void **a3);
void __thiscall sub_40587A(wchar_t *FileName);
int sub_405A12(int a1, unsigned int a2, ...);
void sub_405AEC(unsigned int a1, ...);
int sub_405B88();
void sub_405BB4();
size_t __fastcall sub_405BF3(_DWORD *a1, const wchar_t **a2, wchar_t *String);
unsigned int __fastcall sub_405D5A(char *Src, _DWORD *a2, int a3, unsigned __int8 a4, const wchar_t *a5);
unsigned int __fastcall sub_405D9E(_DWORD *a1, _DWORD *a2, int a3, unsigned __int8 a4, const wchar_t *a5);
wchar_t **__fastcall sub_406271(wchar_t *a1, int a2, wchar_t **ArgList);
wchar_t *__fastcall sub_40638C(int a1, wchar_t **a2);
char *__thiscall sub_4069A9(wchar_t *Str);
char __fastcall sub_406AA7(int a1, wint_t **a2, int *a3);
char __fastcall sub_406C5E(wchar_t *FileName, int a2);
char __fastcall sub_406D7D(wchar_t *String, rsize_t a2, int *a3, int *a4);
int __stdcall sub_406F8B(int a1);
bool __fastcall sub_406F91(_WORD *a1, _DWORD *a2);
char __fastcall sub_407048(wchar_t *FullPath, wchar_t *a2, int a3);
intptr_t __fastcall sub_4074DE(wchar_t *Source, char a2, char a3, char a4, void **a5);
void *sub_407D7B();
char __fastcall sub_407E17(__int16 *a1, int a2, char a3, char a4, const wchar_t *a5, unsigned int *a6);
void __fastcall sub_4080AC(int a1, __int16 **a2);
void __fastcall sub_408136(int ArgList, char a2);
__int64 __thiscall sub_4081C4(char *this);
WCHAR *__fastcall sub_4081DE(wchar_t *Str, LPWIN32_FIND_DATAW lpFindFileData, HANDLE *a3);
WCHAR *__fastcall sub_408369(LPWIN32_FIND_DATAW lpFindFileData, HANDLE hFindFile);
void *__fastcall sub_40838C(wchar_t *a1, wchar_t *a2, struct _WIN32_FIND_DATAW *lpFindFileData, HANDLE *a4);
char __fastcall sub_40847B(_WORD *Block, LPWIN32_FIND_DATAW lpFindFileData);
char __fastcall sub_40850A(wchar_t *Str, _DWORD *a2);
int sub_408680();
wint_t *sub_408829();
wchar_t *__fastcall sub_408965(wchar_t *String1, char *a2);
int __thiscall sub_408AFC(wint_t *this);
char __fastcall sub_408C7B(wchar_t *String1, int a2, wchar_t **a3);
// char __usercall sub_408E57@<al>(char a1@<dl>, wchar_t *a2@<ecx>, int a3@<ebp>);
char sub_40909F();
char __stdcall sub_409188(int a1);
wint_t *__fastcall sub_40923A(wint_t *a1, int a2);
wchar_t *__fastcall sub_4092A9(const wchar_t *a1);
void *__thiscall sub_40933D(__int16 **this);
wchar_t *__fastcall sub_40946B(wchar_t *a1, _DWORD *a2, wchar_t **a3);
errno_t __fastcall sub_409790(void **a1, wchar_t *a2);
int __fastcall sub_409874(wchar_t *Source, const unsigned __int16 *a2, char a3);
wchar_t *__fastcall sub_4099E5(FILE *a1, int a2, const wchar_t **a3, char a4, _BYTE *a5);
char __fastcall sub_409C09(wchar_t *Str, void **a2, _DWORD *a3, char a4);
int sub_409FCF();
wint_t __fastcall sub_40A037(char a1);
unsigned __int8 __fastcall sub_40A0BC(wchar_t a1);
unsigned __int8 __fastcall sub_40A1A0(wint_t Character, _WORD *a2, int a3);
char __fastcall sub_40A3BD(int a1, char a2);
__int16 __fastcall sub_40A462(char a1);
wint_t __fastcall sub_40A53B(wint_t a1, char a2);
const unsigned __int16 *__fastcall sub_40A5EC(char a1, int a2, int a3);
const unsigned __int16 *__fastcall sub_40AC20(const unsigned __int16 *a1, unsigned int a2);
unsigned __int8 __thiscall sub_40AEC3(wchar_t *String);
wchar_t *__thiscall sub_40B36A(wchar_t *FullPath);
int __thiscall sub_40B444(const unsigned __int16 *this);
int sub_40B4D8();
void *__thiscall sub_40B4E9(size_t Size);
void *__thiscall sub_40B50E(size_t Size);
void *__fastcall sub_40B52C(void *Block, size_t Size);
int __fastcall sub_40B562(wchar_t *Source, wchar_t *a2, int a3, int a4, int a5, int a6, int a7, int a8);
wchar_t **__thiscall sub_40BB4E(int this, wchar_t **String, int Radix, wchar_t ***a4);
void __cdecl Handler(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); // idb
void __thiscall sub_40BCB9(void *this);
BOOL __fastcall sub_40BCC0(const void **a1, void *a2, void *a3);
int __cdecl main(int argc, const char **argv, const char **envp);
char *sub_40C136();
int __fastcall sub_40C298(int a1, int a2, int a3);
int sub_40C48D();
char *sub_40C5D7();
void __fastcall sub_40C6A3(unsigned int a1, int a2);
void *sub_40C9A8();
int __fastcall sub_40CA78(wint_t C, char a2);
void __cdecl Function();
int sub_40CD63();
const unsigned __int16 *__fastcall sub_40CDA1(const unsigned __int16 *a1);
int __fastcall sub_40CDF7(unsigned int a1);
void *sub_40CF18();
int sub_40CF1E(wchar_t *Buffer, wchar_t *Format, ...);
bool __thiscall sub_40CF48(FILE *Stream);
bool sub_40CF87();
int sub_40CFB2();
int sub_40CFD0(wchar_t *Format, ...);
int sub_40CFDF();
bool __thiscall sub_40D00B(FILE *Stream);
int __fastcall sub_40D049(wchar_t *Format, va_list ArgList); // idb
int sub_40D093();
int sub_40D0B1(wchar_t *Format, ...);
int sub_40D0C0();
int __fastcall sub_40D0EC(wchar_t *Format, va_list ArgList); // idb
void *sub_40D136();
int __thiscall sub_40D13C(void *this);
unsigned int __fastcall sub_40D320(int a1, _WORD *a2);
void __fastcall sub_40D34F(int a1, int a2, FILETIME FileTime);
void __fastcall sub_40D409(int a1, int a2);
int sub_40D606();
int sub_40D677();
int sub_40D717();
char __stdcall sub_40D86C(char a1);
char __stdcall sub_40DAB4(char a1);
wchar_t *sub_40DAF2();
wchar_t *sub_40DB6D();
int __fastcall sub_40DC36(char a1, int a2);
wchar_t *sub_40DCA4();
int sub_40DDC5();
int sub_40E0B5();
bool sub_40E126();
bool __thiscall sub_40E250(wchar_t *String);
bool __fastcall sub_40E2BF(wchar_t *String, char a2);
void **__fastcall sub_40E31C(wchar_t *Destination, rsize_t a2, wchar_t *Str, int a4, LPWIN32_FIND_DATAW lpFindFileData);
void sub_40E783();
void **__fastcall sub_40E9A3(int a1, wchar_t *a2, int a3, unsigned __int64 a4, _DWORD **a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, wchar_t **a9);
_DWORD *sub_40EB4F();
void *__thiscall sub_40EBA1(char *Src);
_WORD *__thiscall sub_40EBE5(char *this);
wchar_t *__fastcall sub_40EC4B(char *Block, const wchar_t *a2);
_DWORD *__fastcall sub_40ECA6(_DWORD **a1, _DWORD *a2);
int __thiscall sub_40ECBB(wint_t *this, int a2);
_DWORD *__thiscall sub_40ECF3(wchar_t *Source, int a2, int a3);
bool __fastcall sub_40EE9A(__int16 a1);
char __fastcall sub_40EED8(wint_t **a1, int **a2, void **a3, const unsigned __int16 *a4, int a5, int a6, int a7, char a8);
char __fastcall sub_40F4C4(wint_t **this, int **edx0, void **a2, const unsigned __int16 *a3, int a4, int a5, int a6, int a7, char a8, unsigned int a9, unsigned int a10);
wint_t *__fastcall sub_40F637(__int16 *a1, wint_t *a2, bool *a3, int *a4);
_WORD *__thiscall sub_40F785(_WORD *this);
wint_t *__thiscall sub_40F81F(wchar_t *Str);
int __fastcall sub_40F88D(__int16 *a1, char a2, _DWORD *a3);
_DWORD *__fastcall sub_40F8BE(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5, char *a6);
_DWORD *__fastcall sub_40FD9E(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5, char *a6);
void __fastcall sub_40FE08(_DWORD *a1, __int16 **a2, int a3);
wchar_t *__fastcall sub_41014C(__int16 a1, wchar_t *a2, rsize_t SizeInWords, wchar_t *Source);
__int16 *__fastcall sub_4102A4(_DWORD *a1, __int16 **a2, __int16 *a3);
// void __userpurge sub_410388(__int16 **a1@<edx>, _DWORD *a2@<ecx>, int a3@<ebp>, __int16 *a4);
int __fastcall sub_4105D0(_DWORD *a1, __int16 *a2, wchar_t *String2, size_t MaxCount, void *Src, int a6);
int __fastcall sub_410631(_DWORD *a1, __int16 *a2, wchar_t *String2, size_t MaxCount, void *Src, int a6);
// void __userpurge sub_4106B9(__int16 **a1@<edx>, _DWORD *a2@<ecx>, int a3@<ebp>, char a4, _DWORD *a5, char a6);
void __fastcall sub_410781(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4);
void __fastcall sub_41080C(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5, char a6);
void __fastcall sub_41091C(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5);
char __stdcall sub_4109C1(wchar_t *String1, size_t MaxCount, int a3, unsigned int a4);
_WORD *__fastcall sub_410A2F(_DWORD *a1, int *a2, _WORD *a3, int a4);
char __fastcall sub_410AD3(char a1, int a2, int a3, unsigned int a4, int a5, unsigned int a6);
void *__fastcall sub_410C5A(wchar_t *FullPath, wchar_t *Filename);
char __thiscall sub_410CCE(_WORD *this);
char __fastcall sub_410E43(char *a1, int a2, unsigned __int16 *a3, const wchar_t *a4);
_DWORD *__thiscall sub_4111A1(wint_t *this, int a2);
int __fastcall sub_411259(_WORD *a1, int a2);
_WORD *__fastcall sub_411373(_WORD *a1);
FILE *__fastcall sub_4113E8(wchar_t *FileName, wchar_t *Mode);
int __thiscall sub_41142F(char **this, char *a2, unsigned int a3, int a4);
_DWORD *__thiscall sub_411496(_DWORD *this, _DWORD *a2, unsigned int a3, unsigned int a4);
bool __stdcall sub_4114C6(char *a1, int a2, char *a3, int a4);
int __fastcall sub_4114EB(int a1, unsigned int a2, unsigned int a3, __int16 *a4, int a5, int a6);
int __fastcall sub_4115AD(_WORD *a1, int a2, int a3, __int16 *a4, int a5, int a6);
char __thiscall sub_411684(_BYTE *this, __int16 *a2, __int16 *a3);
_WORD *__fastcall sub_4116B4(_WORD *a1, int a2, _WORD *a3);
int __fastcall sub_4116DD(char *a1, char *a2, int a3);
void __noreturn sub_411724();
_DWORD *__thiscall sub_411730(_DWORD *this);
int __thiscall sub_411748(_DWORD *this);
char *__thiscall sub_41175A(char *Block, char a2);
_DWORD *__thiscall sub_411788(_DWORD *this, int a2);
_DWORD *__thiscall sub_4117B0(_DWORD *this, int a2);
void __noreturn sub_4117DD();
_DWORD *__thiscall sub_4117F9(void *this, unsigned int a2);
void __stdcall sub_41184F(_DWORD *Block, int a2);
_DWORD **__thiscall sub_411889(_DWORD **this, unsigned int a2, int a3, void *Src);
int sub_411912(wchar_t *Buffer, size_t BufferCount, wchar_t *Format, ...);
WCHAR *__thiscall sub_411940(wchar_t *FullPath);
// void __cdecl free(void *Block);
int sub_411A7D();
void __cdecl sub_411C31(void *Block);
// void __noreturn __report_rangecheckfailure(void); weak
_DWORD *__thiscall sub_411E6B(_DWORD *Block, char a2);
int __cdecl UserMathErrorFunction();
int sub_41217A();
void sub_412184();
char sub_412190();
// int __scrt_initialize_default_local_stdio_options(void); weak
BOOL sub_4121D1();
void *sub_4121DD();
void *sub_4121E3();
LPTOP_LEVEL_EXCEPTION_FILTER sub_41234B();
// LONG __stdcall __scrt_unhandled_exception_filter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
void sub_4123AD();
void sub_4123B5();
void __cdecl sub_4123E1(); // idb
// void *__cdecl memset(void *, int Val, size_t Size);
int sub_4126DD();
// void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// void __cdecl std::_Xout_of_range(const char *); weak
// void __cdecl __noreturn std::_Xlength_error(const char *); weak
// int __cdecl _std_exception_copy(_DWORD, _DWORD); weak
// int __cdecl _std_exception_destroy(_DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

void *type_info::`vftable' = &sub_411E6B; // weak
const wchar_t Source[] = L"\""; // idb
char byte_401090[] = { '\0' }; // weak
char byte_4011A0[] = { '\x01' }; // weak
char byte_4012C0[] = { '\x01' }; // weak
char byte_4012C1[] = { '\x02' }; // weak
char byte_4012C6[] = { '@' }; // weak
char byte_4012C9[] = { '\x01' }; // weak
wchar_t **off_401390[12] =
{
  &off_401424,
  &off_401418,
  &off_40140C,
  &off_401400,
  &off_4013F4,
  &off_401400,
  &off_4013F4,
  &off_4013E8,
  &off_4013DC,
  &off_4013D0,
  &off_4013C4,
  &off_401384
}; // weak
void *const off_401460 = &aSuffixes_0; // idb
_UNKNOWN off_4014D0; // weak
char byte_401520[] = { '\x01' }; // weak
char byte_401540[] = { '\"' }; // weak
int (*funcs_40D1BC[6])() = { &sub_402C30, &sub_402C61, &sub_4034A8, &sub_403257, &sub_402E4C, &sub_403371 }; // weak
char byte_40159C[] = { '\0' }; // weak
char byte_4015C0[] = { '\0' }; // weak
wchar_t *off_4015E0 = L"filter"; // weak
int dword_40177C = 0; // weak
const wchar_t aPa[] = L"PA"; // idb
const wchar_t aPa_0[] = L"PA"; // idb
int dword_401A48 = 65279; // weak
void *off_4023E0 = (void *)0x41004D; // weak
void *off_4023EC = (void *)0x41004D; // weak
const wchar_t aMa[] = L"MA"; // idb
int (__thiscall *off_402654)(void *Block, char) = &sub_41175A; // weak
const _ThrowInfo _TI3_AVbad_array_new_length_std__ = { 0u, &sub_411748, NULL, &_CTA3_AVbad_array_new_length_std__ }; // idb
int dword_413004 = 1; // weak
char byte_413020 = '\x01'; // weak
char byte_413021 = '\x01'; // weak
int dword_413024 = -1; // weak
int dword_413028 = -1; // weak
wchar_t aMakeflags[29] = L"MAKEFLAGS=                  "; // weak
int dword_413068 = 1; // weak
wchar_t *off_413070 = L"("; // weak
_UNKNOWN unk_413118; // weak
union _SLIST_HEADER ListHead; // idb
int dword_4134E8; // weak
int dword_413500; // weak
int dword_413504; // weak
wchar_t *dword_413508; // idb
char byte_41350C; // weak
char byte_41350D; // weak
char byte_41350E; // weak
char byte_41350F; // weak
wchar_t Destination; // idb
wchar_t Str; // idb
int dword_423510[128]; // weak
int dword_423710; // weak
void *dword_423714; // idb
int dword_423718; // idb
int dword_42371C; // weak
int dword_423720; // weak
int dword_423724; // weak
int dword_423728; // weak
void *dword_42372C; // idb
int dword_423730; // weak
char byte_423734; // weak
char byte_423735; // weak
char byte_423736; // weak
char byte_423737; // weak
wchar_t *Block; // idb
int dword_42373C; // weak
wchar_t Src; // idb
wchar_t word_423742; // idb
__int16 word_423F3C; // weak
int dword_423F40; // weak
int dword_423F44; // weak
int dword_423F48; // weak
void *dword_423F4C; // idb
int dword_423F50; // weak
wchar_t *dword_423F54; // idb
int dword_423F58; // weak
FILE *Stream; // idb
char byte_423F60; // weak
char byte_423F61; // weak
char byte_423F62; // weak
char byte_423F63; // weak
void *ArgList; // idb
wchar_t *dword_423F68; // idb
int dword_423F6C; // weak
wchar_t word_423F70[32768]; // weak
int dword_433F70; // weak
int dword_433F74; // weak
void *dword_433F78; // idb
wchar_t *dword_433F7C; // idb
char byte_433F80[]; // weak
_UNKNOWN unk_433F90; // weak
char byte_43438F[]; // weak
char byte_434390[]; // weak
char byte_434391[]; // weak
int dword_4343A0; // weak
int dword_4343A4; // weak
int dword_4343A8; // weak
int dword_4343AC; // weak
int dword_4343B0[]; // weak
int dword_4343B4[]; // weak
int dword_4343B8[]; // weak
int dword_434470; // weak
int dword_434474; // weak
char byte_434478; // weak
char byte_434479; // weak
char byte_43447A; // weak
char byte_43447B; // weak
char byte_43447C; // weak
char byte_43447D; // weak
char byte_43447E; // weak
char byte_43447F; // weak
_UNKNOWN unk_434480; // weak
char byte_434682; // weak
int dword_434684; // weak
int dword_434688; // weak
int dword_43468C; // weak
int dword_434690; // weak
wchar_t *EndPtr; // idb
int dword_434698; // weak
_UNKNOWN unk_4346A0; // weak
_UNKNOWN unk_436698; // weak
unsigned __int8 byte_4366A0[4088]; // weak
_UNKNOWN unk_437698; // weak
int dword_4376A0; // weak
int dword_4376A4; // weak
int dword_4376A8; // weak
char byte_4376AC; // weak
int dword_4376B0; // weak
_UNKNOWN unk_4376B8; // weak
PVOID dword_4376C0; // idb
PVOID Ptr; // idb
_UNKNOWN unk_4376C8; // weak
int dword_4376D4; // weak
wchar_t word_4376E0[1024]; // weak
char byte_437EE0; // weak
HMODULE hModule; // idb
__int16 word_437EE8; // weak
_UNKNOWN unk_437EEC; // weak
_UNKNOWN unk_437EF0; // weak
// extern HRSRC (__stdcall *FindResourceExW)(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage);
// extern HGLOBAL (__stdcall *LoadResource)(HMODULE hModule, HRSRC hResInfo);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern BOOL (__stdcall *GetExitCodeProcess)(HANDLE hProcess, LPDWORD lpExitCode);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern UINT (__stdcall *GetTempFileNameW)(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern DWORD (__stdcall *FormatMessageW)(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *SetFileTime)(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *GetFileTime)(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern HMODULE (__stdcall *LoadLibraryExW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// extern DWORD (__stdcall *GetLastError)();
// extern DWORD (__stdcall *GetEnvironmentVariableW)(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// extern PVOID (__stdcall *EncodePointer)(PVOID Ptr);
// extern PVOID (__stdcall *DecodePointer)(PVOID Ptr);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern LANGID (__stdcall *GetUserDefaultUILanguage)();
// extern UINT (__stdcall *SetErrorMode)(UINT uMode);
// extern BOOL (__stdcall *GetFileSizeEx)(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// extern DWORD (__stdcall *GetFileType)(HANDLE hFile);
// extern BOOL (__stdcall *GetConsoleMode)(HANDLE hConsoleHandle, LPDWORD lpMode);
// extern BOOL (__stdcall *FileTimeToLocalFileTime)(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
// extern BOOL (__stdcall *FileTimeToSystemTime)(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
// extern int (__stdcall *GetDateFormatW)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate);
// extern int (__stdcall *GetTimeFormatW)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern wchar_t *(__cdecl *wcsstr)(const wchar_t *Str, const wchar_t *SubStr);
// extern wchar_t *(__cdecl *wcsrchr)(const wchar_t *Str, wchar_t Ch);
// extern wchar_t *(__cdecl *wcschr)(const wchar_t *Str, wchar_t Ch);
// extern int (__cdecl *_conio_common_vcwprintf)(unsigned __int64 Options, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern wint_t (__cdecl *putwch)(wchar_t Character);
// extern unsigned int (__cdecl *wcstoul)(const wchar_t *String, wchar_t **EndPtr, int Radix);
// extern int (__cdecl *wcstol)(const wchar_t *String, wchar_t **EndPtr, int Radix);
// extern errno_t (__cdecl *itow_s)(int Value, wchar_t *Buffer, size_t BufferCount, int Radix);
// extern int (__cdecl *wputenv)(const wchar_t *EnvString);
// extern errno_t (__cdecl *wgetenv_s)(size_t *RequiredCount, wchar_t *Buffer, size_t BufferCount, const wchar_t *VarName);
// extern wchar_t ***(__cdecl *_p__wenviron)();
// extern errno_t (__cdecl *wputenv_s)(const wchar_t *Name, const wchar_t *Value);
// extern wchar_t *(__cdecl *wgetcwd)(wchar_t *DstBuf, int SizeInWords);
// extern errno_t (__cdecl *wdupenv_s)(wchar_t **Buffer, size_t *BufferCount, const wchar_t *VarName);
// extern void (__cdecl *wsearchenv)(const wchar_t *Filename, const wchar_t *VarName, wchar_t *ResultPath);
// extern int (__cdecl *wremove)(const wchar_t *FileName);
// extern int (__cdecl *chdrive)(int Drive);
// extern errno_t (__cdecl *wsplitpath_s)(const wchar_t *FullPath, wchar_t *Drive, size_t DriveCount, wchar_t *Dir, size_t DirCount, wchar_t *Filename, size_t FilenameCount, wchar_t *Ext, size_t ExtCount);
// extern errno_t (__cdecl *wmakepath_s)(wchar_t *Buffer, size_t BufferCount, const wchar_t *Drive, const wchar_t *Dir, const wchar_t *Filename, const wchar_t *Ext);
// extern errno_t (__cdecl *waccess_s)(const wchar_t *FileName, int AccessMode);
// extern int (__cdecl *wchdir)(const wchar_t *Path);
// extern int (__cdecl *waccess)(const wchar_t *FileName, int AccessMode);
// extern int (__cdecl *wunlink)(const wchar_t *FileName);
// extern void *(__cdecl *realloc)(void *Block, size_t Size);
// extern void (__cdecl *free)(void *Block);
// extern void *(__cdecl *malloc)(size_t Size);
// extern char *(__cdecl *setlocale)(int Category, const char *Locale);
// extern intptr_t (__cdecl *wspawnvp)(int Mode, const wchar_t *FileName, const wchar_t *const *ArgList);
// extern _crt_signal_t (__cdecl *signal)(int Signal, _crt_signal_t Function);
// extern void (__cdecl __noreturn *exit)(int Code);
// extern unsigned int *(__cdecl *_doserrno)();
// extern _invalid_parameter_handler (__cdecl *set_invalid_parameter_handler)(_invalid_parameter_handler Handler);
// extern wchar_t **(__cdecl *_p__wpgmptr)();
// extern int *(__cdecl *errno)();
// extern errno_t (__cdecl *wcserror_s)(wchar_t *Buffer, size_t SizeInWords, int ErrorNumber);
// extern void (__cdecl __noreturn *invalid_parameter_noinfo_noreturn)();
// extern int (__cdecl *_stdio_common_vswprintf_s)(unsigned __int64 Options, wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern int (__cdecl *_stdio_common_vfwprintf)(unsigned __int64 Options, FILE *Stream, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern wint_t (__cdecl *fputwc)(wchar_t Character, FILE *Stream);
// extern int (__cdecl *fflush)(FILE *Stream);
// extern int (__cdecl *fcloseall)();
// extern errno_t (__cdecl *wfopen_s)(FILE **Stream, const wchar_t *FileName, const wchar_t *Mode);
// extern FILE *(__cdecl *_acrt_iob_func)(unsigned int Ix);
// extern int (__cdecl *setvbuf)(FILE *Stream, char *Buffer, int Mode, size_t Size);
// extern intptr_t (__cdecl *get_osfhandle)(int FileHandle);
// extern int (__cdecl *_stdio_common_vswscanf)(unsigned __int64 Options, const wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern errno_t (__cdecl *wsopen_s)(int *FileHandle, const wchar_t *FileName, int OpenFlag, int ShareFlag, int PermissionFlag);
// extern int (__cdecl *dup2)(int FileHandleSrc, int FileHandleDst);
// extern size_t (__cdecl *fwrite)(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// extern wchar_t *(__cdecl *fgetws)(wchar_t *Buffer, int BufferCount, FILE *Stream);
// extern FILE *(__cdecl *wfsopen)(const wchar_t *FileName, const wchar_t *Mode, int ShFlag);
// extern int (__cdecl *feof)(FILE *Stream);
// extern int (__cdecl *fclose)(FILE *Stream);
// extern wint_t (__cdecl *ungetwc)(wint_t Character, FILE *Stream);
// extern wint_t (__cdecl *getwc)(FILE *Stream);
// extern int (__cdecl *fileno)(FILE *Stream);
// extern int (__cdecl *dup)(int FileHandle);
// extern int (__cdecl *lseek)(int FileHandle, int Offset, int Origin);
// extern int (__cdecl *close)(int FileHandle);
// extern size_t (__cdecl *wcsspn)(const wchar_t *String, const wchar_t *Control);
// extern int (__cdecl *iswalpha)(wint_t C);
// extern errno_t (__cdecl *wcsncpy_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source, rsize_t MaxCount);
// extern errno_t (__cdecl *wcscat_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// extern errno_t (__cdecl *wcscpy_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// extern int (__cdecl *wcsncmp)(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// extern errno_t (__cdecl *wcsncat_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source, rsize_t MaxCount);
// extern errno_t (__cdecl *wcsupr_s)(wchar_t *String, size_t Size);
// extern wchar_t *(__cdecl *wcstok_s)(wchar_t *String, const wchar_t *Delimiter, wchar_t **Context);
// extern int (__cdecl *wcsnicmp)(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// extern int (__cdecl *iswspace)(wint_t C);
// extern wchar_t *(__cdecl *wcspbrk)(const wchar_t *String, const wchar_t *Control);
// extern int (__cdecl *wcsicmp)(const wchar_t *String1, const wchar_t *String2);
// extern wint_t (__cdecl *towupper)(wint_t C);
// extern int (__cdecl *iswdigit)(wint_t C);


//----- (00402C30) --------------------------------------------------------
wchar_t *sub_402C30()
{
  wchar_t *result; // eax
  wint_t *v1; // [esp+4h] [ebp-4h] BYREF

  v1 = &Src;
  sub_40EED8(&v1, (int **)&dword_42373C, 0, 0, 0, 0, 0, 0);
  result = (wchar_t *)sub_40EBA1((char *)&Src);
  Block = result;
  return result;
}
// 42373C: using guessed type int dword_42373C;

//----- (00402C61) --------------------------------------------------------
_DWORD *sub_402C61()
{
  _DWORD *v0; // eax
  char v1; // dl
  _DWORD *v2; // esi
  void *v3; // eax
  int *v4; // esi
  int v5; // ecx
  int *v6; // eax
  wint_t *v8; // [esp+Ch] [ebp-8h] BYREF
  _DWORD *v9; // [esp+10h] [ebp-4h] BYREF

  if ( Block )
  {
    byte_423734 |= 0x20u;
    sub_402D8D();
    Block = 0;
  }
  if ( (byte_423734 & 0x20) != 0 && sub_410CCE(&Src) )
  {
    if ( (byte_423734 & 0x10) != 0 )
      sub_405A12(dword_423730, 0x444u);
    sub_405A12(dword_423730, 0x43Du);
  }
  v0 = sub_40EB4F();
  v1 = byte_423734;
  v2 = v0;
  if ( (byte_423734 & 0x40) != 0 )
  {
    v0[1] = dword_42372C;
    dword_42372C = 0;
  }
  else
  {
    v3 = sub_40EBA1((char *)&Src);
    v1 = byte_423734;
    v2[1] = v3;
  }
  v9 = v2;
  if ( (v1 & 0x30) != 16 )
  {
    v8 = (wint_t *)v2[1];
    sub_40EED8(&v8, (int **)&dword_42373C, 0, 0, 0, 0, 0, 0);
    v1 = byte_423734;
  }
  if ( (v1 & 0x20) != 0 )
  {
    v4 = (int *)dword_42373C;
    sub_403006((wchar_t *)L"$", (int *)&v9, &dword_42373C);
    sub_403006((wchar_t *)L"*?", (int *)&v9, 0);
    dword_42373C = (int)v4;
    if ( v4 )
    {
      v5 = dword_434698;
      v6 = v4;
      do
      {
        v4 = (int *)*v4;
        *v6 = v5;
        v5 = (int)v6;
        dword_42373C = (int)v4;
        v6 = v4;
      }
      while ( v4 );
      dword_434698 = v5;
    }
  }
  return sub_40ECA6((_DWORD **)&dword_423728, v9);
}
// 423728: using guessed type int dword_423728;
// 423730: using guessed type int dword_423730;
// 423734: using guessed type char byte_423734;
// 42373C: using guessed type int dword_42373C;
// 434698: using guessed type int dword_434698;

//----- (00402D8D) --------------------------------------------------------
void sub_402D8D()
{
  _DWORD *v0; // eax
  int *v1; // esi
  int v2; // ecx
  int *v3; // eax
  int v4; // ecx

  byte_41350F = byte_41350E;
  v0 = sub_40EB4F();
  v0[1] = Block;
  v1 = (int *)dword_42373C;
  dword_423728 = (int)v0;
  sub_403006((wchar_t *)L"$", &dword_423728, &dword_42373C);
  sub_403006((wchar_t *)L"*?", &dword_423728, 0);
  dword_42373C = (int)v1;
  if ( v1 )
  {
    v2 = dword_434698;
    v3 = v1;
    do
    {
      v1 = (int *)*v1;
      *v3 = v2;
      v2 = (int)v3;
      dword_42373C = (int)v1;
      v3 = v1;
    }
    while ( v1 );
    dword_434698 = v2;
  }
  v4 = dword_423728;
  if ( dword_423728 || (byte_423734 & 0x20) == 0 && (sub_405A12(dword_423724, 0x43Bu, Block), (v4 = dword_423728) != 0) )
  {
    if ( sub_410CCE(*(_WORD **)(v4 + 4)) )
      byte_423734 |= 0x10u;
  }
}
// 41350E: using guessed type char byte_41350E;
// 41350F: using guessed type char byte_41350F;
// 423724: using guessed type int dword_423724;
// 423728: using guessed type int dword_423728;
// 423734: using guessed type char byte_423734;
// 42373C: using guessed type int dword_42373C;
// 434698: using guessed type int dword_434698;

//----- (00402E4C) --------------------------------------------------------
void sub_402E4C()
{
  char v0; // bl
  int v1; // esi
  _DWORD *v2; // eax
  int v3; // eax

  if ( Block )
  {
    sub_402D8D();
    Block = 0;
  }
  else
  {
    byte_423734 &= ~0x20u;
  }
  v0 = byte_41350F;
  if ( word_423742 )
  {
    v0 = byte_41350F | 0x20;
    byte_41350F |= 0x20u;
  }
  v1 = dword_423728;
  if ( !dword_423728 )
    sub_405A12(dword_423730, 0x40Du);
  if ( (byte_423734 & 0x10) != 0 )
  {
    v2 = sub_40B50E(0x18u);
    v2[2] = *(_DWORD *)(v1 + 4);
    *((_BYTE *)v2 + 20) = (v0 & 0x20) != 0;
    *v2 = dword_423714;
    dword_423714 = v2;
    if ( *v2 )
      *(_DWORD *)(*v2 + 4) = v2;
    goto LABEL_14;
  }
  if ( *(_DWORD *)v1 )
  {
LABEL_16:
    dword_413500 = v1;
    goto LABEL_17;
  }
  if ( !sub_402F2B(*(wchar_t **)(v1 + 4)) )
  {
    v1 = dword_423728;
    goto LABEL_16;
  }
  free(*(void **)(dword_423728 + 4));
LABEL_14:
  v3 = dword_434698;
  dword_434698 = dword_423728;
  *(_DWORD *)dword_423728 = v3;
LABEL_17:
  dword_423728 = 0;
  byte_423734 |= 0x80u;
}
// 413500: using guessed type int dword_413500;
// 41350F: using guessed type char byte_41350F;
// 423728: using guessed type int dword_423728;
// 423730: using guessed type int dword_423730;
// 423734: using guessed type char byte_423734;
// 434698: using guessed type int dword_434698;

//----- (00402F2B) --------------------------------------------------------
char __thiscall sub_402F2B(wchar_t *String1)
{
  wchar_t *v1; // esi
  int v2; // ebx
  int v3; // eax
  const wchar_t *v5; // eax
  bool v6; // cf
  wchar_t v7; // cx
  char v8; // [esp+Fh] [ebp-1h]

  v1 = String1;
  v2 = 0;
  v8 = 0;
  if ( !wcsicmp(String1, L".SILENT") )
  {
    byte_423734 |= 2u;
    sub_40CA78(0x73u, 1);
    v8 = 1;
  }
  if ( !wcsicmp(v1, L".IGNORE") )
  {
    byte_423734 |= 4u;
    sub_40CA78(0x69u, 1);
    return 1;
  }
  v3 = wcscmp(v1, L".SUFFIXES");
  if ( v3 )
    v3 = v3 < 0 ? -1 : 1;
  if ( !v3 )
  {
    byte_423734 |= 1u;
    return 1;
  }
  v5 = L".PRECIOUS";
  while ( 1 )
  {
    v6 = *v1 < *v5;
    if ( *v1 != *v5 )
      break;
    if ( !*v1 )
      goto LABEL_17;
    v7 = v1[1];
    v6 = v7 < v5[1];
    if ( v7 != v5[1] )
      break;
    v1 += 2;
    v5 += 2;
    if ( !v7 )
      goto LABEL_17;
  }
  v2 = v6 ? -1 : 1;
LABEL_17:
  if ( !v2 )
  {
    byte_423734 |= 8u;
    return 1;
  }
  return v8;
}
// 401154: using guessed type wchar_t aPrecious[10];
// 401168: using guessed type wchar_t aSuffixes[10];
// 423734: using guessed type char byte_423734;

//----- (00403006) --------------------------------------------------------
void __fastcall sub_403006(wchar_t *Control, int *a2, _DWORD *a3)
{
  int v3; // esi
  _DWORD *v4; // edi
  int *v5; // ebx
  __int16 *v6; // ecx
  int v7; // eax
  int *v8; // edx
  int *v9; // eax
  void *v10; // eax
  int *v11; // ecx
  char *v12; // esi
  int *v13; // ecx
  _DWORD *v14; // [esp+10h] [ebp-28h] BYREF
  int *v15; // [esp+14h] [ebp-24h]
  void *Block; // [esp+18h] [ebp-20h] BYREF
  wchar_t *v17; // [esp+1Ch] [ebp-1Ch]
  void *v18; // [esp+20h] [ebp-18h] BYREF
  void *v19; // [esp+24h] [ebp-14h]
  int v20; // [esp+28h] [ebp-10h]
  __int16 *v21; // [esp+2Ch] [ebp-Ch] BYREF
  int v22; // [esp+30h] [ebp-8h] BYREF

  Block = 0;
  v3 = *a2;
  v4 = 0;
  v19 = 0;
  v5 = 0;
  v15 = a2;
  v17 = Control;
  v14 = 0;
  while ( v3 )
  {
    if ( !wcspbrk(*(const wchar_t **)(v3 + 4), Control) )
      goto LABEL_24;
    v6 = *(__int16 **)(v3 + 4);
    if ( *v17 == 36 )
    {
      Block = 0;
      v21 = v6;
      sub_40F8BE(&v22, &v21, 255, a3, 0, (char *)&Block);
      free(*(void **)(v3 + 4));
    }
    else
    {
      if ( sub_410CCE(v6) || (v4 = sub_411940(*(wchar_t **)(v3 + 4)), (v14 = v4) == 0) )
      {
LABEL_24:
        v5 = (int *)v3;
        v3 = *(_DWORD *)v3;
        goto LABEL_25;
      }
      v19 = *(void **)(v3 + 4);
    }
    v7 = *(_DWORD *)v3;
    v8 = v15;
    if ( v5 )
    {
      *v5 = v7;
      *(_DWORD *)v3 = dword_434698;
      v9 = v5;
    }
    else
    {
      *v15 = v7;
      *(_DWORD *)v3 = dword_434698;
      v9 = v8;
    }
    v20 = *v9;
    dword_434698 = v3;
    if ( *v17 == 36 )
    {
      v18 = Block;
      while ( 1 )
      {
        v12 = (char *)sub_403191(&v18);
        if ( !v12 )
          break;
        v4 = sub_40EB4F();
        v14 = v4;
        v10 = sub_40EBA1(v12);
        v11 = v15;
        v4[1] = v10;
        *v4 = *v11;
        *v11 = (int)v4;
        if ( !v5 )
          v5 = v4;
      }
      free(Block);
    }
    else
    {
      if ( v4 )
      {
        if ( !v5 )
        {
          v13 = (int *)*v4;
          v5 = v4;
          if ( *v4 )
          {
            do
            {
              v5 = v13;
              v13 = (int *)*v13;
            }
            while ( v13 );
          }
        }
        sub_40ECA6(&v14, (_DWORD *)*v8);
        v4 = v14;
        *v15 = (int)v14;
      }
      free(v19);
    }
    v3 = v20;
LABEL_25:
    Control = v17;
  }
}
// 434698: using guessed type int dword_434698;

//----- (00403191) --------------------------------------------------------
_WORD *__thiscall sub_403191(_DWORD *this)
{
  _DWORD *v1; // edi
  _WORD *i; // ecx
  __int16 v3; // ax
  _WORD *v4; // ebx
  _WORD *result; // eax
  __int16 v6; // dx
  __int16 v7; // si
  _WORD *v8; // eax
  _WORD *v9; // [esp+10h] [ebp-8h]

  v1 = this;
  for ( i = (_WORD *)*this; ; ++i )
  {
    v3 = *i;
    if ( *i != 32 && v3 != 9 )
      break;
  }
  v4 = i;
  v9 = i;
  if ( !v3 )
    return 0;
  if ( v3 == 34 )
  {
    do
      ++i;
    while ( *i && *i != 34 );
    v6 = *i;
  }
  else
  {
    v7 = *i;
    do
    {
      v6 = v7;
      if ( v7 == 32 )
        break;
      v6 = v7;
      if ( v7 == 9 )
        break;
      v7 = *++i;
      v6 = *i;
    }
    while ( *i );
    v1 = this;
    v4 = v9;
  }
  v8 = i;
  if ( v6 == 32 || v6 == 9 )
    goto LABEL_23;
  if ( v6 != 34 )
  {
    if ( !v6 )
      --i;
    goto LABEL_24;
  }
  if ( *++i )
LABEL_23:
    *i = 0;
  else
    i = v8;
LABEL_24:
  result = v4;
  *v1 = i + 1;
  return result;
}

//----- (00403257) --------------------------------------------------------
char sub_403257()
{
  char v0; // al
  const wchar_t *v1; // ecx
  int *v2; // ecx
  int v3; // esi
  int *v4; // ecx
  char result; // al

  v0 = byte_423734;
  v1 = 0;
  if ( byte_423734 < 0 )
  {
    v0 = byte_423734 & 0x7F;
    byte_423734 &= ~0x80u;
  }
  if ( (v0 & 0x10) == 0 )
  {
    if ( (v0 & 6) != 0 )
    {
      if ( dword_423728 )
      {
        if ( (v0 & 2) != 0 )
        {
          v1 = L".SILENT";
        }
        else if ( (v0 & 4) != 0 )
        {
          v1 = L".IGNORE";
        }
        sub_405A12(dword_423730, 0x442u, v1);
        goto LABEL_24;
      }
      goto LABEL_25;
    }
    if ( (v0 & 1) != 0 )
    {
      if ( !dword_423728 )
      {
        v2 = (int *)dword_423720;
        v3 = dword_423720;
        if ( dword_423720 )
        {
          do
          {
            dword_423720 = *v2;
            free(*(void **)(v3 + 4));
            *(_DWORD *)v3 = dword_434698;
            v2 = (int *)dword_423720;
            dword_434698 = v3;
            v3 = dword_423720;
          }
          while ( dword_423720 );
          goto LABEL_24;
        }
        goto LABEL_25;
      }
      v4 = &dword_423720;
    }
    else
    {
      if ( (v0 & 8) == 0 )
      {
        dword_423718 = (int)sub_40B50E(0x20u);
        *(_DWORD *)dword_423718 = dword_423728;
        *(_DWORD *)(dword_423718 + 4) = dword_42373C;
        goto LABEL_24;
      }
      if ( !dword_423728 )
        goto LABEL_25;
      v4 = &dword_42371C;
    }
    sub_40392B((_DWORD **)v4);
    goto LABEL_24;
  }
  if ( dword_423728 )
  {
    sub_405A12(dword_423730, 0x43Eu);
LABEL_24:
    v0 = byte_423734;
  }
LABEL_25:
  dword_423728 = 0;
  result = v0 | 0x40;
  dword_42373C = 0;
  byte_423734 = result;
  return result;
}
// 42371C: using guessed type int dword_42371C;
// 423720: using guessed type int dword_423720;
// 423728: using guessed type int dword_423728;
// 423730: using guessed type int dword_423730;
// 423734: using guessed type char byte_423734;
// 42373C: using guessed type int dword_42373C;
// 434698: using guessed type int dword_434698;

//----- (00403371) --------------------------------------------------------
void sub_403371()
{
  const wchar_t *v0; // ecx
  char v1; // bl
  int v2; // esi
  int v3; // ecx
  int v4; // ecx
  int v5; // [esp-4h] [ebp-10h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = 0;
  v1 = 1;
  v6 = 1;
  if ( (byte_423734 & 0x10) != 0 )
  {
    *((_DWORD *)dword_423714 + 3) = dword_423728;
  }
  else if ( (byte_423734 & 0xF) != 0 )
  {
    if ( dword_423728 )
    {
      if ( (byte_423734 & 2) != 0 )
      {
        v0 = L".SILENT";
      }
      else if ( (byte_423734 & 4) != 0 )
      {
        v0 = L".IGNORE";
      }
      else if ( (byte_423734 & 8) != 0 )
      {
        v0 = L".PRECIOUS";
      }
      else if ( (byte_423734 & 1) != 0 )
      {
        v0 = L".SUFFIXES";
      }
      sub_405A12(dword_423730, 0x441u, v0);
    }
  }
  else
  {
    v2 = dword_413500;
    *(_DWORD *)(dword_423718 + 8) = dword_423728;
    *(_DWORD *)(dword_423718 + 12) = dword_42373C;
    *(_BYTE *)(dword_423718 + 16) = byte_41350F;
    if ( v2 )
    {
      do
      {
        if ( sub_402F2B(*(wchar_t **)(v2 + 4)) )
        {
          sub_405A12(dword_423730, 0x445u);
          v3 = v5;
        }
        sub_40386A(*(wchar_t **)(v2 + 4), v6, v3);
        if ( !dword_423710 )
        {
          dword_423710 = v2;
          v1 = 0;
        }
        v4 = *(_DWORD *)v2;
        dword_413500 = *(_DWORD *)v2;
        if ( v1 )
        {
          *(_DWORD *)v2 = dword_434698;
          dword_434698 = v2;
        }
        v6 = 0;
        v2 = v4;
      }
      while ( v4 );
    }
  }
  dword_413500 = 0;
  dword_423728 = 0;
  dword_42373C = 0;
  dword_423718 = 0;
  byte_423734 = 0;
}
// 4033F8: variable 'v5' is possibly undefined
// 403400: variable 'v3' is possibly undefined
// 401154: using guessed type wchar_t aPrecious[10];
// 401168: using guessed type wchar_t aSuffixes[10];
// 413500: using guessed type int dword_413500;
// 41350F: using guessed type char byte_41350F;
// 423710: using guessed type int dword_423710;
// 423728: using guessed type int dword_423728;
// 423730: using guessed type int dword_423730;
// 423734: using guessed type char byte_423734;
// 42373C: using guessed type int dword_42373C;
// 434698: using guessed type int dword_434698;

//----- (004034A8) --------------------------------------------------------
void sub_4034A8()
{
  int *v0; // esi
  wchar_t *v1; // ebx
  int v2; // ecx
  int *v3; // eax
  wchar_t *v4; // esi
  wint_t v5; // cx
  wchar_t *v6; // [esp+10h] [ebp-10h] BYREF
  wchar_t *v7; // [esp+14h] [ebp-Ch] BYREF
  int v8; // [esp+18h] [ebp-8h] BYREF

  if ( wcschr(Block, 0x24u) )
  {
    v0 = (int *)dword_42373C;
    v7 = Block;
    v6 = 0;
    sub_40F8BE(&v8, (__int16 **)&v7, 255, &dword_42373C, 0, (char *)&v6);
    v1 = v6;
    if ( !*v6 )
      sub_405A12(dword_423730, 0x3ECu);
    dword_42373C = (int)v0;
    if ( v0 )
    {
      v2 = dword_434698;
      v3 = v0;
      do
      {
        v0 = (int *)*v0;
        *v3 = v2;
        v2 = (int)v3;
        dword_42373C = (int)v0;
        v3 = v0;
      }
      while ( v0 );
      dword_434698 = v2;
    }
    free(Block);
    Block = v1;
  }
  v4 = Block;
  if ( *Block )
  {
    v5 = *Block;
    do
    {
      if ( !sub_403A97(v5) )
        break;
      v5 = *++v4;
    }
    while ( *v4 );
  }
  if ( *v4 )
    sub_405A12(dword_423730, 0x3E9u, *v4);
  byte_41350D = 1;
  if ( !sub_403707(Block, (wchar_t *)dword_42372C, 0) )
  {
    free(Block);
    free(dword_42372C);
  }
  dword_42372C = 0;
  Block = 0;
}
// 41350D: using guessed type char byte_41350D;
// 423730: using guessed type int dword_423730;
// 42373C: using guessed type int dword_42373C;
// 434698: using guessed type int dword_434698;

//----- (004035E0) --------------------------------------------------------
char __fastcall sub_4035E0(wchar_t *Name, wchar_t *Block, int a3)
{
  wchar_t *v3; // ebx
  wchar_t *v4; // esi
  wint_t *v5; // edi
  wint_t v6; // cx
  int v7; // eax
  int v9; // edi
  wchar_t *v10; // eax
  wchar_t *v11; // ecx
  __int64 v13; // rax
  wchar_t *v14; // eax
  wchar_t v15; // cx
  wchar_t *v16; // edi
  wchar_t *v17; // edx
  wchar_t *v19; // [esp+14h] [ebp-8h]

  v3 = Name;
  v4 = Block;
  v5 = Name;
  v6 = *Name;
  if ( v6 )
  {
    do
    {
      if ( !sub_403A97(v6) )
        break;
      v6 = *++v5;
    }
    while ( *v5 );
    v3 = Name;
  }
  v7 = *v5;
  if ( (_WORD)v7 )
  {
    if ( (a3 & 4) != 0 )
      return 0;
    sub_405A12(dword_423730, 0x3E9u, v7);
  }
  if ( (a3 & 0x40) != 0 )
  {
    v9 = 0;
    v10 = wcschr(v4, 0x24u);
    if ( v10 )
    {
      do
      {
        ++v9;
        v10 = wcschr(v10 + 1, 0x24u);
      }
      while ( v10 );
      if ( v9 )
      {
        v11 = v4;
        while ( *v11++ )
          ;
        v13 = 2i64 * (unsigned int)(v11 - (v4 + 1) + v9 + 1);
        v14 = (wchar_t *)sub_40B4E9(HIDWORD(v13) != 0 ? -1 : v13);
        v15 = *v4;
        v16 = v4 + 1;
        v19 = v14;
        v17 = v14;
        if ( *v4 )
        {
          do
          {
            *v17++ = v15;
            if ( v15 == 36 )
              *v17++ = 36;
            v15 = *v16++;
          }
          while ( v15 );
          v4 = Block;
          v3 = Name;
        }
        *v17 = 0;
        free(v4);
        v4 = v19;
      }
    }
  }
  return sub_403707(v3, v4, a3);
}
// 423730: using guessed type int dword_423730;

//----- (00403707) --------------------------------------------------------
char __fastcall sub_403707(wchar_t *Name, wchar_t *a2, int a3)
{
  wchar_t *v5; // ecx
  int v6; // eax
  unsigned __int8 v7; // al
  wint_t *v8; // eax
  int v9; // eax
  _DWORD *v10; // esi
  unsigned __int8 v11; // al
  _DWORD *v13; // edx
  _DWORD *v14; // eax
  bool v15; // zf
  _DWORD *v16; // ecx
  char v17; // al
  size_t RequiredCount; // [esp+10h] [ebp-Ch] BYREF
  wchar_t *Str; // [esp+14h] [ebp-8h] BYREF
  char v20; // [esp+1Bh] [ebp-1h]
  int v21; // [esp+24h] [ebp+8h]

  Str = a2;
  v20 = 0;
  RequiredCount = 0;
  if ( (a3 & 2) != 0 )
  {
    if ( !*a2 )
      goto LABEL_14;
    v5 = a2;
  }
  else
  {
    if ( !byte_41350D || (byte_41350C & 4) != 0 || wgetenv_s(&RequiredCount, 0, 0, Name) || !RequiredCount )
      goto LABEL_14;
    v6 = sub_40B444(Name);
    if ( v6 )
    {
      v7 = *(_BYTE *)(v6 + 12);
      if ( (v7 & 2) != 0 || ((unsigned __int8)byte_41350C & v7 & 4) != 0 )
        return 0;
    }
    v5 = Str;
  }
  v8 = sub_40F81F(v5);
  if ( wputenv_s(Name, v8) )
    sub_405A12(dword_423730, 0x41Fu);
LABEL_14:
  byte_41350D = 0;
  v9 = sub_40B444(Name);
  v10 = (_DWORD *)v9;
  if ( v9 )
  {
    v11 = *(_BYTE *)(v9 + 12);
    if ( (v11 & 2) != 0 || ((unsigned __int8)byte_41350C & v11 & 4) != 0 )
      return 0;
  }
  v13 = sub_40EB4F();
  v21 = (int)v13;
  v13[1] = Str;
  if ( v10 )
  {
    v20 = 1;
  }
  else
  {
    v14 = sub_40B50E(0x10u);
    v13 = (_DWORD *)v21;
    v10 = v14;
    v14[1] = Name;
  }
  v15 = v20 == 0;
  *((_BYTE *)v10 + 12) = a3 | v10[3] & 0xEF;
  *v13 = v10[2];
  v10[2] = v13;
  if ( v15 )
  {
    v16 = (_DWORD *)dword_4376A8;
    *v10 = *(_DWORD *)dword_4376A8;
    *v16 = v10;
    dword_4376A8 = 0;
  }
  if ( (a3 & 0x40) == 0 && wcschr(Str, 0x24u) )
  {
    *((_BYTE *)v10 + 12) |= 1u;
    v17 = sub_40EED8(&Str, 0, 0, Name, 1, 0, a3, 0);
    *((_BYTE *)v10 + 12) &= ~1u;
    if ( !v17 )
    {
      *((_BYTE *)v10 + 12) |= 0x10u;
      v10[2] = 0;
    }
  }
  return 1;
}
// 41350C: using guessed type char byte_41350C;
// 41350D: using guessed type char byte_41350D;
// 423730: using guessed type int dword_423730;
// 4376A8: using guessed type int dword_4376A8;

//----- (0040386A) --------------------------------------------------------
void __fastcall sub_40386A(wchar_t *Block, char a2, int a3)
{
  _DWORD *v3; // eax
  _DWORD *v5; // eax
  int v6; // ecx
  _DWORD *v7; // edi
  _DWORD *v8; // eax
  _DWORD *v9; // esi
  int *v10; // eax
  int v11; // ecx
  int *v12; // esi
  int *v13; // ecx

  v3 = (_DWORD *)dword_423718;
  if ( !dword_423718 )
  {
    v3 = sub_40B50E(0x20u);
    dword_423718 = (int)v3;
  }
  if ( a2 )
  {
    v5 = sub_40B50E(8u);
    v6 = dword_423718;
    v7 = v5;
    v5[1] = dword_423718;
  }
  else
  {
    v7 = sub_403A45(v3);
  }
  v8 = sub_40ECF3(Block, v6, v6);
  v9 = v8;
  if ( v8 )
  {
    if ( (((unsigned __int8)byte_41350F ^ *((_BYTE *)v8 + 8)) & 0x20) != 0 )
      sub_405A12(dword_423730, 0x43Fu);
    sub_40ECA6((_DWORD **)v9 + 6, v7);
    free(Block);
  }
  else
  {
    *v7 = 0;
    v10 = (int *)sub_40B50E(0x20u);
    LOBYTE(v11) = byte_41350F;
    v12 = v10;
    *((_BYTE *)v10 + 8) = byte_41350F;
    v10[1] = (int)Block;
    v10[6] = (int)v7;
    v13 = &dword_423510[sub_40ECBB(Block, v11)];
    *v12 = *v13;
    *v13 = (int)v12;
  }
}
// 4038B4: variable 'v6' is possibly undefined
// 403912: variable 'v11' is possibly undefined
// 41350F: using guessed type char byte_41350F;
// 423510: using guessed type int dword_423510[128];
// 423730: using guessed type int dword_423730;

//----- (0040392B) --------------------------------------------------------
void __thiscall sub_40392B(_DWORD **this)
{
  int v1; // edi
  _DWORD **v2; // esi
  _DWORD *v3; // ebx
  int *v4; // esi
  wchar_t *v5; // eax
  int v6; // edx
  int *v7; // ecx
  wchar_t *v8; // eax
  char *v9; // ebx
  _DWORD *v10; // esi
  wchar_t *Block; // [esp+Ch] [ebp-18h]
  int v12; // [esp+14h] [ebp-10h]
  wchar_t *Context; // [esp+1Ch] [ebp-8h] BYREF
  int v15; // [esp+20h] [ebp-4h]

  v1 = dword_423728;
  v2 = this;
  v3 = (_DWORD *)dword_423728;
  v15 = dword_423728;
  v12 = dword_423728;
  while ( v1 )
  {
    if ( wcschr(*(const wchar_t **)(v1 + 4), 0x24u) )
    {
      v4 = (int *)dword_42373C;
      v5 = (wchar_t *)sub_40F88D(*(__int16 **)(v1 + 4), 255, &dword_42373C);
      Block = v5;
      if ( v4 != (int *)dword_42373C )
      {
        v6 = dword_434698;
        do
        {
          v7 = (int *)*v4;
          *v4 = v6;
          v6 = (int)v4;
          v4 = v7;
        }
        while ( v7 != (int *)dword_42373C );
        dword_434698 = v6;
      }
      Context = 0;
      v8 = wcstok_s(v5, L" \t", &Context);
      if ( v8 )
      {
        v9 = (char *)v8;
        do
        {
          v10 = sub_40EB4F();
          v10[1] = sub_40EBA1(v9);
          sub_40ECA6(this, v10);
          v9 = (char *)wcstok_s(0, L" \t", &Context);
        }
        while ( v9 );
        v1 = v15;
        v3 = (_DWORD *)v12;
      }
      free(Block);
      free(*(void **)(v1 + 4));
      v1 = *(_DWORD *)v1;
      v2 = this;
      v15 = v1;
      *v3 = dword_434698;
      dword_434698 = (int)v3;
    }
    else
    {
      v1 = *(_DWORD *)v1;
      *v3 = 0;
      v15 = v1;
      sub_40ECA6(v2, v3);
    }
    v3 = (_DWORD *)v1;
    v12 = v1;
  }
}
// 423728: using guessed type int dword_423728;
// 42373C: using guessed type int dword_42373C;
// 434698: using guessed type int dword_434698;

//----- (00403A45) --------------------------------------------------------
_DWORD *__thiscall sub_403A45(_DWORD *this)
{
  _DWORD *v2; // ebx
  _DWORD *v3; // eax
  int v4; // edx
  _DWORD *v5; // esi
  int v6; // ecx
  _DWORD *result; // eax

  v2 = sub_40B50E(8u);
  v3 = sub_40B50E(0x20u);
  v4 = *this;
  v5 = v3;
  v2[1] = v3;
  *v3 = v4;
  v3[1] = this[1];
  v3[2] = this[2];
  v3[3] = this[3];
  *((_BYTE *)v3 + 16) = *((_BYTE *)this + 16);
  v6 = this[7];
  v3[6] = this[6];
  result = v2;
  v5[7] = v6;
  return result;
}

//----- (00403A8F) --------------------------------------------------------
void *__thiscall sub_403A8F(void *this)
{
  return sub_40B4E9((size_t)this);
}

//----- (00403A97) --------------------------------------------------------
bool __fastcall sub_403A97(wint_t C)
{
  if ( C >= 0x80u )
    return iswspace(C) == 0;
  else
    return byte_401090[C] & 1;
}

//----- (00403ABC) --------------------------------------------------------
wchar_t *__fastcall sub_403ABC(wchar_t *Str, wchar_t Ch)
{
  return wcschr(Str, Ch);
}

//----- (00403AC7) --------------------------------------------------------
__int16 __thiscall sub_403AC7(_DWORD *this, __int16 a2)
{
  __int16 result; // ax

  sub_403C06(this, 1);
  result = a2;
  *(_WORD *)(this[512] + 2 * this[514]++) = a2;
  return result;
}

//----- (00403AF7) --------------------------------------------------------
int __thiscall sub_403AF7(_DWORD *this, __int16 *a2)
{
  __int16 *v2; // esi
  int result; // eax
  __int16 v5; // dx

  v2 = a2;
  result = (unsigned __int16)*a2;
  if ( (_WORD)result )
  {
    v5 = *a2;
    do
    {
      sub_403AC7(this, v5);
      result = (unsigned __int16)*++v2;
      v5 = result;
    }
    while ( (_WORD)result );
  }
  return result;
}

//----- (00403B28) --------------------------------------------------------
int __thiscall sub_403B28(_DWORD *this, void *Src, int a3)
{
  int result; // eax

  sub_403C06(this, a3);
  memcpy((void *)(this[512] + 2 * this[514]), Src, 2 * a3);
  result = a3;
  this[514] += a3;
  return result;
}

//----- (00403B67) --------------------------------------------------------
_DWORD *__thiscall sub_403B67(_DWORD *Src)
{
  _DWORD *v2; // edi
  unsigned int v3; // edx

  v2 = (_DWORD *)Src[512];
  Src[512] = 0;
  if ( v2 == Src )
  {
    v2 = sub_403C81(Src[514]);
    memcpy(v2, Src, 2 * Src[514]);
  }
  else
  {
    v3 = Src[514];
    if ( v3 != Src[513] )
      return sub_403CB3(v2, v3);
  }
  return v2;
}

//----- (00403BBC) --------------------------------------------------------
_DWORD *__thiscall sub_403BBC(_DWORD *this, _DWORD *a2, char *a3)
{
  _DWORD *v4; // eax
  void *v5; // ecx
  _DWORD *result; // eax
  char v7; // [esp+Ch] [ebp-4h] BYREF

  v4 = sub_403B67(this);
  if ( a3 == &v7 )
  {
    if ( v4 )
      sub_411C31(v4);
  }
  else
  {
    v5 = *(void **)a3;
    *(_DWORD *)a3 = v4;
    if ( v5 )
      sub_411C31(v5);
  }
  result = a2;
  *a2 = *(_DWORD *)a3;
  a2[1] = this[514] - 1;
  return result;
}

//----- (00403C06) --------------------------------------------------------
void *__thiscall sub_403C06(_DWORD *Src, int a2)
{
  void *result; // eax
  unsigned int v4; // ecx
  unsigned int v5; // edx
  _DWORD *v6; // ecx
  void *v7; // eax
  size_t v8; // ecx

  result = (void *)(Src[514] + a2);
  v4 = Src[513];
  if ( (unsigned int)result > v4 )
  {
    result = (void *)(((unsigned int)result - v4 - 1) & 0xFFFFFC00);
    v5 = (unsigned int)result + v4 + 1024;
    if ( v5 != v4 )
    {
      v6 = (_DWORD *)Src[512];
      Src[513] = v5;
      if ( v6 == Src )
      {
        v7 = sub_403C81(v5);
        v8 = 2 * Src[514];
        Src[512] = v7;
        return memcpy(v7, Src, v8);
      }
      else
      {
        result = sub_403CB3(v6, v5);
        Src[512] = result;
      }
    }
  }
  return result;
}

//----- (00403C75) --------------------------------------------------------
void __noreturn sub_403C75()
{
  std::_Xout_of_range("invalid string_view position");
  JUMPOUT(0x403C80);
}
// 403C7A: control flows out of bounds to 403C80
// 4380C0: using guessed type void __cdecl std::_Xout_of_range(const char *);

//----- (00403C81) --------------------------------------------------------
void *__fastcall sub_403C81(unsigned int a1)
{
  void *v1; // esi

  v1 = 0;
  if ( a1 > 0x7FFFFFFC || (v1 = malloc(2 * a1)) == 0 )
    sub_405A12(dword_423730, 0x41Bu);
  return v1;
}
// 423730: using guessed type int dword_423730;

//----- (00403CB3) --------------------------------------------------------
void *__fastcall sub_403CB3(void *Block, unsigned int a2)
{
  void *v2; // esi

  if ( !Block )
    return sub_403C81(a2);
  v2 = 0;
  if ( a2 > 0x7FFFFFFC || (v2 = realloc(Block, 2 * a2)) == 0 )
    sub_405A12(dword_423730, 0x41Bu);
  return v2;
}
// 423730: using guessed type int dword_423730;

//----- (00403CF3) --------------------------------------------------------
int sub_403CF3()
{
  int *v0; // ebx
  int v1; // eax
  WCHAR *v2; // eax
  wchar_t *v3; // edi
  int v4; // ecx
  int v5; // esi
  int v7; // esi
  int v8; // [esp-4h] [ebp-27Ch]
  __int64 v9; // [esp+10h] [ebp-268h] BYREF
  HANDLE hFindFile; // [esp+1Ch] [ebp-25Ch] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+20h] [ebp-258h] BYREF

  v0 = (int *)dword_423710;
  if ( !dword_423710 )
    return 0;
  v1 = dword_423710;
  while ( !wcspbrk(*(const wchar_t **)(v1 + 4), L"*?") )
  {
    v9 = 0i64;
    if ( sub_403E51(*(wchar_t **)(dword_423710 + 4), byte_41350E, (unsigned int *)&v9, v8) < 0 && (byte_41350C & 8) != 0 )
    {
      v7 = 255;
      goto LABEL_16;
    }
LABEL_12:
    dword_423710 = *v0;
    *v0 = dword_434698;
    dword_434698 = (int)v0;
    v0 = (int *)dword_423710;
    v1 = dword_423710;
    if ( !dword_423710 )
      return 0;
  }
  v2 = sub_4081DE(*(wchar_t **)(dword_423710 + 4), &FindFileData, &hFindFile);
  if ( !v2 )
  {
    sub_405A12(0, 0x42Du, *(_DWORD *)(dword_423710 + 4));
    goto LABEL_12;
  }
  while ( 1 )
  {
    v3 = (wchar_t *)sub_410C5A(*(wchar_t **)(dword_423710 + 4), v2);
    v9 = sub_4081C4((char *)&FindFileData);
    v5 = sub_403E51(v3, byte_41350E, (unsigned int *)&v9, v4);
    free(v3);
    if ( v5 < 0 && (byte_41350C & 8) != 0 )
      break;
    v2 = sub_408369(&FindFileData, hFindFile);
    if ( !v2 )
      goto LABEL_12;
  }
  v7 = -1;
LABEL_16:
  sub_405208(v0);
  return v7;
}
// 403D84: variable 'v4' is possibly undefined
// 403DEF: variable 'v8' is possibly undefined
// 41350C: using guessed type char byte_41350C;
// 41350E: using guessed type char byte_41350E;
// 423710: using guessed type int dword_423710;
// 434698: using guessed type int dword_434698;
// 403CF3: using guessed type __int64 var_268;

//----- (00403E51) --------------------------------------------------------
int __fastcall sub_403E51(wchar_t *a1, char a2, unsigned int *a3, int a4)
{
  int v4; // edi
  int v5; // eax
  _DWORD *v6; // esi
  int v7; // ebx
  unsigned int v8; // eax
  _DWORD *v9; // esi
  _DWORD *v10; // ecx
  void *v12; // [esp-4h] [ebp-14h]
  void *Block; // [esp+Ch] [ebp-4h] BYREF

  v4 = 0;
  Block = 0;
  v5 = sub_403EBD(a1, a2, a3, 0, &Block);
  v6 = Block;
  v7 = v5;
  if ( Block )
  {
    do
    {
      v8 = sub_405325(v6);
      v6 = (_DWORD *)*v6;
      v4 += v8;
    }
    while ( v6 );
    v9 = Block;
    v7 += v4;
    while ( v9 )
    {
      v10 = (_DWORD *)v9[3];
      v12 = v9;
      *v10 = dword_434698;
      dword_434698 = v9[4];
      *(_DWORD *)dword_434698 = v10;
      v9 = (_DWORD *)*v9;
      free(v12);
    }
  }
  return v7;
}
// 434698: using guessed type int dword_434698;

//----- (00403EBD) --------------------------------------------------------
int __fastcall sub_403EBD(wchar_t *a1, char a2, unsigned int *a3, wchar_t *a4, _DWORD *a5)
{
  _DWORD *v7; // eax
  int result; // eax
  char v9; // [esp+Ch] [ebp-4h]

  ++dword_413504;
  v9 = 1;
  v7 = sub_40ECF3(a1, (int)a1, (int)a1);
  if ( !v7 )
  {
    v7 = sub_405232((char *)a1, a2);
    v9 = 0;
  }
  result = sub_403F13((int)v7, a2, a3, v9, a4, a5);
  --dword_413504;
  return result;
}
// 413504: using guessed type int dword_413504;

//----- (00403F13) --------------------------------------------------------
int __fastcall sub_403F13(int a1, char a2, unsigned int *a3, char a4, wchar_t *a5, _DWORD *a6)
{
  int result; // eax
  bool v8; // zf
  int *v9; // esi
  _DWORD *v10; // ebx
  int v11; // esi
  unsigned int v12; // eax
  unsigned int v13; // ecx
  unsigned int *v14; // edx
  char v15; // al
  unsigned int *v16; // edx
  unsigned int v17; // ecx
  int *v18; // ebx
  __int64 v19; // rax
  wchar_t *v20; // ecx
  unsigned int v21; // eax
  int v22; // eax
  wchar_t **v23; // esi
  int v24; // edx
  _DWORD *v25; // esi
  int v26; // ecx
  int v27; // eax
  int v28; // ecx
  __int64 v29; // rax
  unsigned int v30; // ecx
  unsigned int v31; // esi
  _DWORD *v32; // esi
  void *v33; // eax
  _DWORD *v34; // edx
  _DWORD *v35; // ecx
  _DWORD *v36; // esi
  int *i; // ecx
  _DWORD *v38; // esi
  int v39; // ebx
  unsigned int v40; // eax
  _DWORD *v41; // esi
  _DWORD *v42; // ecx
  void **v43; // ebx
  void **v44; // esi
  unsigned __int8 v45; // dl
  int v46; // eax
  char v47; // cl
  _DWORD *v48; // ebx
  wchar_t *v49; // esi
  int v50; // eax
  wchar_t *v51; // eax
  unsigned int v52; // eax
  __int64 v53; // rax
  DWORD dwHighDateTime; // ecx
  int v55; // esi
  int v56; // esi
  _DWORD *v57; // ebx
  int v58; // esi
  int v59; // esi
  int *v60; // ebx
  unsigned int v61; // ebx
  unsigned int v62; // esi
  char v63; // al
  unsigned int v64; // ebx
  unsigned __int64 v65; // kr00_8
  unsigned __int64 v66; // kr08_8
  void **v67; // eax
  _DWORD *v68; // eax
  _DWORD *v69; // ebx
  _DWORD *v70; // esi
  int v71; // edx
  wchar_t *v72; // eax
  int v73; // eax
  char v74; // dl
  const wchar_t *v75; // eax
  unsigned int v76; // eax
  DWORD v77; // eax
  unsigned int v78; // ecx
  DWORD *v79; // edx
  unsigned int v80; // eax
  int v81; // edi
  int v82; // esi
  int v83; // edi
  char v84; // al
  char v85; // al
  char v86; // al
  unsigned int v87; // ecx
  unsigned int v88; // eax
  unsigned int *v89; // edx
  int v90; // edi
  int v91; // esi
  int v92; // edi
  int v93; // [esp-4h] [ebp-4FCh]
  void *v94; // [esp-4h] [ebp-4FCh]
  int v95; // [esp-4h] [ebp-4FCh]
  struct _FILETIME SystemTimeAsFileTime; // [esp+10h] [ebp-4E8h] BYREF
  DWORD *v97; // [esp+18h] [ebp-4E0h]
  void *v98; // [esp+1Ch] [ebp-4DCh]
  _DWORD *v99; // [esp+20h] [ebp-4D8h]
  unsigned int v100; // [esp+24h] [ebp-4D4h]
  wchar_t *v101; // [esp+28h] [ebp-4D0h]
  int v102; // [esp+2Ch] [ebp-4CCh] BYREF
  void *Block; // [esp+30h] [ebp-4C8h] BYREF
  _DWORD *v104; // [esp+34h] [ebp-4C4h]
  unsigned __int64 v105; // [esp+38h] [ebp-4C0h] BYREF
  unsigned int *v106; // [esp+40h] [ebp-4B8h]
  _DWORD *v107; // [esp+44h] [ebp-4B4h] BYREF
  unsigned int v108; // [esp+48h] [ebp-4B0h]
  int v109; // [esp+4Ch] [ebp-4ACh]
  unsigned __int64 v110; // [esp+50h] [ebp-4A8h] BYREF
  int v111; // [esp+58h] [ebp-4A0h]
  wchar_t *v112; // [esp+5Ch] [ebp-49Ch] BYREF
  int v113; // [esp+60h] [ebp-498h] BYREF
  unsigned int v114; // [esp+64h] [ebp-494h]
  _DWORD *v115; // [esp+68h] [ebp-490h]
  unsigned int v116; // [esp+6Ch] [ebp-48Ch]
  unsigned int v117; // [esp+70h] [ebp-488h]
  unsigned int v118; // [esp+74h] [ebp-484h]
  unsigned int v119; // [esp+78h] [ebp-480h]
  int v120; // [esp+7Ch] [ebp-47Ch] BYREF
  int v121; // [esp+80h] [ebp-478h]
  int *v122; // [esp+84h] [ebp-474h]
  unsigned __int64 v123; // [esp+88h] [ebp-470h]
  int v124; // [esp+90h] [ebp-468h]
  char v125; // [esp+97h] [ebp-461h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+98h] [ebp-460h] BYREF
  __int16 v127[262]; // [esp+2E8h] [ebp-210h] BYREF

  v101 = a5;
  v112 = a5;
  result = 0;
  v125 = a2;
  v106 = a3;
  v124 = 0;
  v120 = 0;
  if ( !a1 )
  {
    *a3 = 0;
    a3[1] = 0;
    return result;
  }
  v8 = (*(_BYTE *)(a1 + 9) & 1) == 0;
  v9 = (int *)(a1 + 4);
  v122 = (int *)(a1 + 4);
  if ( v8 )
  {
    v122 = (int *)(a1 + 4);
  }
  else
  {
    sub_405A12(0, 0x42Fu, *v9);
    a2 = v125;
  }
  v10 = *(_DWORD **)(a1 + 28);
  if ( v10 )
  {
    v11 = sub_40547A((_DWORD *)*v10);
    sub_405498(v10);
    *(_DWORD *)(a1 + 28) = 0;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a1 + 20);
    goto LABEL_8;
  }
  v15 = *(_BYTE *)(a1 + 9);
  if ( (v15 & 2) != 0 )
  {
    if ( (a2 & 1) != 0 )
      sub_40D34F(2 * dword_413504, *v9, *(FILETIME *)(a1 + 16));
    v16 = v106;
    v17 = *(_DWORD *)(a1 + 20);
    *v106 = *(_DWORD *)(a1 + 16);
    v16[1] = v17;
    if ( (byte_41350C & 8) == 0 && dword_413504 == 1 && (*(_BYTE *)(a1 + 9) & 4) == 0 )
    {
      if ( sub_4081DE((wchar_t *)*v9, &FindFileData, (HANDLE *)&v102) )
        sub_405AEC(2u, *v9);
    }
    return (*(unsigned __int8 *)(a1 + 9) >> 2) & 1;
  }
  v97 = 0;
  v18 = 0;
  Block = 0;
  HIDWORD(v19) = 0;
  *(_BYTE *)(a1 + 9) = v15 | 1;
  LODWORD(v19) = *(_DWORD *)(a1 + 24);
  v115 = 0;
  v107 = 0;
  v99 = 0;
  v111 = 0;
  v121 = 0;
  v123 = 0i64;
  v119 = 0;
  v117 = 0;
  v105 = 0i64;
  v100 = 0;
  v110 = 0i64;
  v108 = 0;
  v20 = (wchar_t *)*v9;
  v109 = 0;
  v113 = 0;
  dword_423F54 = v20;
  dword_423F58 = (int)v20;
  v118 = v19;
  if ( !(_DWORD)v19 )
  {
LABEL_124:
    dword_423F48 = 0;
    dword_423F4C = 0;
    v61 = *v106;
    v62 = v106[1];
    v8 = *(_QWORD *)v106 == 0i64;
    HIDWORD(v123) = *v106;
    v118 = v62;
    if ( v8 )
    {
      if ( *(_QWORD *)(a1 + 16) )
      {
        v61 = *(_DWORD *)(a1 + 16);
        v62 = *(_DWORD *)(a1 + 20);
        HIDWORD(v123) = v61;
        v118 = v62;
      }
      else if ( sub_4081DE(v20, &FindFileData, (HANDLE *)&v102) )
      {
        v65 = sub_4081C4((char *)&FindFileData);
        v62 = HIDWORD(v65);
        v61 = v65;
        v66 = __PAIR64__(v62, v61);
        v118 = HIDWORD(v66);
        HIDWORD(v123) = v66;
      }
    }
    if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
      sub_40D34F(2 * dword_413504, *v122, (FILETIME)__PAIR64__(v62, v61));
    v67 = sub_40E9A3(a1, (wchar_t *)v127, (int)v20, __PAIR64__(v62, v61), &v107, &v113, &v120, &v110, &v112);
    v98 = v67;
    if ( v67 && !v111 )
    {
      v68 = v67[3];
      dword_423F4C = v127;
      v99 = v68;
    }
    v69 = v107;
    v70 = (_DWORD *)v113;
    v71 = v120;
    v72 = (wchar_t *)*v122;
    v108 = (unsigned int)v72;
    dword_423F54 = v72;
    dword_423F58 = (int)v72;
    dword_423F50 = (int)v107;
    dword_423F44 = v113;
    v124 = v120;
    if ( byte_423737 && (*(_BYTE *)(a1 + 9) & 8) == 0 || !v120 )
    {
      v73 = HIDWORD(v123);
      if ( __PAIR64__(v118, HIDWORD(v123)) < v110 || byte_423736 && __PAIR64__(v118, HIDWORD(v123)) == v110 )
      {
LABEL_153:
        v74 = byte_434478;
        v125 = byte_434478;
        byte_434478 = 1;
        if ( v111 )
        {
          v75 = v112;
          if ( !v112 )
          {
            if ( v113 )
              v75 = *(const wchar_t **)(v113 + 4);
            else
              v75 = 0;
          }
          v76 = sub_405D5A((char *)*v122, *(_DWORD **)(v111 + 8), *(_DWORD *)(v111 + 12), *(_BYTE *)(v111 + 16), v75);
          goto LABEL_174;
        }
        if ( v99 )
        {
          if ( *((_BYTE *)v98 + 20) && (byte_41350C & 0x40) == 0 )
          {
            sub_405279(a6, (int)v98, a1, v118);
LABEL_163:
            byte_434478 = v125;
            goto LABEL_164;
          }
          v76 = sub_405D5A((char *)*v122, v99, *((_DWORD *)v98 + 4), *(_BYTE *)(a1 + 8), v112);
LABEL_174:
          v124 = v76 + v120;
          goto LABEL_163;
        }
        if ( (byte_41350C & 0x10) != 0 )
        {
          if ( v121 )
          {
            v80 = sub_405D5A((char *)*v122, *(_DWORD **)(v121 + 8), *(_DWORD *)(v121 + 12), *(_BYTE *)(v121 + 16), v112);
            v124 = v80 + v120;
            v74 = v125;
          }
        }
        else if ( !a4 && !(v118 | v73) )
        {
          if ( !byte_423737 )
          {
            sub_405A12(0, 0x431u, *v122);
            byte_434478 = v125;
LABEL_179:
            if ( dword_423F44 )
            {
              v78 = HIDWORD(v110);
              v77 = v110;
LABEL_165:
              v79 = v97;
              v117 = v78;
              v119 = v77;
              if ( v97 && v111 )
              {
                *v97 = v77;
                v79[1] = v78;
              }
              v71 = v124;
LABEL_169:
              if ( byte_423737 && v71 )
              {
                v8 = (*(_BYTE *)(a1 + 9) & 8) == 0;
                byte_413020 = 0;
                if ( v8 )
                {
                  if ( dword_413504 == 1 )
                    sub_405A12(0, 0xFAAu, *v122);
                }
                else
                {
                  sub_405A12(0, 0xFABu, *v122);
                }
              }
              if ( (byte_41350C & 8) != 0 && dword_413504 == 1 )
              {
                if ( v70 == v69 )
                {
                  if ( v70 )
                  {
                    v83 = (int)v70;
                    do
                    {
                      v70 = (_DWORD *)*v70;
                      free(*(void **)(v83 + 4));
                      *(_DWORD *)v83 = dword_434698;
                      dword_434698 = v83;
                      v83 = (int)v70;
                    }
                    while ( v70 );
                  }
                }
                else
                {
                  if ( v70 )
                  {
                    v81 = (int)v70;
                    do
                    {
                      v70 = (_DWORD *)*v70;
                      free(*(void **)(v81 + 4));
                      *(_DWORD *)v81 = dword_434698;
                      dword_434698 = v81;
                      v81 = (int)v70;
                    }
                    while ( v70 );
                  }
                  if ( v69 )
                  {
                    v82 = (int)v69;
                    do
                    {
                      v69 = (_DWORD *)*v69;
                      free(*(void **)(v82 + 4));
                      *(_DWORD *)v82 = dword_434698;
                      dword_434698 = v82;
                      v82 = (int)v69;
                    }
                    while ( v69 );
                  }
                }
                return -(dword_423F40 != 0);
              }
              else
              {
                v84 = *(_BYTE *)(a1 + 9) & 0xFE;
                v8 = *(_DWORD *)(a1 + 28) == 0;
                *(_BYTE *)(a1 + 9) = v84;
                if ( v8 )
                {
                  v85 = v84 | 2;
                  if ( v124 <= 0 )
                    v86 = v85 & 0xFB;
                  else
                    v86 = v85 | 4;
                  *(_BYTE *)(a1 + 9) = v86;
                }
                v87 = v118;
                if ( v117 < v118 )
                {
                  v88 = HIDWORD(v123);
                }
                else if ( v117 > v118 || (v88 = HIDWORD(v123), v119 > HIDWORD(v123)) )
                {
                  v87 = v117;
                  v88 = v119;
                }
                v89 = v106;
                *(_DWORD *)(a1 + 16) = v88;
                *(_DWORD *)(a1 + 20) = v87;
                *v89 = v88;
                v89[1] = v87;
                if ( v70 == v69 )
                {
                  if ( v70 )
                  {
                    v92 = (int)v70;
                    do
                    {
                      v70 = (_DWORD *)*v70;
                      free(*(void **)(v92 + 4));
                      *(_DWORD *)v92 = dword_434698;
                      dword_434698 = v92;
                      v92 = (int)v70;
                    }
                    while ( v70 );
                  }
                }
                else
                {
                  if ( v70 )
                  {
                    v90 = (int)v70;
                    do
                    {
                      v70 = (_DWORD *)*v70;
                      free(*(void **)(v90 + 4));
                      *(_DWORD *)v90 = dword_434698;
                      dword_434698 = v90;
                      v90 = (int)v70;
                    }
                    while ( v70 );
                  }
                  if ( v69 )
                  {
                    v91 = (int)v69;
                    do
                    {
                      v69 = (_DWORD *)*v69;
                      free(*(void **)(v91 + 4));
                      *(_DWORD *)v91 = dword_434698;
                      dword_434698 = v91;
                      v91 = (int)v69;
                    }
                    while ( v69 );
                  }
                }
                return v124;
              }
            }
LABEL_164:
            GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
            v78 = (unsigned __int64)(*(_QWORD *)&SystemTimeAsFileTime + 2i64) >> 32;
            v77 = SystemTimeAsFileTime.dwLowDateTime + 2;
            goto LABEL_165;
          }
          v124 = 1;
        }
        byte_434478 = v74;
        goto LABEL_179;
      }
      if ( !(v118 | HIDWORD(v123)) && !v110 || (*(_BYTE *)(a1 + 8) & 0x10) != 0 )
      {
        v73 = HIDWORD(v123);
        goto LABEL_153;
      }
      v72 = (wchar_t *)v108;
    }
    if ( (byte_41350C & 8) == 0 && dword_413504 == 1 && (*(_BYTE *)(a1 + 9) & 8) == 0 )
    {
      sub_405AEC(2u, v72);
      v71 = v120;
    }
    goto LABEL_169;
  }
  if ( (*(_BYTE *)(*(_DWORD *)(v19 + 4) + 16) & 0x20) != 0 )
  {
    if ( sub_4081DE(v20, &FindFileData, (HANDLE *)&v102) )
    {
      v19 = sub_4081C4((char *)&FindFileData);
      v123 = v19;
    }
    else
    {
      HIDWORD(v19) = 0;
    }
  }
  v21 = v118;
  while ( 1 )
  {
    v22 = *(_DWORD *)(v21 + 4);
    v116 = 0;
    v114 = 0;
    v121 = v22;
    v23 = (wchar_t **)v122;
    if ( !*(_QWORD *)(v22 + 24) )
      break;
    if ( __PAIR64__(HIDWORD(v19), v123) <= *(_QWORD *)(v121 + 24) )
    {
      HIDWORD(v19) = *(_DWORD *)(v121 + 28);
      LODWORD(v123) = *(_DWORD *)(v121 + 24);
      HIDWORD(v123) = HIDWORD(v19);
    }
LABEL_122:
    v21 = *(_DWORD *)v118;
    v118 = v21;
    if ( !v21 )
    {
      v20 = *v23;
      goto LABEL_124;
    }
  }
  v24 = *v122;
  v97 = (DWORD *)(v121 + 24);
  v25 = sub_404D4A(v121, v24);
  v104 = v25;
  v98 = v25;
  if ( !v25 )
    goto LABEL_55;
  while ( 1 )
  {
    v26 = v25[3];
    LODWORD(v105) = v25[2];
    HIDWORD(v105) = v26;
    v27 = sub_403EBD((wchar_t *)v25[1], *(_BYTE *)(v121 + 16), (unsigned int *)&v105, 0, &Block);
    v28 = v27 + v124;
    v124 = v28;
    v120 = v28;
    if ( byte_423737 && v27 )
    {
      if ( (*((_BYTE *)sub_40ECF3((wchar_t *)v25[1], v28, v28) + 9) & 8) == 0 )
      {
        v93 = v25[1];
        byte_413020 = 0;
        sub_405A12(0, 0xFAAu, v93);
      }
      *(_BYTE *)(a1 + 9) |= 8u;
    }
    HIDWORD(v29) = HIDWORD(v105);
    v30 = v105;
    if ( __PAIR64__(v114, v116) <= v105 )
    {
      v114 = HIDWORD(v105);
      v116 = v105;
    }
    v31 = HIDWORD(v123);
    if ( !v123 && (*(_BYTE *)(v121 + 16) & 0x20) == 0 )
    {
      if ( sub_4081DE((wchar_t *)*v122, &FindFileData, (HANDLE *)&v102) )
      {
        v29 = sub_4081C4((char *)&FindFileData);
        v30 = v105;
        v31 = HIDWORD(v29);
        HIDWORD(v29) = HIDWORD(v105);
        v123 = __PAIR64__(v31, v29);
        *(_DWORD *)(a1 + 16) = v29;
        *(_DWORD *)(a1 + 20) = v31;
        goto LABEL_41;
      }
      HIDWORD(v29) = HIDWORD(v105);
      v30 = v105;
    }
    LODWORD(v29) = v123;
LABEL_41:
    if ( (*(_BYTE *)(a1 + 8) & 0x10) != 0
      || v31 < HIDWORD(v29)
      || v31 <= HIDWORD(v29) && (unsigned int)v29 < v30
      || byte_423736 && __PAIR64__(v29, v31) == __PAIR64__(v30, HIDWORD(v29)) )
    {
      v32 = sub_40EB4F();
      v33 = sub_40EBA1((char *)v104[1]);
      v34 = v115;
      v35 = &v107;
      for ( v32[1] = v33; v34; v34 = (_DWORD *)*v34 )
        v35 = v34;
      *v35 = v32;
      v115 = v107;
    }
    v36 = sub_40EB4F();
    v36[1] = sub_40EBA1((char *)v104[1]);
    for ( i = &v113; v18; v18 = (int *)*v18 )
      i = v18;
    *i = (int)v36;
    v25 = (_DWORD *)*v104;
    v104 = v25;
    if ( !v25 )
      break;
    v18 = (int *)v113;
  }
  v109 = v113;
LABEL_55:
  v38 = Block;
  if ( Block )
  {
    v39 = 0;
    do
    {
      v40 = sub_405325(v38);
      v38 = (_DWORD *)*v38;
      v39 += v40;
    }
    while ( v38 );
    v41 = Block;
    v124 += v39;
    v120 = v124;
    while ( v41 )
    {
      v42 = (_DWORD *)v41[3];
      v94 = v41;
      *v42 = dword_434698;
      dword_434698 = v41[4];
      *(_DWORD *)dword_434698 = v42;
      v41 = (_DWORD *)*v41;
      free(v94);
    }
    Block = 0;
  }
  v43 = (void **)v98;
  while ( 1 )
  {
    v44 = v43;
    if ( !v43 )
      break;
    free(v43[1]);
    v43 = (void **)*v43;
    free(v44);
  }
  v45 = *(_BYTE *)(v121 + 16);
  v46 = *(_DWORD *)(v121 + 8);
  if ( (v45 & 0x20) == 0 )
  {
    if ( v46 )
    {
      if ( v111 )
        sub_405A12(0, 0xFA4u, *v122);
      else
        v111 = v121;
    }
    if ( v108 <= v114 && (v108 < v114 || v100 <= v116) )
    {
      v100 = v116;
      v108 = v114;
      v110 = __PAIR64__(v114, v116);
    }
LABEL_118:
    v11 = v124;
    goto LABEL_119;
  }
  if ( !v46 )
    goto LABEL_118;
  v47 = byte_423737;
  dword_423F48 = 0;
  dword_423F4C = 0;
  v48 = (_DWORD *)v109;
  dword_423F50 = (int)v115;
  dword_423F44 = v109;
  v49 = (wchar_t *)*v122;
  dword_423F54 = v49;
  dword_423F58 = (int)v49;
  if ( byte_423737 && (*(_BYTE *)(a1 + 9) & 8) == 0 || !v124 )
  {
    if ( HIDWORD(v123) >= v114 )
    {
      v50 = v123;
      if ( HIDWORD(v123) > v114 || (unsigned int)v123 >= v116 )
        goto LABEL_75;
    }
    goto LABEL_81;
  }
  v50 = v123;
LABEL_75:
  if ( byte_423736 && v50 == v116 && (v50 = v123, HIDWORD(v123) == v114)
    || !(HIDWORD(v123) | v50) && !(v114 | v116)
    || !*(_DWORD *)v121 )
  {
LABEL_81:
    v125 = byte_434478;
    v51 = v101;
    byte_434478 = 1;
    if ( !v101 )
    {
      if ( v109 )
        v51 = *(wchar_t **)(v109 + 4);
      else
        v51 = 0;
      v112 = v51;
      v101 = v51;
    }
    v52 = sub_405D5A((char *)v49, *(_DWORD **)(v121 + 8), *(_DWORD *)(v121 + 12), v45, v51);
    v8 = (*(_BYTE *)(a1 + 8) & 4) == 0;
    v124 += v52;
    v120 = v124;
    if ( v8 && sub_4081DE((wchar_t *)*v122, &FindFileData, (HANDLE *)&v102) )
    {
      v53 = sub_4081C4((char *)&FindFileData);
      dwHighDateTime = HIDWORD(v53);
      goto LABEL_92;
    }
    if ( v108 | v100 )
    {
      LODWORD(v53) = v100;
      v119 = v100;
      dwHighDateTime = v108;
      v117 = v108;
    }
    else
    {
      GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
      LODWORD(v53) = SystemTimeAsFileTime.dwLowDateTime;
      dwHighDateTime = SystemTimeAsFileTime.dwHighDateTime;
LABEL_92:
      v117 = dwHighDateTime;
      v119 = v53;
    }
    v55 = v121;
    *(_DWORD *)(v121 + 24) = v53;
    *(_DWORD *)(v55 + 28) = dwHighDateTime;
    if ( v48 == v115 )
    {
      if ( v48 )
      {
        v59 = (int)v48;
        do
        {
          v48 = (_DWORD *)*v48;
          free(*(void **)(v59 + 4));
          *(_DWORD *)v59 = dword_434698;
          dword_434698 = v59;
          v59 = (int)v48;
        }
        while ( v48 );
      }
    }
    else
    {
      if ( v48 )
      {
        v56 = (int)v48;
        do
        {
          v48 = (_DWORD *)*v48;
          free(*(void **)(v56 + 4));
          *(_DWORD *)v56 = dword_434698;
          dword_434698 = v56;
          v56 = (int)v48;
        }
        while ( v48 );
      }
      v57 = v115;
      if ( v115 )
      {
        v58 = (int)v115;
        do
        {
          v57 = (_DWORD *)*v57;
          free(*(void **)(v58 + 4));
          *(_DWORD *)v58 = dword_434698;
          dword_434698 = v58;
          v58 = (int)v57;
        }
        while ( v57 );
      }
    }
    v47 = byte_423737;
    v115 = 0;
    v107 = 0;
    v109 = 0;
    v113 = 0;
    byte_434478 = v125;
  }
  if ( !v47 )
    goto LABEL_118;
  v60 = v122;
  if ( (*(_BYTE *)(a1 + 9) & 8) != 0 )
  {
    sub_405A12(0, 0xFABu, *v122);
    *(_BYTE *)(a1 + 9) &= ~8u;
  }
  v11 = v124;
  if ( v124 )
  {
    v95 = *v60;
    v11 = 0;
    byte_413020 = 0;
    v124 = 0;
    v120 = 0;
    sub_405A12(0, 0xFAAu, v95);
  }
LABEL_119:
  if ( (*(_BYTE *)(v121 + 16) & 0x20) == 0 || *(_DWORD *)v118 )
  {
    HIDWORD(v19) = HIDWORD(v123);
    v23 = (wchar_t **)v122;
    v18 = (int *)v109;
    goto LABEL_122;
  }
  if ( v11 <= 0 )
    v63 = *(_BYTE *)(a1 + 9) & 0xF8 | 2;
  else
    v63 = *(_BYTE *)(a1 + 9) & 0xF8 | 6;
  v13 = HIDWORD(v123);
  v64 = v117;
  *(_BYTE *)(a1 + 9) = v63;
  if ( v64 < v13 )
  {
    v12 = v123;
  }
  else if ( v64 > v13 || (v12 = v123, v119 > (unsigned int)v123) )
  {
    v12 = v119;
    v13 = v64;
  }
  *(_DWORD *)(a1 + 16) = v12;
  *(_DWORD *)(a1 + 20) = v13;
LABEL_8:
  v14 = v106;
  *v106 = v12;
  result = v11;
  v14[1] = v13;
  return result;
}
// 40489B: variable 'v20' is possibly undefined
// 413020: using guessed type char byte_413020;
// 413504: using guessed type int dword_413504;
// 41350C: using guessed type char byte_41350C;
// 423736: using guessed type char byte_423736;
// 423737: using guessed type char byte_423737;
// 423F40: using guessed type int dword_423F40;
// 423F44: using guessed type int dword_423F44;
// 423F48: using guessed type int dword_423F48;
// 423F50: using guessed type int dword_423F50;
// 423F58: using guessed type int dword_423F58;
// 434478: using guessed type char byte_434478;
// 434698: using guessed type int dword_434698;
// 403F13: using guessed type wchar_t var_210[262];

//----- (00404D4A) --------------------------------------------------------
_DWORD *__fastcall sub_404D4A(int a1, int a2)
{
  _DWORD *v2; // ebx
  int v3; // edi
  int v4; // eax
  __int16 *v5; // ecx
  __int16 v6; // si
  __int16 v7; // dx
  __int16 *v8; // edi
  __int16 *v9; // esi
  __int16 *v10; // esi
  char *v11; // edi
  int v12; // ecx
  wchar_t *v13; // ebx
  wchar_t *v14; // esi
  wchar_t *v15; // esi
  _DWORD *v16; // ebx
  wchar_t *v17; // ecx
  rsize_t v19; // esi
  wchar_t *v20; // eax
  WCHAR *v21; // eax
  __int64 v22; // rax
  bool v23; // zf
  _DWORD *v24; // ecx
  char v26; // [esp+13h] [ebp-295h]
  wchar_t *Source; // [esp+14h] [ebp-294h] BYREF
  unsigned __int16 *v28; // [esp+18h] [ebp-290h] BYREF
  _DWORD *v29; // [esp+1Ch] [ebp-28Ch] BYREF
  HANDLE hFindFile; // [esp+20h] [ebp-288h] BYREF
  _DWORD *v31; // [esp+24h] [ebp-284h]
  unsigned int v32; // [esp+28h] [ebp-280h]
  __int16 *v33; // [esp+2Ch] [ebp-27Ch] BYREF
  wchar_t *v34; // [esp+30h] [ebp-278h]
  int v35; // [esp+34h] [ebp-274h]
  int v36; // [esp+38h] [ebp-270h] BYREF
  __int16 *v37[2]; // [esp+3Ch] [ebp-26Ch] BYREF
  __int16 *v38; // [esp+44h] [ebp-264h]
  int v39; // [esp+48h] [ebp-260h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+50h] [ebp-258h] BYREF

  v2 = *(_DWORD **)a1;
  hFindFile = 0;
  v35 = a2;
  v31 = v2;
  v3 = 0;
  v4 = *(_DWORD *)(a1 + 4);
  v29 = 0;
  v36 = v4;
  if ( v2 )
  {
    do
    {
      v5 = (__int16 *)v2[1];
      v6 = *v5;
      if ( *v5 )
      {
        v7 = *v5;
        do
        {
          v6 = v7;
          if ( v7 == 36 )
            break;
          if ( v7 == 94 )
            ++v5;
          v7 = *++v5;
          v6 = *v5;
        }
        while ( *v5 );
        v2 = v31;
        a2 = v35;
      }
      v8 = (__int16 *)v2[1];
      v34 = (wchar_t *)v8;
      if ( v6 )
      {
        dword_423F48 = a2;
        Source = 0;
        v37[0] = v8;
        sub_40F8BE(&v39, v37, 1, &v36, 0, (char *)&Source);
        v8 = (__int16 *)Source;
        v34 = Source;
      }
      v9 = (__int16 *)sub_40EBA1((char *)v8);
      v38 = v9;
      v33 = v9;
      if ( sub_4050C0(&v33, (__int16 **)&v28) )
      {
        do
        {
          v10 = (__int16 *)v28;
          v11 = (char *)v28;
          v12 = *v28;
          if ( v12 == 123 )
          {
            while ( (_WORD)v12 != 125 )
            {
              if ( (_WORD)v12 == 94 )
                v11 += 2;
              v11 += 2;
              LOWORD(v12) = *(_WORD *)v11;
              if ( !*(_WORD *)v11 )
                goto LABEL_21;
            }
            *(_WORD *)v11 = 0;
            v11 += 2;
            ++v10;
          }
          else
          {
            v10 = 0;
          }
          v28 = (unsigned __int16 *)v10;
LABEL_21:
          v26 = 0;
          FindFileData.ftCreationTime.dwLowDateTime = 0;
          FindFileData.ftCreationTime.dwHighDateTime = 0;
          FindFileData.ftLastWriteTime.dwLowDateTime = 0;
          FindFileData.ftLastWriteTime.dwHighDateTime = 0;
          v13 = (wchar_t *)sub_40EBA1(v11);
          Source = v13;
          if ( (wcspbrk((const wchar_t *)v11, L"*?") || v10)
            && (v14 = (wchar_t *)sub_40838C((wchar_t *)v10, (wchar_t *)v11, &FindFileData, &hFindFile)) != 0 )
          {
            v26 = 1;
            free(v13);
            v11 = (char *)v14;
            v15 = (wchar_t *)sub_410C5A(v14, FindFileData.cFileName);
            Source = v15;
          }
          else
          {
            v15 = Source;
          }
          do
          {
            v16 = sub_40B50E(0x10u);
            if ( !wcschr(v15, 0x20u) || wcschr(v15, 0x22u) )
            {
              v16[1] = sub_40EBA1((char *)v15);
            }
            else
            {
              v17 = v15 + 1;
              while ( *v15++ )
                ;
              v19 = v15 - v17 + 3;
              v20 = (wchar_t *)sub_40B4E9((unsigned __int64)v19 >> 31 != 0 ? -1 : 2 * v19);
              v16[1] = v20;
              wcscpy_s(v20, v19, ::Source);
              wcscat_s((wchar_t *)v16[1], v19, Source);
              wcscat_s((wchar_t *)v16[1], v19, ::Source);
              v15 = Source;
            }
            if ( !byte_423735 || (v21 = sub_4081DE(v15, &FindFileData, &hFindFile)) != 0 )
            {
              v22 = sub_4081C4((char *)&FindFileData);
              v32 = HIDWORD(v22);
              v37[1] = (__int16 *)v22;
              HIDWORD(v22) = v22;
              v16[3] = v32;
            }
            else
            {
              v22 = 0i64;
              v16[3] = 0;
              v32 = 0;
            }
            v23 = byte_423735 == 0;
            v16[2] = v22;
            if ( v23 )
            {
              sub_40ECA6(&v29, v16);
            }
            else
            {
              v24 = v29;
              if ( !v29 )
                goto LABEL_43;
              LODWORD(v22) = v29;
              do
              {
                if ( __PAIR64__(v32, HIDWORD(v22)) > *(_QWORD *)(v22 + 8) )
                  break;
                v24 = (_DWORD *)v22;
                LODWORD(v22) = *(_DWORD *)v22;
              }
              while ( (_DWORD)v22 );
              v15 = Source;
              if ( v24 == (_DWORD *)v22 )
              {
LABEL_43:
                v29 = v16;
              }
              else
              {
                *v24 = v16;
                *v16 = v22;
              }
            }
            free(v15);
            if ( !v26 )
              break;
            if ( !wcspbrk((const wchar_t *)v11, L"*?") )
              break;
            if ( !sub_408369(&FindFileData, hFindFile) )
              break;
            v15 = (wchar_t *)sub_410C5A((wchar_t *)v11, FindFileData.cFileName);
            Source = v15;
          }
          while ( v15 );
        }
        while ( sub_4050C0(&v33, (__int16 **)&v28) );
        v2 = v31;
        v8 = (__int16 *)v34;
        v9 = v38;
      }
      if ( v8 != (__int16 *)v2[1] )
        free(v8);
      free(v9);
      v2 = (_DWORD *)*v2;
      a2 = v35;
      v31 = v2;
    }
    while ( v2 );
    return v29;
  }
  return (_DWORD *)v3;
}
// 423735: using guessed type char byte_423735;
// 423F48: using guessed type int dword_423F48;

//----- (004050C0) --------------------------------------------------------
char __fastcall sub_4050C0(__int16 **a1, __int16 **a2)
{
  __int16 **v2; // ebx
  __int16 *v3; // esi
  __int16 v4; // di
  __int16 v5; // cx
  __int16 v7; // cx
  __int16 v8; // dx
  bool v9; // zf
  __int16 v10; // ax
  __int16 v11; // ax
  int v12; // eax
  __int16 v13; // cx
  __int16 v14; // dx
  __int16 v15; // cx

  v2 = a1;
  v3 = *a1;
  v4 = **a1;
  if ( v4 )
  {
    v5 = **a1;
    do
    {
      if ( v5 != 32 )
      {
        v4 = v5;
        if ( v5 != 9 )
          break;
      }
      v5 = *++v3;
      v4 = *v3;
    }
    while ( *v3 );
    v2 = a1;
  }
  *a2 = v3;
  if ( !v4 )
    return 0;
  v7 = 34;
  if ( v4 == 34 )
  {
    do
    {
      v8 = v7;
      if ( !v7 )
        break;
      v7 = *++v3;
      v8 = *v3;
    }
    while ( *v3 != 34 );
LABEL_12:
    if ( !v8 )
      sub_405A12(0, 0x40Eu);
    v9 = *++v3 == 0;
    goto LABEL_33;
  }
  v10 = v4;
  if ( v4 == 123 )
  {
    while ( 1 )
    {
      if ( *++v3 == 34 )
      {
        ++v3;
        do
        {
          v11 = *v3;
          if ( !*v3 )
            break;
          ++v3;
        }
        while ( v11 != 34 );
      }
      v12 = (unsigned __int16)*v3;
      if ( v12 == 125 )
        break;
      if ( !(_WORD)v12 )
      {
        sub_405A12(0, 0x423u);
        break;
      }
    }
    v13 = *++v3;
    v10 = *v3;
    if ( *v3 == 34 )
    {
      do
      {
        v8 = v13;
        if ( !v13 )
          break;
        v13 = *++v3;
        v8 = *v3;
      }
      while ( *v3 != 34 );
      goto LABEL_12;
    }
  }
  v14 = v10;
  if ( v10 )
  {
    v15 = v10;
    while ( v15 != 32 )
    {
      v14 = v15;
      if ( v15 != 9 )
      {
        v15 = *++v3;
        v14 = *v3;
        if ( *v3 )
          continue;
      }
      goto LABEL_32;
    }
    goto LABEL_34;
  }
LABEL_32:
  v9 = v14 == 0;
LABEL_33:
  if ( !v9 )
LABEL_34:
    *v3++ = 0;
  *v2 = v3;
  return 1;
}

//----- (00405208) --------------------------------------------------------
int __thiscall sub_405208(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // edi
  int result; // eax

  v1 = this;
  v2 = (int)this;
  while ( v1 )
  {
    v1 = (_DWORD *)*v1;
    free(*(void **)(v2 + 4));
    result = dword_434698;
    *(_DWORD *)v2 = dword_434698;
    dword_434698 = v2;
    v2 = (int)v1;
  }
  return result;
}
// 434698: using guessed type int dword_434698;

//----- (00405232) --------------------------------------------------------
_DWORD *__fastcall sub_405232(char *Src, char a2)
{
  _DWORD *v4; // edi
  int v5; // ecx
  int *v6; // ecx
  _DWORD *result; // eax

  v4 = sub_40B50E(0x20u);
  v4[1] = sub_40EBA1(Src);
  *((_BYTE *)v4 + 8) = a2;
  *((_BYTE *)v4 + 9) = 0;
  v4[4] = 0;
  v4[5] = 0;
  v4[6] = 0;
  v6 = &dword_423510[sub_40ECBB((wint_t *)Src, v5)];
  *v4 = *v6;
  result = v4;
  *v6 = (int)v4;
  return result;
}
// 405261: variable 'v5' is possibly undefined
// 423510: using guessed type int dword_423510[128];

//----- (00405279) --------------------------------------------------------
int __fastcall sub_405279(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // eax
  _DWORD *v6; // esi
  _DWORD *v7; // edi
  _DWORD *v8; // esi
  _DWORD *v9; // esi
  int result; // eax

  v5 = a2;
  v6 = 0;
  v7 = (_DWORD *)*a1;
  if ( !*a1 )
    goto LABEL_7;
  do
  {
    if ( v7[1] == v5 )
    {
      if ( *((_BYTE *)v7 + 8) == *(_BYTE *)(a3 + 8) )
        break;
      v5 = a2;
    }
    v6 = v7;
    v7 = (_DWORD *)*v7;
  }
  while ( v7 );
  if ( !v7 )
  {
LABEL_7:
    v7 = sub_40B50E(0x14u);
    v7[1] = a2;
    *((_BYTE *)v7 + 8) = *(_BYTE *)(a3 + 8);
    if ( v6 )
    {
      *v6 = v7;
    }
    else if ( *a1 )
    {
      *(_DWORD *)*a1 = v7;
    }
    else
    {
      *a1 = v7;
    }
  }
  v8 = sub_40EB4F();
  v8[1] = sub_40EBA1(*(char **)(a3 + 4));
  sub_40ECA6((_DWORD **)v7 + 3, v8);
  v9 = sub_40EB4F();
  v9[1] = sub_40EBA1((char *)dword_423F4C);
  sub_40ECA6((_DWORD **)v7 + 4, v9);
  result = a3;
  *(_DWORD *)(a3 + 28) = a1;
  return result;
}

//----- (00405325) --------------------------------------------------------
unsigned int __thiscall sub_405325(_DWORD *this)
{
  _DWORD *v1; // ebx
  int v2; // edi
  _DWORD *v3; // esi
  const unsigned __int16 *v4; // edx
  wchar_t *v5; // edi
  int **v6; // esi
  const wchar_t *v7; // eax
  const wchar_t *v8; // eax
  int v9; // edx
  _DWORD *v10; // ecx
  _DWORD *v11; // edx
  int v12; // ecx
  int **i; // esi
  _DWORD *v14; // eax
  int v16; // [esp-Ch] [ebp-2Ch]
  unsigned __int8 v17; // [esp-8h] [ebp-28h]
  rsize_t SizeInWords; // [esp+10h] [ebp-10h]
  unsigned int SizeInWordsa; // [esp+10h] [ebp-10h]
  char v21; // [esp+1Fh] [ebp-1h]

  v1 = this;
  v2 = 0;
  v3 = (_DWORD *)this[4];
  if ( v3 )
  {
    do
    {
      v4 = (const unsigned __int16 *)v3[1];
      v2 += wcslen(v4) + 1;
      if ( *v4 != 34 && wcschr(v4, 0x20u) )
        v2 += 2;
      v3 = (_DWORD *)*v3;
    }
    while ( v3 );
    v1 = this;
  }
  SizeInWords = v2 + 1;
  v5 = (wchar_t *)sub_40B4E9((unsigned __int64)(unsigned int)(v2 + 1) >> 31 != 0 ? -1 : 2 * (v2 + 1));
  *v5 = 0;
  v6 = (int **)v1[4];
  if ( v6 )
  {
    do
    {
      v7 = (const wchar_t *)v6[1];
      if ( *v7 == 34 || !wcschr(v7, 0x20u) )
      {
        v21 = 0;
      }
      else
      {
        v21 = 1;
        wcscat_s(v5, SizeInWords, Source);
      }
      wcscat_s(v5, SizeInWords, (const wchar_t *)v6[1]);
      v8 = L"\" ";
      if ( !v21 )
        v8 = L" ";
      wcscat_s(v5, SizeInWords, v8);
      v6 = (int **)*v6;
    }
    while ( v6 );
    v1 = this;
  }
  v9 = v1[1];
  v10 = (_DWORD *)v1[3];
  v17 = *((_BYTE *)v1 + 8);
  v16 = *(_DWORD *)(v9 + 16);
  v11 = *(_DWORD **)(v9 + 12);
  dword_423F4C = v5;
  SizeInWordsa = sub_405D9E(v10, v11, v16, v17, 0);
  if ( !SizeInWordsa )
  {
    for ( i = (int **)v1[3]; i; i = (int **)*i )
    {
      v14 = sub_40ECF3((wchar_t *)i[1], v12, v12);
      LOBYTE(v12) = *((_BYTE *)v14 + 9) & 0xFB;
      v14[7] = 0;
      LOBYTE(v12) = v12 | 2;
      *((_BYTE *)v14 + 9) = v12;
    }
  }
  free(v5);
  return SizeInWordsa;
}
// 40544D: variable 'v12' is possibly undefined

//----- (0040547A) --------------------------------------------------------
int __thiscall sub_40547A(_DWORD *this)
{
  int v2; // edi
  unsigned int v3; // eax

  v2 = 0;
  while ( this )
  {
    v3 = sub_405325(this);
    this = (_DWORD *)*this;
    v2 += v3;
  }
  return v2;
}

//----- (00405498) --------------------------------------------------------
void __thiscall sub_405498(_DWORD *this)
{
  _DWORD *v2; // esi
  _DWORD *v3; // ecx
  void *v4; // [esp-4h] [ebp-Ch]

  v2 = (_DWORD *)*this;
  while ( v2 )
  {
    v3 = (_DWORD *)v2[3];
    v4 = v2;
    *v3 = dword_434698;
    dword_434698 = v2[4];
    *(_DWORD *)dword_434698 = v3;
    v2 = (_DWORD *)*v2;
    free(v4);
  }
  *this = 0;
}
// 434698: using guessed type int dword_434698;

//----- (004054C7) --------------------------------------------------------
wchar_t *__fastcall sub_4054C7(wchar_t **a1, int *a2)
{
  wchar_t *result; // eax
  unsigned int v5; // ecx
  int v6; // esi
  unsigned int v7; // kr00_4
  wchar_t *v8; // ecx
  wchar_t *v9; // ecx
  int v10; // eax

  for ( result = *a1; (*a1)[*a2 - 1] != 10; result = *a1 )
  {
    result = fgetws(&Src, 1024, Stream);
    if ( !result )
      break;
    v5 = wcslen(&Src);
    if ( *((_WORD *)&dword_42373C + v5) == 92 && *((_WORD *)&dword_42373C + v5 + 1) == 10 )
    {
      *((_WORD *)&dword_42373C + v5 + 1) = 0;
      *((_WORD *)&dword_42373C + v5) = 32;
    }
    v6 = *a2;
    v7 = wcslen(&Src);
    v8 = *a1;
    *a2 += v7;
    v9 = (wchar_t *)sub_40B52C(v8, 2 * (v7 + v6) + 2);
    if ( !v9 )
    {
      sub_405A12(dword_423724, 0x419u);
      v9 = 0;
    }
    v10 = *a2 - v6;
    *a1 = v9;
    wcscpy_s(&v9[v6], v10 + 1, &Src);
  }
  return result;
}
// 423724: using guessed type int dword_423724;
// 42373C: using guessed type int dword_42373C;

//----- (004055CF) --------------------------------------------------------
void *__fastcall sub_4055CF(char *a1, int a2, void **a3)
{
  void *v4; // edi
  void *result; // eax

  if ( *a3 )
  {
    if ( (a2 & 7) == 0 )
    {
      v4 = 0;
      if ( (unsigned int)(a2 + 8) > 0x3FFFFFFE || (v4 = realloc(*a3, 4 * (a2 + 8))) == 0 )
        sub_405A12(dword_423730, 0x41Bu);
      *a3 = v4;
    }
  }
  else
  {
    *a3 = sub_40B4E9(0x20u);
  }
  result = sub_40EBA1(a1);
  *((_DWORD *)*a3 + a2) = result;
  return result;
}
// 423730: using guessed type int dword_423730;

//----- (0040563D) --------------------------------------------------------
char *__fastcall sub_40563D(wchar_t *Str, int *a2, void **a3)
{
  wchar_t *v5; // eax
  int v6; // ecx
  char *result; // eax
  wchar_t *Context; // [esp+8h] [ebp-4h] BYREF

  v5 = wcschr(Str, 0x5Cu);
  if ( v5 )
  {
    v6 = *(v5 - 1);
    if ( (v6 == 32 || v6 == 9) && v5[1] == 10 )
      *v5 = 0;
  }
  Context = 0;
  for ( result = (char *)wcstok_s(Str, L" \t\n", &Context); result; result = (char *)wcstok_s(0, L" \t\n", &Context) )
  {
    if ( *(_WORD *)result == 64 )
      return (char *)sub_405A12(0, 0xFA1u, result + 2);
    sub_4055CF(result, *a2, a3);
    ++*a2;
  }
  return result;
}

//----- (004056C9) --------------------------------------------------------
void __fastcall sub_4056C9(wchar_t *a1, int *a2, void **a3)
{
  int *v4; // esi
  wchar_t *v5; // eax
  wchar_t *v6; // ebx
  wchar_t *v7; // esi
  bool v8; // zf
  wchar_t v9; // ax
  int *v10; // edx
  unsigned int v11; // ebx
  wchar_t *v12; // edi
  wchar_t v13; // cx
  wchar_t *v14; // ecx
  wchar_t v15; // ax
  __int16 v16; // ax
  int v17; // ebx
  int *v18; // eax
  int v19; // [esp+Ch] [ebp-10h] BYREF
  wchar_t *v20; // [esp+10h] [ebp-Ch] BYREF
  int *v21; // [esp+14h] [ebp-8h]
  char v22; // [esp+1Bh] [ebp-1h]

  v22 = 0;
  v4 = a2;
  v21 = a2;
  v5 = wcschr(a1, 0x22u);
  v6 = v5;
  if ( !v5 )
  {
    sub_40563D(a1, v4, a3);
    return;
  }
  if ( v5 == a1 )
    goto LABEL_14;
  v7 = v5 - 1;
  if ( *(v5 - 1) != 61 )
  {
    v4 = v21;
LABEL_14:
    *v5 = 0;
    sub_40563D(a1, v4, a3);
    v7 = v6 + 1;
    goto LABEL_15;
  }
  *v5 = 32;
  v8 = v7 == a1;
  if ( v7 > a1 )
  {
    while ( 1 )
    {
      v9 = *v7;
      if ( *v7 == 32 )
        goto LABEL_12;
      if ( v9 != 9 && v9 != 10 && --v7 > a1 )
        continue;
      v8 = v7 == a1;
      break;
    }
  }
  if ( !v8 )
  {
LABEL_12:
    v10 = v21;
    *v7++ = 0;
    sub_40563D(a1, v10, a3);
  }
LABEL_15:
  v20 = v7;
  v11 = wcslen(v7);
  v12 = v7;
  if ( !*v7 )
    goto LABEL_32;
  v13 = *v7;
  while ( 1 )
  {
    if ( v13 != 34 )
    {
      if ( v13 == 92 )
      {
        v16 = *(v12 - 1);
        if ( (v16 == 32 || v16 == 9) && v12[1] == 10 )
        {
          v17 = v11 - 2;
          *v12 = 0;
          v19 = v17;
          if ( !v22 )
          {
            v22 = 1;
            v20 = (wchar_t *)sub_40EBA1((char *)v7);
          }
          sub_4054C7(&v20, &v19);
          v7 = v20;
          v12 = &v20[v17];
          v11 = v19;
        }
      }
      goto LABEL_29;
    }
    if ( v12[1] != 34 )
      break;
    v14 = v12;
    *v12 = 34;
    do
    {
      ++v14;
      v15 = v14[1];
      *v14 = v15;
    }
    while ( v15 );
LABEL_29:
    v13 = *++v12;
    if ( !*v12 )
      goto LABEL_32;
  }
  v18 = v21;
  *v12++ = 0;
  sub_4055CF((char *)v7, *v18, a3);
  ++*v21;
  sub_4056C9(a3);
LABEL_32:
  if ( v12 == &v7[v11] )
    sub_405A12(0, 0x3EEu);
  if ( v22 )
    free(v7);
}

//----- (0040587A) --------------------------------------------------------
void __thiscall sub_40587A(wchar_t *FileName)
{
  void **v2; // edi
  unsigned int v3; // esi
  FILE *v4; // eax
  wchar_t *v5; // esi
  unsigned int v6; // ecx
  unsigned int v7; // edx
  void **v8; // [esp+10h] [ebp-10h] BYREF
  unsigned int v9; // [esp+14h] [ebp-Ch] BYREF
  wchar_t *v10; // [esp+18h] [ebp-8h] BYREF
  unsigned int v11; // [esp+1Ch] [ebp-4h] BYREF

  v2 = 0;
  v3 = 0;
  v9 = 0;
  v4 = wfsopen(FileName, L"rt,ccs=unicode", 32);
  Stream = v4;
  if ( !v4 )
    v4 = (FILE *)sub_405A12(0, 0x41Cu, FileName);
  v8 = 0;
  if ( fgetws(&Src, 1024, v4) )
  {
    v5 = &Src;
    do
    {
      v6 = wcslen(&Src);
      v11 = v6;
      if ( v6 == 1023 && word_423F3C != 10
        || *((_WORD *)&dword_42373C + v6 + 1) == 10 && *((_WORD *)&dword_42373C + v6) == 92 )
      {
        if ( *((_WORD *)&dword_42373C + v6 + 1) == 10 && *((_WORD *)&dword_42373C + v6) == 92 )
        {
          v7 = 2 * (v6 - 1);
          if ( v7 >= 0x800 )
            __report_rangecheckfailure();
          v11 = v6 - 1;
          *(wchar_t *)((char *)&Src + v7) = 0;
          *((_WORD *)&dword_42373C + v6) = 32;
        }
        v10 = (wchar_t *)sub_40EBA1((char *)&Src);
        sub_4054C7(&v10, (int *)&v11);
        v5 = v10;
      }
      sub_4056C9(v5, (int *)&v9, (void **)&v8);
      if ( v5 != &Src )
        free(v5);
      v5 = &Src;
    }
    while ( fgetws(&Src, 1024, Stream) );
    v3 = v9;
    v2 = v8;
  }
  if ( fclose(Stream) == -1 )
    sub_405A12(0, 0x424u, FileName);
  sub_40C6A3(v3, (int)v2);
  while ( v3 )
  {
    if ( v2[--v3] )
      free(v2[v3]);
  }
}
// 411D61: using guessed type void __noreturn __report_rangecheckfailure(void);
// 42373C: using guessed type int dword_42373C;
// 423F3C: using guessed type __int16 word_423F3C;

//----- (00405A12) --------------------------------------------------------
int sub_405A12(int a1, unsigned int a2, ...)
{
  int v2; // esi
  int result; // eax
  unsigned int v4; // edi
  wchar_t *v5; // eax
  va_list ArgList; // [esp+18h] [ebp+10h] BYREF

  va_start(ArgList, a2);
  v2 = 2;
  if ( (byte_41350C & 0x20) == 0 || (result = a2 - 4000, a2 - 4000 >= 0x3E8) )
  {
    sub_405B88();
    if ( a1 )
      sub_40CFD0((wchar_t *)L"%s(%u) : ", ::ArgList, a1);
    else
      sub_40CFD0((wchar_t *)L"NMAKE : ");
    v4 = a2 / 0x3E8;
    if ( a2 / 0x3E8 == 1 )
    {
      sub_405AEC(0x14u);
      if ( a2 == 1051 )
        v2 = 4;
    }
    else if ( v4 == 2 )
    {
      sub_405AEC(0x15u);
    }
    else if ( v4 == 4 )
    {
      sub_405AEC(0x16u);
    }
    sub_40CFD0((wchar_t *)L" U%04d: ", a2);
    v5 = (wchar_t *)sub_40CDF7(a2);
    sub_40D049(v5, ArgList);
    sub_40CFDF();
    result = sub_40CFB2();
    if ( v4 == 1 )
    {
      sub_40CFD0((wchar_t *)L"Stop.\n");
      sub_40CD63();
      exit(v2);
    }
  }
  return result;
}
// 41350C: using guessed type char byte_41350C;
// 405A12: using guessed type unsigned int arg_4;

//----- (00405AEC) --------------------------------------------------------
void sub_405AEC(unsigned int a1, ...)
{
  unsigned int v1; // ecx
  unsigned int v2; // esi
  wchar_t *v3; // eax
  wchar_t *v4; // eax
  va_list va; // [esp+14h] [ebp+Ch] BYREF

  va_start(va, a1);
  if ( a1 != 13 && (byte_41350C & 0x20) != 0 )
    return;
  sub_405B88();
  v1 = a1;
  v2 = a1 - 20;
  if ( a1 == 24 )
  {
    if ( v2 > 5 )
    {
      sub_40D0C0();
      v1 = 24;
LABEL_14:
      v4 = (wchar_t *)sub_40CDF7(v1);
      sub_40D0EC(v4, va);
      goto LABEL_8;
    }
    sub_40CFDF();
    v1 = 24;
  }
  else if ( v2 > 5 )
  {
    goto LABEL_14;
  }
  v3 = (wchar_t *)sub_40CDF7(v1);
  sub_40D049(v3, va);
LABEL_8:
  if ( a1 >= 0xA && a1 <= 0x17 || a1 == 124 )
  {
    if ( v2 > 5 )
      goto LABEL_19;
  }
  else
  {
    if ( v2 > 5 )
    {
      sub_40D0C0();
LABEL_19:
      sub_40D093();
      return;
    }
    sub_40CFDF();
  }
  sub_40CFB2();
}
// 41350C: using guessed type char byte_41350C;

//----- (00405B88) --------------------------------------------------------
int sub_405B88()
{
  int result; // eax

  if ( !byte_423F60 )
  {
    byte_423F60 = 1;
    sub_405AEC(0x18u, L"14.30.30711.1");
    sub_405AEC(0x19u);
    return sub_40CFB2();
  }
  return result;
}
// 401748: using guessed type wchar_t a1430307111[14];
// 423F60: using guessed type char byte_423F60;

//----- (00405BB4) --------------------------------------------------------
void sub_405BB4()
{
  unsigned int v0; // edi
  unsigned int v1; // esi
  int v2; // [esp-4h] [ebp-Ch]

  v0 = 100;
  v1 = 103;
  do
    sub_405AEC(v0++, L"NMAKE");
  while ( v0 < 0x67 );
  do
  {
    if ( v1 == 113 )
    {
      v2 = 114;
    }
    else
    {
      if ( v1 != 121 )
        goto LABEL_8;
      v2 = 122;
    }
    v1 = v2;
LABEL_8:
    sub_405AEC(v1++);
  }
  while ( v1 <= 0x7C );
}
// 401764: using guessed type wchar_t aNmake_1[6];

//----- (00405BF3) --------------------------------------------------------
size_t __fastcall sub_405BF3(_DWORD *a1, const wchar_t **a2, wchar_t *String)
{
  wchar_t *v3; // esi
  size_t result; // eax
  wchar_t *i; // edi
  const wchar_t *v7; // esi
  int v8; // eax
  char v10; // [esp+13h] [ebp-1h]

  v3 = String;
  result = (size_t)a1;
  v10 = 1;
  for ( i = String; *i; ++i )
    ;
  *a1 = 0;
  if ( String < i )
  {
    while ( 1 )
    {
      result = wcsspn(v3, L" \t");
      v7 = &v3[result];
      if ( v7 >= i )
        goto LABEL_36;
      if ( a2 )
        *a2++ = v7;
      if ( *v7 == 34 )
        break;
      v3 = wcspbrk(v7, L" \t\"/");
      if ( v3 )
      {
        while ( v3 < i )
        {
          if ( *v3 == 47 )
          {
            if ( v10 )
              break;
            v3 = wcspbrk(v3 + 1, L" \t\"/");
            if ( v3 )
              continue;
          }
          if ( !v3 )
            goto LABEL_26;
          break;
        }
        if ( *v3 == 34 )
        {
          do
            ++v3;
          while ( v3 < i && *v3 != 34 );
          v3 = wcspbrk(v3, L" \t");
        }
      }
LABEL_26:
      if ( !v10 )
        goto LABEL_31;
      v10 = 0;
      if ( !v3 )
        goto LABEL_32;
      if ( *v3 != 47 )
        goto LABEL_33;
      if ( a2 )
      {
        *v3 = 0;
        *(a2 - 1) = (const wchar_t *)sub_40EBA1((char *)*(a2 - 1));
        *v3-- = 47;
        goto LABEL_31;
      }
LABEL_35:
      result = (size_t)a1;
      ++*a1;
      if ( v3 >= i )
        goto LABEL_36;
    }
    v3 = (wchar_t *)(v7 + 1);
    if ( v3 >= i )
      goto LABEL_35;
    do
    {
      v8 = *v3;
      if ( v8 == 92 )
      {
        ++v3;
      }
      else if ( (_WORD)v8 == 34 )
      {
        break;
      }
      ++v3;
    }
    while ( v3 < i );
    if ( v3 >= i )
      goto LABEL_35;
    v3 = wcspbrk(v3 + 1, L" \t");
LABEL_31:
    if ( !v3 )
LABEL_32:
      v3 = i;
LABEL_33:
    if ( a2 )
      *v3++ = 0;
    goto LABEL_35;
  }
LABEL_36:
  if ( a2 )
    *a2 = 0;
  return result;
}

//----- (00405D5A) --------------------------------------------------------
unsigned int __fastcall sub_405D5A(char *Src, _DWORD *a2, int a3, unsigned __int8 a4, const wchar_t *a5)
{
  _DWORD *v7; // ebx
  unsigned int result; // eax

  v7 = sub_40EB4F();
  v7[1] = sub_40EBA1(Src);
  result = sub_405D9E(v7, a2, a3, a4, a5);
  *v7 = dword_434698;
  dword_434698 = (int)v7;
  return result;
}
// 434698: using guessed type int dword_434698;

//----- (00405D9E) --------------------------------------------------------
unsigned int __fastcall sub_405D9E(_DWORD *a1, _DWORD *a2, int a3, unsigned __int8 a4, const wchar_t *a5)
{
  unsigned int v5; // esi
  int v6; // eax
  _DWORD *v7; // ebx
  _DWORD *v8; // edi
  bool v9; // bl
  unsigned int v11; // eax
  char v12; // bl
  char v13; // bh
  wchar_t *v14; // ecx
  wchar_t i; // ax
  BOOL v16; // eax
  wchar_t *v17; // esi
  wchar_t *v18; // eax
  bool v19; // zf
  wchar_t *v20; // esi
  int j; // eax
  wchar_t *v22; // edx
  unsigned int v24; // esi
  wchar_t *v25; // edi
  __int16 *v26; // ecx
  char v27; // bl
  char v28; // al
  char v29; // dl
  intptr_t v30; // eax
  int v31; // [esp-Ch] [ebp-6Ch]
  char v32; // [esp+Fh] [ebp-51h]
  wchar_t *Str; // [esp+10h] [ebp-50h] BYREF
  unsigned int v34; // [esp+14h] [ebp-4Ch] BYREF
  int v35; // [esp+18h] [ebp-48h]
  unsigned int v36; // [esp+1Ch] [ebp-44h]
  int v37; // [esp+20h] [ebp-40h] BYREF
  int v38; // [esp+24h] [ebp-3Ch]
  int v39; // [esp+28h] [ebp-38h]
  int v40; // [esp+2Ch] [ebp-34h]
  int v41; // [esp+30h] [ebp-30h]
  wchar_t *v42; // [esp+34h] [ebp-2Ch] BYREF
  wchar_t *v43; // [esp+38h] [ebp-28h] BYREF
  _DWORD *v44; // [esp+3Ch] [ebp-24h]
  int v45; // [esp+40h] [ebp-20h]
  wchar_t *v46; // [esp+44h] [ebp-1Ch] BYREF
  wchar_t *v47; // [esp+48h] [ebp-18h]
  unsigned int v48; // [esp+4Ch] [ebp-14h]
  int v49; // [esp+50h] [ebp-10h] BYREF
  int v50; // [esp+58h] [ebp-8h] BYREF

  ++dword_423F40;
  v5 = 0;
  v36 = 0;
  v6 = (unsigned __int8)byte_41350C;
  v7 = a2;
  v44 = a2;
  v34 = 0;
  v8 = a1;
  if ( (byte_41350C & 8) != 0 )
    return 0;
  if ( (byte_41350C & 0x10) != 0 )
  {
    if ( a1 )
    {
      v9 = (a4 & 4) != 0;
      do
      {
        sub_408136(v8[1], v9);
        v8 = (_DWORD *)*v8;
      }
      while ( v8 );
    }
    return 0;
  }
  if ( !a2 )
    goto LABEL_36;
  LOBYTE(v6) = a4 >> 6;
  v11 = v6 & 0xFFFFFF01;
  v38 = 45;
  v48 = v11;
  v39 = 64;
  v45 = 94;
  v40 = 32;
  v41 = 9;
  do
  {
    v12 = sub_409C09((wchar_t *)v7[1], (void **)&v43, &a3, v11);
    v13 = 0;
    dword_433F70 = 0;
    v14 = v43;
    LOBYTE(v35) = 0;
    Str = v43;
    for ( i = *v43; ; i = *v14 )
    {
      if ( i == 33 )
      {
        v13 |= 4u;
LABEL_52:
        LOBYTE(v35) = v13;
        goto LABEL_53;
      }
      if ( i != (_WORD)v38 )
      {
        if ( i == (_WORD)v39 )
          goto LABEL_40;
        if ( i == (_WORD)v45 )
          goto LABEL_19;
        if ( i == (_WORD)v40 )
          goto LABEL_53;
        if ( i != (_WORD)v41 )
          goto LABEL_24;
        if ( i != (_WORD)v38 )
          break;
      }
      v13 |= 2u;
      Str = v14 + 1;
      LOBYTE(v35) = v13;
      if ( iswdigit(v14[1]) )
      {
        v20 = Str;
        dword_433F70 = wcstoul(Str, &Str, 10);
        if ( *errno() == 34 )
        {
          v31 = dword_423724;
          *Str = 0;
          sub_405A12(v31, 0x436u, v20);
        }
        for ( j = iswspace(*Str); j; j = iswspace(*Str) )
          ++Str;
      }
      else
      {
        dword_433F70 = -1;
      }
      v14 = Str - 1;
LABEL_53:
      Str = ++v14;
    }
    if ( i == (_WORD)v39 )
    {
LABEL_40:
      if ( (byte_41350E & 4) != 0 )
        goto LABEL_53;
      v13 |= 1u;
      goto LABEL_52;
    }
    if ( i != 94 )
      goto LABEL_53;
LABEL_19:
    Str = ++v14;
    v16 = *v14 == (_WORD)v40 || *v14 == (_WORD)v41;
    if ( (v16 ? 0xFFC2 : 0) != 0 )
      goto LABEL_53;
LABEL_24:
    if ( (v13 & 4) != 0 )
    {
      if ( sub_407E17((__int16 *)v14, a3, a4, v35, a5, &v34) )
      {
        v17 = Str;
        v19 = wcschr(Str, 0x24u) == 0;
        v18 = Str;
        if ( !v19 )
        {
          v46 = Str;
          v42 = 0;
          sub_40F8BE(&v49, (__int16 **)&v46, 255, &a3, 0, (char *)&v42);
          v18 = v42;
          Str = v42;
        }
        if ( v17 != v18 )
          free(v18);
        v5 = v34;
        v19 = (a4 & 2) == 0;
        goto LABEL_31;
      }
      v14 = Str;
    }
    v47 = v14;
    if ( !v12 )
    {
      if ( wcschr(v14, 0x24u) )
      {
        v46 = Str;
        v42 = 0;
        sub_40F8BE(&v50, (__int16 **)&v46, 255, &a3, 0, (char *)&v42);
        v14 = v42;
        Str = v42;
      }
      else
      {
        v14 = Str;
      }
    }
    v22 = v14 + 1;
    while ( *v14++ )
      ;
    v24 = v14 - v22 + 1;
    if ( v24 <= 0x8000 )
      v24 = 0x8000;
    v25 = (wchar_t *)sub_40B4E9((unsigned __int64)v24 >> 31 != 0 ? -1 : 2 * v24);
    wcscpy_s(v25, v24, Str);
    if ( sub_410E43((char *)v25, v24, Str, a5) )
      sub_405A12(0, 0x447u, Str, &dword_40177C, &dword_40177C);
    v27 = a4 & 4;
    LOBYTE(v26) = (v13 & 2) != 0;
    v46 = (wchar_t *)v26;
    v32 = a4 & 2;
    while ( 2 )
    {
      if ( v27 && (v13 & 8) == 0 )
      {
        v28 = 0;
        goto LABEL_69;
      }
      v28 = 1;
      if ( !v27 && ((a4 & 8) != 0 || (v13 & 1) != 0) )
      {
        v28 = 1;
        v29 = 0;
      }
      else
      {
LABEL_69:
        v29 = 1;
      }
      v30 = sub_4074DE(v25, v29, v28, (char)v26, (void **)&v37);
      v5 = v30;
      v34 = v30;
      if ( v32 )
        goto LABEL_84;
      if ( v30 != 259 )
        goto LABEL_80;
      if ( byte_434479 )
      {
        if ( v36 >= 0xA )
          goto LABEL_81;
        sub_405A12(0, 0xFADu, v37);
        LOBYTE(v26) = (_BYTE)v46;
        ++v36;
        continue;
      }
      break;
    }
    sub_405A12(0, 0xFACu, v37);
    v5 = 0;
    v34 = 0;
LABEL_80:
    if ( !v5 )
      goto LABEL_84;
LABEL_81:
    if ( v5 > dword_433F70 && !byte_423737 )
      sub_405A12(0, 0x435u, v37, v5);
LABEL_84:
    if ( v47 != Str )
      free(Str);
    free(v43);
    free(v25);
    v19 = v32 == 0;
LABEL_31:
    if ( v19 && byte_423737 && v5 && v5 > dword_433F70 )
    {
LABEL_37:
      if ( !byte_423737 || v5 <= dword_433F70 )
        return 0;
      return v5;
    }
    LOBYTE(v11) = v48;
    v7 = (_DWORD *)*v44;
    v44 = v7;
  }
  while ( v7 );
LABEL_36:
  if ( (a4 & 2) == 0 )
    goto LABEL_37;
  return 0;
}
// 406179: variable 'v26' is possibly undefined
// 40177C: using guessed type int dword_40177C;
// 41350C: using guessed type char byte_41350C;
// 41350E: using guessed type char byte_41350E;
// 423724: using guessed type int dword_423724;
// 423737: using guessed type char byte_423737;
// 423F40: using guessed type int dword_423F40;
// 433F70: using guessed type int dword_433F70;
// 434479: using guessed type char byte_434479;

//----- (00406271) --------------------------------------------------------
wchar_t **__fastcall sub_406271(wchar_t *a1, int a2, wchar_t **ArgList)
{
  unsigned int v3; // ebx
  int v4; // esi
  wchar_t **v5; // edi
  char v6; // cl
  wchar_t *v7; // edx
  wchar_t *v8; // ecx
  int v10; // eax
  const wchar_t *v11; // eax
  wchar_t **result; // eax
  wchar_t **v13; // esi
  int v14; // [esp+Ch] [ebp-8h]

  v3 = 0;
  v4 = a2;
  v5 = ArgList;
  if ( a1 )
  {
    ArgList[a2] = L">";
    v5[a2 + 1] = a1;
    v4 = a2 + 2;
    v5[a2 + 2] = 0;
LABEL_3:
    v5[v4] = (wchar_t *)Source;
    v6 = 1;
    v5[++v4] = 0;
    goto LABEL_13;
  }
  v7 = *ArgList;
  if ( **ArgList == 34 )
  {
    v8 = *ArgList;
    ArgList = (wchar_t **)(v7 + 1);
    while ( *v8++ )
      ;
    if ( v7[(((char *)v8 - (char *)ArgList) >> 1) - 1] == 34 )
    {
      v10 = v4 - 1;
      v14 = v4 - 1;
      if ( v4 - 1 >= 1 )
      {
        while ( !wcspbrk(v5[v10], Source) )
        {
          v10 = v14 - 1;
          v14 = v10;
          if ( v10 < 1 )
          {
            v6 = 0;
            goto LABEL_14;
          }
        }
        goto LABEL_3;
      }
    }
  }
  v6 = 0;
LABEL_13:
  while ( v4 >= 0 )
  {
LABEL_14:
    v5[v4 + 2] = v5[v4];
    --v4;
  }
  *v5 = (wchar_t *)dword_423F6C;
  v11 = L"/c \"";
  if ( !v6 )
    v11 = L"/c";
  v5[1] = (wchar_t *)v11;
  *errno() = 0;
  result = (wchar_t **)wspawnvp(1, *v5, (const wchar_t *const *)v5);
  v13 = result;
  if ( result != (wchar_t **)-1 )
  {
    WaitForSingleObject(result, 0xFFFFFFFF);
    ArgList = 0;
    do
    {
      GetExitCodeProcess(v13, (LPDWORD)&ArgList);
      if ( ArgList != (wchar_t **)259 )
        break;
      Sleep(0x3E8u);
      ++v3;
    }
    while ( v3 < 0xA );
    CloseHandle(v13);
    return ArgList;
  }
  return result;
}
// 401780: using guessed type wchar_t asc_401780[2];
// 401784: using guessed type wchar_t aC[5];
// 401790: using guessed type wchar_t aC_0[3];
// 423F6C: using guessed type int dword_423F6C;

//----- (0040638C) --------------------------------------------------------
wchar_t *__fastcall sub_40638C(int a1, wchar_t **a2)
{
  char v2; // bl
  wchar_t *v3; // edi
  wchar_t *i; // esi
  wchar_t v5; // ax
  wchar_t v6; // ax
  wchar_t v8; // cx
  int v9; // eax
  __int16 v10; // dx
  wchar_t *v11; // edi
  unsigned int v12; // kr00_4
  FILE *v13; // esi
  wchar_t v14; // cx
  char *v15; // ecx
  wchar_t v16; // bx
  wchar_t v17; // dx
  wchar_t *v18; // ecx
  __int16 v19; // ax
  wchar_t *v20; // ebx
  unsigned int v21; // kr0C_4
  wchar_t *v22; // ebx
  unsigned int v23; // kr10_4
  wchar_t *v25; // [esp+10h] [ebp-106B8h]
  size_t RequiredCount; // [esp+18h] [ebp-106B0h] BYREF
  wchar_t *v28; // [esp+1Ch] [ebp-106ACh] BYREF
  wchar_t Destination[4]; // [esp+20h] [ebp-106A8h] BYREF
  wchar_t v30; // [esp+28h] [ebp-106A0h] BYREF
  char v31; // [esp+2Ah] [ebp-1069Eh] BYREF
  WCHAR TempFileName[260]; // [esp+10020h] [ebp-6A8h] BYREF
  wchar_t VarName[257]; // [esp+10228h] [ebp-4A0h] BYREF
  char v34; // [esp+1042Ah] [ebp-29Eh] BYREF
  wchar_t Source[64]; // [esp+10430h] [ebp-298h] BYREF
  wchar_t Buffer; // [esp+104B0h] [ebp-218h] BYREF
  __int16 v37[265]; // [esp+104B2h] [ebp-216h] BYREF

  v2 = 0;
  RequiredCount = 0;
  v28 = 0;
  wcscpy_s(Destination, 0x8000u, L"set ");
  v3 = &v30;
  for ( i = &Str; ; ++i )
  {
    v5 = *i;
    if ( *i != 32 && v5 != 9 )
      break;
  }
  if ( v5 == 47 && i[1] == 65 )
  {
    v6 = i[2];
    if ( v6 == 32 || v6 == 9 )
    {
      v2 = 1;
      i += 3;
    }
  }
  if ( !wcschr(i, 0x3Du) )
    return (wchar_t *)&dword_40177C;
  v25 = &v30;
  if ( *i != 61 )
  {
    v8 = *i;
    do
    {
      *v3++ = v8;
      if ( v3 >= TempFileName )
        return 0;
      v8 = *++i;
    }
    while ( *i != 61 );
  }
  if ( v2 )
  {
    v9 = *(v3 - 1);
    if ( v9 == 42 || (_WORD)v9 == 47 || v9 == 37 || v9 == 43 || v9 == 45 || v9 == 38 || v9 == 94 || v9 == 124 )
    {
      --v3;
    }
    else
    {
      v10 = 62;
      if ( (_WORD)v9 == 62 || (v10 = 60, (_WORD)v9 == 60) )
      {
        if ( *(v3 - 2) == v10 )
          v3 -= 2;
      }
    }
    if ( v30 == 34 )
      v25 = (wchar_t *)&v31;
    *v3 = 61;
    v11 = v3 + 1;
    if ( v11 < TempFileName )
    {
      RequiredCount = 0;
      if ( wgetenv_s(&RequiredCount, &Buffer, 0x106u, L"TMP") || !RequiredCount )
        wcscpy_s(&Buffer, 0x106u, L".");
      if ( !GetTempFileNameW(&Buffer, L"nm", 0, TempFileName) )
        sub_405A12(dword_423724, 0x43Cu, &Buffer);
      wcscpy_s(&Buffer, 0x106u, TempFileName);
      if ( wcschr(&Buffer, 0x20u) && !wcschr(&Buffer, 0x22u) )
      {
        v12 = wcslen(&Buffer);
        memmove(v37, &Buffer, 2 * v12);
        Buffer = 34;
        v37[v12] = 34;
        if ( 2 * v12 + 4 >= 0x20C )
          __report_rangecheckfailure();
        v37[v12 + 1] = 0;
      }
      if ( !sub_406271(&Buffer, a1, a2) )
      {
        v13 = wfsopen(&Buffer, L"rt", 32);
        if ( !v13 )
          sub_405A12(0, 0x41Cu, &Buffer);
        if ( !fgetws(Source, 64, v13) )
          sub_405A12(0, 0x41Du, &Buffer);
        if ( fclose(v13) == -1 )
          sub_405A12(0, 0x424u, &Buffer);
        if ( wremove(&Buffer) == -1 )
          sub_405A12(0, 0x421u, &Buffer);
        if ( &v11[wcslen(Source) + 1] <= TempFileName )
        {
          wcscpy_s(v11, TempFileName - v11, Source);
          goto LABEL_62;
        }
      }
    }
    return 0;
  }
  if ( !*i )
    goto LABEL_61;
  v14 = *i;
  while ( 1 )
  {
    ++i;
    if ( v14 != 94 )
      break;
    v14 = *i;
    if ( *i )
    {
      ++i;
LABEL_59:
      *v3++ = v14;
      if ( v3 >= TempFileName )
        return 0;
    }
LABEL_60:
    v14 = *i;
    if ( !*i )
      goto LABEL_61;
  }
  if ( v14 != 37 )
    goto LABEL_59;
  v15 = (char *)VarName;
  v16 = *i;
  if ( *i != 37 )
  {
    v17 = *i;
    do
    {
      v16 = v17;
      if ( !v17 )
        break;
      *(_WORD *)v15 = v17;
      v15 += 2;
      if ( v15 == &v34 )
        return 0;
      v17 = *++i;
      v16 = *i;
    }
    while ( *i != 37 );
  }
  ++i;
  *(_WORD *)v15 = 0;
  if ( v16 )
  {
    wdupenv_s(&v28, 0, VarName);
    if ( v28 )
    {
      v18 = v28;
      do
        v19 = *v18++;
      while ( v19 != (_WORD)RequiredCount );
      v20 = &v3[v18 - (v28 + 1)];
      if ( v20 >= TempFileName )
        return 0;
      wcscpy_s(v3, TempFileName - v3, v28);
      v3 = v20;
      free(v28);
      v28 = 0;
    }
    else
    {
      v21 = wcslen(VarName);
      v22 = &v3[v21 + 2];
      if ( v22 >= TempFileName )
        return 0;
      *v3 = 37;
      wcscpy_s(v3 + 1, TempFileName - (v3 + 1), VarName);
      v3 += v21 + 2;
      *(v22 - 1) = 37;
    }
    goto LABEL_60;
  }
  v23 = wcslen(VarName);
  if ( &v3[v23 + 1] >= TempFileName )
    return 0;
  *v3 = 37;
  wcscpy_s(v3 + 1, TempFileName - (v3 + 1), VarName);
  v3 += v23 + 1;
LABEL_61:
  *v3 = 0;
LABEL_62:
  wcscpy_s(&::Destination, 0x8000u, Destination);
  *v25 = 0;
  return &::Destination + wcslen(Destination);
}
// 40177C: using guessed type int dword_40177C;
// 411D61: using guessed type void __noreturn __report_rangecheckfailure(void);
// 423724: using guessed type int dword_423724;
// 40638C: using guessed type __int16 var_216[265];

//----- (004069A9) --------------------------------------------------------
char *__thiscall sub_4069A9(wchar_t *Str)
{
  char *v2; // ebx
  wchar_t *v3; // edi
  wchar_t *v4; // eax
  char *v5; // esi
  char *v6; // eax
  wchar_t *v8; // [esp+10h] [ebp-8h]
  wchar_t *Buffer; // [esp+14h] [ebp-4h] BYREF

  v2 = (char *)sub_40EBA1((char *)&dword_40177C);
  while ( *Str )
  {
    v3 = wcschr(Str, 0x25u);
    if ( v3 && (v4 = wcschr(v3 + 1, 0x25u), (v8 = v4) != 0) )
    {
      *v3 = 0;
      Buffer = 0;
      *v4 = 0;
      v5 = (char *)sub_40EC4B(v2, Str);
      wdupenv_s(&Buffer, 0, v3 + 1);
      if ( Buffer )
      {
        v2 = (char *)sub_40EC4B(v5, Buffer);
        free(Buffer);
        Buffer = 0;
      }
      else
      {
        *v3 = 37;
        v6 = (char *)sub_40EC4B(v5, v3);
        v2 = (char *)sub_40EC4B(v6, L"%");
      }
      *v3 = 37;
      *v8 = 37;
      Str = v8 + 1;
    }
    else
    {
      v2 = (char *)sub_40EC4B(v2, Str);
      Str += wcslen(Str);
    }
  }
  return v2;
}
// 40177C: using guessed type int dword_40177C;
// 4017C0: using guessed type wchar_t asc_4017C0[2];

//----- (00406AA7) --------------------------------------------------------
char __fastcall sub_406AA7(int a1, wint_t **a2, int *a3)
{
  wint_t *v3; // esi
  wint_t *v5; // edi
  wint_t v6; // ax
  char *v8; // eax
  const wchar_t *v9; // eax
  int v10; // eax
  int *v11; // edi
  wchar_t *v12; // esi
  int v13; // eax
  char *v14; // esi
  char *v15; // esi
  int v16; // [esp-4h] [ebp-18h]

  v3 = *a2;
  v5 = a2[1];
  if ( iswalpha(**a2) && v3[1] == 58 && !v3[2] )
  {
    v6 = towupper(*v3);
    chdrive(v6 - 64);
    *a3 = 0;
    return 1;
  }
  if ( wcsicmp(v3, L"set") )
  {
    if ( wcsnicmp(v3, L"cd", 2u) )
    {
      if ( wcsnicmp(v3, L"chdir", 5u) )
        return 0;
      v16 = 5;
    }
    else
    {
      v16 = 2;
    }
    v12 = &v3[v16];
    if ( a1 <= 2 )
    {
      sub_4080AC(a1, (__int16 **)a2);
      v13 = *v12;
      if ( (_WORD)v13 )
      {
        if ( v13 != 46 && v13 != 92 && v13 != 47 )
          return 0;
        v15 = sub_4069A9(v12);
        v11 = a3;
        *a3 = wchdir((const wchar_t *)v15);
        free(v15);
      }
      else
      {
        if ( !v5 || iswalpha(*v5) && v5[1] == 58 && !v5[2] )
          return 0;
        v14 = sub_4069A9(v5);
        v11 = a3;
        *a3 = wchdir((const wchar_t *)v14);
        free(v14);
      }
LABEL_28:
      if ( *v11 )
        *v11 = 1;
      return 1;
    }
  }
  else if ( a1 != 1 )
  {
    if ( Destination )
    {
      v8 = (char *)sub_40638C(a1, a2);
      if ( v8 )
      {
        if ( *(_WORD *)v8 )
        {
          v9 = (const wchar_t *)sub_40EBA1(v8);
          v10 = wputenv(v9);
          v11 = a3;
          *a3 = v10;
          if ( v10 == -1 )
            sub_405A12(dword_423730, 0x41Fu);
          goto LABEL_28;
        }
      }
    }
  }
  return 0;
}
// 423730: using guessed type int dword_423730;

//----- (00406C5E) --------------------------------------------------------
char __fastcall sub_406C5E(wchar_t *FileName, int a2)
{
  int v4; // eax
  wchar_t *v5; // eax
  wchar_t *v6; // edi
  FILE *v7; // eax
  int v8; // ecx
  errno_t v9; // eax
  char v10; // dl
  int v11; // eax
  int v12; // eax
  wchar_t v14; // [esp+10h] [ebp-10h]
  FILE *Stream; // [esp+14h] [ebp-Ch]
  int FileHandle; // [esp+18h] [ebp-8h] BYREF
  bool v17; // [esp+1Fh] [ebp-1h]

  while ( 1 )
  {
    v4 = *FileName;
    if ( (_WORD)v4 != 32 && v4 != 9 )
      break;
    ++FileName;
  }
  v14 = 0;
  v5 = wcspbrk(FileName, L" \t<>\r");
  v6 = v5;
  if ( v5 )
  {
    v14 = *v5;
    *v5 = 0;
  }
  if ( a2 == 4 )
  {
    v7 = _acrt_iob_func(0);
    v8 = 0;
  }
  else
  {
    v7 = _acrt_iob_func(1u);
    v8 = a2 != 2 ? 265 : 769;
  }
  FileHandle = 0;
  Stream = v7;
  v9 = wsopen_s(&FileHandle, FileName, v8, 64, 384);
  v10 = v9 == 0;
  v17 = v9 == 0;
  if ( !v9 )
  {
    v11 = fileno(Stream);
    if ( dup2(FileHandle, v11) == -1 )
      sub_405A12(0, 0x411u);
    close(FileHandle);
    v10 = v17;
  }
  if ( v10 && a2 == 3 )
  {
    v12 = fileno(Stream);
    lseek(v12, 0, 2);
    v10 = v17;
  }
  for ( ; *FileName; ++FileName )
    *FileName = 32;
  if ( v6 )
    *v6 = v14;
  return v10;
}

//----- (00406D7D) --------------------------------------------------------
char __fastcall sub_406D7D(wchar_t *String, rsize_t a2, int *a3, int *a4)
{
  char v4; // bh
  char v5; // bl
  wchar_t *v6; // edi
  wchar_t *v7; // esi
  wchar_t *v8; // esi
  FILE *v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // edx
  FILE *v13; // eax
  int v14; // eax
  int v15; // eax
  FILE *v16; // eax
  int v17; // eax
  FILE *v18; // eax
  int v19; // eax
  int v23; // [esp+14h] [ebp-Ch]
  wchar_t *Stringa; // [esp+18h] [ebp-8h]
  char v25; // [esp+1Fh] [ebp-1h]

  v4 = 0;
  v25 = 0;
  v5 = 0;
  Stringa = String;
  v6 = 0;
  v7 = wcspbrk(String, L"<>|");
  if ( !v7 )
    return v5;
  while ( *v7 != 60 )
  {
    if ( *v7 != 62 )
    {
      if ( *v7 == 124 )
        goto LABEL_22;
      sub_405A12(0, 0x411u);
      goto LABEL_20;
    }
    if ( v25 )
      goto LABEL_22;
    if ( !v6 )
      v6 = (wchar_t *)sub_40EBA1((char *)Stringa);
    *v7 = 32;
    v8 = v7 + 1;
    Stringa = v8;
    v25 = 1;
    if ( *v8 == 62 )
    {
      *v8++ = 32;
      v23 = 3;
    }
    else
    {
      v23 = 2;
    }
    v9 = _acrt_iob_func(1u);
    v10 = fileno(v9);
    v11 = dup(v10);
    *a4 = v11;
    if ( v11 == -1 )
      goto LABEL_22;
    v12 = v23;
LABEL_19:
    if ( !sub_406C5E(v8, v12) )
      goto LABEL_22;
LABEL_20:
    v7 = wcspbrk(Stringa, L"<>|");
    if ( !v7 )
      return v5;
  }
  if ( !v4 )
  {
    if ( !v6 )
      v6 = (wchar_t *)sub_40EBA1((char *)Stringa);
    *v7 = 32;
    v4 = 1;
    v8 = v7 + 1;
    Stringa = v8;
    v13 = _acrt_iob_func(0);
    v14 = fileno(v13);
    v15 = dup(v14);
    *a3 = v15;
    if ( v15 != -1 )
    {
      v12 = 4;
      goto LABEL_19;
    }
  }
LABEL_22:
  v5 = 1;
  if ( v6 )
  {
    wcscpy_s(String, a2, v6);
    free(v6);
  }
  if ( v4 && *a3 != -1 )
  {
    v16 = _acrt_iob_func(0);
    v17 = fileno(v16);
    if ( dup2(*a3, v17) == -1 )
      sub_405A12(0, 0x411u);
    close(*a3);
    *a3 = -1;
  }
  if ( v25 && *a4 != -1 )
  {
    v18 = _acrt_iob_func(1u);
    v19 = fileno(v18);
    if ( dup2(*a4, v19) == -1 )
      sub_405A12(0, 0x411u);
    close(*a4);
    *a4 = -1;
  }
  return v5;
}

//----- (00406F8B) --------------------------------------------------------
int __stdcall sub_406F8B(int a1)
{
  return 1;
}

//----- (00406F91) --------------------------------------------------------
bool __fastcall sub_406F91(_WORD *a1, _DWORD *a2)
{
  _WORD *v2; // edi
  _WORD *v4; // edx
  __int16 v5; // si
  __int16 v6; // bx
  __int16 v7; // si
  _WORD *v9; // [esp+8h] [ebp-4h]

  v2 = a1;
  v9 = a1;
  if ( !a1 )
    return 0;
  v4 = a1;
  v5 = *a1;
  if ( *a1 == 59 )
  {
    do
      ++a1;
    while ( *a1 == 59 );
    v5 = *a1;
  }
  v6 = v5;
  if ( v5 )
  {
    do
    {
      v6 = v5;
      if ( v5 == 59 )
        break;
      ++a1;
      if ( v5 == 34 )
      {
        if ( *a1 )
        {
          v7 = *a1;
          do
          {
            ++a1;
            if ( v7 == 34 )
              break;
            *v4++ = v7;
            v7 = *a1;
          }
          while ( *a1 );
        }
      }
      else
      {
        *v4++ = v5;
      }
      v5 = *a1;
      v6 = *a1;
    }
    while ( *a1 );
    v2 = v9;
  }
  *a2 = v6 != 0 ? a1 + 1 : 0;
  *v4 = 0;
  return v4 != v2;
}

//----- (00407048) --------------------------------------------------------
char __fastcall sub_407048(wchar_t *FullPath, wchar_t *a2, int a3)
{
  wchar_t *v3; // ebx
  unsigned int v4; // eax
  wchar_t *v5; // ebx
  BOOL (__stdcall *NeedCurrentDirectoryForExePathW)(LPCWSTR); // eax
  HMODULE ModuleHandleW; // eax
  size_t v8; // eax
  wchar_t *v9; // edi
  wchar_t *v10; // esi
  size_t v11; // eax
  wchar_t *v12; // esi
  wchar_t *v13; // ecx
  size_t v14; // esi
  wchar_t *v15; // ecx
  unsigned int v17; // edi
  wchar_t *v18; // eax
  wchar_t *v19; // [esp+10h] [ebp-63Ch]
  wchar_t *v20; // [esp+14h] [ebp-638h] BYREF
  wchar_t *v21; // [esp+18h] [ebp-634h]
  wchar_t *v22; // [esp+1Ch] [ebp-630h]
  wchar_t *v23; // [esp+20h] [ebp-62Ch]
  BOOL v24; // [esp+24h] [ebp-628h] BYREF
  wchar_t *Buffer; // [esp+28h] [ebp-624h]
  size_t RequiredCount; // [esp+2Ch] [ebp-620h] BYREF
  size_t SizeInWords; // [esp+30h] [ebp-61Ch] BYREF
  char v28; // [esp+37h] [ebp-615h]
  wchar_t Filename[256]; // [esp+38h] [ebp-614h] BYREF
  wchar_t Dir[256]; // [esp+238h] [ebp-414h] BYREF
  wchar_t Ext[258]; // [esp+438h] [ebp-214h] BYREF
  wchar_t Drive[4]; // [esp+63Ch] [ebp-10h] BYREF

  Buffer = a2;
  v23 = 0;
  v28 = 0;
  if ( *FullPath == 34 )
  {
    v3 = &FullPath[wcslen(FullPath) - 1];
    v23 = v3;
    if ( *v3 == 34 )
    {
      v28 = 1;
      do
        ++FullPath;
      while ( *FullPath == 34 );
      if ( v3 > FullPath )
      {
        do
        {
          v4 = (unsigned int)(v3 - 1);
          if ( *(v3 - 1) != 34 )
            break;
          --v3;
        }
        while ( v4 > (unsigned int)FullPath );
        v23 = v3;
      }
      *v3 = 0;
    }
  }
  wsplitpath_s(FullPath, Drive, 3u, Dir, 0x100u, Filename, 0x100u, Ext, 0x100u);
  if ( !Ext[0] )
  {
    if ( !wgetenv_s(&RequiredCount, 0, 0, aPa) && RequiredCount )
    {
      v5 = (wchar_t *)sub_40B4E9((unsigned __int64)RequiredCount >> 31 != 0 ? -1 : 2 * RequiredCount);
      if ( wgetenv_s(&RequiredCount, v5, RequiredCount, aPa) )
      {
        free(v5);
      }
      else if ( v5 )
      {
        goto LABEL_18;
      }
    }
    RequiredCount = 33;
    v5 = (wchar_t *)sub_40B4E9(0x42u);
    wcscpy_s(v5, RequiredCount, L".COM;.EXE;.BAT;.CMD;.VBS;.JS;.WS");
    goto LABEL_18;
  }
  v5 = Ext;
  RequiredCount = wcslen(Ext) + 1;
LABEL_18:
  if ( Drive[0] || Dir[0] )
  {
    v14 = wcslen(Dir) + wcslen(Drive) + 1;
    v9 = (wchar_t *)sub_40B4E9((unsigned __int64)v14 >> 31 != 0 ? -1 : 2 * v14);
    v22 = v9;
    if ( wmakepath_s(v9, v14, Drive, Dir, 0, 0) )
    {
      free(v9);
      v12 = 0;
      v9 = 0;
      v22 = 0;
      goto LABEL_35;
    }
  }
  else
  {
    if ( wgetenv_s(&SizeInWords, 0, 0, aPa_0) || !SizeInWords )
      SizeInWords = 1;
    NeedCurrentDirectoryForExePathW = (BOOL (__stdcall *)(LPCWSTR))dword_4376D4;
    if ( !dword_4376D4 )
    {
      ModuleHandleW = GetModuleHandleW(L"KERNEL32.DLL");
      NeedCurrentDirectoryForExePathW = (BOOL (__stdcall *)(LPCWSTR))GetProcAddress(
                                                                       ModuleHandleW,
                                                                       "NeedCurrentDirectoryForExePathW");
      dword_4376D4 = (int)NeedCurrentDirectoryForExePathW;
      if ( !NeedCurrentDirectoryForExePathW )
      {
        NeedCurrentDirectoryForExePathW = (BOOL (__stdcall *)(LPCWSTR))sub_406F8B;
        dword_4376D4 = (int)sub_406F8B;
      }
    }
    v24 = NeedCurrentDirectoryForExePathW(Filename);
    v8 = SizeInWords;
    if ( v24 )
    {
      v8 = SizeInWords + 2;
      SizeInWords += 2;
    }
    v9 = (wchar_t *)sub_40B4E9((unsigned __int64)v8 >> 31 != 0 ? -1 : 2 * v8);
    v22 = v9;
    v10 = v9;
    if ( v24 )
    {
      wcscpy_s(v9, SizeInWords, L".;");
      v10 = v9 + 2;
      v11 = SizeInWords - 2;
      SizeInWords -= 2;
    }
    else
    {
      v11 = SizeInWords;
    }
    if ( wgetenv_s(&SizeInWords, v10, v11, aPa_0) || !SizeInWords )
      *v10 = 0;
  }
  v12 = 0;
LABEL_35:
  v19 = v9;
  v13 = v9;
LABEL_44:
  if ( sub_406F91(v13, &v24) )
  {
    v12 = (wchar_t *)sub_40B4E9((unsigned __int64)RequiredCount >> 31 != 0 ? -1 : 2 * RequiredCount);
    wcscpy_s(v12, RequiredCount, v5);
    v21 = v12;
    v15 = v12;
    while ( 1 )
    {
      if ( !sub_406F91(v15, &v20) )
      {
        v13 = (wchar_t *)v24;
        v19 = (wchar_t *)v24;
        goto LABEL_44;
      }
      if ( !wmakepath_s(Buffer, 0x104u, 0, v19, Filename, v21) && !waccess_s(Buffer, 0) )
        break;
      v15 = v20;
      v21 = v20;
    }
    if ( v28 )
    {
      v17 = wcslen(Buffer);
      memmove(Buffer + 1, Buffer, 2 * v17);
      v18 = Buffer;
      *Buffer = 34;
      v18[v17 + 1] = 34;
      v18[v17 + 2] = 0;
      v9 = v22;
      *v23 = 34;
    }
    free(v12);
    free(v9);
    if ( v5 != Ext )
      free(v5);
    return 1;
  }
  else
  {
    free(v12);
    free(v9);
    if ( v5 != Ext )
      free(v5);
    return 0;
  }
}
// 4376D4: using guessed type int dword_4376D4;

//----- (004074DE) --------------------------------------------------------
intptr_t __fastcall sub_4074DE(wchar_t *Source, char a2, char a3, char a4, void **a5)
{
  char v5; // bl
  void *v7; // eax
  int v8; // eax
  wchar_t *v9; // esi
  wchar_t *v11; // eax
  wchar_t *v12; // edi
  const wchar_t **v13; // ebx
  intptr_t v14; // edi
  const wchar_t **v15; // eax
  int v16; // esi
  const wchar_t *v17; // edi
  unsigned int v18; // kr00_4
  void **v19; // esi
  wchar_t *v20; // ecx
  int v21; // eax
  const wchar_t *v22; // esi
  wchar_t *v23; // esi
  wchar_t *v24; // ecx
  __int16 v25; // ax
  const wchar_t *v26; // eax
  unsigned int v27; // edi
  wchar_t *v28; // edx
  __int16 v29; // ax
  unsigned int v30; // ecx
  unsigned int v31; // kr04_4
  unsigned int v32; // esi
  FILE *v33; // eax
  int v34; // eax
  FILE *v35; // eax
  int v36; // eax
  wchar_t *v37; // ecx
  __int16 v38; // ax
  int v39; // esi
  int v40; // eax
  wchar_t **v41; // eax
  int v42; // eax
  int v43; // eax
  signed int v44; // esi
  int v45; // esi
  wchar_t **v46; // ecx
  void *v47; // esi
  int v48; // eax
  char v49; // al
  char v50; // [esp+14h] [ebp-448h]
  int FileHandleSrc; // [esp+18h] [ebp-444h] BYREF
  intptr_t v52; // [esp+1Ch] [ebp-440h] BYREF
  WCHAR Buffer[2]; // [esp+20h] [ebp-43Ch] BYREF
  void *Block; // [esp+24h] [ebp-438h]
  size_t v55; // [esp+28h] [ebp-434h] BYREF
  size_t Size; // [esp+2Ch] [ebp-430h]
  int FileHandle; // [esp+30h] [ebp-42Ch] BYREF
  char v58; // [esp+37h] [ebp-425h]
  wchar_t *String; // [esp+38h] [ebp-424h] BYREF
  char v60; // [esp+3Fh] [ebp-41Dh]
  wchar_t v61; // [esp+40h] [ebp-41Ch] BYREF
  wchar_t Destination[59]; // [esp+42h] [ebp-41Ah] BYREF
  wchar_t v63[200]; // [esp+B8h] [ebp-3A4h] BYREF
  wchar_t Str; // [esp+248h] [ebp-214h] BYREF
  char Src[522]; // [esp+24Ah] [ebp-212h] BYREF

  v5 = a2;
  String = Source;
  if ( !dword_423F6C )
  {
    v7 = sub_407D7B();
    Source = String;
    dword_423F6C = (int)v7;
  }
  v8 = *Source;
  v50 = 1;
  *(_DWORD *)Buffer = 0;
  if ( v8 == 45 )
  {
    v58 = 1;
    String = Source + 1;
    if ( iswdigit(Source[1]) )
    {
      v9 = String;
      dword_433F70 = wcstoul(String, &String, 10);
      if ( *errno() == 34 )
      {
        *String = 0;
        sub_405A12(0, 0x436u, v9);
      }
      for ( ; iswspace(*String); ++String )
        ;
    }
    else
    {
      dword_433F70 = -1;
    }
    Source = String;
  }
  else
  {
    if ( v8 == 64 )
    {
      String = ++Source;
      v5 = a3 != 0 ? 0 : a2;
    }
    v58 = a4;
  }
  if ( !*Source )
    return 0;
  if ( wcslen(Source) >= 0x8000 )
  {
    ::Destination = 0;
  }
  else
  {
    wcscpy_s(&::Destination, 0x8000u, Source);
    Source = String;
  }
  v11 = (wchar_t *)sub_40EBA1((char *)Source);
  v12 = v11;
  Block = v11;
  if ( v5 )
  {
    sub_40D0B1((wchar_t *)L"\t%s\n", v11);
    sub_40D093();
  }
  v13 = 0;
  sub_405BF3(&v55, 0, v12);
  if ( !v55 )
    goto LABEL_23;
  Size = (unsigned __int64)(v55 + 8) >> 30 != 0 ? -1 : 4 * (v55 + 8);
  v15 = (const wchar_t **)sub_40B4E9(Size);
  v13 = v15;
  if ( v15 )
    memset(v15, 0, Size);
  else
    v13 = 0;
  v16 = v55;
  Size = v55;
  sub_405BF3(&v55, v13, v12);
  if ( *v13 && dword_423F68 && !wcsicmp(*v13, dword_423F68) )
  {
    if ( !dword_413508 )
    {
      dword_413508 = *_p__wpgmptr();
      v17 = dword_413508;
      if ( wcspbrk(dword_413508, L" ") )
      {
        v18 = wcslen(dword_413508);
        dword_413508 = (wchar_t *)sub_40B4E9((unsigned __int64)(v18 + 3) >> 31 != 0 ? -1 : 2 * (v18 + 3));
        wcscpy_s(dword_413508, v18 + 3, ::Source);
        wcscat_s(dword_413508, v18 + 3, v17);
        wcscat_s(dword_413508, v18 + 3, ::Source);
        v16 = Size;
      }
      v12 = (wchar_t *)Block;
    }
    *v13 = dword_413508;
  }
  if ( a3 )
  {
    v21 = -(int)wcspbrk(String, L"<>|&%");
    LOBYTE(v21) = v21 == 0;
    FileHandle = v21;
    Size = 0;
    if ( sub_406AA7(v16, (wint_t **)v13, &v52) )
    {
      v22 = *v13;
      v14 = v52;
      v60 = 0;
      FileHandle = (int)v22;
      goto LABEL_85;
    }
    v23 = String;
    v24 = String;
    do
      v25 = *v24++;
    while ( v25 != Buffer[0] );
    if ( (unsigned int)(v24 - (String + 1)) < 0x1000 && !(_BYTE)FileHandle )
    {
      v26 = *v13;
      v60 = 1;
      v27 = 16;
      FileHandle = (int)v26;
      goto LABEL_79;
    }
    FileHandleSrc = -1;
    v28 = String;
    FileHandle = -1;
    do
      v29 = *v28++;
    while ( v29 != Buffer[0] );
    v60 = sub_406D7D(String, v28 - (String + 1) + 1, &FileHandleSrc, &FileHandle);
    if ( v60 )
    {
      v14 = v52;
      Size = 17;
    }
    else
    {
      v30 = wcslen(String);
      if ( v30 >= 0x8000 )
        sub_405A12(0, 0x447u, String, &dword_40177C, &dword_40177C);
      if ( FileHandleSrc != -1 || FileHandle != -1 )
      {
        free(v12);
        Block = sub_40EBA1((char *)String);
        sub_405BF3(&v55, v13, (wchar_t *)Block);
      }
      if ( sub_407048((wchar_t *)*v13, &Str, v30) )
      {
        if ( Str == 34 )
        {
          v31 = wcslen(&Str);
          if ( v63[v31 + 199] == 34 )
          {
            memmove(&Str, Src, 2 * v31);
            v32 = 2 * v31 - 4;
            if ( v32 >= 0x208 )
              __report_rangecheckfailure();
            *(_WORD *)&Src[v32 - 2] = 0;
          }
        }
        *v13 = &Str;
        if ( wcschr(&Str, 0x20u) )
        {
          v61 = 34;
          wcscpy_s(Destination, 0x103u, &Str);
          wcscat_s(&v61, 0x104u, ::Source);
          *v13 = &v61;
        }
        *errno() = 0;
        *_doserrno() = 0;
        v14 = wspawnvp(0, &Str, v13);
        if ( v14 != -1 || *errno() == 12 || *_doserrno() != 193 )
          goto LABEL_69;
        Size = 19;
      }
      else
      {
        v14 = v52;
        Size = 18;
      }
      v60 = 1;
    }
LABEL_69:
    if ( FileHandleSrc != -1 )
    {
      v33 = _acrt_iob_func(0);
      v34 = fileno(v33);
      if ( dup2(FileHandleSrc, v34) == -1 )
        sub_405A12(0, 0x411u);
      close(FileHandleSrc);
    }
    if ( FileHandle != -1 )
    {
      v35 = _acrt_iob_func(1u);
      v36 = fileno(v35);
      if ( dup2(FileHandle, v36) == -1 )
        sub_405A12(0, 0x411u);
      close(FileHandle);
    }
    v22 = *v13;
    FileHandle = (int)*v13;
    if ( !v60 )
    {
LABEL_85:
      if ( v14 == -1 )
      {
        if ( v58 )
          goto LABEL_23;
        v42 = *errno();
        if ( !v42 )
        {
LABEL_98:
          v19 = a5;
          if ( !a5 )
            goto LABEL_103;
          v46 = (wchar_t **)(v13 + 2);
          if ( !v60 )
            v46 = (wchar_t **)v13;
          v20 = *v46;
          goto LABEL_102;
        }
        v43 = v42 - 2;
        if ( v43 )
        {
          if ( v43 == 10 )
          {
            sub_405A12(0, 0x43Au, v22);
          }
          else if ( *_doserrno() )
          {
            *(_DWORD *)Buffer = 0;
            v44 = *_doserrno();
            FormatMessageW(0x1300u, 0, v44, 0x400u, Buffer, 0, 0);
            if ( v44 > 0 )
              v44 = (unsigned __int16)v44 | 0x80070000;
            sub_405A12(0, 0x415u, FileHandle, v44, *(_DWORD *)Buffer);
          }
          else
          {
            v45 = *errno();
            wcserror_s(v63, 0xC8u, v45);
            sub_405A12(0, 0x415u, FileHandle, v45, v63);
          }
          goto LABEL_98;
        }
        sub_405A12(0, 0x439u, v22);
      }
      if ( !v14 )
        goto LABEL_103;
      goto LABEL_98;
    }
    v23 = String;
    v27 = Size;
LABEL_79:
    v37 = v23;
    do
      v38 = *v37++;
    while ( v38 != Buffer[0] );
    if ( (unsigned int)(v37 - (v23 + 1)) >= 0x1000 )
    {
      v39 = sub_40CDF7(v27);
      v40 = sub_40CDF7(0xFu);
      sub_405A12(0, 0x447u, String, v40, v39);
    }
    else
    {
      wcscpy_s(&::Destination, 0x8000u, v23);
    }
    v41 = sub_406271(0, v55, (wchar_t **)v13);
    v22 = (const wchar_t *)FileHandle;
    v14 = (intptr_t)v41;
    goto LABEL_85;
  }
  if ( !sub_406AA7(v16, (wint_t **)v13, &v52) )
  {
LABEL_23:
    v14 = 0;
    goto LABEL_103;
  }
  v14 = v52;
  if ( v52 )
  {
    v19 = a5;
    if ( a5 )
    {
      v20 = (wchar_t *)*v13;
LABEL_102:
      *v19 = sub_40EBA1((char *)v20);
    }
  }
LABEL_103:
  v47 = Block;
  if ( v55 == -8 )
  {
    v49 = 1;
    v50 = 1;
    if ( !v13 )
      goto LABEL_113;
    goto LABEL_111;
  }
  v48 = 0;
  if ( v13 )
  {
    while ( v13[v48] )
    {
      if ( v13[v48] == Block )
      {
        v50 = 0;
        break;
      }
      if ( ++v48 >= v55 + 8 )
        break;
    }
LABEL_111:
    free(v13);
    v49 = v50;
    goto LABEL_113;
  }
  v49 = 1;
LABEL_113:
  if ( v47 && v49 )
    free(v47);
  if ( !v14 )
  {
    if ( a5 )
      *a5 = 0;
  }
  return v14;
}
// 40797D: variable 'v30' is possibly undefined
// 40177C: using guessed type int dword_40177C;
// 411D61: using guessed type void __noreturn __report_rangecheckfailure(void);
// 423F6C: using guessed type int dword_423F6C;
// 433F70: using guessed type int dword_433F70;
// 4074DE: using guessed type char Src[522];
// 4074DE: using guessed type wchar_t Destination[59];

//----- (00407D7B) --------------------------------------------------------
void *sub_407D7B()
{
  void *v0; // esi
  wchar_t *Buffer; // [esp+4h] [ebp-214h] BYREF
  wchar_t ResultPath[262]; // [esp+8h] [ebp-210h] BYREF

  Buffer = 0;
  wdupenv_s(&Buffer, 0, L"COMSPEC");
  if ( Buffer )
  {
    v0 = sub_40EBA1((char *)Buffer);
    free(Buffer);
    return v0;
  }
  else
  {
    wsearchenv(L"CMD.EXE", aPa_0, ResultPath);
    if ( !ResultPath[0] )
      sub_405A12(0, 0x420u);
    return sub_40EBA1((char *)ResultPath);
  }
}

//----- (00407E17) --------------------------------------------------------
char __fastcall sub_407E17(__int16 *a1, int a2, char a3, char a4, const wchar_t *a5, unsigned int *a6)
{
  int v6; // ebx
  __int16 *v7; // edx
  __int16 *v8; // esi
  __int16 v9; // di
  __int16 v10; // ax
  __int16 v11; // cx
  __int16 v12; // dx
  __int16 *v13; // edi
  __int16 v14; // cx
  __int16 v15; // si
  char v17; // bh
  char v18; // bl
  int *v19; // eax
  int v20; // edi
  char v21; // al
  char v22; // dl
  unsigned int v23; // eax
  int *v24; // eax
  void *v25; // [esp-4h] [ebp-3Ch]
  void *Block; // [esp+14h] [ebp-24h] BYREF
  __int16 *v27; // [esp+18h] [ebp-20h]
  int v28; // [esp+1Ch] [ebp-1Ch]
  int v29; // [esp+20h] [ebp-18h]
  __int16 *v30; // [esp+24h] [ebp-14h] BYREF
  char v31[4]; // [esp+28h] [ebp-10h]
  int v32; // [esp+2Ch] [ebp-Ch] BYREF
  int v33; // [esp+30h] [ebp-8h] BYREF

  v29 = a2;
  v6 = 0;
  v7 = a1;
  Block = 0;
  v27 = a1;
  v8 = a1;
  v9 = *a1;
  v28 = 0;
  v10 = v9;
  if ( !v9 )
  {
LABEL_12:
    v15 = (__int16)Block;
    goto LABEL_13;
  }
  v11 = v9;
  Block = (void *)63;
  while ( 1 )
  {
    if ( v11 != 36 )
      goto LABEL_21;
    v12 = v8[1];
    if ( v12 == 40 )
      ++v8;
    v13 = v8 + 1;
    v14 = v8[1];
    if ( v14 != 63 )
      break;
    if ( v12 != 40 || wcschr(L"DFBR", v8[2]) && v8[3] == 41 || v8[2] == 41 )
    {
      v6 = dword_423F50;
      v10 = *v8;
      v7 = v27;
      v28 = dword_423F50;
      goto LABEL_12;
    }
LABEL_21:
    v11 = *++v8;
    if ( !*v8 )
      return 0;
  }
  ++v8;
  if ( v14 != 42 || v13[1] != 42 || v12 == 40 && (!wcschr(L"DFBR", v13[2]) || v13[3] != 41) && v13[2] != 41 )
    goto LABEL_21;
  v6 = dword_423F44;
  v10 = *v13;
  v7 = v27;
  v28 = dword_423F44;
  v15 = 42;
LABEL_13:
  if ( !v10 )
    return 0;
  if ( !v6 )
    goto LABEL_52;
  v31[0] = (a4 & 2) != 0;
  v17 = a3 & 2;
  v18 = a3 & 4;
  while ( 2 )
  {
    dword_42373C = v29;
    v19 = (int *)dword_423F44;
    if ( v15 != 42 )
      v19 = (int *)dword_423F50;
    v20 = *v19;
    *v19 = 0;
    Block = 0;
    v30 = v7;
    sub_40F8BE(&v33, &v30, 255, &dword_42373C, 0, (char *)&Block);
    if ( sub_410E43((char *)word_423F70, 0x8000, (unsigned __int16 *)Block, a5) )
      sub_405A12(0, 0x447u, Block, &dword_40177C, &dword_40177C);
    if ( v18 && (a4 & 8) == 0 )
    {
      v21 = 0;
      goto LABEL_33;
    }
    v21 = 1;
    if ( !v18 && ((a3 & 8) != 0 || (a4 & 1) != 0) )
    {
      v22 = 0;
      v21 = 1;
    }
    else
    {
LABEL_33:
      v22 = 1;
    }
    v23 = sub_4074DE(word_423F70, v22, v21, v31[0], (void **)&v32);
    *a6 = v23;
    if ( !v17 && v23 && v23 > dword_433F70 && !byte_423737 )
      sub_405A12(0, 0x435u, v32, v23);
    if ( v15 == 42 )
    {
      v24 = (int *)dword_423F44;
      dword_423F44 = v20;
    }
    else
    {
      v24 = (int *)dword_423F50;
      dword_423F50 = v20;
    }
    v25 = Block;
    *v24 = v20;
    free(v25);
    if ( v17 || !byte_423737 || !*a6 || *a6 <= dword_433F70 )
    {
      v7 = v27;
      if ( v20 )
        continue;
    }
    break;
  }
  v6 = v28;
LABEL_52:
  if ( v15 == 42 )
    dword_423F44 = v6;
  else
    dword_423F50 = v6;
  return 1;
}
// 40177C: using guessed type int dword_40177C;
// 423737: using guessed type char byte_423737;
// 42373C: using guessed type int dword_42373C;
// 423F44: using guessed type int dword_423F44;
// 423F50: using guessed type int dword_423F50;
// 423F70: using guessed type wchar_t word_423F70[32768];
// 433F70: using guessed type int dword_433F70;

//----- (004080AC) --------------------------------------------------------
void __fastcall sub_4080AC(int a1, __int16 **a2)
{
  int v2; // esi
  __int16 **v3; // ebx
  __int16 *v4; // ecx
  __int16 *v5; // edi
  __int16 v6; // dx
  __int16 *v7; // eax
  __int16 v8; // ax
  __int16 **v9; // [esp+10h] [ebp-4h]

  v2 = a1;
  v3 = a2;
  v9 = a2;
  if ( !a1 )
    return;
  do
  {
    v4 = *v3;
    --v2;
    v5 = *v3;
    if ( !**v3 )
      goto LABEL_15;
    v6 = *v4;
    do
    {
      if ( v6 == 92 || v6 == 94 )
      {
        v7 = v5 + 1;
        if ( v5[1] == 34 )
        {
          *v4 = v6;
          ++v5;
          v8 = *v7;
          ++v4;
        }
        else
        {
          v8 = v6;
        }
        *v4 = v8;
      }
      else
      {
        if ( v6 == 34 )
          goto LABEL_13;
        *v4 = v6;
      }
      ++v4;
LABEL_13:
      v6 = *++v5;
    }
    while ( *v5 );
    v3 = v9;
LABEL_15:
    ++v3;
    *v4 = 0;
    v9 = v3;
  }
  while ( v2 );
}

//----- (00408136) --------------------------------------------------------
void __fastcall sub_408136(int ArgList, char a2)
{
  _WORD *v4; // ecx
  __int16 v5; // ax
  HANDLE FileW; // esi
  struct _FILETIME SystemTimeAsFileTime; // [esp+10h] [ebp-8h] BYREF

  if ( *(_WORD *)ArgList == 34 )
  {
    *wcsrchr((const wchar_t *)ArgList, 0x22u) = 0;
    v4 = (_WORD *)ArgList;
    v5 = *(_WORD *)(ArgList + 2);
    *(_WORD *)ArgList = v5;
    while ( v5 )
    {
      ++v4;
      v5 = v4[1];
      *v4 = v5;
    }
  }
  sub_405AEC(5u, ArgList);
  if ( !a2 )
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    FileW = CreateFileW((LPCWSTR)ArgList, 0x100u, 0, 0, 3u, 0x80u, 0);
    if ( FileW != (HANDLE)-1 )
    {
      SetFileTime(FileW, 0, 0, &SystemTimeAsFileTime);
      CloseHandle(FileW);
    }
  }
}

//----- (004081C4) --------------------------------------------------------
__int64 __thiscall sub_4081C4(char *this)
{
  __int64 result; // rax

  if ( (*this & 0x10) == 0 )
    return *(_QWORD *)(this + 20);
  result = *(_QWORD *)(this + 4);
  if ( !result )
    return *(_QWORD *)(this + 20);
  return result;
}

//----- (004081DE) --------------------------------------------------------
WCHAR *__fastcall sub_4081DE(wchar_t *Str, LPWIN32_FIND_DATAW lpFindFileData, HANDLE *a3)
{
  unsigned __int16 *v3; // ebx
  LPWIN32_FIND_DATAW v4; // edi
  char *v5; // esi
  wchar_t *v6; // eax
  unsigned int v7; // ecx
  unsigned __int16 *v8; // edx
  unsigned __int16 v9; // cx
  HANDLE FirstFileW; // eax
  bool v13; // [esp+1Fh] [ebp-215h]
  char Block[524]; // [esp+20h] [ebp-214h] BYREF

  v3 = Str;
  v4 = lpFindFileData;
  v5 = Block;
  v6 = wcspbrk(Str, L"\"^*?");
  v13 = v6 != 0;
  if ( v6 )
  {
    v7 = wcslen(v3);
    if ( v7 + 1 > 0x104 )
    {
      v5 = (char *)sub_40B4E9((unsigned __int64)(v7 + 1) >> 31 != 0 ? -1 : 2 * (v7 + 1));
      if ( !v5 )
        sub_405A12(dword_423730, 0x41Bu);
    }
    v8 = (unsigned __int16 *)v5;
    if ( *v3 )
    {
      v9 = *v3;
      do
      {
        if ( v9 != 94 && v9 != 34 )
          *v8++ = v9;
        v9 = *++v3;
      }
      while ( *v3 );
      v4 = lpFindFileData;
    }
    v3 = (unsigned __int16 *)v5;
    *v8 = 0;
  }
  FirstFileW = FindFirstFileW(v3, v4);
  *a3 = FirstFileW;
  if ( FirstFileW != (HANDLE)-1 && sub_40850A(v3, v4) )
  {
    if ( !v13 || !wcschr(v3, 0x2Au) && !wcschr(v3, 0x3Fu) )
    {
      FindClose(*a3);
      *a3 = (HANDLE)-1;
    }
    if ( v5 != Block )
      free(v5);
    if ( (v4->dwFileAttributes & 0x10) == 0 && !v4->ftLastWriteTime.dwLowDateTime && !v4->ftLastWriteTime.dwHighDateTime )
    {
      v4->ftLastWriteTime.dwLowDateTime = -1;
      v4->ftLastWriteTime.dwHighDateTime = -1;
    }
    return v4->cFileName;
  }
  else
  {
    if ( v5 != Block )
      free(v5);
    return 0;
  }
}
// 423730: using guessed type int dword_423730;

//----- (00408369) --------------------------------------------------------
WCHAR *__fastcall sub_408369(LPWIN32_FIND_DATAW lpFindFileData, HANDLE hFindFile)
{
  if ( FindNextFileW(hFindFile, lpFindFileData) )
    return lpFindFileData->cFileName;
  FindClose(hFindFile);
  return 0;
}

//----- (0040838C) --------------------------------------------------------
void *__fastcall sub_40838C(wchar_t *a1, wchar_t *a2, struct _WIN32_FIND_DATAW *lpFindFileData, HANDLE *a4)
{
  char *v6; // ecx
  wchar_t *v8; // esi
  wchar_t v9; // ax
  wchar_t v10; // cx
  int v11; // eax

  if ( sub_4081DE(a2, lpFindFileData, a4) )
  {
    v6 = (char *)a2;
    return sub_40EBA1(v6);
  }
  if ( a1 )
  {
LABEL_5:
    v8 = &Src;
    do
    {
LABEL_6:
      v9 = *a1;
      while ( 1 )
      {
        if ( v9 )
        {
          v10 = v9;
          while ( 1 )
          {
            ++a1;
            if ( v10 != 34 )
              break;
            v10 = *a1;
            if ( !*a1 )
              goto LABEL_11;
          }
          *v8 = v10;
          if ( v10 != 59 )
          {
            ++v8;
            goto LABEL_6;
          }
        }
LABEL_11:
        if ( v8 != &Src )
          break;
        v9 = *a1;
        if ( !*a1 )
          return 0;
      }
      v11 = *(v8 - 1);
      if ( (_WORD)v11 != 92 && v11 != 47 )
        *v8++ = 92;
      *v8 = 0;
      if ( wcspbrk(&Src, L"*?") )
        goto LABEL_5;
      wcscpy_s(v8, 1024 - (v8 - &Src), a2);
      v8 = &Src;
    }
    while ( !sub_4081DE(&Src, lpFindFileData, a4) );
    v6 = (char *)&Src;
    return sub_40EBA1(v6);
  }
  return 0;
}

//----- (0040847B) --------------------------------------------------------
char __fastcall sub_40847B(_WORD *Block, LPWIN32_FIND_DATAW lpFindFileData)
{
  WCHAR *v3; // esi
  char *v4; // edx
  char v5; // bl
  int v7; // ecx
  HANDLE hFindFile; // [esp+Ch] [ebp-4h]

  v3 = Block;
  v4 = (char *)(Block + 1);
  v5 = 0;
  while ( *Block++ )
    ;
  v7 = ((char *)Block - v4) >> 1;
  if ( *v3 == 34 && v3[v7 - 1] == 34 )
  {
    v3 = sub_411373(v3);
    v5 = 1;
  }
  hFindFile = FindFirstFileW(v3, lpFindFileData);
  if ( hFindFile != (HANDLE)-1 && sub_40850A(v3, lpFindFileData) )
  {
    FindClose(hFindFile);
    if ( (lpFindFileData->dwFileAttributes & 0x10) == 0
      && !lpFindFileData->ftLastWriteTime.dwLowDateTime
      && !lpFindFileData->ftLastWriteTime.dwHighDateTime )
    {
      lpFindFileData->ftLastWriteTime.dwLowDateTime = -1;
      lpFindFileData->ftLastWriteTime.dwHighDateTime = -1;
    }
    return 1;
  }
  else
  {
    if ( v5 )
      free(v3);
    return 0;
  }
}

//----- (0040850A) --------------------------------------------------------
char __fastcall sub_40850A(wchar_t *Str, _DWORD *a2)
{
  _DWORD *v2; // ebx
  const unsigned __int16 *v3; // edi
  WCHAR *v4; // esi
  wchar_t *v5; // edx
  unsigned int v6; // ecx
  _WORD *v8; // ebx
  int v9; // edx
  __int64 v11; // rax
  WCHAR *v12; // eax
  unsigned __int16 *v13; // ecx
  unsigned __int16 v14; // ax
  WCHAR *v15; // ecx
  WCHAR v16; // dx
  HANDLE FileW; // edi
  wchar_t *v19; // [esp+10h] [ebp-10h]
  wchar_t *v20; // [esp+14h] [ebp-Ch]
  WCHAR *v22; // [esp+1Ch] [ebp-4h]

  v2 = a2;
  v3 = Str;
  if ( (*a2 & 0x400) != 0 && a2[9] == -1610612724 )
  {
    v4 = (WCHAR *)(a2 + 11);
    v5 = wcsrchr(Str, 0x5Cu);
    v20 = v5;
    if ( v5 )
    {
      v6 = wcslen(v3);
      v19 = v5 + 1;
      while ( *v5++ )
        ;
      v8 = v2 + 11;
      v9 = v5 - v19;
      while ( *v8++ )
        ;
      v11 = 2i64 * (v6 + 2 + v8 - (v4 + 1) - v9);
      v12 = (WCHAR *)sub_40B4E9(HIDWORD(v11) != 0 ? -1 : v11);
      v2 = a2;
      v22 = v12;
      if ( !v12 )
      {
        sub_405A12(dword_423730, 0x41Bu);
        v12 = 0;
      }
      v13 = v12;
      if ( v3 != v20 )
      {
        do
        {
          v14 = *v3++;
          *v13++ = v14;
        }
        while ( v3 != v20 );
        v2 = a2;
      }
      *v13 = 92;
      v15 = v13 + 1;
      if ( *v4 )
      {
        v16 = *v4;
        do
        {
          ++v4;
          *v15++ = v16;
          v16 = *v4;
        }
        while ( *v4 );
      }
      v4 = v22;
      *v15 = 0;
    }
    FileW = CreateFileW(v4, 0x80000000, 1u, 0, 3u, 0, 0);
    if ( v20 )
      free(v4);
    if ( FileW == (HANDLE)-1 )
      return 0;
    if ( !GetFileTime(FileW, (LPFILETIME)(v2 + 1), (LPFILETIME)(v2 + 3), (LPFILETIME)(v2 + 5)) )
    {
      CloseHandle(FileW);
      return 0;
    }
    CloseHandle(FileW);
  }
  return 1;
}
// 423730: using guessed type int dword_423730;

//----- (00408680) --------------------------------------------------------
int sub_408680()
{
  int result; // eax
  wchar_t *v1; // edi
  wchar_t *v2; // eax
  wchar_t *v3; // esi
  wchar_t *v4; // esi
  int v5; // eax
  char v6; // [esp+Ah] [ebp-6h] BYREF
  bool v7; // [esp+Bh] [ebp-5h]
  wchar_t *Context; // [esp+Ch] [ebp-4h] BYREF
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  while ( 1 )
  {
    result = getwc(Stream);
    if ( !dword_433F78 && (!byte_413021 || (_WORD)result != 33) )
      break;
    byte_413021 = 0;
    if ( dword_433F78 )
    {
      ungetwc(result, Stream);
      v1 = (wchar_t *)dword_433F78;
      dword_433F78 = 0;
    }
    else
    {
      v1 = sub_408829();
    }
    v7 = v1 != dword_433F7C;
    v2 = sub_408965(v1, &v6);
    v3 = v2;
    switch ( v6 )
    {
      case 9:
        if ( byte_423F61 )
          sub_405A12(dword_423724, 0x409u, v1);
        if ( sub_40AEC3(v3) == 18 )
          return 32;
        break;
      case 10:
        sub_408AFC(v2);
        break;
      case 11:
        sub_405A12(dword_423724, 0x41Au, v2);
        break;
      case 12:
        if ( !wcsnicmp(v2, L"\\t", 2u) )
        {
          sub_40D0B1((wchar_t *)L"\t");
          v3 += 2;
        }
        sub_405AEC(0xDu, v3);
        break;
      case 13:
        Context = 0;
        v4 = wcstok_s(v2, L" \t", &Context);
        if ( wcstok_s(0, L" \t", &Context) )
          sub_405A12(dword_423724, 0x409u, v4);
        v5 = sub_40B444(v4);
        if ( v5 )
          *(_BYTE *)(v5 + 12) |= 0x10u;
        break;
      default:
        sub_408E57(v6, v2, (int)&savedregs);
        break;
    }
    byte_413021 = 1;
    if ( v7 )
      free(v1);
    ++dword_423724;
  }
  return result;
}
// 413021: using guessed type char byte_413021;
// 423724: using guessed type int dword_423724;
// 423F61: using guessed type char byte_423F61;

//----- (00408829) --------------------------------------------------------
wint_t *sub_408829()
{
  __int16 v0; // si
  unsigned int v1; // edi
  wint_t i; // ax
  wchar_t *v3; // eax
  int v4; // edx
  wint_t v5; // ax
  wint_t v6; // si
  wint_t v7; // ax
  FILE *v9; // [esp-4h] [ebp-10h]

  v0 = sub_40A462(1);
  if ( v0 == 10 || v0 == -1 )
    sub_405A12(dword_423724, 0x3FAu);
  v1 = 0;
  for ( i = sub_40A53B(v0, 1); ; i = sub_40A53B(v5, 1) )
  {
    v6 = i;
    if ( i == 35 || i == 10 || i == 0xFFFF )
      break;
    if ( (unsigned int)dword_433F74 < 2 || v1 > dword_433F74 - 2 )
    {
      v4 = dword_433F74 + 1024;
      dword_433F74 += 1024;
      if ( dword_433F7C )
        v3 = (wchar_t *)sub_40B52C(dword_433F7C, 2 * v4 + 2);
      else
        v3 = (wchar_t *)sub_40B4E9((unsigned __int64)(unsigned int)(v4 + 1) >> 31 != 0 ? -1 : 2 * (v4 + 1));
      dword_433F7C = v3;
    }
    else
    {
      v3 = dword_433F7C;
    }
    v9 = Stream;
    v3[v1++] = v6;
    v5 = getwc(v9);
  }
  dword_433F7C[v1] = 0;
  if ( i == 35 )
  {
    while ( 1 )
    {
      v7 = getwc(Stream);
      v6 = v7;
      if ( v7 == 10 )
        break;
      if ( v7 == 0xFFFF )
        goto LABEL_21;
    }
  }
  if ( v6 == 0xFFFF )
LABEL_21:
    ungetwc(v6, Stream);
  return sub_40F81F(dword_433F7C);
}
// 423724: using guessed type int dword_423724;
// 433F74: using guessed type int dword_433F74;

//----- (00408965) --------------------------------------------------------
wchar_t *__fastcall sub_408965(wchar_t *String1, char *a2)
{
  wchar_t *v2; // edi
  wchar_t *v3; // ebx
  wchar_t *v4; // esi
  wchar_t v5; // dx
  wchar_t *v6; // eax
  wchar_t v7; // di
  wchar_t v8; // cx
  bool v9; // zf
  int v10; // esi
  wchar_t v11; // cx
  char v12; // al
  wchar_t *v14; // [esp+14h] [ebp-14h]
  int v15; // [esp+20h] [ebp-8h] BYREF
  char *v16; // [esp+24h] [ebp-4h]

  v2 = String1;
  v16 = a2;
  v3 = String1;
  v14 = String1;
  *a2 = 0;
  v4 = String1;
  v15 = (int)String1;
  v5 = *String1;
  if ( *String1 )
  {
    v6 = String1;
    v7 = *String1;
    do
    {
      v5 = v7;
      if ( v7 == 32 )
        break;
      v4 = v6;
      v5 = v7;
      if ( v7 == 9 )
        break;
      v3 = String1 + 1;
      v4 = v3;
      v8 = String1[1];
      v15 = (int)v3;
      v7 = v8;
      v5 = v8;
      v9 = v8 == 0;
      v6 = v3;
      String1 = v3;
    }
    while ( !v9 );
    v2 = v14;
  }
  v10 = v4 - v2;
  if ( v5 )
  {
    v11 = v5;
    do
    {
      if ( v11 != 32 && v11 != 9 )
        break;
      v15 = (int)++v3;
      v11 = *v3;
    }
    while ( *v3 );
    v2 = v14;
  }
  if ( wcsnicmp(v2, L"INCLUDE", 7u) || v10 != 7 )
  {
    if ( wcsnicmp(v2, L"CMDSWITCHES", 0xBu) || v10 != 11 )
    {
      if ( wcsnicmp(v2, L"ERROR", 5u) || v10 != 5 )
      {
        if ( wcsnicmp(v2, L"MESSAGE", 7u) || v10 != 7 )
        {
          if ( wcsnicmp(v2, L"UNDEF", 5u) || v10 != 5 )
          {
            v12 = sub_408C7B(v2, v10, (wchar_t **)&v15);
            *v16 = v12;
            if ( !v12 )
              sub_405A12(dword_423724, 0x3F9u, dword_433F7C);
            return (wchar_t *)v15;
          }
          else
          {
            *v16 = 13;
          }
        }
        else
        {
          *v16 = 12;
        }
      }
      else
      {
        *v16 = 11;
      }
    }
    else
    {
      *v16 = 10;
    }
  }
  else
  {
    *v16 = 9;
  }
  return v3;
}
// 423724: using guessed type int dword_423724;

//----- (00408AFC) --------------------------------------------------------
int __thiscall sub_408AFC(wint_t *this)
{
  wint_t *v1; // esi
  int result; // eax
  wint_t v3; // dx
  wint_t v4; // cx
  wint_t v5; // dx
  wint_t v6; // cx
  wchar_t v7; // ax
  wchar_t v8; // ax
  wint_t v9; // dx
  wchar_t v10; // ax
  wchar_t v11; // ax

  v1 = this;
  result = *this;
  if ( (_WORD)result )
  {
    v3 = *this;
    do
    {
      if ( v3 == 43 )
      {
        result = *++v1;
        v5 = result;
        if ( (_WORD)result )
        {
          v6 = *v1;
          do
          {
            v5 = v6;
            if ( v6 == 45 )
              break;
            v7 = towupper(v6);
            if ( wcschr(L"DINSU", v7) || byte_423F61 && (v8 = towupper(*v1), wcschr(L"ABCEKLPQRTY", v8)) )
              sub_40CA78(*v1, 1);
            else
              sub_405A12(dword_423724, 0x400u);
            result = *++v1;
            v6 = result;
            v5 = *v1;
          }
          while ( (_WORD)result );
        }
        v4 = v5;
        if ( !v5 )
          goto LABEL_27;
      }
      else
      {
        result = v3 - 45;
        if ( v3 != 45 )
        {
          v4 = v3;
          if ( v3 != 32 )
          {
            v4 = v3;
            if ( v3 != 9 )
            {
              result = sub_405A12(dword_423724, 0x400u);
              v4 = *v1;
            }
          }
LABEL_27:
          if ( !v4 )
            return result;
          goto LABEL_28;
        }
      }
      result = *++v1;
      v4 = result;
      if ( !(_WORD)result )
        goto LABEL_27;
      v9 = *v1;
      while ( v9 != 43 )
      {
        v10 = towupper(v9);
        if ( wcschr(L"DINSU", v10) || byte_423F61 && (v11 = towupper(*v1), wcschr(L"ABCEKLMPQRTV", v11)) )
          sub_40CA78(*v1, 0);
        else
          sub_405A12(dword_423724, 0x400u);
        result = *++v1;
        v9 = result;
        v4 = *v1;
        if ( !(_WORD)result )
          goto LABEL_27;
      }
LABEL_28:
      result = *++v1;
      v3 = result;
    }
    while ( (_WORD)result );
  }
  return result;
}
// 423724: using guessed type int dword_423724;
// 423F61: using guessed type char byte_423F61;

//----- (00408C7B) --------------------------------------------------------
char __fastcall sub_408C7B(wchar_t *String1, int a2, wchar_t **a3)
{
  char v4; // bl
  wchar_t *v5; // ecx
  wchar_t v6; // dx
  wchar_t v7; // ax
  int (__cdecl *v8)(const wchar_t *, const wchar_t *, size_t); // edi
  int v9; // esi
  wchar_t v10; // di
  wchar_t *String1b; // [esp+10h] [ebp-4h]

  v4 = 0;
  if ( !wcsnicmp(String1, L"IF", 2u) && a2 == 2 )
    return 1;
  if ( !wcsnicmp(String1, L"IFDEF", 5u) && a2 == 5 )
    return 6;
  if ( !wcsnicmp(String1, L"IFNDEF", 6u) && a2 == 6 )
    return 7;
  if ( wcsnicmp(String1, L"ELSE", 4u) || a2 != 4 )
  {
    if ( wcsnicmp(String1, L"ELSEIF", 6u) || a2 != 6 )
    {
      if ( wcsnicmp(String1, L"ELSEIFDEF", 9u) || a2 != 9 )
      {
        if ( !wcsnicmp(String1, L"ELSEIFNDEF", 0xAu) && a2 == 10 )
          return 5;
        if ( !wcsnicmp(String1, L"ENDIF", 5u) && a2 == 5 )
          return 8;
        return v4;
      }
      return 4;
    }
    return 3;
  }
  v5 = *a3;
  if ( !**a3 )
    return 2;
  String1b = *a3;
  v6 = **a3;
  do
  {
    v7 = v6;
    if ( v6 == 32 )
      break;
    v7 = v6;
    if ( v6 == 9 )
      break;
    v7 = *++v5;
    v6 = *v5;
  }
  while ( *v5 );
  v8 = wcsnicmp;
  v9 = v5 - String1b;
  if ( v7 )
  {
    v10 = v7;
    do
    {
      if ( v10 != 32 && v10 != 9 )
        break;
      v10 = *++v5;
    }
    while ( *v5 );
    v8 = wcsnicmp;
  }
  *a3 = v5;
  if ( !v8(String1b, L"IF", 2u) && v9 == 2 )
    return 3;
  if ( !v8(String1b, L"IFDEF", 5u) && v9 == 5 )
    return 4;
  if ( !v8(String1b, L"IFNDEF", 6u) && v9 == 6 )
    return 5;
  return v4;
}

//----- (00408E57) --------------------------------------------------------
char __usercall sub_408E57@<al>(char a1@<dl>, wchar_t *a2@<ecx>, int a3@<ebp>)
{
  int v3; // eax
  wchar_t *v4; // esi
  int v5; // eax
  int v6; // eax
  char v7; // al
  char v8; // al
  bool v9; // zf
  char v10; // al
  char v11; // al
  wint_t v12; // ax
  _DWORD v14[2]; // [esp-4h] [ebp-8h] BYREF

  LOBYTE(v3) = a1 - 1;
  v4 = a2;
  switch ( a1 )
  {
    case 1:
    case 6:
    case 7:
      v5 = dword_413024;
      if ( dword_413024 != 15 )
        goto LABEL_5;
      v5 = sub_405A12(dword_423724, 0x3FBu);
      goto LABEL_4;
    case 2:
      if ( dword_413024 < 0 )
        goto LABEL_21;
      a2 = (wchar_t *)&byte_433F80[dword_413024];
      v7 = byte_433F80[dword_413024];
      if ( (v7 & 9) == 0 )
        goto LABEL_21;
      v8 = v7 & 0xF6;
      *(_BYTE *)a2 = v8;
      if ( (v8 & 4) != 0 )
        goto LABEL_8;
      if ( (v8 & 2) != 0 )
        LOBYTE(v3) = v8 & 0xFD;
      else
        LOBYTE(v3) = v8 | 2;
      v9 = (v3 & 2) == 0;
      *(_BYTE *)a2 = v3;
      goto LABEL_19;
    case 3:
    case 4:
    case 5:
      a2 = (wchar_t *)dword_413024;
      if ( dword_413024 < 0 || (v10 = byte_433F80[dword_413024], (v10 & 9) == 0) )
      {
LABEL_21:
        v5 = sub_405A12(dword_423724, 0x3FDu);
        goto LABEL_4;
      }
      v11 = v10 & 0xF6 | 8;
      byte_433F80[dword_413024] = v11;
      if ( (v11 & 4) != 0 )
        goto LABEL_8;
      if ( (v11 & 2) != 0 )
      {
        byte_433F80[(_DWORD)a2] = v11 & 0xF9 | 4;
        goto LABEL_8;
      }
      a2 = v4;
      goto LABEL_9;
    case 8:
      if ( dword_413024 >= 0 )
      {
        v3 = dword_413024 - 1;
        dword_413024 = v3;
        if ( v3 < 0 )
          return v3;
        v9 = (byte_433F80[v3] & 2) == 0;
LABEL_19:
        if ( !v9 )
          return v3;
      }
      else
      {
        v5 = sub_405A12(dword_423724, 0x401u);
LABEL_4:
        a2 = (wchar_t *)v14[0];
LABEL_5:
        v9 = v5 == -1;
        v6 = v5 + 1;
        dword_413024 = v6;
        byte_433F80[v6] = 1;
        if ( v9 || (*((_BYTE *)&dword_433F7C + v6 + 3) & 2) != 0 )
        {
LABEL_9:
          if ( sub_40E2BF(a2, a1) )
          {
            LOBYTE(v3) = dword_413024;
            byte_433F80[dword_413024] |= 2u;
            return v3;
          }
        }
        else
        {
          byte_433F80[v6] = 5;
        }
      }
LABEL_8:
      v14[1] = a3;
      HIBYTE(v14[0]) = HIBYTE(a2);
      while ( 1 )
      {
        v12 = getwc(Stream);
        if ( v12 != 33 )
        {
          do
          {
            if ( v12 == 0xFFFF )
              goto LABEL_52;
            ++dword_423724;
            while ( 1 )
            {
              if ( v12 == 92 )
              {
                v12 = sub_40A53B(0x5Cu, 1);
                if ( v12 == 33 && byte_413021 )
                  goto LABEL_47;
                byte_413021 = 0;
              }
              if ( v12 == 35 )
                break;
              if ( v12 == 10 )
                goto LABEL_45;
              if ( v12 == 0xFFFF )
                goto LABEL_46;
              v12 = getwc(Stream);
            }
            while ( 1 )
            {
              v12 = getwc(Stream);
              if ( v12 == 10 )
                break;
              if ( v12 == 0xFFFF )
                goto LABEL_46;
            }
LABEL_45:
            v12 = getwc(Stream);
          }
          while ( v12 != 33 );
LABEL_46:
          if ( v12 != 33 )
          {
LABEL_52:
            LOBYTE(v3) = sub_405A12(dword_423724, 0x3FCu);
            return v3;
          }
        }
LABEL_47:
        if ( dword_433F78 && dword_433F78 != dword_433F7C )
          free(dword_433F78);
        dword_433F78 = sub_408829();
        LOBYTE(v3) = (unsigned __int8)sub_408965((wchar_t *)dword_433F78, (char *)v14 + 3);
        if ( HIBYTE(v14[0]) <= 8u )
          return v3;
        ++dword_423724;
      }
    default:
      return v3;
  }
}
// 408E57: could not find valid save-restore pair for ebp
// 409024: conditional instruction was optimized away because ax.2==A
// 409029: conditional instruction was optimized away because ax.2==A
// 409086: conditional instruction was optimized away because ax.2==FFFF
// 408F8A: variable 'a2' is possibly undefined
// 408EAD: variable 'a1' is possibly undefined
// 413021: using guessed type char byte_413021;
// 413024: using guessed type int dword_413024;
// 423724: using guessed type int dword_423724;

//----- (0040909F) --------------------------------------------------------
char sub_40909F()
{
  char v0; // bl
  wchar_t *i; // eax
  const wchar_t *v2; // ecx
  wchar_t *v3; // edx
  int v5; // edx
  wchar_t *v7; // [esp+4h] [ebp-Ch]
  wchar_t *Context; // [esp+Ch] [ebp-4h] BYREF

  v0 = 0;
  for ( dword_423724 = 0; ; ++dword_423724 )
  {
    if ( !fgetws(&Src, 1024, Stream) )
    {
      if ( !feof(Stream) )
      {
        dword_423730 = dword_423724;
        sub_405A12(0, 0x41Du);
      }
      return 0;
    }
    if ( Src == 91 )
      break;
LABEL_13:
    ;
  }
  Context = 0;
  for ( i = wcstok_s(&word_423742, L" \t\n", &Context); ; i = wcstok_s(0, L" \t\n", &Context) )
  {
    v2 = i;
    if ( !i || v0 )
    {
      v0 = 0;
      goto LABEL_13;
    }
    v3 = i;
    v7 = i + 1;
    while ( *v3++ )
      ;
    v5 = v3 - v7;
    if ( v2[v5 - 1] == 93 )
    {
      v0 = 1;
      v2[v5 - 1] = 0;
    }
    if ( !wcsicmp(v2, L"nmake") )
      break;
  }
  return 1;
}
// 423724: using guessed type int dword_423724;
// 423730: using guessed type int dword_423730;

//----- (00409188) --------------------------------------------------------
char __stdcall sub_409188(int a1)
{
  wchar_t ResultPath[260]; // [esp+0h] [ebp-20Ch] BYREF

  wsearchenv(L"tools.ini", L"INIT", ResultPath);
  if ( ResultPath[0] )
  {
    Stream = wfsopen(ResultPath, L"rt,ccs=unicode", 32);
    if ( !Stream )
      sub_405A12(0, 0x41Du, ResultPath);
    if ( sub_40909F() )
      return 1;
    if ( fclose(Stream) == -1 )
      sub_405A12(0, 0x424u, ResultPath);
  }
  return 0;
}

//----- (0040923A) --------------------------------------------------------
wint_t *__fastcall sub_40923A(wint_t *a1, int a2)
{
  wint_t *v2; // esi
  wint_t *v3; // edi
  wint_t *v4; // ecx
  wint_t v5; // ax
  wint_t *result; // eax
  FILE *v7; // [esp-4h] [ebp-Ch]

  v2 = a1;
  v3 = &a1[a2];
  while ( 1 )
  {
    v5 = sub_408680();
    if ( !v5 )
      return v2;
    v4 = v2;
    if ( v5 == 0xFFFF )
      break;
    *v2++ = v5;
    if ( v2 == v3 )
    {
      v7 = Stream;
      *v4 = 0;
      ungetwc(v5, v7);
      return v2;
    }
    if ( v5 == 10 )
    {
      ++dword_423724;
      byte_413021 = 1;
      *v2 = 0;
      return v2;
    }
    byte_413021 = 0;
  }
  result = 0;
  *v2 = 0;
  return result;
}
// 413021: using guessed type char byte_413021;
// 423724: using guessed type int dword_423724;

//----- (004092A9) --------------------------------------------------------
wchar_t *__fastcall sub_4092A9(const wchar_t *a1)
{
  wchar_t *result; // eax
  const wchar_t *v3; // esi

  for ( result = wcschr(a1, 0xAu); result && (result <= a1 || *(result - 1) == 94); result = wcschr(v3, 0xAu) )
  {
    v3 = result + 1;
    if ( !fgetws(result + 1, 1024 - (result + 1 - a1), Stream) )
    {
      if ( feof(Stream) )
        sub_405A12(dword_423724, 0x409u, L"EOF");
      sub_405A12(dword_423724, 0x41Du);
    }
    ++dword_423724;
  }
  return result;
}
// 4019B8: using guessed type wchar_t aEof[4];
// 423724: using guessed type int dword_423724;

//----- (0040933D) --------------------------------------------------------
void *__thiscall sub_40933D(__int16 **this)
{
  __int16 **v1; // ebx
  _WORD *v2; // edi
  const wchar_t *v3; // edx
  wchar_t *v4; // eax
  __int16 *v5; // edx
  __int16 v6; // ax
  bool v7; // bl
  __int16 v8; // si
  bool v9; // zf
  __int16 v10; // cx
  void *result; // eax

  v1 = this;
  v2 = &unk_434480;
  v3 = (const wchar_t *)*this;
  do
  {
    v4 = wcschr(v3, 0x3Cu);
    if ( !v4 )
      return 0;
    v3 = v4 + 1;
  }
  while ( v4[1] != 60 );
  v5 = (__int16 *)(v4 + 2);
  v6 = *v5;
  if ( *v5 )
  {
    v7 = 0;
LABEL_6:
    v8 = v6;
    do
    {
      if ( v8 == 62 || v8 == 60 || v8 == 94 || v8 == 44 || v8 == 9 || v8 == 10 )
        break;
      if ( v8 == 34 )
        v7 = !v7;
      if ( v8 == 32 && !v7 )
        break;
      if ( v8 == 36 )
      {
        v9 = v5[1] == 40;
        ++v5;
        if ( v9 )
        {
          *v2++ = 36;
          *v2 = 40;
          if ( *v5 == 10 )
            break;
          v10 = *v5;
          while ( 1 )
          {
            v6 = v10;
            if ( v10 == 41 )
              goto LABEL_6;
            ++v5;
            *v2++ = v10;
            v10 = *v5;
            if ( *v5 == 10 )
              goto LABEL_27;
          }
        }
      }
      else
      {
        ++v5;
      }
      *v2++ = v8;
      v8 = *v5;
    }
    while ( *v5 );
LABEL_27:
    v1 = this;
  }
  result = &unk_434480;
  *v2 = 0;
  *v1 = v5;
  return result;
}

//----- (0040946B) --------------------------------------------------------
wchar_t *__fastcall sub_40946B(wchar_t *a1, _DWORD *a2, wchar_t **a3)
{
  _DWORD *v4; // ebx
  int *v5; // edx
  int *v6; // ecx
  char *v7; // esi
  wchar_t v8; // cx
  wchar_t *v9; // ebx
  _WORD *v10; // esi
  char *v11; // eax
  int v12; // esi
  char *v13; // eax
  char *v16; // [esp+1Ch] [ebp-820h]
  unsigned int v17; // [esp+20h] [ebp-81Ch]
  wchar_t *v18; // [esp+24h] [ebp-818h] BYREF
  void *Block; // [esp+28h] [ebp-814h]
  char v20; // [esp+2Fh] [ebp-80Dh]
  wchar_t Destination[2]; // [esp+30h] [ebp-80Ch] BYREF
  wint_t v22[1024]; // [esp+34h] [ebp-808h] BYREF

  v16 = 0;
  v17 = 0;
  v20 = 0;
  Block = 0;
  wcscpy_s(Destination, 0x400u, L"<<");
  if ( !sub_40923A(v22, 1022) )
  {
    if ( feof(Stream) )
      sub_405A12(dword_423724, 0x409u, L"EOF");
    sub_405A12(dword_423724, 0x41Du);
  }
  v18 = Destination;
  sub_4092A9(Destination);
  while ( 1 )
  {
    v7 = (char *)sub_40933D((__int16 **)&v18);
    if ( !v7 )
      break;
    v4 = sub_40B50E(0xCu);
    v4[1] = sub_40EBA1(v7);
    v5 = &dword_4343A0;
    v6 = (int *)dword_4343A0;
    if ( dword_4343A0 )
    {
      do
      {
        v5 = v6;
        v6 = (int *)*v6;
      }
      while ( v6 );
    }
    *v5 = (int)v4;
  }
  if ( dword_4343A0 )
  {
    v18 = (wchar_t *)wcsncpy_s;
    do
    {
      while ( 1 )
      {
        v8 = Destination[0];
        v9 = Destination;
        do
        {
          ++v9;
          *a1++ = v8;
          if ( a1 == *a3 )
          {
            if ( Block )
            {
              v12 = 2 * v17;
              if ( v17 + 1024 < v17 || (v13 = (char *)sub_40B52C(Block, v12 + 2048), (v16 = v13) == 0) )
              {
                sub_405A12(dword_423724, 0x419u);
                v13 = v16;
              }
              Block = v13;
              a1 = (wchar_t *)&v13[v12];
              v10 = v13;
              v17 += 1024;
              v11 = &v13[2 * v17];
            }
            else
            {
              v10 = sub_40B4E9(0x1000u);
              Block = v10;
              ((void (__cdecl *)(_WORD *, int, _DWORD, int))v18)(v10, 2048, *a2, 1024);
              a1 = v10 + 1024;
              v17 = 2048;
              v11 = (char *)(v10 + 2048);
            }
            *a3 = (wchar_t *)v11;
            *a2 = v10;
          }
          v8 = *v9;
        }
        while ( *v9 );
        if ( v20 && Destination[0] == 60 && Destination[1] == 60 )
          break;
        v20 = 1;
        if ( !sub_40923A(Destination, 1024) )
        {
          if ( feof(Stream) )
            sub_405A12(dword_423724, 0x409u, L"EOF");
          sub_405A12(dword_423724, 0x41Du);
        }
      }
      if ( *(_DWORD *)dword_4343A0 && !sub_40923A(Destination, 1024) )
      {
        if ( feof(Stream) )
          sub_405A12(dword_423724, 0x409u, L"EOF");
        sub_405A12(dword_423724, 0x41Du);
      }
      dword_4343A0 = *(_DWORD *)dword_4343A0;
    }
    while ( dword_4343A0 );
  }
  *a1 = 0;
  return a1;
}
// 4019B8: using guessed type wchar_t aEof[4];
// 423724: using guessed type int dword_423724;
// 4343A0: using guessed type int dword_4343A0;
// 40946B: using guessed type wint_t var_808[1024];

//----- (00409790) --------------------------------------------------------
errno_t __fastcall sub_409790(void **a1, wchar_t *a2)
{
  char *v2; // edi
  _WORD *v3; // esi
  int v4; // ecx
  int v6; // esi
  wchar_t *v7; // ecx
  int v8; // esi
  wchar_t *v9; // edx
  void *v11; // esp
  wchar_t *i; // eax
  __int16 v13; // dx
  unsigned int v14; // kr00_4
  void **v15; // edi
  wchar_t *v16; // eax
  rsize_t v18; // [esp-8h] [ebp-28h]
  wchar_t *v19; // [esp-4h] [ebp-24h]
  wchar_t v20[8]; // [esp+0h] [ebp-20h] BYREF
  void **v21; // [esp+10h] [ebp-10h]
  wchar_t *Source; // [esp+14h] [ebp-Ch]
  rsize_t SizeInWords; // [esp+18h] [ebp-8h]

  Source = a2;
  v21 = a1;
  v2 = (char *)*a1;
  v3 = *a1;
  v4 = (int)*a1 + 2;
  while ( *v3++ )
    ;
  v6 = (int)v3 - v4;
  v7 = a2;
  v8 = v6 >> 1;
  v9 = a2 + 1;
  while ( *v7++ )
    ;
  SizeInWords = v7 - v9 - 1 + v8;
  v11 = alloca(2 * SizeInWords);
  for ( i = v20; ; ++i )
  {
    if ( *(_WORD *)v2 != 60 )
    {
      v13 = *(_WORD *)v2;
      goto LABEL_10;
    }
    if ( *((_WORD *)v2 + 1) == 60 )
      break;
    v13 = 60;
LABEL_10:
    v2 += 2;
    *i = v13;
  }
  v19 = Source;
  v18 = SizeInWords;
  *i = 0;
  wcscat_s(v20, v18, v19);
  wcscat_s(v20, SizeInWords, (const wchar_t *)v2 + 2);
  v14 = wcslen(v20);
  v15 = v21;
  v16 = (wchar_t *)sub_40B52C(*v21, 2 * (v14 + 1));
  *v15 = v16;
  return wcscpy_s(v16, v14 + 1, v20);
}

//----- (00409874) --------------------------------------------------------
int __fastcall sub_409874(wchar_t *Source, const unsigned __int16 *a2, char a3)
{
  const wchar_t *v3; // edi
  wint_t *v4; // esi
  wint_t v5; // cx
  const wchar_t *v6; // eax
  int result; // eax
  int v8; // esi
  int v9; // edi
  wint_t v10; // cx
  unsigned int v11; // esi
  const wchar_t *v12; // eax
  unsigned int v13; // [esp+Ch] [ebp-10h]
  wchar_t *v14; // [esp+10h] [ebp-Ch]
  wint_t *v15; // [esp+14h] [ebp-8h]
  const unsigned __int16 *v16; // [esp+18h] [ebp-4h]
  char v17; // [esp+27h] [ebp+Bh]

  v3 = Source;
  v14 = Source;
  v16 = a2;
  v4 = Source;
  v5 = *Source;
  if ( v5 )
  {
    while ( iswspace(v5) )
    {
      v5 = *++v4;
      if ( !*v4 )
      {
        a2 = v16;
        goto LABEL_5;
      }
    }
    result = 1012 - wcslen(v16);
    v13 = result;
    if ( *v3 )
    {
      v17 = a3;
      do
      {
        wcsncpy_s(word_4376E0, 0x400u, v3, result);
        v8 = wcslen(word_4376E0);
        if ( v13 < wcslen(v3) )
        {
          v15 = word_4376E0;
          if ( word_4376E0[0] )
          {
            v9 = 0;
            v10 = word_4376E0[0];
            do
            {
              if ( iswspace(v10) )
                v8 = (v9 >> 1) + 1;
              v9 += 2;
              v10 = *++v15;
            }
            while ( *v15 );
            v3 = v14;
          }
        }
        v11 = v8;
        if ( v11 >= 1024 )
          __report_rangecheckfailure();
        word_4376E0[v11] = 0;
        v12 = L">>";
        if ( !v17 )
          v12 = L">";
        sub_40D0B1((wchar_t *)L"\techo %s %s %s\n", word_4376E0, v12, v16);
        v3 = (const wchar_t *)((char *)v3 + v11 * 2);
        v17 = 1;
        v14 = (wchar_t *)v3;
        result = v13;
      }
      while ( *v3 );
    }
  }
  else
  {
LABEL_5:
    v6 = L">>";
    if ( !a3 )
      v6 = L">";
    return sub_40D0B1((wchar_t *)L"\techo. %s %s\n", v6, a2);
  }
  return result;
}
// 401780: using guessed type wchar_t asc_401780[2];
// 4019D0: using guessed type wchar_t asc_4019D0[3];
// 411D61: using guessed type void __noreturn __report_rangecheckfailure(void);
// 4376E0: using guessed type wchar_t word_4376E0[1024];

//----- (004099E5) --------------------------------------------------------
wchar_t *__fastcall sub_4099E5(FILE *a1, int a2, const wchar_t **a3, char a4, _BYTE *a5)
{
  const wchar_t **v5; // edi
  const unsigned __int16 *v6; // esi
  wchar_t *v7; // eax
  char *v8; // ebx
  wchar_t *v9; // esi
  void *v10; // eax
  wchar_t *v11; // esi
  wchar_t *result; // eax
  wchar_t *v13; // ebx
  wchar_t *v14; // ecx
  const wchar_t *v15; // esi
  FILE *v16; // edi
  int v17; // eax
  void *Block; // [esp+10h] [ebp-14h] BYREF
  wchar_t *Context; // [esp+14h] [ebp-10h] BYREF
  const unsigned __int16 *v20; // [esp+18h] [ebp-Ch]
  FILE *Stream; // [esp+1Ch] [ebp-8h]
  char v22; // [esp+23h] [ebp-1h]
  char v23; // [esp+34h] [ebp+10h]

  v5 = a3;
  v6 = (const unsigned __int16 *)a2;
  v20 = (const unsigned __int16 *)a2;
  Stream = a1;
  v7 = wcsstr(*a3, L"<<");
  v22 = 0;
  if ( v7 && (v7 == *a3 || *(v7 - 1) == 10) )
  {
    v8 = (char *)(v7 + 2);
    v9 = wcschr(v7 + 2, 0xAu);
    if ( v9 )
      *v9 = 0;
    v10 = sub_40EBA1(v8);
    Block = v10;
    if ( v9 )
      *v9 = 10;
    Context = 0;
    v11 = wcstok_s((wchar_t *)v10, L", \t", &Context);
    if ( v11 )
    {
      do
      {
        if ( wcsicmp(v11, L"keep") )
        {
          if ( wcsicmp(v11, L"nokeep") )
          {
            if ( wcsicmp(v11, L"unicode") )
              sub_405A12(dword_423724, 0x446u);
            else
              v22 = 1;
          }
          else
          {
            *a5 = 0;
          }
        }
        else
        {
          *a5 = 1;
        }
        v11 = wcstok_s(0, L", \t", &Context);
      }
      while ( v11 );
      v5 = a3;
    }
    free(Block);
    if ( v22 )
      fwrite(&dword_401A48, 2u, 1u, Stream);
    v6 = v20;
  }
  result = (wchar_t *)wcsncmp(*v5, L"<<", 2u);
  if ( result )
  {
    v23 = 0;
    while ( 1 )
    {
      result = wcschr(*v5, 0xAu);
      v13 = result;
      if ( !result )
        break;
      if ( a4 )
      {
        v14 = (wchar_t *)*v5;
        *result = 0;
        sub_409874(v14, v6, v23);
        *v13 = 10;
      }
      v15 = *v5;
      if ( v22 )
      {
        fwrite(v15, v13 - v15, 2u, Stream);
        fwrite("\r", 4u, 1u, Stream);
      }
      else
      {
        if ( v15 < v13 )
        {
          v16 = Stream;
          do
          {
            v17 = WideCharToMultiByte(0, 0, v15, 1, (LPSTR)&Block, 4, 0, 0);
            if ( v17 )
              fwrite(&Block, v17, 1u, v16);
            ++v15;
          }
          while ( v15 < v13 );
          v5 = a3;
        }
        fwrite("\r\n", 2u, 1u, Stream);
      }
      v23 = 1;
      *v5 = v13 + 1;
      result = (wchar_t *)wcsncmp(v13 + 1, L"<<", 2u);
      v6 = v20;
      if ( !result )
        goto LABEL_36;
    }
  }
  else
  {
LABEL_36:
    *v5 += 2;
  }
  return result;
}
// 401A48: using guessed type int dword_401A48;
// 423724: using guessed type int dword_423724;

//----- (00409C09) --------------------------------------------------------
char __fastcall sub_409C09(wchar_t *Str, void **a2, _DWORD *a3, char a4)
{
  wchar_t *v5; // eax
  wchar_t *v6; // ebx
  wchar_t **v8; // ecx
  __int16 *v9; // ebx
  void *v10; // eax
  const wchar_t **v11; // esi
  _WORD *v12; // edi
  FILE *v13; // eax
  unsigned int v14; // kr00_4
  wchar_t *v15; // edx
  const wchar_t *v16; // eax
  __int16 *v17; // ecx
  __int16 v18; // ax
  wchar_t *v19; // edi
  wchar_t *v20; // eax
  wchar_t *v21; // eax
  wchar_t *v22; // ecx
  __int16 v23; // ax
  _DWORD *v24; // eax
  void *v25; // edi
  _DWORD *v26; // esi
  char *v27; // eax
  char v28; // [esp+13h] [ebp-445h] BYREF
  void **v29; // [esp+14h] [ebp-444h]
  void *v30; // [esp+18h] [ebp-440h] BYREF
  FILE *Stream; // [esp+1Ch] [ebp-43Ch]
  void *Block; // [esp+20h] [ebp-438h]
  const wchar_t *v33; // [esp+24h] [ebp-434h] BYREF
  wchar_t *Stra; // [esp+28h] [ebp-430h] BYREF
  size_t RequiredCount[2]; // [esp+2Ch] [ebp-42Ch] BYREF
  int v36; // [esp+34h] [ebp-424h]
  __int16 *v37[2]; // [esp+38h] [ebp-420h] BYREF
  wchar_t Buffer; // [esp+40h] [ebp-418h] BYREF
  __int16 v39[259]; // [esp+42h] [ebp-416h] BYREF
  WCHAR TempFileName[262]; // [esp+248h] [ebp-210h] BYREF

  v29 = a2;
  v5 = wcschr(Str, 0xAu);
  v6 = v5;
  if ( v5 )
  {
    RequiredCount[0] = (size_t)Str;
    *v5 = 0;
    v36 = 0;
    v30 = 0;
    sub_40F8BE(v37, (__int16 **)RequiredCount, 255, a3, 0, (char *)&v30);
    v8 = (wchar_t **)v29;
    *v29 = v30;
    *v6 = 10;
    v9 = (__int16 *)(v6 + 1);
    if ( *v8 == Str )
    {
      v10 = sub_40EBA1((char *)Str);
      v11 = (const wchar_t **)v29;
      *v29 = v10;
    }
    else
    {
      v11 = (const wchar_t **)v8;
    }
    v33 = *v11;
    v30 = 0;
    v37[0] = v9;
    sub_40F8BE(RequiredCount, v37, 255, a3, 0, (char *)&v30);
    Stra = (wchar_t *)v30;
    while ( 1 )
    {
      v27 = (char *)sub_40933D((__int16 **)&v33);
      if ( !v27 )
        break;
      v28 = 0;
      v12 = sub_40EBA1(v27);
      Block = v12;
      if ( *v12 )
      {
        Stream = sub_4113E8(v12, (wchar_t *)L"wb");
        if ( Stream )
        {
          v15 = wcschr(*v11, 0x3Cu);
          v16 = v15 + 1;
          if ( v15[1] != 60 )
          {
            do
            {
              v15 = wcschr(v16, 0x3Cu);
              v16 = v15 + 1;
            }
            while ( v15[1] != 60 );
            v11 = (const wchar_t **)v29;
          }
          v17 = (__int16 *)(v15 + 2);
          v33 = v15 + 3;
          do
            v18 = *v17++;
          while ( v18 != (_WORD)v36 );
          memmove(v15, v15 + 2, 2 * (((char *)v17 - (char *)v33) >> 1) + 2);
          v12 = Block;
        }
        else
        {
          sub_405A12(dword_423724, 0x41Eu, v12);
        }
      }
      else
      {
        RequiredCount[0] = 0;
        if ( wgetenv_s(RequiredCount, &Buffer, 0x103u, L"TMP") || !RequiredCount[0] )
          wcscpy_s(&Buffer, 0x103u, L".");
        Stream = 0;
        if ( GetTempFileNameW(&Buffer, L"nm", 0, TempFileName) )
        {
          wcscpy_s(&Buffer, 0x103u, TempFileName);
          v13 = wfsopen(&Buffer, L"wb", 32);
          Stream = v13;
        }
        else
        {
          v13 = Stream;
        }
        if ( !v13 )
          sub_405A12(dword_423724, 0x41Eu, &Buffer);
        if ( wcschr(&Buffer, 0x20u) && !wcschr(&Buffer, 0x22u) )
        {
          v14 = wcslen(&Buffer);
          memmove(v39, &Buffer, 2 * v14);
          Buffer = 34;
          v39[v14] = 34;
          if ( 2 * v14 + 4 >= 0x206 )
            __report_rangecheckfailure();
          v11 = (const wchar_t **)v29;
          v39[v14 + 1] = 0;
          v12 = Block;
        }
        sub_409790((void **)v11, &Buffer);
        free(v12);
        v12 = sub_40EBA1((char *)&Buffer);
        Block = v12;
      }
      v33 = *v11;
      sub_4099E5(Stream, (int)v12, (const wchar_t **)&Stra, a4, &v28);
      v19 = Stra;
      v20 = wcschr(Stra, 0xAu);
      if ( v20 )
      {
        v21 = v20 + 1;
      }
      else
      {
        v22 = v19;
        do
          v23 = *v22++;
        while ( v23 != (_WORD)v36 );
        v21 = &v19[v22 - (v19 + 1)];
      }
      Stra = v21;
      fclose(Stream);
      if ( v28 )
      {
        v25 = Block;
      }
      else
      {
        v24 = sub_40EB4F();
        v25 = Block;
        v26 = v24;
        v24[1] = sub_40EBA1((char *)Block);
        sub_40ECA6((_DWORD **)&dword_434474, v26);
        v11 = (const wchar_t **)v29;
      }
      free(v25);
    }
    if ( v30 != v9 )
      free(v30);
    return 1;
  }
  else
  {
    *v29 = sub_40EBA1((char *)Str);
    return 0;
  }
}
// 411D61: using guessed type void __noreturn __report_rangecheckfailure(void);
// 423724: using guessed type int dword_423724;
// 434474: using guessed type int dword_434474;
// 409C09: using guessed type __int16 var_416[259];

//----- (00409FCF) --------------------------------------------------------
int sub_409FCF()
{
  int v0; // ecx
  int result; // eax

  if ( fclose(Stream) == 0xFFFF )
    sub_405A12(0, 0x424u, ArgList);
  free(ArgList);
  v0 = 3 * --dword_4343A4;
  Stream = (FILE *)dword_4343B8[v0];
  ArgList = (void *)dword_4343B4[v0];
  result = dword_4343B0[v0];
  dword_423724 = result;
  return result;
}
// 423724: using guessed type int dword_423724;
// 4343A4: using guessed type int dword_4343A4;
// 4343B0: using guessed type int dword_4343B0[];
// 4343B4: using guessed type int dword_4343B4[];
// 4343B8: using guessed type int dword_4343B8[];

//----- (0040A037) --------------------------------------------------------
wint_t __fastcall sub_40A037(char a1)
{
  wint_t result; // ax
  wint_t v3; // ax

LABEL_1:
  byte_413021 = 0;
  while ( 1 )
  {
    result = a1 ? getwc(Stream) : sub_408680();
    if ( result == 0xFFFF )
      return result;
    if ( result == 10 )
    {
      byte_413021 = 1;
      if ( a1 )
        v3 = getwc(Stream);
      else
        v3 = sub_408680();
      if ( v3 == 59 && byte_423F61 || v3 == 35 )
      {
        ++dword_423724;
        goto LABEL_1;
      }
      return ungetwc(v3, Stream);
    }
  }
}
// 413021: using guessed type char byte_413021;
// 423724: using guessed type int dword_423724;
// 423F61: using guessed type char byte_423F61;

//----- (0040A0BC) --------------------------------------------------------
unsigned __int8 __fastcall sub_40A0BC(wchar_t a1)
{
  wchar_t *v2; // ecx
  unsigned int v3; // edx
  int v4; // eax

  if ( a1 == 10 || a1 == 0xFFFF )
    sub_405A12(dword_423724, 0x407u);
  Src = a1;
  if ( !fgetws(&word_423742, 1023, Stream) )
  {
    if ( feof(Stream) )
      sub_405A12(dword_423724, 0x409u, L"EOF");
    sub_405A12(dword_423724, 0x41Du);
  }
  v2 = &Src;
  v3 = 2 * wcslen(&Src) - 2;
  if ( *(wchar_t *)((char *)&Src + v3) == 10 )
  {
    if ( v3 >= 0x800 )
      __report_rangecheckfailure();
    *(wchar_t *)((char *)&Src + v3) = 0;
  }
  while ( 1 )
  {
    v4 = *v2;
    if ( v4 != 32 && v4 != 9 )
      break;
    ++v2;
  }
  return sub_40AEC3(v2);
}
// 4019B8: using guessed type wchar_t aEof[4];
// 411D61: using guessed type void __noreturn __report_rangecheckfailure(void);
// 423724: using guessed type int dword_423724;

//----- (0040A1A0) --------------------------------------------------------
unsigned __int8 __fastcall sub_40A1A0(wint_t Character, _WORD *a2, int a3)
{
  char v4; // dl
  wint_t v5; // ax
  char v6; // bl
  unsigned __int8 result; // al
  __int16 v8; // ax
  wchar_t v9; // si

  v4 = byte_413021;
  while ( 1 )
  {
    switch ( Character )
    {
      case 0xAu:
        goto LABEL_15;
      case 0x3Au:
        byte_413021 = 0;
        Character = sub_408680();
        if ( Character == 58 )
        {
          *a2 = 58;
          result = 21;
          a2[1] = 0;
          return result;
        }
        v6 = 20;
LABEL_23:
        ungetwc(Character, Stream);
        return v6;
      case 0x3Bu:
        result = 19;
LABEL_44:
        byte_413021 = 0;
        return result;
      case 0x3Du:
        result = 22;
        goto LABEL_44;
    }
    if ( Character == 91 )
      break;
    if ( Character == 94 )
      goto LABEL_27;
    if ( Character != 0xFFFF )
      goto LABEL_28;
    if ( !feof(Stream) )
      sub_405A12(dword_423724, 0x40Eu);
    if ( dword_4343A4 )
    {
      sub_409FCF();
    }
    else
    {
      if ( dword_413024 < 0 )
        return 23;
      sub_405A12(dword_423724, 0x3FCu);
    }
LABEL_15:
    ++dword_423724;
    byte_413021 = 1;
    v5 = sub_408680();
    Character = v5;
    if ( v5 == 59 && byte_423F61 || v5 == 35 )
    {
      sub_40A037(0);
      ++dword_423724;
      byte_413021 = 1;
      Character = sub_408680();
    }
    if ( Character == 32 || Character == 9 )
    {
      result = 18;
      goto LABEL_44;
    }
    v4 = 1;
    byte_413021 = 1;
    if ( Character != 0xFFFF )
    {
      v6 = 17;
      goto LABEL_23;
    }
  }
  if ( byte_423F61 && v4 )
    return 23;
LABEL_27:
  ungetwc(Character, Stream);
  --a2;
LABEL_28:
  sub_40AC20(a2 - 1, a3);
  if ( !byte_413021 || wcsicmp(&Src, L"include") )
  {
    byte_413021 = 0;
    return 16;
  }
  byte_413021 = 0;
  v8 = sub_40A462(0);
  v9 = v8;
  if ( v8 == 58 || v8 == 61 )
  {
    ungetwc(v8, Stream);
    return 16;
  }
  if ( byte_423F61 )
    sub_405A12(dword_423724, 0x409u, a2);
  return sub_40A0BC(v9);
}
// 413021: using guessed type char byte_413021;
// 413024: using guessed type int dword_413024;
// 423724: using guessed type int dword_423724;
// 423F61: using guessed type char byte_423F61;
// 4343A4: using guessed type int dword_4343A4;

//----- (0040A3BD) --------------------------------------------------------
char __fastcall sub_40A3BD(int a1, char a2)
{
  wint_t v3; // ax
  __int16 v4; // cx
  wchar_t *v5; // edx

  if ( byte_423F62 )
  {
    ++dword_423724;
    byte_423F62 = 0;
    v3 = sub_408680();
    if ( v3 == 32 || v3 == 9 )
    {
      byte_413021 = 0;
      return 18;
    }
    else
    {
      v4 = -1;
      byte_413021 = 1;
      if ( v3 == 0xFFFF )
      {
        v5 = &Src;
        return sub_40A1A0(v4, v5, (int)&dword_423F40);
      }
      ungetwc(v3, Stream);
      return 17;
    }
  }
  else
  {
    if ( a2 != 24 && a2 != 25 )
    {
      v4 = sub_40A462(0);
      v5 = &word_423742;
      Src = v4;
      word_423742 = 0;
      return sub_40A1A0(v4, v5, (int)&dword_423F40);
    }
    sub_40A5EC(a2, a2, (int)&dword_423F40);
    return a2;
  }
}
// 413021: using guessed type char byte_413021;
// 423724: using guessed type int dword_423724;
// 423F40: using guessed type int dword_423F40;
// 423F62: using guessed type char byte_423F62;

//----- (0040A462) --------------------------------------------------------
__int16 __fastcall sub_40A462(char a1)
{
  __int16 v2; // si
  wint_t v3; // ax

  v2 = 94;
  do
  {
    if ( a1 )
      v3 = getwc(Stream);
    else
      v3 = sub_408680();
    if ( v3 != 32 && v3 != 9 )
    {
      if ( v3 != 94 )
        goto LABEL_14;
      if ( a1 )
        v3 = getwc(Stream);
      else
        v3 = sub_408680();
      if ( v3 != 32 && v3 != 9 )
      {
        ungetwc(v3, Stream);
        return v2;
      }
    }
    byte_413021 = 0;
LABEL_14:
    if ( v3 == 92 )
      v3 = sub_40A53B(0x5Cu, a1);
  }
  while ( v3 == 32 || v3 == 9 );
  v2 = v3;
  if ( v3 == 59 )
  {
    if ( !byte_413021 )
      return v2;
    if ( byte_423F61 )
      goto LABEL_22;
  }
  if ( v3 == 35 )
  {
LABEL_22:
    sub_40A037(a1);
    v2 = 10;
    byte_413021 = 1;
  }
  return v2;
}
// 413021: using guessed type char byte_413021;
// 423F61: using guessed type char byte_423F61;

//----- (0040A53B) --------------------------------------------------------
wint_t __fastcall sub_40A53B(wint_t a1, char a2)
{
  wint_t v3; // ax
  wint_t v4; // ax
  wint_t v5; // ax

  if ( a1 != 92 )
    return a1;
  while ( 1 )
  {
    v3 = a2 ? getwc(Stream) : sub_408680();
    if ( v3 != 10 )
      break;
    ++dword_423724;
    byte_413021 = 1;
    if ( a2 )
      v4 = getwc(Stream);
    else
      v4 = sub_408680();
    a1 = v4;
    if ( v4 == 59 && byte_423F61 || v4 == 35 )
    {
      sub_40A037(a2);
      ++dword_423724;
      if ( a2 )
        v5 = getwc(Stream);
      else
        v5 = sub_408680();
      a1 = v5;
    }
    if ( a1 != 92 )
      return a1;
  }
  ungetwc(v3, Stream);
  return 92;
}
// 413021: using guessed type char byte_413021;
// 423724: using guessed type int dword_423724;
// 423F61: using guessed type char byte_423F61;

//----- (0040A5EC) --------------------------------------------------------
const unsigned __int16 *__fastcall sub_40A5EC(char a1, int a2, int a3)
{
  wchar_t *v3; // edi
  char v5; // bl
  int v6; // esi
  unsigned __int8 v7; // bh
  wint_t v8; // ax
  wchar_t *v9; // eax
  unsigned int v10; // edi
  unsigned int v11; // esi
  char *v12; // eax
  unsigned __int8 v13; // dl
  wint_t v14; // ax
  int v15; // ecx
  char v16; // bl
  int v17; // esi
  unsigned __int8 v18; // bl
  wint_t v19; // ax
  int v20; // ecx
  int v21; // eax
  char *v22; // eax
  wchar_t *v23; // ecx
  unsigned int v24; // edi
  unsigned int v25; // esi
  wint_t v26; // ax
  char *v27; // ebx
  void *v28; // ecx
  const unsigned __int16 *result; // eax
  unsigned int v30; // edx
  const unsigned __int16 *v31; // [esp-4h] [ebp-30h]
  char *v32; // [esp+Ch] [ebp-20h]
  wchar_t *v33; // [esp+10h] [ebp-1Ch] BYREF
  unsigned int v34; // [esp+14h] [ebp-18h]
  wchar_t *Source; // [esp+18h] [ebp-14h]
  wchar_t *v36; // [esp+1Ch] [ebp-10h]
  int v37; // [esp+20h] [ebp-Ch]
  int v38; // [esp+24h] [ebp-8h]
  unsigned __int8 v39; // [esp+29h] [ebp-3h]
  char v40; // [esp+2Ah] [ebp-2h]
  bool v41; // [esp+2Bh] [ebp-1h]

  v32 = 0;
  v3 = &Src;
  v37 = 0;
  v40 = a1;
  v5 = 0;
  v34 = 0;
  v41 = 0;
  Source = &Src;
  v33 = &Src;
  v6 = (unsigned __int16)sub_408680();
  v38 = v6;
  if ( a1 != 24 )
  {
    if ( (_WORD)v6 == 32 || (_WORD)v6 == 9 )
      goto LABEL_10;
    if ( (_WORD)v6 != 94 )
    {
      v7 = 1;
      goto LABEL_12;
    }
    v8 = sub_408680();
    if ( v8 == 32 || v8 == 9 )
    {
LABEL_10:
      v7 = 2;
      v6 = (unsigned __int16)sub_40A462(0);
    }
    else
    {
      ungetwc(v8, Stream);
      v7 = 1;
      v6 = 94;
    }
    v38 = v6;
    goto LABEL_12;
  }
  v7 = 2;
LABEL_12:
  v36 = (wchar_t *)a3;
  while ( 1 )
  {
    if ( (_WORD)v6 == 34 )
    {
      v41 = !v41;
    }
    else
    {
      v41 = v5;
      if ( (_WORD)v6 == 94 )
      {
        if ( v5 || v40 != 25 )
        {
          v14 = sub_408680();
          ungetwc(v14, Stream);
          LOWORD(v6) = 94;
          v38 = 94;
          v41 = v5;
        }
        else
        {
          LOWORD(v6) = sub_408680();
          v38 = (unsigned __int16)v6;
          if ( (unsigned __int16)v6 > 0x29u )
          {
            v41 = 0;
            switch ( (unsigned __int16)v6 )
            {
              case '-':
              case '@':
                goto LABEL_33;
              case '\\':
                goto LABEL_41;
              case '^':
              case '{':
              case '}':
LABEL_33:
                *v3++ = 94;
                if ( v3 == v36 )
                {
                  if ( dword_42372C )
                  {
                    v10 = v34;
                    v11 = v34 + 1024;
                    if ( v34 + 1024 < v34 || (v12 = (char *)sub_40B52C(dword_42372C, 2 * v11), (v32 = v12) == 0) )
                    {
                      sub_405A12(dword_423724, 0x419u);
                      v12 = v32;
                    }
                    dword_42372C = v12;
                    v3 = (wchar_t *)&v12[2 * v10];
                    v34 = v11;
                    v9 = (wchar_t *)&v12[2 * v11];
                  }
                  else
                  {
                    dword_42372C = sub_40B4E9(0x1000u);
                    wcsncpy_s((wchar_t *)dword_42372C, 0x800u, Source, 0x400u);
                    v34 = 2048;
                    v3 = (wchar_t *)((char *)dword_42372C + 2048);
                    v9 = (wchar_t *)((char *)dword_42372C + 4096);
                  }
                  v36 = v9;
                  a3 = (int)v9;
                  Source = (wchar_t *)dword_42372C;
                  v33 = (wchar_t *)dword_42372C;
                }
LABEL_41:
                v13 = 0;
                v41 = 0;
                goto LABEL_78;
            }
          }
          else
          {
            if ( (unsigned __int16)v6 == 41 )
              goto LABEL_33;
            v41 = 0;
            switch ( (unsigned __int16)v6 )
            {
              case 0xAu:
                goto LABEL_41;
              case 0x21u:
                goto LABEL_33;
              case 0x22u:
              case 0x23u:
                goto LABEL_41;
              case 0x24u:
              case 0x28u:
                goto LABEL_33;
            }
          }
        }
      }
    }
    if ( (unsigned __int16)v6 > 0x3Bu )
    {
      if ( (unsigned __int16)v6 > 0x44u )
      {
        if ( (unsigned __int16)v6 == 70 || (unsigned __int16)v6 == 82 )
        {
LABEL_77:
          v13 = 13;
          goto LABEL_78;
        }
        if ( (unsigned __int16)v6 != 92 )
        {
          if ( (unsigned __int16)v6 != 0xFFFF )
            goto LABEL_95;
LABEL_96:
          v13 = 6;
          goto LABEL_78;
        }
        v13 = 3;
      }
      else
      {
        if ( (unsigned __int16)v6 == 68 )
          goto LABEL_77;
        if ( (unsigned __int16)v6 != 60 )
        {
          if ( (unsigned __int16)v6 == 61 )
          {
            v13 = 2;
            goto LABEL_78;
          }
          if ( (unsigned __int16)v6 != 63 && (unsigned __int16)v6 != 64 )
          {
            if ( (unsigned __int16)v6 == 66 )
              goto LABEL_77;
            goto LABEL_95;
          }
        }
        v18 = 12;
        v13 = 12;
        if ( v40 == 24 && (_WORD)v6 == 60 )
        {
          v19 = sub_408680();
          if ( v19 == 60 )
          {
            v3 = sub_40946B(v3, &v33, (wchar_t **)&a3);
            v38 = 10;
            v18 = 6;
            --dword_423724;
            v36 = (wchar_t *)a3;
            Source = v33;
          }
          else
          {
            ungetwc(v19, Stream);
          }
          v20 = 15 * v7;
          v21 = v18;
          goto LABEL_103;
        }
      }
    }
    else
    {
      if ( (unsigned __int16)v6 != 59 )
      {
        if ( (unsigned __int16)v6 > 0x28u )
        {
          switch ( (unsigned __int16)v6 )
          {
            case ')':
              v13 = 9;
              goto LABEL_78;
            case '*':
              v13 = 11;
              goto LABEL_78;
            case ',':
              v13 = 14;
              goto LABEL_78;
            case ':':
              v13 = 4;
              goto LABEL_78;
          }
          goto LABEL_95;
        }
        if ( (unsigned __int16)v6 == 40 )
        {
          v13 = 8;
          goto LABEL_78;
        }
        if ( (unsigned __int16)v6 == 9 )
          goto LABEL_56;
        if ( (unsigned __int16)v6 != 10 )
        {
          switch ( (unsigned __int16)v6 )
          {
            case ' ':
LABEL_56:
              v13 = 5;
              goto LABEL_78;
            case '#':
              if ( !v7 )
                goto LABEL_68;
              if ( v40 == 25 )
                goto LABEL_129;
              v7 = byte_4012C1[15 * v7];
              goto LABEL_104;
            case '$':
              v13 = 7;
              goto LABEL_78;
          }
LABEL_95:
          v13 = sub_403A97(v6) ? 0xA : 0;
          goto LABEL_78;
        }
        goto LABEL_96;
      }
      if ( !v7 && byte_423F61 )
      {
LABEL_68:
        v5 = 0;
        v41 = 0;
        sub_40A037(0);
        ++dword_423724;
        goto LABEL_127;
      }
      v13 = 0;
    }
LABEL_78:
    v15 = v37;
    if ( v37 > 0 )
      break;
LABEL_102:
    v20 = 15 * v7;
    v21 = v13;
LABEL_103:
    v7 = byte_4012C0[v20 + v21];
LABEL_104:
    v15 = v37;
LABEL_105:
    v16 = v7;
    v17 = v15;
    if ( v7 )
      goto LABEL_106;
    ++dword_423724;
    *(v3 - 1) = 32;
    v38 = (int)v3;
    byte_413021 = 1;
    v26 = sub_408680();
    byte_413021 = 0;
    if ( v26 == 32 || v26 == 9 )
    {
      v7 = 2;
      do
      {
        do
          v26 = sub_408680();
        while ( v26 == 32 );
      }
      while ( v26 == 9 );
      v3 = (wchar_t *)v38;
    }
    ungetwc(v26, Stream);
LABEL_126:
    v5 = v41;
LABEL_127:
    v6 = (unsigned __int16)sub_408680();
    v38 = v6;
  }
  if ( v13 != 14 )
  {
    if ( v13 == 9 )
    {
      v7 = byte_4012C9[15 * v7];
      if ( v7 != 1 )
        goto LABEL_105;
      v15 = --v37;
      goto LABEL_101;
    }
    goto LABEL_102;
  }
  v7 = byte_4012C6[15 * v7];
  if ( (v7 & 0x20) != 0 )
    goto LABEL_105;
  if ( !v7 || v7 == 64 )
  {
LABEL_101:
    v7 = 2;
    goto LABEL_105;
  }
  sub_405A12(dword_423724, 0x40Eu);
  v15 = v37;
  v16 = v7;
  v17 = v37;
LABEL_106:
  if ( v7 == 13 )
  {
    v7 = 2;
    v37 = v15 + 1;
LABEL_111:
    v39 = v7;
LABEL_112:
    *v3++ = v38;
    if ( v3 == v36 )
    {
      if ( dword_42372C )
      {
        v24 = v34;
        v25 = v34 + 1024;
        if ( v34 + 1024 < v34 || (v22 = (char *)sub_40B52C(dword_42372C, 2 * v25), (v32 = v22) == 0) )
        {
          sub_405A12(dword_423724, 0x419u);
          return sub_40AC20(v31, v30);
        }
        v3 = (wchar_t *)&v22[2 * v24];
        dword_42372C = v22;
        v34 = v25;
        v23 = (wchar_t *)&v22[2 * v25];
      }
      else
      {
        dword_42372C = sub_40B4E9(0x1000u);
        wcsncpy_s((wchar_t *)dword_42372C, 0x800u, Source, 0x400u);
        v22 = (char *)dword_42372C;
        v34 = 2048;
        v3 = (wchar_t *)((char *)dword_42372C + 2048);
        v23 = (wchar_t *)((char *)dword_42372C + 4096);
      }
      v7 = v39;
      v36 = v23;
      Source = (wchar_t *)v22;
      a3 = (int)v23;
      v33 = (wchar_t *)v22;
    }
    goto LABEL_126;
  }
  if ( v7 != 64 )
  {
    v37 = v17;
    v7 = v16;
    v39 = v16;
    if ( (v16 & 0x20) != 0 )
    {
      sub_405A12(dword_423724, (v16 & 0xDF) + 1000, (unsigned __int16)v38);
      v37 = v17;
      goto LABEL_111;
    }
    goto LABEL_112;
  }
  LOWORD(v6) = v38;
LABEL_129:
  ungetwc(v6, Stream);
  v27 = (char *)Source;
  while ( v3 > (wchar_t *)v27 && iswspace(*(v3 - 1)) )
    --v3;
  v28 = dword_42372C;
  *v3 = 0;
  if ( v28 )
  {
    result = (const unsigned __int16 *)sub_40B52C(v28, 2 * (((char *)v3 - (_BYTE *)v28) >> 1) + 2);
    if ( !result )
      return result;
  }
  else
  {
    result = (const unsigned __int16 *)sub_40EBA1(v27);
  }
  dword_42372C = (void *)result;
  return result;
}
// 40AC1F: variable 'v31' is possibly undefined
// 40AC1F: variable 'v30' is possibly undefined
// 413021: using guessed type char byte_413021;
// 423724: using guessed type int dword_423724;
// 423F61: using guessed type char byte_423F61;

//----- (0040AC20) --------------------------------------------------------
const unsigned __int16 *__fastcall sub_40AC20(const unsigned __int16 *a1, unsigned int a2)
{
  char v2; // bh
  wchar_t *v3; // edi
  unsigned __int8 v4; // bl
  wint_t v5; // si
  wint_t v6; // ax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  unsigned __int8 v10; // dl
  int v11; // eax
  int v12; // eax
  int v13; // eax
  unsigned __int16 *v17; // [esp+18h] [ebp-8h]
  char v18; // [esp+1Fh] [ebp-1h]

  v2 = 0;
  v3 = (wchar_t *)(a1 + 1);
  v18 = 0;
  v17 = (unsigned __int16 *)(a1 + 1);
  switch ( *a1 )
  {
    case '"':
      v18 = 1;
      v4 = 16;
      break;
    case '$':
      v4 = 2;
      break;
    case '{':
      v4 = 8;
      break;
    default:
      v4 = 0;
      break;
  }
  while ( 1 )
  {
    v5 = sub_408680();
    if ( v5 == 94 )
    {
      v6 = sub_408680();
      v5 = v6;
      if ( v6 > 0x29u )
      {
        v11 = v6 - 92;
        if ( !v11 )
          goto LABEL_30;
        v12 = v11 - 2;
        if ( !v12 || (v13 = v12 - 29) == 0 || v13 == 2 )
        {
LABEL_29:
          *v3++ = 94;
          v17 = v3;
          goto LABEL_30;
        }
      }
      else
      {
        if ( v6 == 41 )
          goto LABEL_29;
        v7 = v6 - 10;
        if ( !v7 )
          goto LABEL_30;
        v8 = v7 - 25;
        if ( !v8 )
          goto LABEL_30;
        v9 = v8 - 1;
        if ( !v9 || v9 == 4 )
          goto LABEL_29;
      }
    }
    if ( v5 > 0x29u )
    {
      switch ( v5 )
      {
        case 0x3Au:
          v10 = 4;
          goto LABEL_57;
        case 0x3Bu:
          v10 = 3;
          goto LABEL_57;
        case 0x3Du:
          v10 = 2;
          goto LABEL_57;
        case 0x5Cu:
          v10 = 13;
          goto LABEL_57;
        case 0x7Bu:
          v10 = 11;
          goto LABEL_57;
        case 0x7Du:
          v10 = 12;
          goto LABEL_57;
        case 0xFFFFu:
LABEL_50:
          v10 = 6;
          goto LABEL_57;
      }
LABEL_44:
      if ( byte_423734 >= 0 )
      {
        v10 = sub_403A97(v5) ? 0xA : 0;
        goto LABEL_57;
      }
      if ( sub_403A97(v5) || v5 == 42 || v5 == 64 )
      {
        v10 = 10;
        goto LABEL_57;
      }
LABEL_30:
      v10 = 0;
      goto LABEL_57;
    }
    switch ( v5 )
    {
      case 0x29u:
        v10 = 9;
        break;
      case 9u:
        goto LABEL_35;
      case 0xAu:
        goto LABEL_50;
      case 0x20u:
LABEL_35:
        v10 = v18 != 0 ? 0 : 5;
        break;
      case 0x22u:
        v10 = 14;
        if ( v4 == 18 )
          v18 = 1;
        break;
      case 0x23u:
        v10 = 1;
        break;
      case 0x24u:
        v10 = 7;
        break;
      case 0x28u:
        v10 = 8;
        break;
      default:
        goto LABEL_44;
    }
LABEL_57:
    v4 = byte_4011A0[15 * v4 + v10];
    if ( v18 && v4 == 1 )
      v4 = 16;
    if ( v2 )
    {
      if ( v10 == 6 )
      {
        ++dword_423724;
        byte_413021 = 1;
        v5 = sub_408680();
        byte_413021 = 0;
        if ( v5 == 32 || v5 == 9 )
        {
          v4 = 64;
          do
          {
            do
              v5 = sub_408680();
            while ( v5 == 32 );
          }
          while ( v5 == 9 );
          v3 = v17;
        }
        else
        {
          v4 = v3 != &word_423742;
        }
      }
      else
      {
        *v3++ = 92;
        v17 = v3;
      }
    }
    v2 = 0;
    if ( (unsigned int)v3 >= a2 )
      sub_405A12(dword_423724, 0x434u);
    if ( v4 == 64 )
      break;
    if ( (v4 & 0x20) != 0 )
      sub_405A12(dword_423724, (v4 & 0xDF) + 1000, v5);
    if ( v4 == 15 )
    {
      v2 = 1;
    }
    else
    {
      *v3++ = v5;
      v17 = v3;
    }
  }
  ungetwc(v5, Stream);
  *v3 = 0;
  return sub_40CDA1(a1);
}
// 413021: using guessed type char byte_413021;
// 423724: using guessed type int dword_423724;
// 423734: using guessed type char byte_423734;

//----- (0040AEC3) --------------------------------------------------------
unsigned __int8 __thiscall sub_40AEC3(wchar_t *String)
{
  unsigned __int16 *v1; // edi
  wchar_t *v2; // eax
  unsigned __int16 *v3; // esi
  wchar_t v4; // cx
  __int16 *i; // ebx
  __int16 v6; // ax
  wchar_t *j; // ebx
  unsigned __int16 *v8; // ecx
  __int16 v9; // ax
  int v10; // ecx
  wchar_t *v11; // edi
  wchar_t *v12; // esi
  int v13; // eax
  char *v14; // ecx
  wchar_t *v15; // edi
  wchar_t *v16; // ebx
  int v17; // edx
  int v18; // eax
  wchar_t **v19; // ecx
  wchar_t *v20; // ecx
  wchar_t *v21; // eax
  wchar_t *v22; // ecx
  wchar_t *v23; // edx
  int v25; // ecx
  wchar_t *v26; // edx
  int v27; // ecx
  __int16 v28; // ax
  rsize_t v29; // esi
  wchar_t *v30; // esi
  int v31; // edx
  int v32; // esi
  const wchar_t **v33; // ebx
  int v34; // ecx
  bool v35; // zf
  wint_t v36; // ax
  rsize_t v38; // [esp-8h] [ebp-288h]
  wchar_t *v39; // [esp-4h] [ebp-284h]
  int v40; // [esp+10h] [ebp-270h] BYREF
  wchar_t *v41; // [esp+14h] [ebp-26Ch]
  int v42; // [esp+18h] [ebp-268h]
  wchar_t *Source; // [esp+1Ch] [ebp-264h]
  int v44; // [esp+20h] [ebp-260h]
  wchar_t *Destination; // [esp+24h] [ebp-25Ch]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+28h] [ebp-258h] BYREF

  v1 = String;
  if ( !*String || *String == 35 )
  {
    sub_405A12(dword_423724, 0x407u);
    return (unsigned __int8)sub_40B36A(v39);
  }
  else
  {
    Destination = (wchar_t *)wcspbrk;
    v2 = wcspbrk(String, L"\t#");
    v41 = 0;
    v3 = v2;
    v44 = 32;
    if ( !v2 )
      goto LABEL_28;
    v4 = *v2;
    *v2 = 0;
    if ( v4 != 35 )
    {
      for ( i = (__int16 *)(v2 + 1); ; ++i )
      {
        v6 = *i;
        if ( !*i || v6 == 35 )
          break;
        if ( v6 != 32 && v6 != 9 )
          sub_405A12(dword_423724, 0x409u, i);
      }
    }
    for ( j = 0; ; j = 0 )
    {
      if ( v3 > v1 )
      {
        do
        {
          v8 = v3 - 1;
          v9 = *(v3 - 1);
          if ( v9 != (_WORD)v44 && v9 != 9 )
            break;
          --v3;
        }
        while ( v8 > v1 );
        j = v41;
      }
      *v3 = 0;
      v10 = *v1;
      if ( v10 != 60 || *(v3 - 1) != 62 )
        break;
      *(v3 - 1) = 0;
      v11 = v1 + 1;
      v12 = sub_40F81F(v11);
      if ( v12 == v11 )
        v12 = (wchar_t *)sub_40EBA1((char *)v11);
      v13 = sub_40B444(L"INCLUDE");
      if ( v13 )
      {
        v14 = *(char **)(*(_DWORD *)(v13 + 8) + 4);
        if ( v14 )
        {
          v15 = (wchar_t *)sub_40EBA1(v14);
          j = sub_40F81F(v15);
          if ( j != v15 )
            free(v15);
        }
      }
      v1 = (unsigned __int16 *)sub_40838C(j, v12, &FindFileData, (HANDLE *)&v40);
      if ( v1 )
      {
        if ( j )
          free(j);
        free(v12);
        goto LABEL_57;
      }
      sub_405A12(dword_423724, 0x41Cu, v12);
LABEL_28:
      v3 = &v1[wcslen(v1)];
    }
    if ( (_WORD)v10 == 34 && *(v3 - 1) == 34 )
    {
      *(v3 - 1) = 0;
      ++v1;
    }
    v16 = sub_40F81F(v1);
    if ( v16 == v1 )
      v16 = (wchar_t *)sub_40EBA1((char *)v1);
    if ( !sub_4081DE(v16, &FindFileData, (HANDLE *)&v40) )
    {
      if ( ((int (__cdecl *)(wchar_t *, const wchar_t *))Destination)(v16, L"\\/:") )
      {
        sub_405A12(dword_423724, 0x41Cu, v16);
      }
      else
      {
        v17 = dword_4343A4;
        v18 = dword_4343A4;
        v42 = dword_4343A4;
        if ( dword_4343A4 >= 0 )
        {
          v19 = (wchar_t **)&dword_4343B4[3 * dword_4343A4];
          v44 = (int)v19;
          while ( 1 )
          {
            if ( v18 == v17 )
              v20 = (wchar_t *)ArgList;
            else
              v20 = *v19;
            v21 = sub_40B36A(v20);
            Source = v21;
            if ( v21 )
            {
              v22 = v21;
              v23 = v21 + 1;
              while ( *v22++ )
                ;
              v25 = (char *)v22 - (char *)v23;
              v26 = v16;
              v27 = v25 >> 1;
              do
                v28 = *v26++;
              while ( v28 != (_WORD)v41 );
              v29 = v26 - (v16 + 1) + v27 + 2;
              Destination = (wchar_t *)sub_40B4E9((unsigned __int64)v29 >> 31 != 0 ? -1 : 2 * v29);
              wcscpy_s(Destination, v29, Source);
              wcscat_s(Destination, v29, L"\\");
              v38 = v29;
              v30 = Destination;
              wcscat_s(Destination, v38, v16);
              if ( sub_4081DE(v30, &FindFileData, (HANDLE *)&v40) )
              {
                v1 = v30;
                free(Source);
                break;
              }
              free(Source);
              free(v30);
            }
            v18 = v42 - 1;
            v19 = (wchar_t **)(v44 - 12);
            v42 = v18;
            v44 -= 12;
            if ( v18 < 0 )
              break;
            v17 = dword_4343A4;
          }
        }
        free(v16);
        if ( v42 < 0 )
          sub_405A12(dword_423724, 0x41Cu, v1);
      }
    }
LABEL_57:
    v31 = dword_4343A4;
    v32 = 0;
    if ( dword_4343A4 > 0 )
    {
      v33 = (const wchar_t **)dword_4343B4;
      do
      {
        if ( !wcsicmp(v1, *v33) )
          sub_405A12(dword_423724, 0x430u, v1);
        v31 = dword_4343A4;
        ++v32;
        v33 += 3;
      }
      while ( v32 < dword_4343A4 );
    }
    v34 = 3 * v31;
    v35 = byte_423F63 == 0;
    dword_4343A4 = v31 + 1;
    dword_423730 = 0;
    dword_4343B8[v34] = (int)Stream;
    dword_4343B0[v34] = dword_423724;
    dword_4343B4[v34] = (int)ArgList;
    if ( !v35 )
      sub_40D0B1((wchar_t *)L"Included: %s\n", v1);
    Stream = sub_4113E8(v1, (wchar_t *)L"rt,ccs=unicode");
    if ( !Stream )
      sub_405A12(dword_423724, 0x41Cu, v1);
    ArgList = sub_40EBA1((char *)v1);
    dword_423724 = 1;
    byte_413021 = 1;
    v36 = sub_408680();
    if ( v36 == 32 || v36 == 9 )
    {
      byte_413021 = 0;
      return 18;
    }
    else
    {
      byte_413021 = 1;
      ungetwc(v36, Stream);
      --dword_423724;
      return 17;
    }
  }
}
// 40B369: variable 'v39' is possibly undefined
// 401A6C: using guessed type wchar_t asc_401A6C[4];
// 413021: using guessed type char byte_413021;
// 423724: using guessed type int dword_423724;
// 423730: using guessed type int dword_423730;
// 423F63: using guessed type char byte_423F63;
// 4343A4: using guessed type int dword_4343A4;
// 4343B0: using guessed type int dword_4343B0[];
// 4343B4: using guessed type int dword_4343B4[];
// 4343B8: using guessed type int dword_4343B8[];

//----- (0040B36A) --------------------------------------------------------
wchar_t *__thiscall sub_40B36A(wchar_t *FullPath)
{
  size_t v1; // esi
  wchar_t *v2; // edi
  unsigned int v3; // ecx
  wchar_t v4; // dx
  wchar_t Dir[258]; // [esp+10h] [ebp-210h] BYREF
  wchar_t Drive[4]; // [esp+214h] [ebp-Ch] BYREF

  wsplitpath_s(FullPath, Drive, 3u, Dir, 0x100u, 0, 0, 0, 0);
  v1 = wcslen(Dir) + wcslen(Drive) + 1;
  v2 = (wchar_t *)sub_40B4E9((unsigned __int64)v1 >> 31 != 0 ? -1 : 2 * v1);
  wmakepath_s(v2, v1, Drive, Dir, 0, 0);
  v3 = wcslen(v2);
  v4 = v2[v3 - 1];
  if ( v4 == 92 || v4 == 47 )
    v2[v3 - 1] = 0;
  return v2;
}

//----- (0040B444) --------------------------------------------------------
int __thiscall sub_40B444(const unsigned __int16 *this)
{
  const unsigned __int16 *v2; // edx
  unsigned __int16 v3; // ax
  unsigned __int8 v4; // cl
  unsigned __int16 v5; // di
  int ***v6; // eax
  int **v7; // ecx
  int v8; // eax

  v2 = this;
  v3 = *this;
  if ( *this )
  {
    v4 = 0;
    LOBYTE(v5) = v3;
    do
    {
      ++v2;
      v4 += v5;
      v5 = *v2;
    }
    while ( *v2 );
    v6 = (int ***)((char *)&unk_433F90 + 4 * v4);
    v7 = *v6;
    dword_4376A8 = (int)v6;
    while ( v7 )
    {
      v8 = wcscmp((const unsigned __int16 *)v7[1], this);
      if ( v8 )
        v8 = v8 < 0 ? -1 : 1;
      if ( !v8 )
        return ((_BYTE)v7[3] & 0x10) == 0 ? (unsigned int)v7 : 0;
      v7 = (int **)*v7;
    }
  }
  else
  {
    dword_4376A8 = (int)&unk_433F90;
  }
  return 0;
}
// 4376A8: using guessed type int dword_4376A8;

//----- (0040B4D8) --------------------------------------------------------
int sub_40B4D8()
{
  int result; // eax

  result = 0;
  memset(&unk_433F90, 0, 0x400u);
  return result;
}

//----- (0040B4E9) --------------------------------------------------------
void *__thiscall sub_40B4E9(size_t Size)
{
  void *v1; // esi

  v1 = malloc(Size);
  if ( !v1 )
    sub_405A12(dword_423730, 0x41Bu);
  return v1;
}
// 423730: using guessed type int dword_423730;

//----- (0040B50E) --------------------------------------------------------
void *__thiscall sub_40B50E(size_t Size)
{
  void *v2; // edi

  v2 = sub_40B4E9(Size);
  memset(v2, 0, Size);
  return v2;
}

//----- (0040B52C) --------------------------------------------------------
void *__fastcall sub_40B52C(void *Block, size_t Size)
{
  void *v2; // esi

  if ( !Block )
    return sub_40B4E9(Size);
  v2 = realloc(Block, Size);
  if ( !v2 )
    sub_405A12(dword_423730, 0x41Bu);
  return v2;
}
// 423730: using guessed type int dword_423730;

//----- (0040B562) --------------------------------------------------------
int __fastcall sub_40B562(wchar_t *Source, wchar_t *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // esi
  DWORD EnvironmentVariableW; // eax
  HMODULE ModuleHandleW; // eax
  BOOL (__stdcall *SetThreadPreferredUILanguages)(DWORD, PCZZWSTR, PULONG); // esi
  HMODULE v12; // eax
  BOOL (__stdcall *GetThreadPreferredUILanguages)(DWORD, PULONG, PZZWSTR, PULONG); // edi
  SIZE_T v14; // esi
  HANDLE ProcessHeap; // eax
  WCHAR *v16; // eax
  wchar_t **v17; // ebx
  int result; // eax
  wchar_t **v19; // esi
  int v20; // edi
  HANDLE v21; // eax
  LANGID UserDefaultUILanguage; // ax
  int v23; // ebx
  HANDLE FirstFileW; // edi
  unsigned int v25; // kr04_4
  int v26; // eax
  int v27; // eax
  HMODULE Library; // ecx
  int v29; // [esp+10h] [ebp-6D0h] BYREF
  char ArgList[4]; // [esp+14h] [ebp-6CCh] BYREF
  int v31; // [esp+18h] [ebp-6C8h] BYREF
  wchar_t *v32; // [esp+1Ch] [ebp-6C4h] BYREF
  int v33; // [esp+20h] [ebp-6C0h] BYREF
  wchar_t *Sourcea; // [esp+24h] [ebp-6BCh] BYREF
  DWORD dwFlags; // [esp+28h] [ebp-6B8h] BYREF
  HMODULE *v36; // [esp+2Ch] [ebp-6B4h] BYREF
  __int16 *v37; // [esp+30h] [ebp-6B0h] BYREF
  rsize_t SizeInWords; // [esp+34h] [ebp-6ACh] BYREF
  char v39[4]; // [esp+38h] [ebp-6A8h] BYREF
  int v40[7]; // [esp+3Ch] [ebp-6A4h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+58h] [ebp-688h] BYREF
  __int16 v42[4]; // [esp+2A8h] [ebp-438h]
  wchar_t *Buffer[3]; // [esp+2B0h] [ebp-430h] BYREF
  wchar_t String[6]; // [esp+2BCh] [ebp-424h] BYREF
  wchar_t FileName[260]; // [esp+2C8h] [ebp-418h] BYREF
  wchar_t Destination[262]; // [esp+4D0h] [ebp-210h] BYREF

  v8 = 0;
  Sourcea = a2;
  v37 = &word_437EE8;
  SizeInWords = 0;
  v32 = 0;
  v36 = &hModule;
  dwFlags = 96;
  if ( !Source || !*Source || !a2 || !*a2 )
    return -2147024809;
  hModule = 0;
  if ( wcsncpy_s(Destination, 0x104u, Source, 0xFFFFFFFF)
    || FileName[wcslen(Destination) + 259] != 92 && wcsncat_s(Destination, 0x104u, L"\\", 0xFFFFFFFF) )
  {
    return -2147467259;
  }
  v29 = -2147024894;
  v40[0] = (int)Destination;
  v40[1] = (int)&Sourcea;
  v40[2] = (int)&dwFlags;
  v40[3] = (int)&v36;
  v40[4] = (int)&v37;
  v40[5] = (int)&v32;
  v40[6] = (int)&SizeInWords;
  memset(Buffer, 0, sizeof(Buffer));
  EnvironmentVariableW = GetEnvironmentVariableW(L"VSLANG", (LPWSTR)Buffer, 6u);
  if ( EnvironmentVariableW )
  {
    if ( EnvironmentVariableW < 6 )
    {
      sub_40BB4E((int)v40, Buffer, 10, (wchar_t ***)&v29);
      if ( !v29 )
        return 0;
    }
  }
  if ( Ptr )
  {
    SetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PCZZWSTR, PULONG))DecodePointer(Ptr);
  }
  else
  {
    ModuleHandleW = GetModuleHandleW(L"kernel32.dll");
    if ( !ModuleHandleW )
    {
LABEL_35:
      UserDefaultUILanguage = GetUserDefaultUILanguage();
      if ( (UserDefaultUILanguage & 0x3FF) == 1 || (UserDefaultUILanguage & 0x3FF) == 13 )
        UserDefaultUILanguage = 1033;
      v42[0] = UserDefaultUILanguage;
      v42[2] = 1033;
      v42[1] = UserDefaultUILanguage & 0x3FF | 0x400;
      while ( 1 )
      {
        itow_s((unsigned __int16)v42[v8], String, 6u, 10);
        sub_40BB4E((int)v40, (wchar_t **)String, 10, (wchar_t ***)&v29);
        if ( !v29 )
          return 0;
        if ( (unsigned int)++v8 >= 3 )
          goto LABEL_41;
      }
    }
    SetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PCZZWSTR, PULONG))GetProcAddress(
                                                                                   ModuleHandleW,
                                                                                   "SetThreadPreferredUILanguages");
    Ptr = EncodePointer(SetThreadPreferredUILanguages);
  }
  if ( !SetThreadPreferredUILanguages )
  {
    v8 = 0;
    goto LABEL_35;
  }
  if ( !GetEnvironmentVariableW(L"VS_UNICODE_OUTPUT", 0, 0) && !SetThreadPreferredUILanguages(256, 0, 0) )
    return -2147467259;
  v31 = 0;
  v33 = 0;
  if ( dword_4376C0 )
  {
    GetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PULONG, PZZWSTR, PULONG))DecodePointer(dword_4376C0);
  }
  else
  {
    v12 = GetModuleHandleW(L"kernel32.dll");
    if ( !v12 )
      goto LABEL_41;
    GetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PULONG, PZZWSTR, PULONG))GetProcAddress(
                                                                                          v12,
                                                                                          "GetThreadPreferredUILanguages");
    dword_4376C0 = EncodePointer(GetThreadPreferredUILanguages);
  }
  if ( GetThreadPreferredUILanguages )
  {
    if ( GetThreadPreferredUILanguages(52, (PULONG)&v33, 0, (PULONG)&v31) )
    {
      v14 = 2 * v31;
      ProcessHeap = GetProcessHeap();
      v16 = (WCHAR *)HeapAlloc(ProcessHeap, 0, v14);
      v17 = (wchar_t **)v16;
      if ( !v16 )
        return -2147024882;
      if ( GetThreadPreferredUILanguages(52, (PULONG)&v33, v16, (PULONG)&v31) )
      {
        v19 = v17;
        if ( *(_WORD *)v17 )
        {
          do
          {
            sub_40BB4E((int)v40, v19, 16, (wchar_t ***)&v29);
            v20 = v29;
            if ( !v29 )
              break;
            v19 = (wchar_t **)((char *)v19 + 10);
          }
          while ( *(_WORD *)v19 );
        }
        else
        {
          v20 = v29;
        }
        v21 = GetProcessHeap();
        HeapFree(v21, 0, v17);
        if ( !v20 )
          return 0;
        goto LABEL_41;
      }
    }
    return -2147467259;
  }
LABEL_41:
  sub_40BB4E((int)v40, (wchar_t **)L"1033", 10, (wchar_t ***)&v29);
  v23 = v29;
  if ( !v29 )
    return 0;
  if ( wcsncpy_s(FileName, 0x104u, Destination, 0xFFFFFFFF) || wcsncat_s(FileName, 0x104u, L"*", 0xFFFFFFFF) )
    return -2147024893;
  FirstFileW = FindFirstFileW(FileName, &FindFileData);
  if ( FirstFileW == (HANDLE)-1 )
  {
    result = GetLastError();
    if ( result > 0 )
      return (unsigned __int16)result | 0x80070000;
  }
  else
  {
    v25 = wcslen(Destination);
    while ( FindNextFileW(FirstFileW, &FindFileData) )
    {
      if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
      {
        v26 = wcscmp(FindFileData.cFileName, L".");
        if ( v26 )
          v26 = v26 < 0 ? -1 : 1;
        if ( v26 )
        {
          v27 = wcscmp(FindFileData.cFileName, L"..");
          if ( v27 )
            v27 = v27 < 0 ? -1 : 1;
          if ( v27 && sub_40CF1E(FindFileData.cFileName, (wchar_t *)L"%hu%c", ArgList, v39, 1) != -1 )
          {
            if ( 2 * v25 >= 0x208 )
              __report_rangecheckfailure();
            FileName[v25] = 0;
            if ( !wcsncat_s(FileName, 0x104u, FindFileData.cFileName, 0xFFFFFFFF)
              && !wcsncat_s(FileName, 0x104u, L"\\", 0xFFFFFFFF)
              && !wcsncat_s(FileName, 0x104u, Sourcea, 0xFFFFFFFF) )
            {
              Library = LoadLibraryExW(FileName, 0, dwFlags);
              if ( Library )
              {
                *v36 = Library;
                if ( v37 )
                  *v37 = *(_WORD *)ArgList;
                if ( v32 )
                  wcscpy_s(v32, SizeInWords, FileName);
                v23 = 0;
                break;
              }
            }
          }
        }
      }
    }
    FindClose(FirstFileW);
    return v23;
  }
  return result;
}
// 401B34: using guessed type wchar_t asc_401B34[3];
// 411D61: using guessed type void __noreturn __report_rangecheckfailure(void);
// 437EE8: using guessed type __int16 word_437EE8;
// 40B562: using guessed type char var_6A8[4];

//----- (0040BB4E) --------------------------------------------------------
wchar_t **__thiscall sub_40BB4E(int this, wchar_t **String, int Radix, wchar_t ***a4)
{
  wchar_t **result; // eax
  _WORD *v6; // eax
  __int16 v7; // [esp+Ch] [ebp-220h]
  wchar_t *EndPtr; // [esp+10h] [ebp-21Ch] BYREF
  wchar_t Destination[260]; // [esp+14h] [ebp-218h] BYREF
  wchar_t Buffer[6]; // [esp+21Ch] [ebp-10h] BYREF

  result = String;
  if ( *(_WORD *)String )
  {
    result = (wchar_t **)wcstoul((const wchar_t *)String, &EndPtr, Radix);
    v7 = (__int16)result;
    if ( !*EndPtr )
    {
      itow_s((unsigned __int16)result, Buffer, 6u, 10);
      result = (wchar_t **)wcsncpy_s(Destination, 0x104u, *(const wchar_t **)this, 0xFFFFFFFF);
      if ( !result )
      {
        result = (wchar_t **)wcsncat_s(Destination, 0x104u, Buffer, 0xFFFFFFFF);
        if ( !result )
        {
          result = (wchar_t **)wcsncat_s(Destination, 0x104u, L"\\", 0xFFFFFFFF);
          if ( !result )
          {
            result = (wchar_t **)wcsncat_s(Destination, 0x104u, **(const wchar_t ***)(this + 4), 0xFFFFFFFF);
            if ( !result )
            {
              result = (wchar_t **)LoadLibraryExW(Destination, 0, **(_DWORD **)(this + 8));
              if ( result )
              {
                ***(_DWORD ***)(this + 12) = result;
                v6 = **(_WORD ***)(this + 16);
                if ( v6 )
                  *v6 = v7;
                result = *(wchar_t ***)(this + 20);
                if ( *result )
                  result = (wchar_t **)wcscpy_s(*result, **(_DWORD **)(this + 24), Destination);
                *a4 = 0;
              }
              else if ( *a4 == (wchar_t **)-2147024894 )
              {
                result = (wchar_t **)GetLastError();
                if ( (int)result > 0 )
                  result = (wchar_t **)((unsigned __int16)result | 0x80070000);
                *a4 = result;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (0040BCB9) --------------------------------------------------------
void __thiscall sub_40BCB9(void *this)
{
  dword_413068 = (int)this;
}
// 413068: using guessed type int dword_413068;

//----- (0040BCC0) --------------------------------------------------------
BOOL __fastcall sub_40BCC0(const void **a1, void *a2, void *a3)
{
  int v5; // ecx

  if ( !byte_423F60 )
    sub_405B88();
  sub_40D0B1((wchar_t *)L"\nNMAKE : fatal error U1038: Internal error\n");
  sub_40D093();
  qmemcpy(a2, *a1, 0x50u);
  if ( a3 )
    qmemcpy(a3, a1[1], 0x2CCu);
  v5 = 0;
  if ( *(_DWORD *)*a1 != -2147483645 )
    return dword_413068 == 0;
  return v5;
}
// 413068: using guessed type int dword_413068;
// 423F60: using guessed type char byte_423F60;

//----- (0040BD2B) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl main(int argc, const char **argv, const char **envp)
{
  const char **v3; // edi
  int v4; // esi
  int v5; // ebx
  const char *v6; // ecx
  int v7; // eax
  const char **v8; // edi
  int v9; // ecx
  const void *v10; // eax
  wchar_t *v11; // esi
  wchar_t *v12; // ebx
  rsize_t v14; // ebx
  wchar_t *v15; // edi
  int v16; // esi
  int v18; // [esp-10h] [ebp-584h]
  int v19; // [esp-10h] [ebp-584h]
  int v20[179]; // [esp+10h] [ebp-564h] BYREF
  int v21; // [esp+2F8h] [ebp-27Ch]
  const char **v22; // [esp+2FCh] [ebp-278h]
  char ArgList[80]; // [esp+300h] [ebp-274h] BYREF
  CPPEH_RECORD ms_exc; // [esp+55Ch] [ebp-18h]

  v3 = argv;
  v22 = argv;
  SetErrorMode(1u);
  memset(ArgList, 0, sizeof(ArgList));
  memset(v20, 0, sizeof(v20));
  ms_exc.registration.TryLevel = 0;
  setlocale(2, ".ACP");
  sub_40CF87();
  set_invalid_parameter_handler(Handler);
  v4 = 1;
  v5 = argc;
  while ( 1 )
  {
    v21 = v4;
    if ( v4 >= v5 )
    {
      if ( byte_43447B )
        MEMORY[0] = 0;
      sub_40B4D8();
      if ( !dword_423F68 )
      {
        v11 = *_p__wpgmptr();
        if ( sub_403ABC(v11, 0x20u) )
        {
          v12 = v11;
          while ( *v12++ )
            ;
          v14 = v12 - (v11 + 1) + 3;
          v15 = (wchar_t *)sub_403A8F((void *)((unsigned __int64)v14 >> 31 != 0 ? -1 : 2 * v14));
          wcscpy_s(v15, v14, Source);
          wcscat_s(v15, v14, v11);
          wcscat_s(v15, v14, Source);
          v11 = v15;
          v5 = argc;
          v3 = v22;
        }
        dword_423F68 = (wchar_t *)sub_40EBA1((char *)v11);
      }
      signal(2, (_crt_signal_t)Function);
      signal(15, (_crt_signal_t)Function);
      v16 = sub_40C298(v5, (int)v3, v19);
      sub_40CD63();
      if ( !byte_413020 )
        v16 = 1;
      exit(v16);
    }
    v6 = v3[v4];
    v7 = *(unsigned __int16 *)v6;
    if ( v7 == 45 || v7 == 47 )
    {
      v8 = &v3[v4];
      if ( !wcsicmp((const wchar_t *)v6 + 1, L"errorreport:none") )
      {
        v9 = 0;
        goto LABEL_7;
      }
      if ( !wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:prompt") )
      {
        v9 = 1;
        goto LABEL_7;
      }
      if ( !wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:queue") )
      {
        v18 = 2;
        goto LABEL_14;
      }
      if ( !wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:send") )
      {
        v18 = 3;
LABEL_14:
        v9 = v18;
LABEL_7:
        sub_40BCB9((void *)v9);
        memmove(v8, v8 + 1, 4 * (v5 - v4) - 4);
        argc = --v5;
        v21 = --v4;
LABEL_8:
        v3 = v22;
        goto LABEL_9;
      }
      if ( wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:test") )
      {
        if ( wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:internal") )
          goto LABEL_8;
        byte_43447A = 1;
        v3 = v22;
        memmove(&v22[v4], &v22[v4 + 1], 4 * (v5 - v4) - 4);
      }
      else
      {
        byte_43447B = 1;
        v10 = v8 + 1;
        v3 = v22;
        memmove(&v22[v4], v10, 4 * (v5 - v4) - 4);
      }
      argc = --v5;
      v21 = --v4;
    }
LABEL_9:
    ++v4;
  }
}
// 40C134: positive sp value C has been found
// 40BFAB: variable 'v19' is possibly undefined
// 413020: using guessed type char byte_413020;
// 43447A: using guessed type char byte_43447A;
// 43447B: using guessed type char byte_43447B;

//----- (0040C136) --------------------------------------------------------
char *sub_40C136()
{
  wchar_t *v0; // esi
  wchar_t *v1; // eax
  int v2; // edi
  wchar_t *v3; // esi
  wchar_t *v4; // eax
  wchar_t *v5; // esi
  wchar_t *v6; // eax
  wchar_t *v7; // esi
  wchar_t *v8; // eax
  wchar_t *v9; // esi
  wchar_t *v10; // eax
  wchar_t *v11; // esi
  wchar_t *v12; // eax
  wchar_t *v13; // esi
  wchar_t *v14; // eax
  char *result; // eax
  int v16; // esi
  wchar_t *v17; // eax
  const wchar_t **v18; // esi
  const wchar_t **i; // esi

  v0 = (wchar_t *)sub_40EBA1((char *)L"CC");
  v1 = (wchar_t *)sub_40EBA1((char *)L"cl");
  v2 = 0;
  sub_4035E0(v0, v1, 0);
  v3 = (wchar_t *)sub_40EBA1((char *)L"CXX");
  v4 = (wchar_t *)sub_40EBA1((char *)L"cl");
  sub_4035E0(v3, v4, 0);
  v5 = (wchar_t *)sub_40EBA1((char *)L"CPP");
  v6 = (wchar_t *)sub_40EBA1((char *)L"cl");
  sub_4035E0(v5, v6, 0);
  v7 = (wchar_t *)sub_40EBA1((char *)L"AS");
  v8 = (wchar_t *)sub_40EBA1((char *)L"ml");
  sub_4035E0(v7, v8, 0);
  v9 = (wchar_t *)sub_40EBA1((char *)L"RC");
  v10 = (wchar_t *)sub_40EBA1((char *)L"rc");
  sub_4035E0(v9, v10, 0);
  v11 = (wchar_t *)sub_40EBA1((char *)L"_NMAKE_VER");
  v12 = (wchar_t *)sub_40EBA1((char *)L"14.30.30711.1");
  sub_4035E0(v11, v12, 2);
  v13 = (wchar_t *)sub_40EBA1((char *)&off_4023E0);
  v14 = (wchar_t *)sub_40EBA1((char *)dword_423F68);
  sub_4035E0(v13, v14, 76);
  result = (char *)L".SUFFIXES";
  if ( L".SUFFIXES" )
  {
    v16 = 0;
    do
    {
      v17 = (wchar_t *)sub_40EBA1(result);
      v18 = (const wchar_t **)off_401390[v16];
      Block = v17;
      wcscpy_s(&Src, 0x400u, *v18);
      sub_402E4C();
      for ( i = v18 + 1; *i; ++i )
      {
        wcscpy_s(&Src, 0x400u, *i);
        sub_402C61();
      }
      if ( !v2 )
        sub_403257();
      sub_403371();
      v16 = ++v2;
      result = (char *)*((_DWORD *)&off_401460 + v2);
    }
    while ( result );
  }
  return result;
}
// 401390: using guessed type wchar_t **off_401390[12];
// 401748: using guessed type wchar_t a1430307111[14];
// 401B48: using guessed type wchar_t aSuffixes_0[10];
// 402388: using guessed type wchar_t aCc[3];
// 402390: using guessed type wchar_t aCl[3];
// 402398: using guessed type wchar_t aCxx[4];
// 4023A0: using guessed type wchar_t aCpp[4];
// 4023A8: using guessed type wchar_t aAs[3];
// 4023B0: using guessed type wchar_t aMl[3];
// 4023B8: using guessed type wchar_t aRc[3];
// 4023C0: using guessed type wchar_t aRc_0[3];
// 4023C8: using guessed type wchar_t aNmakeVer[11];
// 4023E0: using guessed type void *off_4023E0;

//----- (0040C298) --------------------------------------------------------
int __fastcall sub_40C298(int a1, int a2, int a3)
{
  wchar_t *v3; // esi
  wchar_t *v4; // ebx
  wchar_t *v5; // edi
  wchar_t *v6; // esi
  wchar_t *v7; // eax
  int v8; // ecx
  void *v9; // ecx
  const wchar_t *v10; // eax
  int v11; // esi
  size_t RequiredCount; // [esp+18h] [ebp-8h] BYREF
  wchar_t *Buffer; // [esp+1Ch] [ebp-4h] BYREF

  Buffer = 0;
  v3 = (wchar_t *)sub_40EBA1((char *)&off_4023EC);
  v4 = wgetcwd(0, 0);
  sub_4035E0(v3, v4, 66);
  wdupenv_s(&Buffer, 0, aMa);
  v5 = Buffer;
  if ( Buffer )
    wcsncpy_s(&aMakeflags[10], wcslen(aMakeflags) - 9, Buffer, 0xFFFFFFFF);
  byte_41350D = 1;
  v6 = (wchar_t *)sub_40EBA1((char *)&aMakeflags[10]);
  v7 = (wchar_t *)sub_40EBA1((char *)aMa);
  sub_4035E0(v7, v6, 6);
  for ( ; v5; ++v5 )
  {
    if ( !*v5 )
      break;
    sub_40CA78(*v5, 1);
  }
  free(Buffer);
  Buffer = 0;
  if ( !wgetenv_s(&RequiredCount, 0, 0, L"NTMAKEENV") && RequiredCount )
    byte_434479 = 1;
  sub_40C6A3(a1 - 1, a2 + 4);
  if ( !byte_423F60 )
    sub_405B88();
  if ( (byte_41350C & 2) == 0 )
  {
    sub_40C136();
    ArgList = (void *)L"tools.ini";
    if ( sub_409188(v8) )
    {
      ++dword_423724;
      byte_423F61 = 1;
      sub_40D13C(v9);
      if ( fclose(Stream) == -1 )
        sub_405A12(0, 0x424u, ArgList);
    }
  }
  v10 = (const wchar_t *)sub_40EBA1((char *)&aMakeflags[10]);
  if ( wputenv_s(aMa, v10) )
    sub_405A12(0, 0x41Fu);
  if ( !dword_434470 )
    sub_40C9A8();
  sub_40C5D7();
  sub_40C48D();
  dword_423730 = 0;
  sub_40E783();
  if ( (byte_41350C & 1) != 0 )
  {
    sub_40D606();
    sub_40D677();
    sub_40D717();
  }
  if ( dword_433F7C )
    free(dword_433F7C);
  v11 = sub_403CF3();
  wchdir(v4);
  return v11;
}
// 40C3C4: variable 'v8' is possibly undefined
// 40C3DA: variable 'v9' is possibly undefined
// 4023EC: using guessed type void *off_4023EC;
// 41302C: using guessed type wchar_t aMakeflags[29];
// 41350C: using guessed type char byte_41350C;
// 41350D: using guessed type char byte_41350D;
// 423724: using guessed type int dword_423724;
// 423730: using guessed type int dword_423730;
// 423F60: using guessed type char byte_423F60;
// 423F61: using guessed type char byte_423F61;
// 434470: using guessed type int dword_434470;
// 434479: using guessed type char byte_434479;

//----- (0040C48D) --------------------------------------------------------
int sub_40C48D()
{
  _DWORD *v0; // esi
  int v1; // ecx
  FILE *v2; // eax
  void *v3; // ecx
  FILE *v4; // eax
  int v5; // eax
  void *osfhandle; // eax
  void *v8; // [esp-4h] [ebp-14h]
  void *v9; // [esp-4h] [ebp-14h]
  LARGE_INTEGER FileSize; // [esp+8h] [ebp-8h] BYREF

  v0 = (_DWORD *)dword_434470;
  if ( dword_434470 )
  {
    do
    {
      v1 = v0[1];
      if ( *(_WORD *)v1 != 45 || *(_WORD *)(v1 + 2) )
      {
        ArgList = sub_40EBA1((char *)v1);
        v4 = wfsopen((const wchar_t *)ArgList, L"rt,ccs=unicode", 32);
        Stream = v4;
        if ( !v4 )
        {
          sub_405A12(0, 0x41Cu, ArgList);
          v4 = Stream;
        }
        FileSize.QuadPart = 0i64;
        v5 = fileno(v4);
        osfhandle = (void *)get_osfhandle(v5);
        v3 = v9;
        if ( osfhandle != (void *)-1 )
        {
          if ( GetFileSizeEx(osfhandle, &FileSize) )
          {
            v3 = (void *)(FileSize.LowPart + 1);
            if ( (unsigned __int64)(FileSize.QuadPart - 1) <= 0x7FFFFFFD )
              setvbuf(Stream, 0, 0, FileSize.LowPart + 1);
          }
        }
      }
      else
      {
        ArgList = sub_40EBA1((char *)L"STDIN");
        v2 = _acrt_iob_func(0);
        v3 = v8;
        Stream = v2;
      }
      dword_423724 = 0;
      byte_423F61 = 0;
      sub_40D13C(v3);
      if ( Stream != _acrt_iob_func(0) && fclose(Stream) == -1 )
        sub_405A12(0, 0x424u, ArgList);
      v0 = (_DWORD *)*v0;
    }
    while ( v0 );
    v0 = (_DWORD *)dword_434470;
  }
  return sub_405208(v0);
}
// 40C4CC: variable 'v8' is possibly undefined
// 40C52B: variable 'v9' is possibly undefined
// 40C582: variable 'v3' is possibly undefined
// 402450: using guessed type wchar_t aStdin[6];
// 423724: using guessed type int dword_423724;
// 423F61: using guessed type char byte_423F61;
// 434470: using guessed type int dword_434470;

//----- (0040C5D7) --------------------------------------------------------
char *sub_40C5D7()
{
  char ***v0; // eax
  char **v1; // esi
  char *result; // eax
  wchar_t *v3; // edi
  wchar_t *v4; // eax
  wchar_t *v5; // ebx
  _WORD *v6; // edx
  wchar_t *v8; // eax
  wchar_t *Block; // [esp+4h] [ebp-8h]

  v0 = (char ***)_p__wenviron();
  v1 = *v0;
  result = **v0;
  if ( result )
  {
    do
    {
      v3 = wcschr((const wchar_t *)result, 0x3Du);
      if ( v3 )
      {
        if ( wcsnicmp((const wchar_t *)*v1, aMa, 8u) )
        {
          *v3 = 0;
          if ( *(_WORD *)*v1 )
          {
            v4 = (wchar_t *)sub_40EBA1(*v1);
            v5 = v4;
            v6 = v4 + 1;
            while ( *v4++ )
              ;
            wcsupr_s(v5, v4 - v6 + 1);
            v8 = (wchar_t *)sub_40EBA1((char *)v3 + 2);
            *v3 = 61;
            Block = v8;
            byte_41350D = 0;
            if ( !sub_4035E0(v5, v8, 4) )
            {
              free(v5);
              free(Block);
            }
          }
        }
      }
      result = *++v1;
    }
    while ( *v1 );
  }
  return result;
}
// 41350D: using guessed type char byte_41350D;

//----- (0040C6A3) --------------------------------------------------------
void __fastcall sub_40C6A3(unsigned int a1, int a2)
{
  int v2; // edi
  int (__cdecl *v3)(const wchar_t *, const wchar_t *); // ecx
  wchar_t *(__cdecl *v4)(const wchar_t *, wchar_t); // esi
  wchar_t *v5; // ebx
  int v6; // eax
  wchar_t *v7; // eax
  wchar_t *v8; // esi
  wchar_t *v9; // eax
  const wchar_t *v10; // esi
  int v11; // ecx
  size_t v12; // eax
  wchar_t *v13; // esi
  size_t v14; // eax
  wchar_t *v15; // eax
  _DWORD *v16; // esi
  void *v17; // eax
  const wchar_t *v18; // esi
  int v19; // ecx
  const wchar_t *v20; // esi
  wchar_t v21; // cx
  FILE *v22; // eax
  char *v23; // ebx
  _DWORD *v24; // esi
  char v25; // cl
  char v26; // [esp+13h] [ebp-25h]
  int v27; // [esp+14h] [ebp-24h]
  FILE *Stream; // [esp+28h] [ebp-10h] BYREF
  FILE *(__cdecl *v30)(unsigned int); // [esp+2Ch] [ebp-Ch]
  errno_t (__cdecl *v31)(FILE **, const wchar_t *, const wchar_t *); // [esp+30h] [ebp-8h]
  int (__cdecl *v32)(FILE *); // [esp+34h] [ebp-4h]

  v27 = a2;
  v26 = 0;
  v2 = 0;
  if ( !a1 )
    return;
  v3 = wcsicmp;
  v4 = wcschr;
  v30 = _acrt_iob_func;
  v31 = wfopen_s;
  v32 = fclose;
  while ( 1 )
  {
    v5 = *(wchar_t **)(a2 + 4 * v2);
    v6 = *v5;
    if ( v6 == 64 )
    {
      sub_40587A(v5 + 1);
    }
    else
    {
      if ( (_WORD)v6 != 45 && v6 != 47 )
      {
        v7 = v4(v5, 0x3Du);
        v8 = v7;
        if ( v7 )
        {
          if ( v7 == v5 )
            sub_405A12(0, 0x427u);
          *v8 = 0;
          v9 = v8 - 1;
          v10 = v8 + 1;
          while ( 1 )
          {
            v11 = *v9;
            if ( (_WORD)v11 != 32 && v11 != 9 )
              break;
            --v9;
          }
          byte_41350D = 1;
          v9[1] = 0;
          v12 = wcsspn(v10, L" \t");
          v13 = (wchar_t *)sub_40EBA1((char *)&v10[v12]);
          v14 = wcsspn(v5, L" \t");
          v15 = (wchar_t *)sub_40EBA1((char *)&v5[v14]);
          sub_4035E0(v15, v13, 2);
        }
        else
        {
          sub_40CDA1(v5);
          if ( *v5 )
          {
            v16 = sub_40EB4F();
            if ( (int)wcschr(v5, 32) )
              v17 = sub_40EBE5((char *)v5);
            else
              v17 = sub_40EBA1((char *)v5);
            v16[1] = v17;
            sub_40ECA6((_DWORD **)&dword_423710, v16);
          }
        }
        a2 = v27;
        v4 = wcschr;
        *(_DWORD *)(v27 + 4 * v2) = 0;
        goto LABEL_51;
      }
      v18 = v5 + 1;
      if ( !v3(v5 + 1, L"help") )
        goto LABEL_54;
      if ( *v18 )
      {
        while ( 1 )
        {
          if ( !wcsicmp(v18, L"nologo") )
          {
            sub_40CA78(v18[2], 1);
            goto LABEL_49;
          }
          v19 = *v18;
          if ( v19 == 63 )
          {
            a2 = v27;
            v25 = 1;
            v4 = wcschr;
            v26 = 1;
            goto LABEL_52;
          }
          if ( v19 == 102 || v19 == 70 )
            break;
          if ( v19 == 120 || v19 == 88 )
          {
            v20 = v18 + 1;
            v21 = *v20;
            if ( !*v20 )
            {
              if ( ++v2 >= a1 || (v20 = *(const wchar_t **)(v27 + 4 * v2), (v21 = *v20) == 0) )
              {
                sub_405A12(0, 0x426u);
                v21 = *v20;
              }
            }
            if ( v21 != 45 || v20[1] )
            {
              if ( v31(&Stream, v20, L"wt") )
                sub_405A12(0, 0x418u, v20);
              sub_40D00B(Stream);
              v32(Stream);
            }
            else
            {
              v22 = v30(1u);
              sub_40D00B(v22);
            }
            goto LABEL_49;
          }
          sub_40CA78(v19, 1);
          if ( !*++v18 )
            goto LABEL_49;
        }
        v23 = (char *)(v18 + 1);
        if ( !v18[1] )
        {
          if ( ++v2 >= a1 || (v23 = *(char **)(v27 + 4 * v2), !*(_WORD *)v23) )
            sub_405A12(0, 0x425u);
        }
        v24 = sub_40EB4F();
        v24[1] = sub_40EBA1(v23);
        sub_40ECA6((_DWORD **)&dword_434470, v24);
      }
LABEL_49:
      v4 = wcschr;
    }
    a2 = v27;
LABEL_51:
    v25 = v26;
LABEL_52:
    if ( ++v2 >= a1 )
      break;
    v3 = wcsicmp;
  }
  if ( v25 )
  {
LABEL_54:
    sub_405BB4();
    exit(0);
  }
}
// 402468: using guessed type wchar_t aNologo[7];
// 402478: using guessed type wchar_t aWt[3];
// 41350D: using guessed type char byte_41350D;
// 423710: using guessed type int dword_423710;
// 434470: using guessed type int dword_434470;

//----- (0040C9A8) --------------------------------------------------------
void *sub_40C9A8()
{
  void *result; // eax
  _DWORD *v1; // esi
  wchar_t *v2; // esi
  wchar_t *v3; // eax
  int v4; // ecx
  struct _WIN32_FIND_DATAW FindFileData; // [esp+8h] [ebp-460h] BYREF
  wchar_t Destination[262]; // [esp+258h] [ebp-210h] BYREF

  result = (void *)waccess(L"makefile", 4);
  if ( result )
  {
    if ( dword_423710 )
    {
      v2 = *(wchar_t **)(dword_423710 + 4);
      result = (void *)waccess(v2, 4);
      if ( !result )
      {
        v3 = wcsrchr(v2, 0x2Eu);
        if ( !v3 || (result = sub_40E31C(Destination, 0x101u, v2, (int)v3, &FindFileData)) == 0 )
        {
          v4 = dword_423710;
          result = *(void **)dword_423710;
          dword_423710 = *(_DWORD *)dword_423710;
          dword_434470 = v4;
        }
      }
    }
    else if ( (byte_41350C & 1) == 0 )
    {
      return (void *)sub_405A12(0, 0x428u);
    }
  }
  else
  {
    v1 = sub_40EB4F();
    result = sub_40EBA1((char *)L"makefile");
    v1[1] = result;
    dword_434470 = (int)v1;
  }
  return result;
}
// 41350C: using guessed type char byte_41350C;
// 423710: using guessed type int dword_423710;
// 434470: using guessed type int dword_434470;
// 40C9A8: using guessed type wchar_t Destination[262];

//----- (0040CA78) --------------------------------------------------------
int __fastcall sub_40CA78(wint_t C, char a2)
{
  char *v2; // esi
  int v3; // edi
  int result; // eax
  char v5; // bl
  int v6; // ecx
  char v7; // bl
  wchar_t *v8; // eax
  wchar_t *v9; // eax
  wchar_t v10; // dx
  const wchar_t *v11; // eax
  char v13; // [esp+10h] [ebp-8h]

  v2 = &byte_41350E;
  v13 = 0;
  v3 = towupper(C);
  result = v3;
  if ( (unsigned __int16)v3 > 0x4Cu )
  {
    if ( (unsigned __int16)v3 > 0x52u )
    {
      result = (unsigned __int16)v3 - 83;
      if ( (unsigned __int16)v3 == 83 )
      {
        v13 = 8;
        goto LABEL_44;
      }
      result = (unsigned __int16)v3 - 84;
      if ( (unsigned __int16)v3 == 84 )
      {
        v13 = 16;
        goto LABEL_11;
      }
      result = (unsigned __int16)v3 - 85;
      if ( (unsigned __int16)v3 == 85 )
      {
        v13 = 64;
        goto LABEL_44;
      }
      result = (unsigned __int16)v3 - 89;
      if ( (unsigned __int16)v3 == 89 )
      {
        v13 = 64;
        goto LABEL_11;
      }
      goto LABEL_39;
    }
    if ( v3 == 82 )
    {
      v13 = 2;
      goto LABEL_11;
    }
    result = (unsigned __int16)v3 - 78;
    if ( (unsigned __int16)v3 == 78 )
    {
      v13 = 4;
      goto LABEL_44;
    }
    result = (unsigned __int16)v3 - 79;
    if ( (unsigned __int16)v3 == 79 )
    {
      byte_423735 = 1;
      return result;
    }
    result = (unsigned __int16)v3 - 80;
    if ( (unsigned __int16)v3 == 80 )
    {
      v13 = 1;
      goto LABEL_11;
    }
    result = (unsigned __int16)v3 - 81;
    if ( (unsigned __int16)v3 == 81 )
    {
      v13 = 8;
      goto LABEL_11;
    }
    goto LABEL_39;
  }
  if ( (unsigned __int16)v3 == 76 )
  {
    v13 = 0x80;
    goto LABEL_10;
  }
  if ( (unsigned __int16)v3 > 0x44u )
  {
    result = (unsigned __int16)v3 - 69;
    if ( (unsigned __int16)v3 == 69 )
    {
      v13 = 4;
      goto LABEL_11;
    }
    result = (unsigned __int16)v3 - 71;
    if ( (unsigned __int16)v3 == 71 )
    {
      byte_423F63 = 1;
      return result;
    }
    result = (unsigned __int16)v3 - 73;
    if ( (unsigned __int16)v3 == 73 )
    {
      v13 = 2;
      goto LABEL_44;
    }
    result = (unsigned __int16)v3 - 75;
    if ( (unsigned __int16)v3 == 75 )
    {
      byte_423737 = 1;
      return result;
    }
LABEL_39:
    result = sub_405A12(0, 0x429u, C);
    goto LABEL_44;
  }
  if ( v3 == 68 )
  {
    v13 = 1;
  }
  else
  {
    result = (unsigned __int16)v3 - 32;
    if ( (unsigned __int16)v3 == 32 )
      return result;
    result = (unsigned __int16)v3 - 65;
    if ( (unsigned __int16)v3 != 65 )
    {
      result = (unsigned __int16)v3 - 66;
      if ( (unsigned __int16)v3 == 66 )
      {
        byte_423736 = 1;
        return result;
      }
      result = (unsigned __int16)v3 - 67;
      if ( (unsigned __int16)v3 == 67 )
      {
        v13 = 32;
LABEL_10:
        byte_423F60 = 1;
LABEL_11:
        v5 = byte_41350C;
        v2 = &byte_41350C;
        goto LABEL_45;
      }
      goto LABEL_39;
    }
    v13 = 16;
  }
LABEL_44:
  v5 = byte_41350E;
LABEL_45:
  if ( dword_4343AC )
  {
    v6 = dword_4343A8;
  }
  else
  {
    result = sub_40B444(aMa);
    dword_4343AC = result;
    v6 = *(_DWORD *)(result + 8);
    dword_4343A8 = v6;
  }
  if ( a2 )
  {
    v7 = v13 | v5;
    *v2 = v7;
    if ( v3 == 81 )
      *v2 = v7 | 0x20;
    if ( !wcschr(*(const wchar_t **)(v6 + 4), v3) )
    {
      v8 = wcschr(*(const wchar_t **)(dword_4343A8 + 4), 0x20u);
      if ( v8 )
        *v8 = v3;
    }
  }
  else
  {
    if ( v2 != &byte_41350E )
      return result;
    *v2 = v5 & ~v13;
    v9 = wcschr(*(const wchar_t **)(v6 + 4), v3);
    if ( v9 )
    {
      do
      {
        v10 = v9[1];
        *v9++ = v10;
      }
      while ( v10 );
    }
  }
  v11 = (const wchar_t *)sub_40EBA1((char *)&aMakeflags[10]);
  result = wputenv_s(aMa, v11);
  if ( result )
    return sub_405A12(dword_423724, 0x41Fu);
  return result;
}
// 41302C: using guessed type wchar_t aMakeflags[29];
// 41350C: using guessed type char byte_41350C;
// 41350E: using guessed type char byte_41350E;
// 423724: using guessed type int dword_423724;
// 423735: using guessed type char byte_423735;
// 423736: using guessed type char byte_423736;
// 423737: using guessed type char byte_423737;
// 423F60: using guessed type char byte_423F60;
// 423F63: using guessed type char byte_423F63;
// 4343A8: using guessed type int dword_4343A8;
// 4343AC: using guessed type int dword_4343AC;

//----- (0040CCB3) --------------------------------------------------------
void __cdecl Function()
{
  int v0; // esi
  const wchar_t *v1; // edi

  signal(2, (_crt_signal_t)1);
  signal(15, (_crt_signal_t)1);
  if ( byte_434478 && (byte_41350E & 4) == 0 && (byte_41350C & 0x10) == 0 && dword_423F54 && waccess(dword_423F54, 0) )
  {
    v0 = dword_42371C;
    v1 = dword_423F54;
    if ( dword_42371C )
    {
      while ( wcsicmp(*(const wchar_t **)(v0 + 4), v1) )
      {
        v0 = *(_DWORD *)v0;
        if ( !v0 )
        {
          v1 = dword_423F54;
          goto LABEL_10;
        }
      }
    }
    else
    {
LABEL_10:
      if ( !wunlink(v1) )
        sub_405A12(dword_423724, 0xFA8u, dword_423F54);
    }
  }
  sub_405A12(0, 0x422u);
  sub_40CD63();
}
// 41350C: using guessed type char byte_41350C;
// 41350E: using guessed type char byte_41350E;
// 42371C: using guessed type int dword_42371C;
// 423724: using guessed type int dword_423724;
// 434478: using guessed type char byte_434478;

//----- (0040CD63) --------------------------------------------------------
int sub_40CD63()
{
  int result; // eax
  int i; // esi

  result = fcloseall();
  for ( i = dword_434474; i; i = *(_DWORD *)i )
  {
    result = wunlink(*(const wchar_t **)(i + 4));
    if ( (byte_41350E & 4) != 0 )
    {
      sub_40D0B1((wchar_t *)L"\tdel %s\n", *(_DWORD *)(i + 4));
      result = sub_40D093();
    }
  }
  return result;
}
// 41350E: using guessed type char byte_41350E;
// 434474: using guessed type int dword_434474;

//----- (0040CDA1) --------------------------------------------------------
const unsigned __int16 *__fastcall sub_40CDA1(const unsigned __int16 *a1)
{
  char v1; // bl
  const unsigned __int16 *result; // eax
  int v3; // edx

  v1 = 0;
  result = &a1[wcslen(a1) - 1];
  if ( *a1 != 34 || *result != 34 )
    goto LABEL_7;
  v1 = 1;
  do
  {
    --result;
LABEL_7:
    if ( result <= a1 )
      break;
    v3 = *result;
  }
  while ( v3 == 32 || v3 == 46 );
  if ( v1 )
    *++result = 34;
  *((_WORD *)result + 1) = 0;
  return result;
}

//----- (0040CDF7) --------------------------------------------------------
int __fastcall sub_40CDF7(unsigned int a1)
{
  int v1; // esi
  wchar_t **v3; // eax
  HMODULE v4; // edi
  HRSRC Resource; // eax
  _WORD *v6; // edx
  int i; // ebx
  int v9; // [esp-18h] [ebp-640h]
  int v10; // [esp-14h] [ebp-63Ch]
  int v11; // [esp-10h] [ebp-638h]
  int v12; // [esp-Ch] [ebp-634h]
  int v13; // [esp-8h] [ebp-630h]
  int v14; // [esp-4h] [ebp-62Ch]
  wchar_t Buffer[260]; // [esp+10h] [ebp-618h] BYREF
  wchar_t Dir[256]; // [esp+218h] [ebp-410h] BYREF
  wchar_t Filename[258]; // [esp+418h] [ebp-210h] BYREF
  wchar_t Drive[4]; // [esp+61Ch] [ebp-Ch] BYREF

  v1 = 0;
  if ( byte_437EE0 )
  {
    v4 = hModule;
  }
  else
  {
    v3 = _p__wpgmptr();
    wsplitpath_s(*v3, Drive, 3u, Dir, 0x100u, Filename, 0x100u, 0, 0);
    wmakepath_s(Buffer, 0x104u, Drive, Dir, 0, 0);
    if ( wcsncat_s(Filename, 0x100u, L"UI.DLL", 0xFFFFFFFF)
      || sub_40B562(Buffer, Filename, v9, v10, v11, v12, v13, v14) < 0 )
    {
      v4 = 0;
      hModule = 0;
    }
    else
    {
      v4 = hModule;
    }
    byte_437EE0 = 1;
  }
  Resource = FindResourceExW(v4, (LPCWSTR)6, (LPCWSTR)(unsigned __int16)((a1 >> 4) + 1), word_437EE8);
  if ( Resource )
  {
    v6 = LoadResource(v4, Resource);
    if ( v6 )
    {
      for ( i = a1 & 0xF; i; --i )
        v6 += (unsigned __int16)*v6 + 1;
      return *v6 != 0 ? (unsigned int)(v6 + 1) : 0;
    }
  }
  return v1;
}
// 40CE93: variable 'v9' is possibly undefined
// 40CE93: variable 'v10' is possibly undefined
// 40CE93: variable 'v11' is possibly undefined
// 40CE93: variable 'v12' is possibly undefined
// 40CE93: variable 'v13' is possibly undefined
// 40CE93: variable 'v14' is possibly undefined
// 437EE0: using guessed type char byte_437EE0;
// 437EE8: using guessed type __int16 word_437EE8;

//----- (0040CF18) --------------------------------------------------------
void *sub_40CF18()
{
  return &unk_4376B8;
}

//----- (0040CF1E) --------------------------------------------------------
int sub_40CF1E(wchar_t *Buffer, wchar_t *Format, ...)
{
  _DWORD *v2; // eax
  unsigned __int64 v4; // [esp-1Ch] [ebp-1Ch]
  va_list va; // [esp+10h] [ebp+10h] BYREF

  va_start(va, Format);
  v2 = sub_40CF18();
  HIDWORD(v4) = v2[1];
  LODWORD(v4) = *v2 | 1;
  return _stdio_common_vswscanf(v4, Buffer, 0xFFFFFFFF, Format, 0, va);
}

//----- (0040CF48) --------------------------------------------------------
bool __thiscall sub_40CF48(FILE *Stream)
{
  int v1; // eax
  void *osfhandle; // esi
  DWORD Mode; // [esp+4h] [ebp-4h] BYREF

  v1 = fileno(Stream);
  osfhandle = (void *)get_osfhandle(v1);
  return (GetFileType(osfhandle) & 0xFFFF7FFF) == 2 && GetConsoleMode(osfhandle, &Mode);
}

//----- (0040CF87) --------------------------------------------------------
bool sub_40CF87()
{
  FILE *v0; // eax
  FILE *v1; // eax
  bool result; // al

  v0 = _acrt_iob_func(1u);
  byte_43447D = sub_40CF48(v0);
  v1 = _acrt_iob_func(2u);
  result = sub_40CF48(v1);
  byte_43447C = result;
  return result;
}
// 43447C: using guessed type char byte_43447C;
// 43447D: using guessed type char byte_43447D;

//----- (0040CFB2) --------------------------------------------------------
int sub_40CFB2()
{
  FILE *v1; // eax

  if ( byte_43447C )
    return 0;
  v1 = _acrt_iob_func(2u);
  return fflush(v1);
}
// 43447C: using guessed type char byte_43447C;

//----- (0040CFD0) --------------------------------------------------------
int sub_40CFD0(wchar_t *Format, ...)
{
  va_list va; // [esp+Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  return sub_40D049(Format, va);
}

//----- (0040CFDF) --------------------------------------------------------
int sub_40CFDF()
{
  int result; // eax
  FILE *v1; // eax

  if ( byte_43447C )
  {
    LOWORD(result) = putwch(0xAu);
  }
  else
  {
    v1 = _acrt_iob_func(2u);
    LOWORD(result) = fputwc(0xAu, v1);
  }
  return (unsigned __int16)result;
}
// 43447C: using guessed type char byte_43447C;

//----- (0040D00B) --------------------------------------------------------
bool __thiscall sub_40D00B(FILE *Stream)
{
  FILE *v2; // eax
  int v3; // edi
  int v4; // eax
  FILE *v5; // eax
  bool result; // al

  v2 = _acrt_iob_func(2u);
  v3 = fileno(v2);
  v4 = fileno(Stream);
  dup2(v4, v3);
  v5 = _acrt_iob_func(2u);
  result = sub_40CF48(v5);
  byte_43447C = result;
  return result;
}
// 43447C: using guessed type char byte_43447C;

//----- (0040D049) --------------------------------------------------------
int __fastcall sub_40D049(wchar_t *Format, va_list ArgList)
{
  unsigned __int64 *v4; // eax
  unsigned __int64 *v5; // esi
  FILE *v7; // eax

  v4 = (unsigned __int64 *)sub_40D136();
  v5 = v4;
  if ( byte_43447C )
    return _conio_common_vcwprintf(*v4, Format, 0, ArgList);
  v7 = _acrt_iob_func(2u);
  return _stdio_common_vfwprintf(*v5, v7, Format, 0, ArgList);
}
// 43447C: using guessed type char byte_43447C;

//----- (0040D093) --------------------------------------------------------
int sub_40D093()
{
  FILE *v1; // eax

  if ( byte_43447D )
    return 0;
  v1 = _acrt_iob_func(1u);
  return fflush(v1);
}
// 43447D: using guessed type char byte_43447D;

//----- (0040D0B1) --------------------------------------------------------
int sub_40D0B1(wchar_t *Format, ...)
{
  va_list va; // [esp+Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  return sub_40D0EC(Format, va);
}

//----- (0040D0C0) --------------------------------------------------------
int sub_40D0C0()
{
  int result; // eax
  FILE *v1; // eax

  if ( byte_43447D )
  {
    LOWORD(result) = putwch(0xAu);
  }
  else
  {
    v1 = _acrt_iob_func(1u);
    LOWORD(result) = fputwc(0xAu, v1);
  }
  return (unsigned __int16)result;
}
// 43447D: using guessed type char byte_43447D;

//----- (0040D0EC) --------------------------------------------------------
int __fastcall sub_40D0EC(wchar_t *Format, va_list ArgList)
{
  unsigned __int64 *v4; // eax
  unsigned __int64 *v5; // esi
  FILE *v7; // eax

  v4 = (unsigned __int64 *)sub_40D136();
  v5 = v4;
  if ( byte_43447D )
    return _conio_common_vcwprintf(*v4, Format, 0, ArgList);
  v7 = _acrt_iob_func(1u);
  return _stdio_common_vfwprintf(*v5, v7, Format, 0, ArgList);
}
// 43447D: using guessed type char byte_43447D;

//----- (0040D136) --------------------------------------------------------
void *sub_40D136()
{
  return &unk_4376C8;
}

//----- (0040D13C) --------------------------------------------------------
int __thiscall sub_40D13C(void *this)
{
  int v1; // eax
  unsigned int v2; // eax
  int result; // eax
  int v4; // edx
  int v5; // ecx
  char v6; // bh
  unsigned __int8 i; // bl
  int v8; // eax
  char v9; // al
  int v10; // eax
  char v11; // al
  _BYTE *v12; // esi
  int v13; // [esp+10h] [ebp-8h]
  int v14; // [esp+10h] [ebp-8h]
  char v15; // [esp+17h] [ebp-1h]

  v1 = dword_413028;
  byte_423F62 = 1;
  byte_434391[dword_413028] = 23;
  v2 = v1 + 2;
  dword_413028 = v2;
  if ( v2 >= 0x10 )
    __report_rangecheckfailure();
  byte_434390[v2] = 0;
  dword_423730 = dword_423724;
  LOBYTE(result) = sub_40A3BD((int)this, 0);
  v4 = dword_413028;
  LOBYTE(v5) = result;
  v6 = 0;
  v15 = result;
  for ( i = byte_434390[dword_413028]; i != 23; i = byte_434390[v4] )
  {
    if ( (i & 0x40) != 0 )
    {
      v8 = byte_434390[v4] & 0xF;
      dword_413028 = v4 - 1;
      result = funcs_40D1BC[v8]();
    }
    else
    {
      if ( (i & 0x10) == 0 )
      {
        result = (unsigned __int8)byte_401540[8 * i + (v5 & 0xF)];
        v13 = result;
        if ( (result & 0x20) != 0 )
        {
          sub_405A12(dword_423730, result + 1000, &Src);
          v4 = dword_413028;
          result = v13;
        }
        dword_413028 = --v4;
        if ( (result & 0x80u) != 0 )
        {
          v10 = result & 0xF;
          v14 = v10;
          if ( !v6 )
          {
            v11 = sub_40A3BD(v5, i);
            v4 = dword_413028;
            v6 = v11;
            v10 = v14;
          }
          result = (unsigned __int8)byte_401520[8 * i + (v6 & 0xF)] + v10;
        }
        v12 = (_BYTE *)*((_DWORD *)&off_4014D0 + result);
        v5 = (unsigned __int8)*v12;
        if ( *v12 )
        {
          do
          {
            LOBYTE(result) = v12[v5];
            byte_434390[++v4] = result;
            --v5;
          }
          while ( v5 );
          dword_413028 = v4;
        }
        goto LABEL_25;
      }
      if ( i == (_BYTE)v5 )
      {
        LOBYTE(v5) = byte_43438F[v4--];
        dword_413028 = v4;
        if ( (v5 & 0x40) != 0 )
        {
          dword_413028 = v4 - 1;
          funcs_40D1BC[v5 & 0xF]();
          v4 = dword_413028;
        }
        result = dword_423724;
        dword_423730 = dword_423724;
        if ( v6 )
        {
          if ( Src == 10 )
          {
            result = dword_423724 - 1;
            dword_423730 = dword_423724 - 1;
          }
          LOBYTE(v5) = v6;
          v6 = 0;
          v15 = v5;
        }
        else
        {
          v9 = sub_40A3BD(v5, byte_434390[v4]);
          v4 = dword_413028;
          LOBYTE(v5) = v9;
          result = dword_423724;
          v15 = v5;
          dword_423730 = dword_423724;
        }
        continue;
      }
      result = sub_405A12(dword_423730, 0x409u, &Src);
    }
    v4 = dword_413028;
LABEL_25:
    LOBYTE(v5) = v15;
  }
  dword_413028 = v4 - 1;
  return result;
}
// 40D24C: variable 'v5' is possibly undefined
// 401580: using guessed type int (*funcs_40D1BC[6])();
// 411D61: using guessed type void __noreturn __report_rangecheckfailure(void);
// 413028: using guessed type int dword_413028;
// 423724: using guessed type int dword_423724;
// 423730: using guessed type int dword_423730;
// 423F62: using guessed type char byte_423F62;

//----- (0040D320) --------------------------------------------------------
unsigned int __fastcall sub_40D320(int a1, _WORD *a2)
{
  _WORD *v2; // esi
  unsigned int v4; // ecx

  v2 = a2 + 1;
  while ( *a2++ )
    ;
  v4 = a2 - v2 + a1;
  if ( v4 > 0x28 )
  {
    sub_40D0B1((wchar_t *)L"\n\t\t\t");
    return 0;
  }
  return v4;
}

//----- (0040D34F) --------------------------------------------------------
void __fastcall sub_40D34F(int a1, int a2, FILETIME FileTime)
{
  struct _FILETIME LocalFileTime; // [esp+Ch] [ebp-5Ch] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+14h] [ebp-54h] BYREF
  WCHAR DateStr[20]; // [esp+24h] [ebp-44h] BYREF
  WCHAR TimeStr[12]; // [esp+4Ch] [ebp-1Ch] BYREF

  if ( FileTime )
  {
    if ( FileTimeToLocalFileTime(&FileTime, &LocalFileTime)
      && FileTimeToSystemTime(&LocalFileTime, &SystemTime)
      && GetDateFormatW(0x400u, 0, &SystemTime, L"ddd, MMM dd yyyy", DateStr, 20) )
    {
      if ( GetTimeFormatW(0x400u, 0, &SystemTime, L"HH:mm:ss", TimeStr, 12) )
        sub_405AEC(4u, DateStr, TimeStr, a1, 32, a2);
    }
  }
  else
  {
    sub_405AEC(6u, a1 + 26, 32, a2);
  }
}

//----- (0040D409) --------------------------------------------------------
void __fastcall sub_40D409(int a1, int a2)
{
  int v2; // edi
  int v3; // ebx
  wchar_t *v4; // eax
  __int16 *v5; // ecx
  wchar_t *v6; // ebx
  int v7; // edi
  WCHAR *i; // eax
  _WORD *v9; // esi
  WCHAR *v10; // eax
  _WORD *v11; // esi
  int v12; // [esp+Ch] [ebp-27Ch]
  wchar_t *String; // [esp+10h] [ebp-278h] BYREF
  HANDLE hFindFile; // [esp+14h] [ebp-274h] BYREF
  wchar_t *Context; // [esp+18h] [ebp-270h] BYREF
  int v16; // [esp+1Ch] [ebp-26Ch]
  int v17; // [esp+20h] [ebp-268h] BYREF
  __int16 *v18; // [esp+24h] [ebp-264h] BYREF
  int v19; // [esp+28h] [ebp-260h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+30h] [ebp-258h] BYREF

  v2 = a1;
  v16 = a1;
  v17 = a2;
  sub_405AEC(0xCu);
  v3 = 0;
  v12 = 0;
  while ( v2 )
  {
    v4 = wcschr(*(const wchar_t **)(v2 + 4), 0x24u);
    v5 = *(__int16 **)(v2 + 4);
    if ( v4 )
    {
      Context = 0;
      String = 0;
      v18 = v5;
      sub_40F8BE(&v19, &v18, 1, &v17, 0, (char *)&String);
      v6 = wcstok_s(String, L" \t", &Context);
      if ( v6 )
      {
        v7 = v12;
        do
        {
          if ( wcspbrk(v6, L"*?") )
          {
            for ( i = sub_4081DE(v6, &FindFileData, &hFindFile); i; i = sub_408369(&FindFileData, hFindFile) )
            {
              v9 = sub_410C5A(v6, i);
              sub_40D0B1((wchar_t *)L"%s ", v9);
              v7 = sub_40D320(v7, v9);
              free(v9);
            }
          }
          else
          {
            sub_40D0B1((wchar_t *)L"%s ", v6);
            v7 = sub_40D320(v7, v6);
          }
          v6 = wcstok_s(0, L" \t", &Context);
        }
        while ( v6 );
        v12 = v7;
        v2 = v16;
      }
      free(String);
      v3 = v12;
    }
    else
    {
      if ( wcspbrk((const wchar_t *)v5, L"*?") )
      {
        v10 = sub_4081DE(*(wchar_t **)(v2 + 4), &FindFileData, &hFindFile);
        if ( !v10 )
          goto LABEL_20;
        do
        {
          v11 = sub_410C5A(*(wchar_t **)(v2 + 4), v10);
          sub_40D0B1((wchar_t *)L"%s ", v11);
          v3 = sub_40D320(v3, v11);
          free(v11);
          v10 = sub_408369(&FindFileData, hFindFile);
        }
        while ( v10 );
      }
      else
      {
        sub_40D0B1((wchar_t *)L"%s ", *(_DWORD *)(v2 + 4));
        v3 = sub_40D320(v3, *(_WORD **)(v2 + 4));
      }
      v12 = v3;
    }
LABEL_20:
    v2 = *(_DWORD *)v2;
    v16 = v2;
  }
}

//----- (0040D606) --------------------------------------------------------
int sub_40D606()
{
  _DWORD *v0; // edi
  _DWORD *i; // esi
  int v2; // eax
  _DWORD *j; // ebx

  sub_405AEC(8u);
  v0 = &unk_433F90;
  do
  {
    for ( i = (_DWORD *)*v0; i; i = (_DWORD *)*i )
    {
      v2 = i[2];
      if ( v2 && *(_DWORD *)(v2 + 4) )
      {
        sub_405AEC(0xEu, i[1], *(_DWORD *)(v2 + 4));
        for ( j = *(_DWORD **)i[2]; j; j = (_DWORD *)*j )
        {
          if ( j[1] )
            sub_40D0B1((wchar_t *)L"\t\t%s\n", j[1]);
        }
      }
    }
    ++v0;
  }
  while ( (int)v0 < (int)byte_434390 );
  sub_40D0C0();
  return sub_40D093();
}

//----- (0040D677) --------------------------------------------------------
int sub_40D677()
{
  _BYTE *v0; // esi
  wchar_t *v1; // eax
  _DWORD *v2; // edi
  _DWORD *i; // esi

  sub_405AEC(7u);
  v0 = dword_423714;
  if ( dword_423714 )
  {
    do
    {
      v1 = (wchar_t *)L"%s::";
      if ( !v0[20] )
        v1 = L"%s:";
      sub_40D0B1(v1, *((_DWORD *)v0 + 2));
      sub_405AEC(0xAu);
      v2 = (_DWORD *)*((_DWORD *)v0 + 3);
      if ( v2 )
      {
        sub_40D0B1(L"%s\n", v2[1]);
        while ( 1 )
        {
          v2 = (_DWORD *)*v2;
          if ( !v2 )
            break;
          sub_40D0B1((wchar_t *)L"\t\t\t%s\n", v2[1]);
        }
      }
      sub_40D0C0();
      v0 = *(_BYTE **)v0;
    }
    while ( v0 );
  }
  sub_40D0B1((wchar_t *)L"%s: ", L".SUFFIXES");
  for ( i = (_DWORD *)dword_423720; i; i = (_DWORD *)*i )
    sub_40D0B1((wchar_t *)L"%s ", i[1]);
  sub_40D0C0();
  return sub_40D093();
}
// 401168: using guessed type wchar_t aSuffixes[10];
// 40251C: using guessed type wchar_t aS_3[4];
// 402524: using guessed type wchar_t aS_4[4];
// 423720: using guessed type int dword_423720;

//----- (0040D717) --------------------------------------------------------
int sub_40D717()
{
  unsigned int v0; // ebx
  _DWORD *v1; // esi
  _DWORD *v2; // ebx
  int v3; // edi
  unsigned __int16 *v4; // esi
  unsigned int v5; // eax
  _DWORD *v6; // edi
  int result; // eax
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]
  unsigned int v10; // [esp+14h] [ebp-4h]

  sub_405AEC(9u);
  v0 = 0;
  v10 = 0;
  do
  {
    v1 = *(_DWORD **)((char *)dword_423510 + v0);
    v9 = v1;
    if ( v1 )
    {
      do
      {
        sub_40D0B1((wchar_t *)L"%s:%c", v1[1], (*(_BYTE *)(*(_DWORD *)(v1[6] + 4) + 16) & 0x20) != 0 ? 58 : 32);
        v2 = (_DWORD *)v1[6];
        dword_423F48 = v1[1];
        dword_423F54 = (wchar_t *)dword_423F48;
        dword_423F58 = dword_423F48;
        if ( v2 )
        {
          do
          {
            v3 = v2[1];
            sub_405AEC(0xBu);
            v4 = L"dinsb";
            v5 = 1;
            v8 = 1;
            do
            {
              if ( ((unsigned __int8)v5 & *(_BYTE *)(v3 + 16)) != 0 )
              {
                sub_40D0B1((wchar_t *)L"-%c ", *v4);
                v5 = v8;
              }
              v5 *= 2;
              ++v4;
              v8 = v5;
            }
            while ( v5 < 0x10 );
            sub_40D409(*(_DWORD *)v3, *(_DWORD *)(v3 + 4));
            sub_405AEC(0xAu);
            v6 = *(_DWORD **)(v3 + 8);
            if ( v6 )
            {
              if ( v6[1] )
                sub_40D0B1(L"%s\n", v6[1]);
              while ( 1 )
              {
                v6 = (_DWORD *)*v6;
                if ( !v6 )
                  break;
                if ( v6[1] )
                  sub_40D0B1((wchar_t *)L"\t\t\t%s\n", v6[1]);
              }
            }
            else
            {
              sub_40D0C0();
            }
            v2 = (_DWORD *)*v2;
          }
          while ( v2 );
          v1 = v9;
        }
        v1 = (_DWORD *)*v1;
        v9 = v1;
        sub_40D0C0();
      }
      while ( v1 );
      v0 = v10;
    }
    v0 += 4;
    v10 = v0;
  }
  while ( v0 < 0x200 );
  sub_40D0C0();
  sub_40D093();
  result = 0;
  dword_423F48 = 0;
  dword_423F54 = 0;
  dword_423F58 = 0;
  return result;
}
// 402524: using guessed type wchar_t aS_4[4];
// 402560: using guessed type wchar_t aDinsb[6];
// 423510: using guessed type int dword_423510[128];
// 423F48: using guessed type int dword_423F48;
// 423F58: using guessed type int dword_423F58;

//----- (0040D86C) --------------------------------------------------------
char __stdcall sub_40D86C(char a1)
{
  int v1; // edi
  char v2; // al
  int v3; // esi
  int v4; // eax
  BOOL v5; // ecx
  int v6; // ecx
  BOOL v7; // eax
  unsigned int v8; // eax

  v1 = dword_434690;
  v2 = *(_BYTE *)dword_434690;
  v3 = dword_434690 - 8;
  dword_434690 -= 8;
  if ( v2 != 22 )
  {
    if ( v2 != 23 || *(_BYTE *)v3 != 23 )
      return 0;
    v6 = wcscmp(*(const unsigned __int16 **)(v3 + 4), *(const unsigned __int16 **)(v1 + 4));
    if ( v6 )
      v6 = v6 < 0 ? -1 : 1;
    switch ( a1 )
    {
      case 6:
        v7 = v6 != 0;
        goto LABEL_48;
      case 7:
        v7 = v6 == 0;
        goto LABEL_48;
      case 8:
        v7 = v6 > 0;
        goto LABEL_48;
      case 9:
        v8 = v6;
        break;
      case 10:
        v8 = ~v6;
        break;
      case 11:
        v7 = v6 <= 0;
LABEL_48:
        *(_DWORD *)(v3 + 4) = v7;
        *(_BYTE *)v3 = 22;
        return 1;
      default:
        return 0;
    }
    v7 = v8 >> 31;
    goto LABEL_48;
  }
  if ( *(_BYTE *)v3 == 22 )
  {
    switch ( a1 )
    {
      case 1:
        v4 = 0;
        if ( !*(_DWORD *)(v3 + 4) )
          goto LABEL_5;
        goto LABEL_6;
      case 2:
        v4 = 0;
        if ( *(_DWORD *)(v3 + 4) )
        {
LABEL_5:
          if ( *(_DWORD *)(v1 + 4) )
LABEL_6:
            v4 = 1;
        }
        goto LABEL_30;
      case 3:
        *(_DWORD *)(v3 + 4) |= *(_DWORD *)(v1 + 4);
        return 1;
      case 4:
        *(_DWORD *)(v3 + 4) ^= *(_DWORD *)(v1 + 4);
        return 1;
      case 5:
        *(_DWORD *)(v3 + 4) &= *(_DWORD *)(v1 + 4);
        return 1;
      case 6:
        v5 = *(_DWORD *)(v1 + 4) != *(_DWORD *)(v3 + 4);
        goto LABEL_13;
      case 7:
        v4 = *(_DWORD *)(v3 + 4) == *(_DWORD *)(v1 + 4);
        goto LABEL_30;
      case 8:
        v5 = *(_DWORD *)(v3 + 4) > *(_DWORD *)(v1 + 4);
        goto LABEL_13;
      case 9:
        v5 = *(_DWORD *)(v3 + 4) < *(_DWORD *)(v1 + 4);
        goto LABEL_13;
      case 10:
        v5 = *(_DWORD *)(v3 + 4) >= *(_DWORD *)(v1 + 4);
        goto LABEL_13;
      case 11:
        v5 = *(_DWORD *)(v3 + 4) <= *(_DWORD *)(v1 + 4);
LABEL_13:
        *(_DWORD *)(v3 + 4) = v5;
        return 1;
      case 12:
        *(int *)(v3 + 4) >>= *(_DWORD *)(v1 + 4);
        return 1;
      case 13:
        *(_DWORD *)(v3 + 4) <<= *(_DWORD *)(v1 + 4);
        return 1;
      case 14:
        *(_DWORD *)(v3 + 4) -= *(_DWORD *)(v1 + 4);
        return 1;
      case 15:
        *(_DWORD *)(v3 + 4) += *(_DWORD *)(v1 + 4);
        return 1;
      case 16:
        if ( !*(_DWORD *)(v1 + 4) )
          sub_405A12(dword_423724, 0x437u);
        *(int *)(v3 + 4) %= *(_DWORD *)(v1 + 4);
        return 1;
      case 17:
        if ( !*(_DWORD *)(v1 + 4) )
          sub_405A12(dword_423724, 0x437u);
        v4 = *(_DWORD *)(v3 + 4) / *(_DWORD *)(v1 + 4);
        goto LABEL_30;
      case 18:
        v4 = *(_DWORD *)(v1 + 4) * *(_DWORD *)(v3 + 4);
LABEL_30:
        *(_DWORD *)(v3 + 4) = v4;
        break;
      default:
        return 0;
    }
    return 1;
  }
  return 0;
}
// 423724: using guessed type int dword_423724;
// 434690: using guessed type int dword_434690;

//----- (0040DAB4) --------------------------------------------------------
char __stdcall sub_40DAB4(char a1)
{
  if ( *(_BYTE *)dword_434690 == 22 )
  {
    switch ( a1 )
    {
      case 19:
        *(_DWORD *)(dword_434690 + 4) = -*(_DWORD *)(dword_434690 + 4);
        return 1;
      case 20:
        *(_DWORD *)(dword_434690 + 4) = ~*(_DWORD *)(dword_434690 + 4);
        return 1;
      case 21:
        *(_DWORD *)(dword_434690 + 4) = *(_DWORD *)(dword_434690 + 4) == 0;
        return 1;
    }
  }
  return 0;
}
// 434690: using guessed type int dword_434690;

//----- (0040DAF2) --------------------------------------------------------
wchar_t *sub_40DAF2()
{
  wchar_t *v0; // esi
  wchar_t *v1; // ecx
  wchar_t v2; // bx
  wchar_t *v3; // edx
  wchar_t *v4; // edi
  wchar_t *result; // eax

  v0 = EndPtr + 1;
  v1 = EndPtr + 1;
  EndPtr = v1;
  if ( *v1 )
  {
    v2 = *v1;
    v3 = v0;
    v4 = v0;
    while ( 1 )
    {
      if ( v2 == 34 )
      {
        v3 = v4 + 1;
        if ( v4[1] != 34 )
          break;
      }
      v1 = v3 + 1;
      EndPtr = v1;
      ++v3;
      v4 = v1;
      v2 = *v1;
      if ( !*v1 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    sub_405A12(dword_423724, 0x3FEu, 34);
    v1 = EndPtr;
  }
  *v1 = 0;
  result = v0;
  ++EndPtr;
  return result;
}
// 423724: using guessed type int dword_423724;

//----- (0040DB6D) --------------------------------------------------------
wchar_t *sub_40DB6D()
{
  wchar_t *v0; // edi
  wchar_t *v1; // edx
  wchar_t v2; // ax
  wchar_t v3; // si
  wchar_t *v4; // ebx
  _WORD *v5; // ebx
  wchar_t *result; // eax
  wchar_t *v7; // [esp+10h] [ebp-8h]

  v0 = EndPtr + 1;
  v1 = EndPtr + 1;
  v7 = ++EndPtr;
  v2 = *EndPtr;
  if ( *EndPtr )
  {
    v3 = *EndPtr;
    v4 = v0;
    do
    {
      if ( v3 == 94 && (v5 = v4 + 1, *v5 == 93) )
      {
        memmove(v0, v5, 2 * wcslen(v5) + 2);
        v1 = EndPtr;
      }
      else
      {
        v2 = v3;
        if ( v3 == 93 )
          break;
      }
      EndPtr = ++v1;
      v0 = v1;
      v4 = v1;
      v2 = *v1;
      v3 = *v1;
    }
    while ( *v1 );
    v0 = v7;
  }
  if ( !v2 )
  {
    sub_405A12(dword_423724, 0x3FEu, 93);
    v1 = EndPtr;
  }
  *v1 = 0;
  result = v0;
  ++EndPtr;
  return result;
}
// 423724: using guessed type int dword_423724;

//----- (0040DC36) --------------------------------------------------------
int __fastcall sub_40DC36(char a1, int a2)
{
  unsigned __int8 v4; // bl
  int result; // eax

  if ( a1 == 25 )
  {
    v4 = 3;
  }
  else if ( a1 )
  {
    if ( (unsigned __int8)a1 <= 0x15u )
      v4 = ((unsigned __int8)a1 > 0x12u) + 1;
    else
      v4 = 0;
  }
  else
  {
    v4 = 4;
  }
  result = v4;
  if ( !byte_40159C[5 * (unsigned __int8)byte_43447E + v4] )
    result = sub_405A12(dword_423724, 0x3FFu);
  dword_434688 = a2;
  byte_43447E = v4;
  byte_434682 = a1;
  LOBYTE(dword_434684) = a1;
  return result;
}
// 423724: using guessed type int dword_423724;
// 43447E: using guessed type char byte_43447E;
// 434682: using guessed type char byte_434682;
// 434684: using guessed type int dword_434684;
// 434688: using guessed type int dword_434688;

//----- (0040DCA4) --------------------------------------------------------
wchar_t *sub_40DCA4()
{
  wchar_t *i; // eax
  wchar_t v1; // cx
  wchar_t *j; // eax
  wchar_t *v3; // esi
  wchar_t v4; // cx
  wchar_t *v5; // eax
  wchar_t *v6; // ecx
  wchar_t v7; // dx
  wchar_t *v8; // edx
  wchar_t v9; // cx

  for ( i = EndPtr; ; EndPtr = i )
  {
    v1 = *i;
    if ( *i != 32 && v1 != 9 )
      break;
    ++i;
  }
  if ( v1 != 40 )
  {
    sub_405A12(dword_423724, 0x3FFu);
    i = EndPtr;
  }
  for ( j = i + 1; ; ++j )
  {
    EndPtr = j;
    v3 = j;
    v4 = *j;
    if ( *j != 32 && v4 != 9 )
      break;
  }
  if ( v4 != 34 )
  {
    v8 = j;
    while ( 1 )
    {
      v9 = *j++;
      EndPtr = j;
      if ( !v9 )
        break;
      if ( v9 == 41 )
      {
        *v8 = 0;
        return v3;
      }
      if ( v9 != 32 && v9 != 9 )
LABEL_25:
        v8 = j;
    }
    sub_405A12(dword_423724, 0x3FFu);
    j = EndPtr;
    goto LABEL_25;
  }
  v5 = sub_40DAF2();
  v6 = EndPtr;
  v3 = v5;
  while ( 1 )
  {
    v7 = *v6;
    if ( *v6 != 32 && v7 != 9 )
      break;
    EndPtr = ++v6;
  }
  if ( v7 != 41 )
  {
    sub_405A12(dword_423724, 0x3FFu);
    v6 = EndPtr;
  }
  EndPtr = v6 + 1;
  return v3;
}
// 423724: using guessed type int dword_423724;

//----- (0040DDC5) --------------------------------------------------------
int sub_40DDC5()
{
  wchar_t *i; // ecx
  wint_t v1; // si
  wchar_t *v2; // edx
  wchar_t **v3; // edi
  wchar_t *v4; // ebx
  wchar_t v5; // cx
  char v6; // cl
  wchar_t *v7; // edx
  wchar_t *v8; // ebx
  int v9; // edi
  wchar_t *v10; // eax
  wchar_t *v11; // eax
  int v13; // [esp-Ch] [ebp-1Ch]

  for ( i = EndPtr; ; EndPtr = i )
  {
    v1 = *i;
    if ( *i != 32 && v1 != 9 )
      break;
    ++i;
  }
  if ( v1 < 0x80u && (byte_401090[v1] & 2) != 0 )
  {
    v2 = off_413070;
    v3 = &off_413070;
    if ( off_413070 )
    {
      while ( 1 )
      {
        v4 = i;
        i = EndPtr;
        if ( *v2 )
        {
          v5 = *v2;
          do
          {
            if ( *v4 != v5 )
              break;
            ++v2;
            ++v4;
            v5 = *v2;
          }
          while ( *v2 );
          i = EndPtr;
        }
        if ( !*v2 )
          break;
        v3 += 2;
        v2 = *v3;
        if ( !*v3 )
          goto LABEL_15;
      }
      i = v4;
      EndPtr = v4;
    }
  }
  else
  {
    v3 = (wchar_t **)&unk_413118;
  }
LABEL_15:
  if ( *v3 )
  {
    v6 = *((_BYTE *)v3 + 4);
    v7 = 0;
    return sub_40DC36(v6, (int)v7);
  }
  switch ( v1 )
  {
    case '-':
      EndPtr = i + 1;
      v6 = byte_434682 != 22 ? 19 : 14;
      v7 = 0;
      return sub_40DC36(v6, (int)v7);
    case '"':
      v7 = sub_40DAF2();
      v6 = 23;
      return sub_40DC36(v6, (int)v7);
    case '[':
      v7 = sub_40DB6D();
      v6 = 24;
      return sub_40DC36(v6, (int)v7);
  }
  if ( iswdigit(v1) )
  {
    v8 = EndPtr;
    *errno() = 0;
    v9 = wcstol(EndPtr, &EndPtr, 0);
    if ( *errno() == 34 )
    {
      v13 = dword_423724;
      *EndPtr = 0;
      sub_405A12(v13, 0x436u, v8);
    }
    if ( towupper(*EndPtr) == 76 )
      ++EndPtr;
    v7 = (wchar_t *)v9;
    goto LABEL_40;
  }
  if ( !v1 )
  {
    v7 = 0;
    byte_43447F = 1;
    v6 = 0;
    return sub_40DC36(v6, (int)v7);
  }
  if ( !wcsnicmp(EndPtr, L"DEFINED", 7u) )
  {
    EndPtr += 7;
    v10 = sub_40DCA4();
    v7 = (wchar_t *)sub_40E250(v10);
LABEL_40:
    v6 = 22;
    return sub_40DC36(v6, (int)v7);
  }
  if ( !wcsnicmp(EndPtr, L"EXISTS", 6u) )
  {
    EndPtr += 6;
LABEL_39:
    v11 = sub_40DCA4();
    v7 = (wchar_t *)(waccess(v11, 0) == 0);
    goto LABEL_40;
  }
  if ( !wcsnicmp(EndPtr, L"EXIST", 5u) )
  {
    EndPtr += 5;
    goto LABEL_39;
  }
  return sub_405A12(dword_423724, 0x3FFu);
}
// 413070: using guessed type wchar_t *off_413070;
// 423724: using guessed type int dword_423724;
// 43447F: using guessed type char byte_43447F;
// 434682: using guessed type char byte_434682;

//----- (0040E0B5) --------------------------------------------------------
int sub_40E0B5()
{
  int *v0; // edx
  int *v1; // esi
  int result; // eax
  int v3; // ecx

  v0 = (int *)dword_434690;
  if ( dword_434690 < (unsigned int)byte_4366A0 )
  {
    sub_405A12(dword_423724, 0x3FFu);
    v0 = (int *)dword_434690;
  }
  v1 = (int *)dword_43468C;
  if ( dword_43468C > (unsigned int)&unk_436698 )
  {
    sub_405A12(dword_423724, 0x412u);
    v0 = (int *)dword_434690;
    v1 = (int *)dword_43468C;
  }
  result = *v0;
  v3 = v0[1];
  *v1 = *v0;
  v1[1] = v3;
  dword_43468C = (int)(v1 + 2);
  dword_434690 = (int)(v0 - 2);
  return result;
}
// 423724: using guessed type int dword_423724;
// 43468C: using guessed type int dword_43468C;
// 434690: using guessed type int dword_434690;
// 4366A0: using guessed type unsigned __int8 byte_4366A0[4088];

//----- (0040E126) --------------------------------------------------------
bool sub_40E126()
{
  int v0; // edx
  char *v1; // esi
  char v2; // al
  wchar_t *v3; // ecx
  intptr_t v4; // eax
  char (__stdcall *v5)(char); // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // ecx
  unsigned __int8 *v10; // edx
  unsigned __int8 v11; // bh
  int v12; // eax

  dword_43468C = (int)&unk_4346A0;
  dword_434690 = (int)byte_4366A0;
  byte_43447F = 0;
  byte_43447E = 3;
  byte_434682 = 25;
  sub_40DC36(25, 0);
  v7 = dword_434690;
  v8 = dword_434688;
  *(_DWORD *)dword_434690 = dword_434684;
  *(_DWORD *)(v7 + 4) = v8;
  while ( !byte_43447F )
  {
    sub_40DDC5();
    v9 = dword_434684;
    v10 = (unsigned __int8 *)dword_434690;
    if ( (_BYTE)dword_434684 != 25 )
    {
      while ( 1 )
      {
        v11 = byte_4015C0[(unsigned __int8)v9];
        if ( v11 > (unsigned __int8)byte_4015C0[*v10] )
          break;
        if ( !v11 )
        {
          if ( *v10 != 25 )
          {
            do
            {
              sub_40E0B5();
              v10 = (unsigned __int8 *)dword_434690;
            }
            while ( *(_BYTE *)dword_434690 != 25 );
          }
          if ( v10 < byte_4366A0 )
          {
            sub_405A12(dword_423724, 0x3FFu);
            v10 = (unsigned __int8 *)dword_434690;
          }
          v7 = (int)(v10 - 8);
          goto LABEL_15;
        }
        sub_40E0B5();
        v10 = (unsigned __int8 *)dword_434690;
        v9 = dword_434684;
      }
    }
    if ( v10 == (unsigned __int8 *)&unk_437698 )
    {
      sub_405A12(dword_423724, 0x412u);
      v7 = dword_434690;
    }
    else
    {
      v12 = dword_434688;
      v7 = (int)(v10 + 8);
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 4) = v12;
LABEL_15:
      dword_434690 = v7;
    }
  }
  if ( (unsigned __int8 *)v7 != &byte_4366A0[-8] )
    sub_405A12(dword_423724, 0x3FFu);
  v0 = dword_434690;
  v1 = (char *)&unk_4346A0;
  if ( dword_43468C > (unsigned int)&unk_4346A0 )
  {
    do
    {
      v2 = *v1;
      if ( (unsigned __int8)*v1 <= 0x15u )
      {
        v5 = sub_40DAB4;
        if ( (unsigned __int8)v2 <= 0x12u )
          v5 = sub_40D86C;
        if ( !v5(v2) )
          sub_405A12(dword_423724, 0x438u);
        v0 = dword_434690;
      }
      else
      {
        v3 = (wchar_t *)*((_DWORD *)v1 + 1);
        v0 += 8;
        dword_434690 = v0;
        if ( v2 == 24 )
        {
          v4 = sub_4074DE(v3, 0, 1, 0, 0);
          v0 = dword_434690;
          *(_DWORD *)(dword_434690 + 4) = v4;
          *(_BYTE *)v0 = 22;
        }
        else
        {
          *(_DWORD *)v0 = *(_DWORD *)v1;
          *(_DWORD *)(v0 + 4) = v3;
        }
      }
      v1 += 8;
    }
    while ( (unsigned int)v1 < dword_43468C );
  }
  if ( (unsigned __int8 *)v0 == byte_4366A0 && *(_BYTE *)v0 == 22 )
    return *(_DWORD *)(v0 + 4) != 0;
  sub_405A12(dword_423724, 0x3FFu);
  return 0;
}
// 423724: using guessed type int dword_423724;
// 43447E: using guessed type char byte_43447E;
// 43447F: using guessed type char byte_43447F;
// 434682: using guessed type char byte_434682;
// 434684: using guessed type int dword_434684;
// 434688: using guessed type int dword_434688;
// 43468C: using guessed type int dword_43468C;
// 434690: using guessed type int dword_434690;
// 4366A0: using guessed type unsigned __int8 byte_4366A0[4088];

//----- (0040E250) --------------------------------------------------------
bool __thiscall sub_40E250(wchar_t *String)
{
  wchar_t *v1; // edi
  wchar_t *Context; // [esp+Ch] [ebp-4h] BYREF

  Context = 0;
  v1 = wcstok_s(String, L" \t", &Context);
  if ( wcstok_s(0, L" \t", &Context) )
    sub_405A12(dword_423724, 0x409u, v1);
  if ( !v1 )
    sub_405A12(dword_423724, 0x417u);
  return sub_40B444(v1) != 0;
}
// 423724: using guessed type int dword_423724;

//----- (0040E2BF) --------------------------------------------------------
bool __fastcall sub_40E2BF(wchar_t *String, char a2)
{
  if ( !*String )
    sub_405A12(dword_423724, 0x3FAu);
  if ( a2 != 4 )
  {
    if ( a2 == 5 )
      return !sub_40E250(String);
    if ( a2 != 6 )
    {
      if ( a2 != 7 )
      {
        EndPtr = String;
        return sub_40E126();
      }
      return !sub_40E250(String);
    }
  }
  return sub_40E250(String);
}
// 423724: using guessed type int dword_423724;

//----- (0040E31C) --------------------------------------------------------
void **__fastcall sub_40E31C(wchar_t *Destination, rsize_t a2, wchar_t *Str, int a4, LPWIN32_FIND_DATAW lpFindFileData)
{
  void *v5; // eax
  wchar_t *v6; // edi
  const wchar_t *v7; // ebx
  _WORD *v8; // esi
  wchar_t v9; // cx
  char *v10; // edx
  int v11; // ebx
  wchar_t *v12; // ecx
  int v13; // edx
  const wchar_t *v14; // edi
  int v15; // ecx
  __int16 v16; // ax
  const wchar_t *v17; // edi
  wchar_t *v18; // eax
  __int16 v19; // ax
  const wchar_t *v20; // esi
  wchar_t v21; // cx
  int v22; // esi
  wchar_t *v23; // edi
  wchar_t *v24; // eax
  int v25; // eax
  const wchar_t *v26; // edi
  int v27; // esi
  wchar_t *v28; // edi
  wchar_t v29; // cx
  wchar_t v30; // dx
  int v31; // eax
  int v32; // esi
  rsize_t v33; // ebx
  const wchar_t *v34; // eax
  int v35; // ebx
  wchar_t *v36; // eax
  int v37; // edi
  _DWORD *v38; // eax
  DWORD v40; // ecx
  DWORD v41; // edx
  wchar_t *v42; // [esp+14h] [ebp-28h]
  int v43; // [esp+14h] [ebp-28h]
  char *v44; // [esp+1Ch] [ebp-20h]
  void **v45; // [esp+28h] [ebp-14h]
  int v46; // [esp+2Ch] [ebp-10h]
  int v47; // [esp+2Ch] [ebp-10h]
  wchar_t *Source; // [esp+30h] [ebp-Ch]

  v5 = dword_423714;
  v45 = (void **)dword_423714;
  v6 = Destination;
  if ( !dword_423714 )
    return 0;
  while ( 1 )
  {
    Source = (wchar_t *)*((_DWORD *)v5 + 2);
    v42 = wcsrchr(Source, 0x2Eu);
    if ( sub_411259(v42, a4) )
      goto LABEL_88;
    v7 = Source + 1;
    *v6 = 0;
    v8 = Source + 1;
    if ( !Source[1] )
      break;
    v9 = *v7;
    while ( v9 != 123 )
    {
      if ( v9 == 94 )
      {
        ++v8;
      }
      else if ( v9 == 34 )
      {
        do
          ++v8;
        while ( *v8 != 34 );
      }
      v9 = *++v8;
      if ( !*v8 )
        goto LABEL_36;
    }
    v10 = (char *)v8;
    do
    {
      if ( v9 == 125 )
        break;
      if ( v9 == 94 )
        v10 += 2;
      v10 += 2;
      v9 = *(_WORD *)v10;
    }
    while ( *(_WORD *)v10 );
    v44 = v10;
    v11 = (v10 - (char *)v8 - 2) >> 1;
    v12 = Str;
    v13 = v11;
    v46 = v11;
    if ( *Str == 34 )
      v12 = Str + 1;
    v14 = v8 + 1;
    if ( v11 )
    {
      v15 = (char *)v12 - (char *)v14;
      v43 = v15;
      do
      {
        if ( *v14 == 92 || *v14 == 47 )
        {
          v16 = *(const wchar_t *)((char *)v14 + v15);
          if ( v16 != 92 && v16 != 47 )
            goto LABEL_87;
        }
        else
        {
          if ( wcsnicmp(v14, (const wchar_t *)((char *)v14 + v15), 1u) )
            goto LABEL_87;
          v15 = v43;
          v13 = v46;
        }
        --v13;
        ++v14;
        v46 = v13;
      }
      while ( v13 );
    }
    v42 = v8;
    v17 = &Str[v11 + 1];
    v18 = wcschr(v17, 0x5Cu);
    if ( !v18 )
    {
      v18 = wcschr(v17, 0x2Fu);
      if ( !v18 )
      {
        v6 = Destination;
LABEL_35:
        v7 = Source + 1;
        break;
      }
    }
    if ( v18 != v17 || (v19 = *((_WORD *)v44 - 1), v19 == 92) )
    {
LABEL_87:
      v6 = Destination;
      goto LABEL_88;
    }
    v6 = Destination;
    if ( v19 != 47 )
      goto LABEL_35;
LABEL_88:
    v5 = *v45;
    v45 = (void **)v5;
    if ( !v5 )
      return 0;
  }
LABEL_36:
  if ( *Source == 123 )
  {
    v20 = v7;
    if ( *v7 )
    {
      v21 = *v7;
      do
      {
        if ( v21 == 125 )
          break;
        if ( v21 == 94 )
          ++v20;
        v21 = *++v20;
      }
      while ( *v20 );
      v6 = Destination;
    }
    v22 = v20 - v7;
    if ( v22 )
    {
      wcsncpy_s(v6, a2, v7, v22);
      v7 += v22;
      if ( *(v7 - 1) != 92 )
        v6[v22++] = 92;
    }
    else if ( *Str == 34 )
    {
      v22 = 3;
      wcsncpy_s(v6, a2, L"\".\\", 3u);
    }
    else
    {
      v22 = 2;
      wcsncpy_s(v6, a2, L".\\", 2u);
    }
    Source = (wchar_t *)(v7 + 1);
    v23 = wcsrchr(Str, 0x5Cu);
    v24 = wcsrchr(Str, 0x2Fu);
    if ( v24 > v23 )
      v23 = v24;
    if ( v23 )
    {
      wcscpy_s(&Destination[v22], a2 - v22, v23 + 1);
      v25 = a4 - (_DWORD)v23 - 2;
    }
    else
    {
      v26 = Str + 1;
      if ( *Str != 34 )
        v26 = Str;
      wcscpy_s(&Destination[v22], a2 - v22, v26);
      v25 = a4 - (_DWORD)v26;
    }
    v27 = (v25 >> 1) + v22;
    goto LABEL_76;
  }
  if ( *v8 )
  {
    v28 = wcsrchr(Str, 0x2Eu);
    v29 = *v28;
    if ( *v28 == 58 )
    {
LABEL_65:
      if ( v29 == 58 )
      {
LABEL_68:
        ++v28;
        goto LABEL_70;
      }
    }
    else
    {
      v30 = *v28;
      while ( 1 )
      {
        v29 = v30;
        if ( v30 == 92 )
          break;
        v29 = v30;
        if ( v30 != 47 )
        {
          v29 = v30;
          if ( v28 > Str )
          {
            v30 = *--v28;
            v29 = *v28;
            if ( *v28 != 58 )
              continue;
          }
        }
        goto LABEL_65;
      }
    }
    if ( v29 != 92 && v29 != 47 )
      goto LABEL_70;
    goto LABEL_68;
  }
  v28 = Str;
LABEL_70:
  v31 = 0;
  v47 = 0;
  v32 = (a4 - (int)v28) >> 1;
  if ( v28 != Str && *Str == 34 )
  {
    *Destination = 34;
    v31 = 1;
    v47 = 1;
  }
  v33 = a2 - v31;
  if ( v32 >= (int)(a2 - v31) )
  {
    sub_405A12(0, 0x434u);
    v31 = v47;
  }
  wcsncpy_s(&Destination[v31], v33, v28, v32);
  v27 = v47 + v32;
LABEL_76:
  v34 = Source;
  v35 = v42 - Source;
  if ( v35 >= (int)(a2 - v27) )
  {
    sub_405A12(0, 0x434u);
    v34 = Source;
  }
  v6 = Destination;
  wcsncpy_s(&Destination[v27], a2 - v27, v34, v35);
  if ( *Destination == 34 )
  {
    v36 = Destination;
    v37 = v35 + v27;
    if ( Destination[v35 - 1 + v27] != 34 )
    {
      if ( (int)(a2 - v35 - v27) <= 1 )
        sub_405A12(0, 0x434u);
      v36 = Destination;
      ++v35;
      Destination[v37] = 34;
    }
    v6 = v36;
  }
  v6[v35 + v27] = 0;
  v38 = sub_40ECF3(v6, 0, 0);
  if ( !v38 )
  {
    if ( sub_40847B(v6, lpFindFileData) )
      return v45;
    goto LABEL_88;
  }
  v40 = v38[4];
  v41 = v38[5];
  lpFindFileData->ftCreationTime.dwLowDateTime = v40;
  lpFindFileData->ftCreationTime.dwHighDateTime = v41;
  lpFindFileData->ftLastWriteTime.dwLowDateTime = v40;
  lpFindFileData->ftLastWriteTime.dwHighDateTime = v41;
  return v45;
}
// 4025F4: using guessed type wchar_t asc_4025F4[4];

//----- (0040E783) --------------------------------------------------------
void sub_40E783()
{
  int v0; // eax
  char *v1; // esi
  wchar_t *v2; // edx
  _WORD *v3; // ecx
  char *v5; // ebx
  int v6; // edx
  const wchar_t *v7; // edi
  int v8; // ecx
  int v9; // eax
  void **v10; // ecx
  _DWORD *v11; // ebx
  _DWORD *v12; // edx
  const wchar_t *v13; // edi
  _DWORD *v14; // edi
  int *v15; // esi
  void **v16; // edx
  void **v17; // ecx
  int v18; // edi
  char *v19; // ebx
  wchar_t *String1; // [esp+Ch] [ebp-1Ch]
  int *v21; // [esp+10h] [ebp-18h]
  int v22; // [esp+14h] [ebp-14h]
  char *v23; // [esp+18h] [ebp-10h]
  int *v24; // [esp+1Ch] [ebp-Ch] BYREF
  const wchar_t **v25; // [esp+20h] [ebp-8h] BYREF
  void *Block; // [esp+24h] [ebp-4h]

  v0 = dword_423720;
  v24 = 0;
  v21 = (int *)dword_423720;
  v1 = (char *)dword_423714;
  v23 = (char *)dword_423714;
  for ( dword_423714 = 0; v0; v21 = (int *)v0 )
  {
    v2 = *(wchar_t **)(v0 + 4);
    String1 = v2;
    v3 = v2 + 1;
    while ( *v2++ )
      ;
    v5 = v1;
    v6 = v2 - v3;
    v22 = v6;
    for ( Block = v1; v5; v6 = v22 )
    {
      v7 = (const wchar_t *)*((_DWORD *)v5 + 2);
      v25 = (const wchar_t **)(v5 + 8);
      if ( *v7 == 123 )
      {
        LOWORD(v8) = 123;
        do
        {
          if ( (_WORD)v8 == 94 )
            ++v7;
          v8 = *++v7;
        }
        while ( v8 != 125 );
        ++v7;
      }
      if ( !wcsnicmp(String1, v7, v6) && ((v9 = v7[v22], v9 == 46) || (_WORD)v9 == 123) )
      {
        v10 = (void **)Block;
        v11 = Block;
        v12 = (_DWORD *)*((_DWORD *)Block + 1);
        if ( v12 )
        {
          *v12 = *(_DWORD *)Block;
        }
        else
        {
          v1 = *(char **)Block;
          v23 = *(char **)Block;
        }
        if ( *v10 )
          *((_DWORD *)*v10 + 1) = v10[1];
        Block = *v10;
        *v11 = 0;
        v13 = (const wchar_t *)dword_423714;
        if ( dword_423714 )
        {
          while ( wcsicmp(*((const wchar_t **)v13 + 2), *v25) )
          {
            v13 = *(const wchar_t **)v13;
            if ( !v13 )
              goto LABEL_22;
          }
          free((void *)*v25);
          while ( 1 )
          {
            v18 = v11[3];
            if ( !v18 )
              break;
            v11[3] = *(_DWORD *)v18;
            free(*(void **)(v18 + 4));
            *(_DWORD *)v18 = dword_434698;
            dword_434698 = v18;
          }
          free(v11);
        }
        else
        {
LABEL_22:
          v14 = (_DWORD *)v11[3];
          if ( v14 )
          {
            v15 = (int *)v25;
            do
            {
              v25 = (const wchar_t **)v14[1];
              byte_4376AC = *((_BYTE *)v11 + 20);
              if ( byte_4376AC )
                dword_4376B0 = *v15;
              sub_40EED8((wint_t **)&v25, &v24, 0, 0, 0, 0, 0, 0);
              v14 = (_DWORD *)*v14;
              byte_4376AC = 0;
            }
            while ( v14 );
            v1 = v23;
          }
          v16 = &dword_423714;
          v11[4] = v24;
          v24 = 0;
          v17 = (void **)dword_423714;
          if ( dword_423714 )
          {
            do
            {
              v16 = v17;
              v17 = (void **)*v17;
            }
            while ( v17 );
          }
          *v16 = v11;
        }
        v5 = (char *)Block;
      }
      else
      {
        v5 = *(char **)v5;
        Block = v5;
      }
    }
    v0 = *v21;
  }
  if ( v1 )
  {
    v19 = v1;
    do
    {
      if ( (byte_41350C & 1) != 0 )
        sub_405A12(0, 0xFA5u, *((_DWORD *)v1 + 2));
      free(*((void **)v1 + 2));
      sub_405208(*((_DWORD **)v1 + 3));
      sub_405208(*((_DWORD **)v1 + 4));
      v1 = *(char **)v1;
      free(v19);
      v19 = v1;
    }
    while ( v1 );
  }
}
// 41350C: using guessed type char byte_41350C;
// 423720: using guessed type int dword_423720;
// 434698: using guessed type int dword_434698;
// 4376AC: using guessed type char byte_4376AC;
// 4376B0: using guessed type int dword_4376B0;

//----- (0040E9A3) --------------------------------------------------------
void **__fastcall sub_40E9A3(
        int a1,
        wchar_t *a2,
        int a3,
        unsigned __int64 a4,
        _DWORD **a5,
        _DWORD *a6,
        _DWORD *a7,
        _DWORD *a8,
        wchar_t **a9)
{
  wchar_t *v11; // eax
  __int64 v12; // rax
  _DWORD *v13; // esi
  char v14; // dl
  int v15; // eax
  int v16; // eax
  unsigned int v17; // edx
  unsigned int v18; // ecx
  _DWORD *v19; // esi
  _DWORD *v20; // edx
  _DWORD *v21; // esi
  _DWORD *v22; // ebx
  unsigned int v23; // esi
  int v24; // eax
  void **result; // eax
  const wchar_t *v26; // [esp-8h] [ebp-298h]
  __int64 v27; // [esp+10h] [ebp-280h] BYREF
  _DWORD *v28; // [esp+1Ch] [ebp-274h] BYREF
  int v29; // [esp+20h] [ebp-270h]
  _DWORD *v30; // [esp+24h] [ebp-26Ch]
  _DWORD *v31; // [esp+28h] [ebp-268h]
  _DWORD **v32; // [esp+2Ch] [ebp-264h]
  _DWORD *v33; // [esp+30h] [ebp-260h]
  void **v34; // [esp+34h] [ebp-25Ch]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+38h] [ebp-258h] BYREF

  v32 = a5;
  v30 = a6;
  v26 = *(const wchar_t **)(a1 + 4);
  v31 = a7;
  v33 = a8;
  v11 = wcsrchr(v26, 0x2Eu);
  if ( !v11 )
    return 0;
  v34 = sub_40E31C(a2, 0x101u, *(wchar_t **)(a1 + 4), (int)v11, &FindFileData);
  if ( !v34 )
    return 0;
  v12 = sub_4081C4((char *)&FindFileData);
  *a9 = a2;
  v13 = v30;
  v27 = v12;
  while ( 1 )
  {
    v13 = (_DWORD *)*v13;
    if ( !v13 )
      break;
    if ( !wcsicmp((const wchar_t *)v13[1], a2) )
    {
      *(_BYTE *)(a1 + 8) &= ~1u;
      break;
    }
  }
  v14 = *(_BYTE *)(a1 + 8);
  v28 = 0;
  v15 = sub_403EBD(a2, v14, (unsigned int *)&v27, 0, &v28);
  v29 = v15;
  if ( v28 )
  {
    v16 = sub_40547A(v28);
    v29 += v16;
    sub_405498(&v28);
    v15 = v29;
  }
  v17 = v27;
  *v31 += v15;
  v18 = HIDWORD(v27);
  if ( (*(_BYTE *)(a1 + 8) & 0x10) != 0
    || a4 < __PAIR64__(HIDWORD(v27), v17)
    || byte_423736 && a4 == __PAIR64__(HIDWORD(v27), v17) )
  {
    if ( !v13 )
    {
      v19 = sub_40EB4F();
      v19[1] = sub_40EBA1((char *)a2);
      v20 = v19;
      v21 = v32;
      sub_40ECA6(v32, v20);
      v17 = v27;
      if ( !*v30 )
        *v30 = *v21;
      v18 = HIDWORD(v27);
    }
    if ( (*(_BYTE *)(a1 + 8) & 0x11) == 1 )
    {
      sub_405AEC(3u, a2, *(_DWORD *)(a1 + 4));
      v18 = HIDWORD(v27);
      v17 = v27;
    }
  }
  v22 = v33;
  v23 = v33[1];
  v24 = *v33;
  if ( *(_QWORD *)v33 <= __PAIR64__(v18, v17) )
  {
    v24 = v17;
    v23 = v18;
  }
  *v33 = v24;
  result = v34;
  v22[1] = v23;
  return result;
}
// 423736: using guessed type char byte_423736;

//----- (0040EB4F) --------------------------------------------------------
_DWORD *sub_40EB4F()
{
  _DWORD *v0; // edx
  int v1; // esi
  _DWORD *result; // eax

  v0 = (_DWORD *)dword_434698;
  if ( dword_434698 )
  {
    dword_434698 = *(_DWORD *)dword_434698;
  }
  else
  {
    v1 = dword_4376A4;
    if ( (unsigned int)dword_4376A4 >= 8 )
    {
      v0 = (_DWORD *)dword_4376A0;
    }
    else
    {
      v1 = 0x8000;
      v0 = sub_40B4E9(0x8000u);
    }
    dword_4376A0 = (int)(v0 + 2);
    dword_4376A4 = v1 - 8;
  }
  *v0 = 0;
  result = v0;
  v0[1] = 0;
  return result;
}
// 434698: using guessed type int dword_434698;
// 4376A0: using guessed type int dword_4376A0;
// 4376A4: using guessed type int dword_4376A4;

//----- (0040EBA1) --------------------------------------------------------
void *__thiscall sub_40EBA1(char *Src)
{
  char *v2; // edi
  char *v3; // ecx
  __int16 v4; // ax
  int v5; // edi
  void *v6; // esi

  v2 = Src;
  v3 = Src + 2;
  do
  {
    v4 = *(_WORD *)v2;
    v2 += 2;
  }
  while ( v4 );
  v5 = ((v2 - v3) >> 1) + 1;
  v6 = sub_40B4E9((unsigned __int64)(unsigned int)v5 >> 31 != 0 ? -1 : 2 * v5);
  memcpy(v6, Src, 2 * v5);
  return v6;
}

//----- (0040EBE5) --------------------------------------------------------
_WORD *__thiscall sub_40EBE5(char *this)
{
  char *v1; // ebx
  char *v2; // ecx
  __int16 v3; // ax
  int v4; // ebx
  _WORD *v5; // edi

  v1 = this;
  v2 = this + 2;
  do
  {
    v3 = *(_WORD *)v1;
    v1 += 2;
  }
  while ( v3 );
  v4 = (v1 - v2) >> 1;
  v5 = sub_40B4E9((unsigned __int64)(unsigned int)(v4 + 3) >> 31 != 0 ? -1 : 2 * (v4 + 3));
  *v5 = 34;
  memcpy(v5 + 1, this, 2 * v4);
  v5[v4 + 1] = 34;
  v5[v4 + 2] = 0;
  return v5;
}

//----- (0040EC4B) --------------------------------------------------------
wchar_t *__fastcall sub_40EC4B(char *Block, const wchar_t *a2)
{
  char *v3; // esi
  char *v4; // ecx
  __int16 v5; // ax
  int v6; // esi
  const wchar_t *v7; // ecx
  int v8; // esi
  const wchar_t *v9; // edx
  unsigned int v11; // edi
  wchar_t *v12; // esi

  v3 = Block;
  v4 = Block + 2;
  do
  {
    v5 = *(_WORD *)v3;
    v3 += 2;
  }
  while ( v5 );
  v6 = v3 - v4;
  v7 = a2;
  v8 = v6 >> 1;
  v9 = a2 + 1;
  while ( *v7++ )
    ;
  v11 = v7 - v9 + v8 + 1;
  v12 = (wchar_t *)sub_403CB3(Block, v11);
  wcscat_s(v12, v11, a2);
  return v12;
}

//----- (0040ECA6) --------------------------------------------------------
_DWORD *__fastcall sub_40ECA6(_DWORD **a1, _DWORD *a2)
{
  _DWORD *v2; // esi
  _DWORD *result; // eax

  v2 = *a1;
  if ( *a1 )
  {
    do
    {
      result = (_DWORD *)*v2;
      a1 = (_DWORD **)v2;
      v2 = result;
    }
    while ( result );
  }
  *a1 = a2;
  return result;
}

//----- (0040ECBB) --------------------------------------------------------
int __thiscall sub_40ECBB(wint_t *this, int a2)
{
  char v3; // si
  char v4; // al

  v3 = 0;
  while ( *this )
  {
    if ( *this == 47 )
      v4 = 92;
    else
      v4 = towupper(*this);
    v3 += v4;
    ++this;
  }
  return v3 & 0x7F;
}

//----- (0040ECF3) --------------------------------------------------------
_DWORD *__thiscall sub_40ECF3(wchar_t *Source, int a2, int a3)
{
  int v4; // eax
  _DWORD *result; // eax
  int v6; // ecx
  wchar_t *v7; // esi
  rsize_t v9; // esi
  wchar_t *v10; // ebx
  wchar_t *v11; // esi
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  _DWORD *v15; // esi
  int v16; // ecx
  wchar_t *v17; // ebx
  wchar_t *v18; // esi
  rsize_t v20; // esi
  int v21; // eax
  _DWORD *v22; // [esp+10h] [ebp-8h]
  char v23; // [esp+17h] [ebp-1h]

  v23 = 0;
  if ( !*Source )
    return 0;
  v4 = sub_40ECBB(Source, (int)Source);
  result = sub_4111A1(Source, v4);
  if ( !result )
  {
    if ( !wcsncmp(Source, L".\\", 2u) || !wcsncmp(Source, L"./", 2u) )
    {
      v11 = Source + 2;
      v10 = Source + 2;
    }
    else
    {
      v7 = Source;
      while ( *v7++ )
        ;
      v9 = v7 - (Source + 1) + 3;
      v10 = (wchar_t *)sub_40B4E9((unsigned __int64)v9 >> 31 != 0 ? -1 : 2 * v9);
      wcscpy_s(v10, v9, L".\\");
      wcscat_s(v10, v9, Source);
      v23 = 1;
      v11 = Source + 2;
    }
    v12 = sub_40ECBB(v10, v6);
    result = sub_4111A1(v10, v12);
    v22 = result;
    if ( result )
    {
      if ( v23 )
      {
        free(v10);
        return v22;
      }
    }
    else
    {
      if ( v10 != v11 )
        v10[1] = 47;
      v14 = sub_40ECBB(v10, v13);
      v15 = sub_4111A1(v10, v14);
      if ( v23 )
        free(v10);
      if ( !v15 )
      {
        if ( *Source == 34 )
        {
          v17 = sub_411373(Source);
        }
        else
        {
          v18 = Source;
          while ( *v18++ )
            ;
          v20 = v18 - (Source + 1) + 3;
          v17 = (wchar_t *)sub_40B4E9((unsigned __int64)v20 >> 31 != 0 ? -1 : 2 * v20);
          wcscpy_s(v17, v20, ::Source);
          wcscat_s(v17, v20, Source);
          wcscat_s(v17, v20, ::Source);
        }
        v21 = sub_40ECBB(v17, v16);
        v15 = sub_4111A1(v17, v21);
        free(v17);
      }
      return v15;
    }
  }
  return result;
}
// 40EDA4: variable 'v6' is possibly undefined
// 40EDE0: variable 'v13' is possibly undefined
// 40EE75: variable 'v16' is possibly undefined

//----- (0040EE9A) --------------------------------------------------------
bool __fastcall sub_40EE9A(__int16 a1)
{
  int v1; // esi
  const wchar_t *v2; // eax
  const wchar_t *v3; // edx
  int v4; // eax

  v1 = 3;
  v2 = 0;
  v3 = L" \t\n";
  if ( a1 == 32 )
  {
LABEL_4:
    v2 = v3;
  }
  else
  {
    while ( v1 != 1 )
    {
      ++v3;
      --v1;
      if ( *v3 == a1 )
        goto LABEL_4;
    }
  }
  if ( v2 )
    v4 = v2 - L" \t\n";
  else
    v4 = -1;
  return v4 != -1;
}

//----- (0040EED8) --------------------------------------------------------
char __fastcall sub_40EED8(
        wint_t **a1,
        int **a2,
        void **a3,
        const unsigned __int16 *a4,
        int a5,
        int a6,
        int a7,
        char a8)
{
  wint_t **v8; // edi
  int *v9; // ecx
  _DWORD *i; // ecx
  wint_t *v11; // ecx
  wint_t v12; // si
  wint_t *v13; // edx
  char v14; // dl
  wint_t *v15; // eax
  bool v16; // zf
  wint_t *v17; // eax
  wint_t *v18; // ecx
  int v19; // eax
  wint_t *v20; // eax
  void *v21; // esp
  wchar_t *v22; // edi
  wchar_t **v23; // esi
  unsigned int v24; // ecx
  unsigned int v25; // edi
  int *v26; // edi
  int v27; // esi
  int v28; // eax
  int v29; // ecx
  _DWORD *v30; // eax
  void *v31; // eax
  void **v32; // esi
  char v33; // al
  _BYTE *v34; // edi
  int v35; // eax
  int v36; // eax
  wchar_t v38[6]; // [esp+0h] [ebp-240h] BYREF
  int v39[2]; // [esp+Ch] [ebp-234h] BYREF
  const unsigned __int16 *v40; // [esp+14h] [ebp-22Ch]
  int **v41; // [esp+18h] [ebp-228h]
  wint_t **v42; // [esp+1Ch] [ebp-224h]
  void *v43; // [esp+20h] [ebp-220h] BYREF
  bool v44; // [esp+27h] [ebp-219h] BYREF
  void *v45; // [esp+28h] [ebp-218h] BYREF
  char v46; // [esp+2Eh] [ebp-212h]
  bool v47; // [esp+2Fh] [ebp-211h]
  wchar_t v48[2]; // [esp+30h] [ebp-210h] BYREF
  __int16 v49[4]; // [esp+234h] [ebp-Ch] BYREF

  v8 = a1;
  v41 = a2;
  v40 = a4;
  v42 = a1;
  v47 = 0;
  if ( a2 )
  {
    if ( a3 )
    {
      v45 = *a3;
    }
    else
    {
      v9 = *a2;
      v45 = v9;
      if ( v9 )
      {
        for ( i = (_DWORD *)*v9; i; i = (_DWORD *)*i )
          v45 = i;
      }
    }
  }
  else
  {
    v45 = 0;
  }
  v11 = *v8;
  if ( !**v8 )
    return 1;
  v12 = **v8;
  v13 = *v8;
  while ( 1 )
  {
    if ( v12 == 36 )
      goto LABEL_23;
    if ( v12 == 34 )
    {
      v14 = !v47;
      v47 = !v47;
    }
    else
    {
      v14 = v47;
    }
    if ( a8 && (v12 == 44 || v12 == 41) )
      break;
    if ( !v14 && v12 == 94 )
    {
      *v8 = v11 + 1;
      if ( v11[1] == 34 )
        v47 = 1;
    }
    v11 = *v8 + 1;
    *v8 = v11;
    v13 = v11;
    v12 = *v11;
    if ( !*v11 )
    {
LABEL_23:
      if ( !*v13 )
        return 1;
      v46 = a7 & 4;
      if ( !v13[1] )
      {
        if ( (a7 & 4) != 0 )
          goto LABEL_106;
        sub_405A12(dword_423730, 0x3EAu);
        v46 = 0;
      }
      v15 = *v8 + 1;
      v16 = !v47;
      *v8 = v15;
      if ( v16 && *v15 == 94 )
      {
        v17 = v15 + 1;
        *v8 = v17;
        if ( !sub_403A97(*v17) && v46 )
          goto LABEL_106;
        sub_405A12(dword_423730, 0x3E9u, **v8);
      }
      v18 = *v8;
      v19 = **v8;
      if ( (_WORD)v19 == 36 )
      {
        *v8 = sub_40F785(v18);
      }
      else
      {
        v43 = 0;
        v44 = 0;
        if ( v19 == 40 )
        {
          v20 = sub_40F637((__int16 *)v18 + 1, v48, &v44, (int *)&v43);
          v16 = !v44;
          *v8 = v20;
          if ( !v16 )
          {
            v22 = (wchar_t *)v43;
            v23 = &off_4015E0;
            while ( v23[1] != v22 || sub_4116DD((char *)*v23, (char *)v48, (int)v23[1]) )
            {
              v23 += 4;
              if ( v23 == (wchar_t **)L"DFBR" )
              {
                if ( v46 )
                  goto LABEL_106;
                sub_405A12(dword_423730, 0x3E8u);
                goto LABEL_46;
              }
            }
            v24 = (unsigned int)v23[2];
            if ( !v24 )
            {
LABEL_46:
              v8 = v42;
              --*v42;
              goto LABEL_100;
            }
            v25 = 1;
            while ( 1 )
            {
              v43 = (void *)v25;
              if ( !sub_40F4C4(v42, v41, &v45, v40, a5, a6, a7, (int)*v23, *((_BYTE *)v23 + v25 + 11), v25, v24) )
                break;
              v24 = (unsigned int)v23[2];
              ++v25;
              if ( (unsigned int)v43 >= v24 )
                goto LABEL_46;
            }
LABEL_106:
            if ( a3 )
              *a3 = v45;
            return 0;
          }
          if ( !wcschr(L"*@<?", v48[0]) )
            goto LABEL_61;
          if ( byte_4376AC && (byte_41350C & 0x40) == 0 )
          {
            v21 = alloca(2 * ((_DWORD)v43 + 4));
            sub_411912(v38, (size_t)v43 + 4, (wchar_t *)L"$(%s)", v48);
            sub_405A12(0, 0x44Cu, v38, dword_4376B0);
            goto LABEL_61;
          }
        }
        else
        {
          if ( !wcschr(L"*@<?", v19) )
            goto LABEL_57;
          if ( byte_4376AC && (byte_41350C & 0x40) == 0 && **v8 != 60 )
          {
            v49[1] = **v8;
            v49[2] = 0;
            v49[0] = 36;
            sub_405A12(0, 0x44Cu, v49, dword_4376B0);
LABEL_57:
            if ( !sub_403A97(**v8) )
            {
              if ( v46 )
                goto LABEL_106;
              sub_405A12(dword_423730, 0x3EAu);
            }
            v48[0] = **v8;
            v48[1] = 0;
LABEL_61:
            v39[0] = 0;
            v39[1] = 0;
            if ( v41 )
              v26 = sub_40EB4F();
            else
              v26 = v39;
            v27 = sub_40B444(v48);
            v43 = (void *)v27;
            if ( v27 )
            {
              if ( v40 )
              {
                v28 = wcscmp(v40, v48);
                if ( v28 )
                  v28 = v28 < 0 ? -1 : 1;
                if ( !v28 )
                {
                  v29 = a5;
                  v30 = *(_DWORD **)(v27 + 8);
                  if ( a5 == a6 )
                  {
LABEL_72:
                    if ( !v30 )
                      goto LABEL_74;
                    v31 = (void *)v30[1];
                  }
                  else
                  {
                    while ( v30 )
                    {
                      v30 = (_DWORD *)*v30;
                      if ( --v29 == a6 )
                        goto LABEL_72;
                    }
LABEL_74:
                    v31 = sub_40EBA1((char *)&dword_40177C);
                  }
                  v32 = (void **)(v26 + 1);
LABEL_83:
                  *v32 = v31;
LABEL_84:
                  if ( !*v32 )
                    sub_405A12(dword_423730, 0x410u);
                  if ( v41 )
                  {
                    if ( v45 )
                      *(_DWORD *)v45 = v26;
                    else
                      *v41 = v26;
                    v45 = v26;
                  }
                  v34 = v43;
                  if ( v43 && wcschr((const wchar_t *)*v32, 0x24u) )
                  {
                    v34[12] |= 1u;
                    v43 = *v32;
                    if ( !v40 )
                      goto LABEL_97;
                    v35 = wcscmp(v40, v48);
                    if ( v35 )
                      v35 = v35 < 0 ? -1 : 1;
                    v16 = v35 == 0;
                    v36 = a5;
                    if ( v16 )
LABEL_97:
                      v36 = a6;
                    sub_40EED8((wint_t **)&v43, v41, &v45, v48, a5 + 1, v36, a7, 0);
                    v34[12] &= ~1u;
                  }
                  v8 = v42;
LABEL_100:
                  if ( a3 )
                    *a3 = v45;
                  goto LABEL_102;
                }
              }
              v33 = *(_BYTE *)(v27 + 12);
              if ( (v33 & 1) != 0 )
              {
                if ( v46 )
                  goto LABEL_106;
                sub_405A12(dword_423730, 0x42Eu, v48);
                v32 = (void **)(v26 + 1);
                goto LABEL_84;
              }
              v32 = (void **)(v26 + 1);
              if ( (v33 & 0x10) == 0 )
              {
                v31 = *(void **)(*((_DWORD *)v43 + 2) + 4);
                goto LABEL_83;
              }
            }
            else
            {
              v32 = (void **)(v26 + 1);
            }
            v31 = sub_40EBA1((char *)&dword_40177C);
            goto LABEL_83;
          }
        }
      }
LABEL_102:
      v11 = *v8 + 1;
      *v8 = v11;
      v13 = v11;
      v12 = *v11;
      if ( !*v11 )
        return 1;
    }
  }
  if ( a3 )
    *a3 = v45;
  return 1;
}
// 4015E0: using guessed type wchar_t *off_4015E0;
// 40177C: using guessed type int dword_40177C;
// 41350C: using guessed type char byte_41350C;
// 423730: using guessed type int dword_423730;
// 4376AC: using guessed type char byte_4376AC;
// 4376B0: using guessed type int dword_4376B0;
// 40EED8: using guessed type int *var_218;
// 40EED8: using guessed type wint_t *var_220;

//----- (0040F4C4) --------------------------------------------------------
char __fastcall sub_40F4C4(
        wint_t **this,
        int **edx0,
        void **a2,
        const unsigned __int16 *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        char a8,
        unsigned int a9,
        unsigned int a10)
{
  wint_t *v12; // esi
  char v13; // bl
  __int16 v14; // cx
  int v15; // ebx
  __int16 v16; // cx
  __int16 v18; // [esp+10h] [ebp-8h]

  v12 = *this;
  if ( !sub_40EED8(this, edx0, a2, a3, a4, a5, a6, 1) )
    return 0;
  if ( !a8 && *this == v12 )
  {
    if ( (a6 & 4) != 0 )
      return 0;
    sub_405A12(dword_423730, 0x44Eu, a9, a7);
  }
  v13 = a6 & 4;
  if ( !**this )
  {
    if ( v13 )
      return 0;
    sub_405A12(dword_423730, 0x3E8u);
    v13 = 0;
  }
  v14 = *(*this)++;
  v18 = v14;
  if ( v14 != 44 && v14 != 41 )
  {
    if ( v13 )
      return 0;
    sub_405A12(dword_423730, 0x3E8u);
    v14 = v18;
  }
  if ( a9 >= a10 )
  {
    if ( a9 != a10 || v14 == 41 )
      return 1;
    if ( !v13 )
    {
      v15 = 0;
      do
      {
        ++v15;
        sub_40EED8(this, edx0, a2, a3, a4, a5, a6, 1);
        if ( !**this )
          sub_405A12(dword_423730, 0x3E8u);
        v16 = *(*this)++;
      }
      while ( v16 == 44 );
      sub_405A12(dword_423730, 0x44Fu, a7, a10, v15 + a10);
      return 1;
    }
  }
  else
  {
    if ( v14 == 44 )
      return 1;
    if ( !v13 )
    {
      sub_405A12(dword_423730, 0x44Fu, a7, a10, a9);
      return 1;
    }
  }
  return 0;
}
// 423730: using guessed type int dword_423730;

//----- (0040F637) --------------------------------------------------------
wint_t *__fastcall sub_40F637(__int16 *a1, wint_t *a2, bool *a3, int *a4)
{
  wint_t *v4; // esi
  wint_t *v5; // ebx
  __int16 v6; // di
  __int16 v7; // cx
  __int16 v8; // cx
  wint_t v9; // ax
  bool v10; // al
  wint_t v11; // cx
  wint_t v12; // dx
  wint_t v13; // ax
  wint_t *v15; // [esp+Ch] [ebp-8h]
  wint_t *v16; // [esp+10h] [ebp-4h]

  v4 = (wint_t *)a1;
  v15 = a2;
  v5 = a2;
  v16 = a2;
  v6 = *a1;
  if ( *a1 )
  {
    v7 = *a1;
    do
    {
      v6 = v7;
      if ( v7 == 41 )
        break;
      v6 = v7;
      if ( v7 == 58 )
        break;
      v6 = v7;
      if ( sub_40EE9A(v7) )
        break;
      if ( v8 == 94 && !sub_403A97(*++v4) )
        sub_405A12(dword_423730, 0x3E9u, *v4);
      v9 = *v4++;
      *v5++ = v9;
      v7 = *v4;
      v6 = *v4;
    }
    while ( *v4 );
    a2 = v15;
    v16 = v5;
  }
  *a4 = v5 - a2;
  v10 = sub_40EE9A(v6);
  *a3 = v10;
  if ( v10 )
  {
    do
    {
      if ( !*++v4 )
        sub_405A12(dword_423730, 0x410u);
    }
    while ( sub_40EE9A(*v4) );
  }
  else
  {
    v11 = v6;
    if ( v6 != 41 )
    {
      v12 = v6;
      do
      {
        v13 = v12;
        if ( v12 == 94 )
          v13 = *++v4;
        v11 = v13;
        if ( !v13 )
          break;
        v12 = *++v4;
        v11 = *v4;
      }
      while ( *v4 != 41 );
      v5 = v16;
    }
    if ( v11 != 41 )
      sub_405A12(dword_423730, 0x3E8u);
    *v5 = 0;
    if ( (unsigned int)*a4 > 0x101 )
      sub_405A12(dword_423730, 0x434u);
  }
  return v4;
}
// 40F67B: variable 'v8' is possibly undefined
// 423730: using guessed type int dword_423730;

//----- (0040F785) --------------------------------------------------------
_WORD *__thiscall sub_40F785(_WORD *this)
{
  int v2; // eax
  _WORD *result; // eax
  int v4; // eax
  __int16 v5; // ax
  int v6; // eax
  __int16 v7; // ax
  bool v8; // zf

  if ( *this )
  {
    v2 = (unsigned __int16)this[1];
    if ( (_WORD)v2 == 94 )
      return this + 1;
    if ( v2 == 40 )
    {
      v4 = (unsigned __int16)this[2];
      if ( (_WORD)v4 == 94 || v4 != 64 )
        return this + 2;
      v5 = this[3];
      if ( v5 == 94 )
      {
        v6 = (unsigned __int16)this[4];
      }
      else
      {
        if ( v5 == 41 )
          return this + 3;
        if ( !wcschr(L"DFBR", this[3]) )
          return this;
        v7 = this[4];
        if ( v7 != 94 )
        {
          v8 = v7 == 41;
          result = this + 4;
          if ( v8 )
            return result;
          return this;
        }
        v6 = (unsigned __int16)this[5];
      }
      sub_405A12(dword_423730, 0x3E9u, v6);
    }
  }
  return this;
}
// 423730: using guessed type int dword_423730;

//----- (0040F81F) --------------------------------------------------------
wint_t *__thiscall sub_40F81F(wchar_t *Str)
{
  wint_t *v1; // edi
  int *v2; // esi
  int v3; // eax
  int v4; // ecx
  int *v5; // eax
  wint_t *v7; // [esp+8h] [ebp-8h] BYREF
  int *v8; // [esp+Ch] [ebp-4h] BYREF

  v1 = Str;
  if ( wcschr(Str, 0x24u) )
  {
    v7 = v1;
    v8 = 0;
    sub_40EED8(&v7, &v8, 0, 0, 0, 0, 0, 0);
    v2 = v8;
    v3 = sub_40F88D((__int16 *)v1, 255, &v8);
    v8 = v2;
    v1 = (wint_t *)v3;
    if ( v2 )
    {
      v4 = dword_434698;
      v5 = v2;
      do
      {
        v2 = (int *)*v2;
        *v5 = v4;
        v4 = (int)v5;
        v8 = v2;
        v5 = v2;
      }
      while ( v2 );
      dword_434698 = v4;
    }
  }
  return v1;
}
// 434698: using guessed type int dword_434698;

//----- (0040F88D) --------------------------------------------------------
int __fastcall sub_40F88D(__int16 *a1, char a2, _DWORD *a3)
{
  int v4; // [esp+0h] [ebp-10h] BYREF
  __int16 *v5; // [esp+4h] [ebp-Ch] BYREF
  int v6; // [esp+8h] [ebp-8h] BYREF

  v4 = 0;
  v5 = a1;
  sub_40F8BE(&v6, &v5, a2, a3, 0, (char *)&v4);
  return v4;
}

//----- (0040F8BE) --------------------------------------------------------
_DWORD *__fastcall sub_40F8BE(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5, char *a6)
{
  __int16 *v7; // esi
  unsigned __int16 v8; // cx
  __int16 *v9; // edx
  int v10; // eax
  bool v11; // cl
  __int16 v12; // ax
  wchar_t *v13; // eax
  int v14; // ecx
  int v15; // ecx
  __int16 *v16; // esi
  __int16 *v17; // ecx
  int v18; // esi
  int v19; // esi
  __int16 *v20; // esi
  _DWORD *v21; // ecx
  wchar_t *v22; // eax
  __int16 *v23; // esi
  __int16 v25; // [esp-4h] [ebp-84Ch]
  int v26; // [esp-4h] [ebp-84Ch]
  bool v27; // [esp+Bh] [ebp-83Dh]
  __int16 *v28; // [esp+Ch] [ebp-83Ch]
  bool v29; // [esp+1Ch] [ebp-82Ch]
  __int16 *v30; // [esp+20h] [ebp-828h]
  __int16 *v31; // [esp+20h] [ebp-828h]
  int v32; // [esp+24h] [ebp-824h]
  _DWORD *v33; // [esp+24h] [ebp-824h]
  _DWORD v35[517]; // [esp+30h] [ebp-818h] BYREF
  int savedregs; // [esp+848h] [ebp+0h] BYREF

  v35[514] = 0;
  v7 = *a2;
  v35[512] = v35;
  v35[513] = 1024;
  v8 = *v7;
  v27 = 0;
  if ( *v7 )
  {
    v9 = v7;
    while ( 1 )
    {
      v10 = v8;
      if ( v8 == 36 )
        break;
      if ( v8 == 34 )
      {
        v11 = !v27;
        v27 = !v27;
      }
      else
      {
        v11 = v27;
      }
      if ( a5 && (v10 == 44 || (_WORD)v10 == 41) )
        goto LABEL_67;
      if ( !v11 && (_WORD)v10 == 94 )
      {
        sub_403AC7(v35, 94);
        if ( *++*a2 == 34 )
          v27 = 1;
      }
      v25 = *(*a2)++;
      sub_403AC7(v35, v25);
      v7 = *a2;
      v9 = *a2;
      v12 = **a2;
      v8 = v12;
      if ( !v12 )
      {
LABEL_17:
        if ( !v12 )
          goto LABEL_67;
        v13 = (wchar_t *)(v7 + 2);
        if ( v7[1] == 40 )
        {
          if ( wcschr(L"*@<?", *v13) )
          {
            v26 = 3;
            goto LABEL_21;
          }
          v9 = *a2;
          v13 = (wchar_t *)(v7 + 2);
        }
        if ( v7[1] != 36 )
        {
          if ( wcschr(L"*@<?", v9[1]) )
          {
            sub_40FE08(v35, a2, 1);
          }
          else if ( (*a2)[1] == 40
                 && (v16 = (__int16 *)wcspbrk((const wchar_t *)*a2 + 2, L" \t\n:)"), v30 = v16, sub_40EE9A(*v16)) )
          {
            v17 = *a2;
            v18 = v16 - *a2;
            *a2 = v30 + 1;
            v19 = v18 - 2;
            v28 = v17;
            v32 = v19;
            LOWORD(v17) = v30[1];
            v31 = v30 + 1;
            if ( sub_40EE9A((__int16)v17) )
            {
              v20 = v31;
              do
                *a2 = ++v20;
              while ( sub_40EE9A(*v20) );
              v19 = v32;
            }
            v29 = v28[v19 + 1] == 105;
            if ( sub_4114C6((char *)v28 + 4, v19, (char *)L"subst", 5)
              || sub_4114C6((char *)v28 + 4, v19, (char *)L"substi", 6) )
            {
              sub_4106B9(a2, v35, (int)&savedregs, a3, a4, v29);
            }
            else if ( sub_4114C6((char *)v28 + 4, v19, (char *)L"strip", 5) )
            {
              sub_410781(v35, a2, a3, a4);
            }
            else if ( sub_4114C6((char *)v28 + 4, v19, (char *)L"filter", 6)
                   || sub_4114C6((char *)v28 + 4, v19, (char *)L"filteri", 7) )
            {
              sub_41080C(v35, a2, a3, a4, v29, 1);
            }
            else if ( sub_4114C6((char *)v28 + 4, v19, (char *)L"filterout", 9)
                   || sub_4114C6((char *)v28 + 4, v19, (char *)L"filterouti", 10) )
            {
              sub_41080C(v35, a2, a3, a4, v29, 0);
            }
            else if ( sub_4114C6((char *)v28 + 4, v19, (char *)L"findstring", 10)
                   || sub_4114C6((char *)v28 + 4, v19, (char *)L"findstringi", 11) )
            {
              sub_41091C(v35, a2, a3, a4, v29);
            }
            else
            {
              sub_405A12(dword_423730, 0x410u);
            }
          }
          else
          {
            v21 = a4;
            if ( !*a4 )
            {
              sub_405A12(dword_423730, 0x410u);
              v21 = a4;
            }
            v33 = (_DWORD *)*v21;
            *v21 = *(_DWORD *)*v21;
            v22 = wcschr((const wchar_t *)v33[1], 0x24u);
            v23 = (__int16 *)v33[1];
            if ( v22 )
              v23 = (__int16 *)sub_40F88D(v23, a3, a4);
            sub_4102A4(v35, a2, v23);
            if ( v23 != (__int16 *)v33[1] )
              free(v23);
          }
          goto LABEL_66;
        }
        v14 = *v13;
        if ( (_WORD)v14 == 94 || a3 != 1 )
        {
LABEL_36:
          v26 = 5;
          goto LABEL_21;
        }
        if ( v14 == 64 )
        {
          v26 = 2;
        }
        else
        {
          if ( (_WORD)v14 == 40 )
            ++v13;
          v15 = v13[1];
          if ( v15 != 70 && v15 != 68 && v15 != 66 && v15 != 82 || v13[2] != 41 )
            goto LABEL_36;
          v26 = 4;
        }
LABEL_21:
        sub_40FE08(v35, a2, v26);
LABEL_66:
        v7 = *a2;
        v9 = *a2;
        v8 = **a2;
        if ( !v8 )
          goto LABEL_67;
      }
    }
    v12 = 36;
    goto LABEL_17;
  }
LABEL_67:
  sub_403AC7(v35, 0);
  sub_403BBC(v35, a1, a6);
  return a1;
}
// 402670: using guessed type wchar_t aFilter[7];
// 402680: using guessed type wchar_t aFilteri[8];
// 402690: using guessed type wchar_t aFilterout[10];
// 4026A4: using guessed type wchar_t aFilterouti[11];
// 4026BC: using guessed type wchar_t aFindstring[11];
// 4026D4: using guessed type wchar_t aFindstringi[12];
// 4026EC: using guessed type wchar_t aStrip[6];
// 4026F8: using guessed type wchar_t aSubst[6];
// 402704: using guessed type wchar_t aSubsti[7];
// 423730: using guessed type int dword_423730;

//----- (0040FD9E) --------------------------------------------------------
_DWORD *__fastcall sub_40FD9E(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5, char *a6)
{
  int v8; // ecx

  sub_40F8BE(a1, a2, a3, a4, 1, a6);
  if ( !**a2 )
    sub_405A12(dword_423730, 0x410u);
  v8 = (unsigned __int16)*(*a2)++;
  if ( a5 )
  {
    if ( v8 == 41 )
      return a1;
    goto LABEL_7;
  }
  if ( v8 != 44 )
LABEL_7:
    sub_405A12(dword_423730, 0x410u);
  return a1;
}
// 423730: using guessed type int dword_423730;

//----- (0040FE08) --------------------------------------------------------
void __fastcall sub_40FE08(_DWORD *a1, __int16 **a2, int a3)
{
  char v4; // dl
  wchar_t *v5; // esi
  void *v6; // edi
  int v7; // ecx
  __int16 *v8; // esi
  __int16 v9; // di
  __int16 v10; // cx
  wchar_t *v11; // ebx
  unsigned int v12; // ecx
  int v13; // eax
  wchar_t *v14; // eax
  int v15; // ebx
  __int16 *v16; // eax
  _WORD *v17; // ecx
  __int16 *v18; // edx
  unsigned int v20; // eax
  wchar_t *v21; // [esp+Ch] [ebp-838h]
  __int16 **v23; // [esp+18h] [ebp-82Ch]
  int v24; // [esp+20h] [ebp-824h]
  unsigned int v25; // [esp+20h] [ebp-824h]
  rsize_t v26; // [esp+24h] [ebp-820h]
  rsize_t v27; // [esp+24h] [ebp-820h]
  char v28; // [esp+29h] [ebp-81Bh]
  char v29; // [esp+2Ah] [ebp-81Ah]
  _DWORD Src[517]; // [esp+2Ch] [ebp-818h] BYREF

  v4 = 0;
  v29 = 0;
  v28 = 0;
  v5 = 0;
  v26 = 0;
  v6 = 0;
  v23 = a2;
  v7 = 1;
  v24 = 1;
  if ( a3 != 1 )
  {
    if ( a3 == 2 )
    {
LABEL_8:
      v5 = (wchar_t *)dword_423F48;
      goto LABEL_23;
    }
    if ( a3 != 3 )
    {
      if ( a3 != 4 )
      {
        if ( a3 == 5 )
        {
          sub_403AC7(a1, 36);
          *a2 += 2;
        }
        return;
      }
      v24 = 4;
      v29 = 1;
      goto LABEL_8;
    }
    v7 = 2;
    v29 = 1;
  }
  switch ( (*a2)[v7] )
  {
    case '*':
      if ( (*a2)[v7 + 1] == 42 )
      {
        v5 = (wchar_t *)dword_423F44;
        ++v7;
LABEL_21:
        v4 = 1;
        goto LABEL_22;
      }
      v5 = (wchar_t *)dword_423F58;
      v28 = 1;
      break;
    case '<':
      v5 = (wchar_t *)dword_423F4C;
      break;
    case '?':
      v5 = (wchar_t *)dword_423F50;
      goto LABEL_21;
    default:
      v4 = 0;
      if ( (*a2)[v7] == 64 )
        v5 = dword_423F54;
      goto LABEL_22;
  }
  v4 = 0;
LABEL_22:
  v24 = v7 + 1;
LABEL_23:
  if ( v5 )
  {
    v11 = 0;
    if ( v4 )
    {
      v15 = v24;
      Src[512] = Src;
      Src[513] = 1024;
      Src[514] = 0;
      do
      {
        v16 = (__int16 *)*((_DWORD *)v5 + 1);
        v21 = (wchar_t *)v16;
        if ( v29 )
        {
          v17 = (_WORD *)*((_DWORD *)v5 + 1);
          v18 = v16 + 1;
          while ( *v17++ )
            ;
          v20 = v17 - v18 + 1;
          v25 = v20;
          if ( v20 > v26 )
          {
            if ( v6 )
            {
              free(v6);
              v20 = v25;
            }
            v26 = v20;
            v6 = sub_40B4E9((unsigned __int64)v20 >> 31 != 0 ? -1 : 2 * v20);
          }
          v16 = (__int16 *)sub_41014C((*v23)[v15], (wchar_t *)v6, v26, v21);
        }
        sub_403AF7(Src, v16);
        if ( *(_DWORD *)v5 )
          sub_403AC7(Src, 32);
        v5 = *(wchar_t **)v5;
      }
      while ( v5 );
      sub_403AC7(Src, 0);
      v5 = (wchar_t *)sub_403B67(Src);
      v11 = v5;
      goto LABEL_36;
    }
  }
  else
  {
    v8 = *a2;
    v9 = **a2;
    if ( v9 )
    {
      v10 = **a2;
      do
      {
        v9 = v10;
        if ( v10 == 32 )
          break;
        v9 = v10;
        if ( v10 == 9 )
          break;
        v10 = *++v8;
        v9 = *v8;
      }
      while ( *v8 );
    }
    *v8 = 0;
    sub_405A12(dword_423730, 0xFA6u, *a2);
    *v8 = v9;
    v5 = (wchar_t *)sub_40EBA1((char *)&dword_40177C);
    v11 = v5;
  }
  v12 = wcslen(v5);
  v13 = v12 + 1;
  v27 = v12 + 1;
  if ( !v12 )
  {
    v13 = 2;
    v27 = 2;
  }
  v14 = (wchar_t *)sub_40B4E9((unsigned __int64)(unsigned int)v13 >> 31 != 0 ? -1 : 2 * v13);
  v6 = v14;
  if ( v28 )
    v5 = sub_41014C(82, v14, v27, v5);
  if ( v29 )
    v5 = sub_41014C((*v23)[v24], (wchar_t *)v6, v27, v5);
LABEL_36:
  sub_4102A4(a1, v23, (__int16 *)v5);
  if ( v11 )
    free(v11);
  if ( v6 )
    free(v6);
}
// 40177C: using guessed type int dword_40177C;
// 423730: using guessed type int dword_423730;
// 423F44: using guessed type int dword_423F44;
// 423F48: using guessed type int dword_423F48;
// 423F50: using guessed type int dword_423F50;
// 423F58: using guessed type int dword_423F58;

//----- (0041014C) --------------------------------------------------------
wchar_t *__fastcall sub_41014C(__int16 a1, wchar_t *a2, rsize_t SizeInWords, wchar_t *Source)
{
  wchar_t *v4; // esi
  wchar_t *v5; // ebx
  wchar_t *v6; // edi
  wchar_t *i; // eax
  int v8; // ecx
  int v9; // eax
  wchar_t *v10; // eax
  unsigned __int16 Sourcea; // [esp+24h] [ebp+Ch]

  v4 = a2;
  v5 = 0;
  v6 = 0;
  if ( wcscpy_s(a2, SizeInWords, Source) )
    sub_405A12(dword_423730, 0x410u);
  Sourcea = *v4;
  for ( i = &v4[wcslen(v4) - 1]; i >= v4; --i )
  {
    v8 = *i;
    if ( v8 == 92 || v8 == 47 )
    {
      v6 = i;
      break;
    }
    if ( v8 == 46 && !v5 )
      v5 = i;
  }
  if ( a1 == 66 )
  {
    if ( v5 )
      *v5 = 0;
LABEL_30:
    if ( v6 )
    {
      v4 = v6 + 1;
    }
    else if ( v4[1] == 58 )
    {
      v4 += 2;
    }
    goto LABEL_34;
  }
  if ( a1 != 68 )
  {
    if ( a1 != 70 )
    {
      if ( a1 == 82 && v5 )
        *v5 = 0;
      goto LABEL_34;
    }
    goto LABEL_30;
  }
  v9 = v4[1];
  if ( v6 )
  {
    if ( v9 == 58 && v6 == v4 + 2 )
      ++v6;
    *v6 = 0;
  }
  else if ( v9 == 58 )
  {
    v4[2] = 0;
  }
  else if ( wcscpy_s(v4, SizeInWords, L".") )
  {
    sub_405A12(dword_423730, 0x410u);
  }
LABEL_34:
  if ( Sourcea == 34 )
  {
    if ( *v4 != 34 && v4 > a2 )
      *--v4 = 34;
    v10 = wcschr(v4, 0);
    if ( *(v10 - 1) != 34 )
      *(_DWORD *)v10 = 34;
  }
  return v4;
}
// 423730: using guessed type int dword_423730;

//----- (004102A4) --------------------------------------------------------
__int16 *__fastcall sub_4102A4(_DWORD *a1, __int16 **a2, __int16 *a3)
{
  _DWORD *v4; // ebx
  const wchar_t *v5; // eax
  __int16 *v6; // eax
  __int16 *v7; // ecx
  __int16 *v8; // edi
  __int16 v9; // dx
  __int16 *result; // eax
  __int16 *v11; // ecx
  __int16 *v12; // edx
  int v13; // edi
  __int16 *v15; // [esp+10h] [ebp-4h] BYREF
  int savedregs; // [esp+14h] [ebp+0h] BYREF

  v4 = a1;
  v5 = (const wchar_t *)(*a2 + 1);
  *a2 = (__int16 *)v5;
  if ( *v5 == 94 )
    *a2 = (__int16 *)++v5;
  v6 = (__int16 *)wcschr(v5, 0x3Au);
  v7 = *a2;
  v8 = v6;
  v15 = v6;
  if ( *v7 )
  {
    v9 = *v7;
    do
    {
      if ( v9 == 41 )
        break;
      if ( v9 == 94 )
        ++v7;
      v9 = *++v7;
    }
    while ( *v7 );
    v8 = v15;
    v4 = a1;
  }
  if ( **a2 == 40 && v8 && v8 < v7 )
  {
    sub_410388(&v15, v4, (int)&savedregs, a3);
    result = v15;
  }
  else
  {
    sub_403AF7(v4, a3);
    v11 = *a2;
    v12 = *a2;
    v13 = (unsigned __int16)**a2;
    if ( v13 == 36 )
    {
      v12 = ++v11;
      *a2 = v11;
      LOWORD(v13) = *v11;
    }
    if ( (_WORD)v13 == 40 )
    {
      do
        *a2 = ++v11;
      while ( *v11 != 41 );
      v12 = v11;
    }
    else if ( (_WORD)v13 == 42 && v11[1] == 42 )
    {
      v12 = v11 + 1;
    }
    result = v12 + 1;
  }
  *a2 = result;
  return result;
}

//----- (00410388) --------------------------------------------------------
void __userpurge sub_410388(__int16 **a1@<edx>, _DWORD *a2@<ecx>, int a3@<ebp>, __int16 *a4)
{
  __int16 **v4; // esi
  __int16 *v5; // edi
  __int16 v6; // ax
  __int16 v7; // dx
  __int16 v8; // cx
  __int16 v9; // dx
  __int16 v10; // cx
  _WORD *v11; // eax
  __int16 *v12; // esi
  _WORD *v13; // edx
  __int16 v14; // cx
  __int16 v15; // ax
  __int16 *v16; // esi
  char *v17; // edi
  char *v18; // edx
  __int16 v19; // cx
  __int16 v20; // ax
  unsigned int v21; // ecx
  int v22; // esi
  _DWORD **v23; // eax
  int v25; // [esp-34h] [ebp-40h]
  int v26; // [esp-30h] [ebp-3Ch]
  __int16 *v28; // [esp-28h] [ebp-34h]
  __int16 *v29; // [esp-20h] [ebp-2Ch]
  wchar_t *v30; // [esp-20h] [ebp-2Ch]
  _DWORD *v31[4]; // [esp-1Ch] [ebp-28h] BYREF
  int v32; // [esp-Ch] [ebp-18h]
  unsigned int v33; // [esp-8h] [ebp-14h]
  int v34; // [esp+0h] [ebp-Ch]
  int v35; // [esp+4h] [ebp-8h]
  int retaddr; // [esp+Ch] [ebp+0h]

  v34 = a3;
  v35 = retaddr;
  v4 = a1;
  v5 = ++*a1;
  v29 = *a1;
  v6 = **a1;
  v7 = v6;
  if ( v6 )
  {
    v8 = v6;
    do
    {
      v7 = v8;
      if ( v8 == 61 )
        break;
      if ( v8 == 94 )
        ++v5;
      v8 = *++v5;
      v7 = *v5;
    }
    while ( *v5 );
    v4 = a1;
    v29 = v5;
  }
  if ( v7 != 61 )
    sub_405A12(dword_423724, 0x3EBu);
  if ( v5 == *v4 )
    sub_405A12(dword_423724, 0x3EDu);
  v28 = v5;
  v9 = *v5;
  v25 = 41;
  if ( *v5 )
  {
    v10 = *v5;
    do
    {
      v9 = v10;
      if ( v10 == 41 )
        break;
      if ( v10 == 94 )
        ++v5;
      v10 = *++v5;
      v9 = *v5;
    }
    while ( *v5 );
    v4 = a1;
    v28 = v5;
    v5 = v29;
  }
  if ( v9 != 41 )
    sub_405A12(dword_423724, 0x3E8u);
  v11 = sub_403C81(v5 - *v4 + 1);
  v12 = *v4;
  v13 = v11;
  v30 = v11;
  if ( *v12 != 61 )
  {
    v14 = *v12;
    do
    {
      v15 = v14;
      if ( v14 == 94 )
        v15 = *++v12;
      ++v12;
      *v13++ = v15;
      v14 = *v12;
    }
    while ( *v12 != 61 );
  }
  v26 = v13 - v30;
  *v13 = 0;
  v16 = v12 + 1;
  v17 = (char *)sub_403C81(v28 - v5);
  v18 = v17;
  if ( *v16 != 41 )
  {
    v19 = *v16;
    do
    {
      v20 = v19;
      if ( v19 == 94 )
        v20 = *++v16;
      ++v16;
      *(_WORD *)v18 = v20;
      v18 += 2;
      v19 = *v16;
    }
    while ( *v16 != 41 );
  }
  *(_WORD *)v18 = 0;
  v21 = (v18 - v17) >> 1;
  *a1 = v28 + 1;
  v31[0] = 0;
  v32 = 0;
  v33 = 7;
  if ( v21 > 7 )
  {
    LOBYTE(v25) = 0;
    sub_411889(v31, v21, v25, v17);
  }
  else
  {
    v22 = 2 * v21;
    v32 = (v18 - v17) >> 1;
    memmove(v31, v17, 2 * v21);
    *(_WORD *)((char *)v31 + v22) = 0;
  }
  v23 = v31;
  if ( v33 >= 8 )
    v23 = (_DWORD **)v31[0];
  sub_4105D0(a2, a4, v30, v26, v23, v32);
  if ( v33 >= 8 )
    sub_41184F(v31[0], v33 + 1);
  free(v30);
  free(v17);
}
// 410388: could not find valid save-restore pair for ebp
// 423724: using guessed type int dword_423724;

//----- (004105D0) --------------------------------------------------------
int __fastcall sub_4105D0(_DWORD *a1, __int16 *a2, wchar_t *String2, size_t MaxCount, void *Src, int a6)
{
  __int16 *v6; // esi
  int result; // eax
  __int16 v9; // dx
  int v10; // eax

  v6 = a2;
  result = (unsigned __int16)*a2;
  if ( (_WORD)result )
  {
    v9 = *a2;
    do
    {
      if ( v9 == *String2 && !wcsncmp((const wchar_t *)v6, String2, MaxCount) )
      {
        sub_403B28(a1, Src, a6);
        v10 = 2 * MaxCount;
      }
      else
      {
        sub_403AC7(a1, *v6);
        v10 = 2;
      }
      v6 = (__int16 *)((char *)v6 + v10);
      result = (unsigned __int16)*v6;
      v9 = result;
    }
    while ( (_WORD)result );
  }
  return result;
}

//----- (00410631) --------------------------------------------------------
int __fastcall sub_410631(_DWORD *a1, __int16 *a2, wchar_t *String2, size_t MaxCount, void *Src, int a6)
{
  int result; // eax
  wint_t v9; // cx
  const wchar_t *v10; // eax
  int v11; // eax
  wint_t v12; // [esp+Ch] [ebp-4h]

  v12 = towupper(*String2);
  result = (unsigned __int16)*a2;
  if ( (_WORD)result )
  {
    v9 = *a2;
    do
    {
      v10 = String2;
      if ( v9 != *String2 )
      {
        if ( towupper(v9) != v12 )
          goto LABEL_8;
        v10 = String2;
      }
      if ( wcsnicmp((const wchar_t *)a2, v10, MaxCount) )
      {
LABEL_8:
        sub_403AC7(a1, *a2);
        v11 = 2;
        goto LABEL_9;
      }
      sub_403B28(a1, Src, a6);
      v11 = 2 * MaxCount;
LABEL_9:
      a2 = (__int16 *)((char *)a2 + v11);
      result = (unsigned __int16)*a2;
      v9 = result;
    }
    while ( (_WORD)result );
  }
  return result;
}

//----- (004106B9) --------------------------------------------------------
void __userpurge sub_4106B9(__int16 **a1@<edx>, _DWORD *a2@<ecx>, int a3@<ebp>, char a4, _DWORD *a5, char a6)
{
  int v6; // esi
  void **v7; // edi
  __int16 *v8; // [esp-30h] [ebp-3Ch] BYREF
  __int16 **v9; // [esp-28h] [ebp-34h]
  wchar_t *v10; // [esp-24h] [ebp-30h] BYREF
  size_t v11; // [esp-20h] [ebp-2Ch]
  void *v12; // [esp-1Ch] [ebp-28h] BYREF
  int v13; // [esp-18h] [ebp-24h]
  _DWORD *v14; // [esp-14h] [ebp-20h]
  int v15; // [esp-10h] [ebp-1Ch] BYREF
  int v16; // [esp-Ch] [ebp-18h] BYREF
  int v17; // [esp-8h] [ebp-14h] BYREF
  _DWORD v18[4]; // [esp-4h] [ebp-10h] BYREF
  void *retaddr; // [esp+Ch] [ebp+0h]

  v18[1] = a3;
  v18[2] = retaddr;
  v14 = a2;
  v15 = 0;
  v9 = a1;
  v16 = 0;
  v17 = 0;
  sub_40FD9E(&v10, a1, a4, a5, 0, (char *)&v15);
  sub_40FD9E(&v12, v9, a4, a5, 0, (char *)&v16);
  sub_40FD9E(&v8, v9, a4, a5, 1, (char *)&v17);
  if ( a6 )
    sub_410631(v14, v8, v10, v11, v12, v13);
  else
    sub_4105D0(v14, v8, v10, v11, v12, v13);
  v6 = 3;
  v7 = (void **)v18;
  do
  {
    --v7;
    --v6;
    if ( *v7 )
      sub_411C31(*v7);
  }
  while ( v6 );
}
// 4106B9: could not find valid save-restore pair for ebp

//----- (00410781) --------------------------------------------------------
void __fastcall sub_410781(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4)
{
  int v5; // esi
  _WORD *v6; // eax
  _WORD *v7; // [esp+Ch] [ebp-1Ch] BYREF
  int v8; // [esp+10h] [ebp-18h]
  _WORD *v9; // [esp+14h] [ebp-14h] BYREF
  int v10; // [esp+18h] [ebp-10h]
  void *Src; // [esp+1Ch] [ebp-Ch] BYREF
  int v12; // [esp+20h] [ebp-8h]
  void *Block; // [esp+24h] [ebp-4h] BYREF

  Block = 0;
  sub_40FD9E(&v7, a2, a3, a4, 1, (char *)&Block);
  v5 = v8;
  v6 = v7;
  v9 = v7;
  v10 = v8;
  if ( v8 )
  {
    while ( 1 )
    {
      Src = 0;
      v12 = 0;
      sub_410A2F(&Src, (int *)&v9, v6, v5);
      v5 = v10;
      if ( v12 )
      {
        sub_403B28(a1, Src, v12);
        if ( !v5 )
          break;
        sub_403AC7(a1, 32);
      }
      if ( !v5 )
        break;
      v6 = v9;
    }
  }
  if ( Block )
    sub_411C31(Block);
}

//----- (0041080C) --------------------------------------------------------
void __fastcall sub_41080C(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5, char a6)
{
  char v6; // bl
  int v9; // eax
  _WORD *v10; // ecx
  int v11; // esi
  int v12; // eax
  _WORD *v13; // ecx
  int v14; // edx
  char v15; // al
  int v16; // esi
  void **v17; // edi
  _WORD *v18; // [esp+10h] [ebp-38h] BYREF
  int v19; // [esp+14h] [ebp-34h]
  _WORD *v20; // [esp+18h] [ebp-30h] BYREF
  int v21; // [esp+1Ch] [ebp-2Ch]
  int v22; // [esp+20h] [ebp-28h] BYREF
  int v23; // [esp+24h] [ebp-24h] BYREF
  _WORD *v24; // [esp+28h] [ebp-20h] BYREF
  int v25; // [esp+2Ch] [ebp-1Ch]
  _WORD *v26; // [esp+30h] [ebp-18h] BYREF
  int v27; // [esp+34h] [ebp-14h]
  int v28; // [esp+38h] [ebp-10h] BYREF
  unsigned int v29; // [esp+3Ch] [ebp-Ch]
  void *Src; // [esp+40h] [ebp-8h] BYREF
  int v31; // [esp+44h] [ebp-4h]

  v6 = 0;
  v22 = 0;
  v23 = 0;
  sub_40FD9E(&v18, a2, a3, a4, 0, (char *)&v22);
  sub_40FD9E(&v20, a2, a3, a4, 1, (char *)&v23);
  v9 = v21;
  v10 = v20;
  v24 = v20;
  v25 = v21;
  if ( v21 )
  {
    while ( 1 )
    {
      Src = 0;
      v31 = 0;
      sub_410A2F(&Src, (int *)&v24, v10, v9);
      v11 = v31;
      if ( v31 )
      {
        v12 = v19;
        v13 = v18;
        v26 = v18;
        v27 = v19;
        if ( v19 )
        {
          while ( 1 )
          {
            v28 = 0;
            v29 = 0;
            sub_410A2F(&v28, (int *)&v26, v13, v12);
            if ( sub_410AD3(a5, v14, (int)Src, v11, v28, v29) )
              break;
            v12 = v27;
            if ( !v27 )
              goto LABEL_8;
            v13 = v26;
          }
          v15 = 1;
        }
        else
        {
LABEL_8:
          v15 = 0;
        }
        if ( v15 == a6 )
        {
          if ( v6 )
            sub_403AC7(a1, 32);
          sub_403B28(a1, Src, v11);
          v6 = 1;
        }
      }
      v9 = v25;
      if ( !v25 )
        break;
      v10 = v24;
    }
  }
  v16 = 2;
  v17 = (void **)&v24;
  do
  {
    --v17;
    --v16;
    if ( *v17 )
      sub_411C31(*v17);
  }
  while ( v16 );
}
// 4108AF: variable 'v14' is possibly undefined

//----- (0041091C) --------------------------------------------------------
void __fastcall sub_41091C(_DWORD *a1, __int16 **a2, char a3, _DWORD *a4, char a5)
{
  int v7; // ecx
  int v8; // esi
  wchar_t *v9; // edi
  int v10; // esi
  void **p_String1; // edi
  int v12[2]; // [esp+10h] [ebp-1Ch] BYREF
  int v13; // [esp+18h] [ebp-14h] BYREF
  int v14; // [esp+1Ch] [ebp-10h] BYREF
  wchar_t *String1; // [esp+20h] [ebp-Ch] BYREF
  size_t MaxCount; // [esp+24h] [ebp-8h]

  v13 = 0;
  v14 = 0;
  sub_40FD9E(&String1, a2, a3, a4, 0, (char *)&v13);
  sub_40FD9E(v12, a2, a3, a4, 1, (char *)&v14);
  if ( a5 )
  {
    if ( sub_4109C1(String1, MaxCount, v12[0], v12[1]) )
    {
      v8 = MaxCount;
      v9 = String1;
LABEL_5:
      sub_403B28(a1, v9, v8);
    }
  }
  else
  {
    v8 = MaxCount;
    v9 = String1;
    if ( sub_41142F((char **)v12, (char *)String1, MaxCount, v7) != -1 )
      goto LABEL_5;
  }
  v10 = 2;
  p_String1 = (void **)&String1;
  do
  {
    --p_String1;
    --v10;
    if ( *p_String1 )
      sub_411C31(*p_String1);
  }
  while ( v10 );
}
// 410989: variable 'v7' is possibly undefined

//----- (004109C1) --------------------------------------------------------
char __stdcall sub_4109C1(wchar_t *String1, size_t MaxCount, int a3, unsigned int a4)
{
  wint_t v4; // bx
  int v5; // esi
  int v6; // eax
  const wchar_t *v7; // ecx

  if ( MaxCount > a4 )
    return 0;
  v4 = towupper(*String1);
  v5 = 0;
  while ( 1 )
  {
    v6 = a3;
    v7 = String1;
    if ( *String1 == *(_WORD *)(a3 + 2 * v5) )
      break;
    if ( v4 == towupper(*(_WORD *)(a3 + 2 * v5)) )
    {
      v6 = a3;
      v7 = String1;
      break;
    }
LABEL_7:
    if ( ++v5 > a4 - MaxCount )
      return 0;
  }
  if ( wcsnicmp(v7, (const wchar_t *)(v6 + 2 * v5), MaxCount) )
    goto LABEL_7;
  return 1;
}

//----- (00410A2F) --------------------------------------------------------
_WORD *__fastcall sub_410A2F(_DWORD *a1, int *a2, _WORD *a3, int a4)
{
  int v6; // eax
  _WORD *result; // eax
  int v8; // ecx
  int *v9; // eax
  unsigned int v10; // edx
  int v11; // ecx
  int v12; // eax
  int v13; // eax
  int *v14; // eax
  int v15; // ecx
  int v16; // [esp-4h] [ebp-1Ch]
  _DWORD v17[2]; // [esp+8h] [ebp-10h] BYREF
  int v18; // [esp+10h] [ebp-8h] BYREF
  int v19; // [esp+14h] [ebp-4h]

  v6 = sub_4115AD(a3, a4, (int)a1, L" \t\n", 3, a4);
  v19 = v6;
  if ( v6 == -1 )
  {
    result = a3;
    v8 = a4;
    *a2 = 0;
    a2[1] = 0;
    *a1 = result;
    a1[1] = v8;
  }
  else
  {
    v9 = sub_411496(&a3, v17, 0, v6);
    v16 = a4;
    v10 = a4;
    v11 = *v9;
    a1[1] = v9[1];
    v12 = v19;
    *a1 = v11;
    v13 = sub_4114EB((int)a3, v10, v12 + 1, L" \t\n", 3, v16);
    if ( v13 == -1 )
    {
      v18 = 0;
      v14 = &v18;
      v19 = 0;
    }
    else
    {
      v14 = sub_411496(&a3, v17, v13, 0xFFFFFFFF);
    }
    v15 = *v14;
    result = (_WORD *)v14[1];
    *a2 = v15;
    a2[1] = (int)result;
  }
  return result;
}
// 410A2F: using guessed type _DWORD var_10[2];

//----- (00410AD3) --------------------------------------------------------
char __fastcall sub_410AD3(char a1, int a2, int a3, unsigned int a4, int a5, unsigned int a6)
{
  unsigned int v6; // edx
  int v7; // esi
  char v8; // bl
  unsigned int v9; // eax
  unsigned int v10; // edi
  unsigned __int16 v11; // ax
  unsigned __int16 v12; // ax
  int v13; // ecx
  wint_t v14; // si
  size_t v16; // esi
  int v17; // eax
  bool v18; // zf
  wchar_t *String1; // [esp+10h] [ebp-20h] BYREF
  int v20; // [esp+14h] [ebp-1Ch]
  wchar_t *String2; // [esp+18h] [ebp-18h] BYREF
  wint_t C[2]; // [esp+1Ch] [ebp-14h]
  int v23; // [esp+20h] [ebp-10h] BYREF
  unsigned int v24; // [esp+24h] [ebp-Ch]
  int v25; // [esp+28h] [ebp-8h]
  char v26; // [esp+2Fh] [ebp-1h]

  v6 = a6;
  v7 = a5;
  v8 = 0;
  v26 = a1;
  v9 = 0;
  v24 = 0;
  v10 = 0;
  if ( a6 )
  {
    v25 = 4;
    while ( v9 < a4 )
    {
      v11 = *(_WORD *)(v7 + 2 * v10);
      *(_DWORD *)C = v11;
      if ( v11 == 37 )
      {
        sub_411496(&a5, &String2, v10 + 1, 0xFFFFFFFF);
        sub_411496(&a3, &v23, v24, 0xFFFFFFFF);
        v16 = *(_DWORD *)C;
        if ( v24 < *(_DWORD *)C )
          return 0;
        sub_411496(&v23, &String1, v24 - *(_DWORD *)C, 0xFFFFFFFF);
        if ( v26 )
        {
          v17 = wcsnicmp(String1, String2, v16);
        }
        else
        {
          if ( v20 != v16 )
            return v8;
          v17 = sub_4116DD((char *)String1, (char *)String2, v20);
        }
        v18 = v17 == 0;
        goto LABEL_29;
      }
      if ( C[0] == 92 )
      {
        *(_DWORD *)C = v10 + 1;
        if ( v10 + 1 != v6 )
        {
          v12 = *(_WORD *)(v7 + 2 * v10 + 2);
          v20 = v12;
          if ( v12 == 37 || (_WORD)v20 == 92 && v10 + 2 < v6 && *(_WORD *)(v25 + v7) == 37 )
          {
            v10 = *(_DWORD *)C;
            v25 += 2;
          }
        }
      }
      v13 = *(unsigned __int16 *)(v7 + 2 * v10);
      v20 = v13;
      v6 = a6;
      *(_DWORD *)C = *(unsigned __int16 *)(a3 + 2 * v24);
      if ( (_WORD)v13 != C[0] )
      {
        if ( !v26 )
          return 0;
        v14 = towupper(v13);
        if ( v14 != towupper(C[0]) )
          return 0;
        v6 = a6;
        v7 = a5;
      }
      ++v10;
      v25 += 2;
      v9 = ++v24;
      if ( v10 >= v6 )
        break;
    }
  }
  if ( v10 + 1 == v6 && *(_WORD *)(v7 + 2 * v10) == 37 )
    return 1;
  if ( v10 == v6 )
  {
    v18 = v24 == a4;
LABEL_29:
    if ( v18 )
      return 1;
  }
  return v8;
}

//----- (00410C5A) --------------------------------------------------------
void *__fastcall sub_410C5A(wchar_t *FullPath, wchar_t *Filename)
{
  wchar_t Buffer[260]; // [esp+8h] [ebp-418h] BYREF
  wchar_t Dir[258]; // [esp+210h] [ebp-210h] BYREF
  wchar_t Drive[4]; // [esp+414h] [ebp-Ch] BYREF

  wsplitpath_s(FullPath, Drive, 3u, Dir, 0x100u, 0, 0, 0, 0);
  wmakepath_s(Buffer, 0x104u, Drive, Dir, Filename, 0);
  return sub_40EBA1((char *)Buffer);
}

//----- (00410CCE) --------------------------------------------------------
char __thiscall sub_410CCE(_WORD *this)
{
  _WORD *v1; // edx
  char v2; // bl
  __int16 v3; // cx
  __int16 v4; // si
  __int16 v5; // cx
  _WORD *v6; // ecx
  __int16 v7; // si
  _WORD *v8; // edx
  _WORD *v9; // ecx
  __int16 v10; // dx
  const wchar_t *v11; // esi
  wchar_t *v12; // eax
  _WORD *v14; // [esp+14h] [ebp-4h]

  v1 = this;
  v2 = 0;
  v14 = this;
  v3 = *this;
  if ( v3 == 123 )
  {
    v14 = ++v1;
    v4 = *v1;
    if ( *v1 )
    {
      v5 = *v1;
      do
      {
        v4 = v5;
        if ( v5 == 125 )
          break;
        if ( v5 == 94 )
          ++v1;
        v5 = *++v1;
        v4 = *v1;
      }
      while ( *v1 );
      v14 = v1;
      v2 = 0;
    }
    v3 = v4;
    if ( v4 )
    {
      v14 = ++v1;
      v3 = *v1;
    }
  }
  if ( v3 == 46 )
  {
    v6 = v1;
    v7 = 46;
    do
    {
      if ( v7 == 123 )
        break;
      if ( v7 == 94 )
        ++v6;
      v7 = *++v6;
    }
    while ( *v6 );
    v8 = v14;
    v2 = 0;
    while ( v8 < v6 && *v8 != 92 && *v8 != 47 )
      ++v8;
    if ( !*v6 || v8 != v6 )
    {
      v12 = wcspbrk(v14 + 1, L"./\\");
      if ( !v12 || *v12 != 46 )
        return v2;
      v11 = v12 + 1;
      goto LABEL_36;
    }
    v9 = v6 + 1;
    if ( *v9 )
    {
      v10 = *v9;
      while ( v10 != 125 )
      {
        if ( v10 == 94 )
          ++v9;
        v10 = *++v9;
        if ( !*v9 )
          return v2;
      }
      if ( v9[1] == 46 )
      {
        v11 = v9 + 2;
LABEL_36:
        if ( !wcschr(v11, 0x2Fu) && !wcschr(v11, 0x5Cu) )
        {
          if ( wcschr(v11, 0x2Eu) )
            sub_405A12(dword_423730, 0x444u);
          else
            return 1;
        }
      }
    }
  }
  return v2;
}
// 423730: using guessed type int dword_423730;

//----- (00410E43) --------------------------------------------------------
char __fastcall sub_410E43(char *a1, int a2, unsigned __int16 *a3, const wchar_t *a4)
{
  unsigned __int16 *v4; // edi
  char *v5; // esi
  unsigned __int16 v6; // ax
  char *v7; // ebx
  unsigned __int16 *v8; // ecx
  int v9; // eax
  unsigned __int16 *v10; // edx
  char v11; // bh
  char v12; // bl
  const wchar_t *v13; // eax
  unsigned int v14; // kr00_4
  const wchar_t *v15; // ebx
  unsigned int v16; // kr04_4
  unsigned int v17; // kr08_4
  int v18; // ecx
  __int16 v19; // ax
  const wchar_t *i; // eax
  char result; // al
  unsigned int v22; // [esp+1Ch] [ebp-21Ch]
  char v23; // [esp+24h] [ebp-214h]
  char v24; // [esp+25h] [ebp-213h]
  char v25; // [esp+26h] [ebp-212h]
  char v26; // [esp+27h] [ebp-211h]
  wchar_t Drive[262]; // [esp+28h] [ebp-210h] BYREF

  v4 = a3;
  v5 = a1;
  v6 = *a3;
  v7 = &a1[2 * a2];
  v22 = (unsigned int)v7;
  if ( *a3 )
  {
    while ( 1 )
    {
      v8 = v4;
      if ( v5 >= v7 )
        return 1;
      if ( v6 != 37 )
        goto LABEL_10;
      v9 = *++v4;
      if ( !(_WORD)v9 )
      {
        v4 = v8;
        goto LABEL_57;
      }
      if ( (_WORD)v9 == 37 )
      {
        *(_WORD *)v5 = 37;
        goto LABEL_11;
      }
      if ( v9 != 115 )
        break;
      for ( i = a4; i; ++i )
      {
        if ( !*i )
          break;
        if ( v5 >= v7 )
          break;
        *(_WORD *)v5 = *i;
        v5 += 2;
      }
LABEL_57:
      v6 = *++v4;
      if ( !*v4 )
        goto LABEL_58;
    }
    if ( *v4 != 124 )
    {
      *(_WORD *)v5 = 37;
      v5 += 2;
      if ( v5 != v7 )
      {
        v6 = *v4;
LABEL_10:
        *(_WORD *)v5 = v6;
LABEL_11:
        v5 += 2;
        goto LABEL_57;
      }
      return 1;
    }
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    Drive[0] = 0;
    while ( 1 )
    {
      v10 = v4++;
      switch ( *v4 )
      {
        case 0u:
          v4 = v10;
LABEL_45:
          v7 = (char *)v22;
          while ( v8 <= v4 && (unsigned int)v5 < v22 )
          {
            v19 = *v8++;
            *(_WORD *)v5 = v19;
            v5 += 2;
          }
          goto LABEL_57;
        case 0x46u:
          if ( *v10 == 124 )
          {
            v12 = 1;
            v11 = 1;
            v26 = 1;
            v25 = 1;
            v24 = 1;
            v23 = 1;
            goto LABEL_23;
          }
          break;
        case 0x64u:
          v11 = v25;
          v12 = 1;
          v26 = 1;
          goto LABEL_23;
        case 0x65u:
          v23 = 1;
          break;
        case 0x66u:
          v24 = 1;
          break;
        case 0x70u:
          v11 = 1;
          v25 = 1;
          goto LABEL_22;
        default:
          goto LABEL_45;
      }
      v11 = v25;
LABEL_22:
      v12 = v26;
LABEL_23:
      if ( *v4 == 70 )
      {
        v13 = a4;
        if ( !a4 )
        {
          sub_405A12(0, 0x449u);
          v13 = 0;
        }
        if ( v12 )
          wsplitpath_s(v13, Drive, 0x104u, 0, 0, 0, 0, 0, 0);
        if ( v11 )
        {
          v14 = wcslen(Drive);
          v15 = a4;
          wsplitpath_s(a4, 0, 0, &Drive[v14], 260 - v14, 0, 0, 0, 0);
        }
        else
        {
          v15 = a4;
        }
        if ( v24 )
        {
          v16 = wcslen(Drive);
          wsplitpath_s(v15, 0, 0, 0, 0, &Drive[v16], 260 - v16, 0, 0);
        }
        if ( v23 )
        {
          v17 = wcslen(Drive);
          wsplitpath_s(v15, 0, 0, 0, 0, 0, 0, &Drive[v17], 260 - v17);
        }
        v7 = (char *)v22;
        if ( Drive[0] )
        {
          v18 = (char *)Drive - v5;
          do
          {
            if ( (unsigned int)v5 >= v22 )
              break;
            *(_WORD *)v5 = *(_WORD *)&v5[v18];
            v5 += 2;
          }
          while ( *(_WORD *)&v5[v18] );
        }
        goto LABEL_57;
      }
    }
  }
LABEL_58:
  if ( v5 < v7 )
  {
    result = 0;
    *(_WORD *)v5 = 0;
    return result;
  }
  return 1;
}
// 410E43: using guessed type wchar_t Drive[262];

//----- (004111A1) --------------------------------------------------------
_DWORD *__thiscall sub_4111A1(wint_t *this, int a2)
{
  _DWORD *v2; // edi
  wint_t *v3; // ebx
  wint_t *v4; // eax
  wint_t v5; // cx
  wint_t v6; // si
  bool v7; // zf
  wint_t *v9; // [esp+Ch] [ebp-8h]
  _DWORD *v10; // [esp+10h] [ebp-4h]
  wint_t *v11; // [esp+1Ch] [ebp+8h]

  v2 = (_DWORD *)dword_423510[a2];
  v9 = this;
  v10 = v2;
  if ( !v2 )
    return 0;
  while ( 1 )
  {
    v3 = this;
    v4 = (wint_t *)v2[1];
    v11 = v4;
    if ( *this )
    {
      do
      {
        v5 = *v4;
        if ( !*v4 )
          break;
        if ( *v3 == 92 || *v3 == 47 )
        {
          if ( v5 != 92 && v5 != 47 )
            break;
        }
        else
        {
          v6 = towupper(*v4);
          v7 = towupper(*v3) == v6;
          v4 = v11;
          if ( !v7 )
            break;
        }
        ++v3;
        v11 = ++v4;
      }
      while ( *v3 );
      v2 = v10;
      this = v9;
    }
    if ( !*v3 && !*v4 )
      return v2;
    v2 = (_DWORD *)*v2;
    v10 = v2;
    if ( !v2 )
      return 0;
  }
}
// 423510: using guessed type int dword_423510[128];

//----- (00411259) --------------------------------------------------------
int __fastcall sub_411259(_WORD *a1, int a2)
{
  __int16 *v2; // edi
  _WORD *v3; // edx
  char *v4; // esi
  void *v6; // esp
  __int16 *v7; // ecx
  __int16 v8; // ax
  void *v9; // esp
  wchar_t v10; // ax
  wchar_t v11; // cx
  wchar_t *v12; // eax
  int v13; // esi
  wchar_t v14; // cx
  wchar_t *v15; // eax
  int v16; // edi
  wchar_t *v17; // esi
  wchar_t v19[6]; // [esp+0h] [ebp-20h] BYREF
  int v20; // [esp+Ch] [ebp-14h]
  __int16 *v21; // [esp+10h] [ebp-10h]
  wchar_t *v22; // [esp+14h] [ebp-Ch]
  int v23; // [esp+18h] [ebp-8h]

  v2 = (__int16 *)a2;
  v21 = (__int16 *)a2;
  v3 = a1 + 1;
  v4 = (char *)a1;
  v23 = 0;
  while ( *a1++ )
    ;
  v6 = alloca(2 * (a1 - v3) + 2);
  v7 = v2;
  do
    v8 = *v7++;
  while ( v8 != (_WORD)v23 );
  v9 = alloca(2 * (v7 - (v2 + 1)) + 2);
  v10 = *(_WORD *)v4;
  v23 = 34;
  v11 = v10;
  if ( v10 == 34 )
  {
    v4 += 2;
    v11 = *(_WORD *)v4;
  }
  v12 = v19;
  if ( v11 )
  {
    v13 = v4 - (char *)v19;
    do
    {
      *v12 = v11;
      v22 = v12++;
      v20 = v11;
      v11 = *(wchar_t *)((char *)v12 + v13);
    }
    while ( v11 );
    v2 = v21;
    if ( v12 != v19 && (_WORD)v20 == (_WORD)v23 )
      v12 = v22;
  }
  *v12 = 0;
  v14 = *v2;
  if ( *v2 == (_WORD)v23 )
    v14 = *++v2;
  v15 = v19;
  if ( v14 )
  {
    v16 = (char *)v2 - (char *)v19;
    do
    {
      v22 = (wchar_t *)v14;
      v17 = v15;
      *v15++ = v14;
      v14 = *(wchar_t *)((char *)v15 + v16);
    }
    while ( v14 );
    if ( v15 != v19 && (_WORD)v22 == (_WORD)v23 )
      v15 = v17;
  }
  *v15 = 0;
  return wcsicmp(v19, v19);
}

//----- (00411373) --------------------------------------------------------
_WORD *__fastcall sub_411373(_WORD *a1)
{
  char *v1; // esi
  _WORD *v2; // edx
  __int64 v4; // rax
  _WORD *v5; // edx
  __int16 v6; // ax
  _WORD *v7; // ecx
  int v8; // esi
  __int16 v9; // di

  v1 = (char *)a1;
  v2 = a1 + 1;
  while ( *a1++ )
    ;
  v4 = 2i64 * (unsigned int)(a1 - v2 + 1);
  v5 = sub_40B4E9(HIDWORD(v4) != 0 ? -1 : v4);
  v6 = *(_WORD *)v1;
  if ( *(_WORD *)v1 == 34 )
  {
    v1 += 2;
    v6 = *(_WORD *)v1;
  }
  v7 = v5;
  if ( v6 )
  {
    v8 = v1 - (char *)v5;
    v9 = v6;
    do
    {
      *v7++ = v9;
      v9 = *(_WORD *)((char *)v7 + v8);
    }
    while ( v9 );
  }
  if ( *(v7 - 1) == 34 )
    --v7;
  *v7 = 0;
  return v5;
}

//----- (004113E8) --------------------------------------------------------
FILE *__fastcall sub_4113E8(wchar_t *FileName, wchar_t *Mode)
{
  wchar_t *v4; // ecx
  wchar_t v5; // ax

  if ( *FileName == 34 )
  {
    *wcsrchr(FileName, 0x22u) = 0;
    v4 = FileName;
    v5 = FileName[1];
    *FileName = v5;
    while ( v5 )
    {
      ++v4;
      v5 = v4[1];
      *v4 = v5;
    }
  }
  return wfsopen(FileName, Mode, 32);
}

//----- (0041142F) --------------------------------------------------------
int __thiscall sub_41142F(char **this, char *a2, unsigned int a3, int a4)
{
  unsigned int v4; // eax
  char *v5; // ebx
  unsigned int v6; // eax
  char *v8; // ecx
  int v9; // edx
  char *v10; // esi
  char *v11; // eax
  char *v12; // esi
  char *v14; // [esp+Ch] [ebp-4h]

  v4 = (unsigned int)this[1];
  v5 = *this;
  if ( a3 > v4 )
    return -1;
  v6 = v4 - a3;
  if ( a3 )
  {
    v8 = *this;
    v14 = &v5[2 * v6 + 2];
    v9 = 2 * (v6 + 1);
    while ( 1 )
    {
      v11 = (char *)sub_4116B4(v8, v9 >> 1, a2);
      v12 = v11;
      if ( !v11 )
        break;
      if ( !sub_4116DD(v11, a2, a3) )
        return (v12 - v5) >> 1;
      v10 = v12 + 2;
      v9 = v14 - v10;
      v8 = v10;
    }
    return -1;
  }
  return 0;
}

//----- (00411496) --------------------------------------------------------
_DWORD *__thiscall sub_411496(_DWORD *this, _DWORD *a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // edx
  unsigned int v5; // edx
  _DWORD *result; // eax

  v4 = this[1];
  if ( v4 < a3 )
    sub_403C75();
  v5 = v4 - a3;
  if ( v5 >= a4 )
    v5 = a4;
  result = a2;
  *a2 = *this + 2 * a3;
  a2[1] = v5;
  return result;
}

//----- (004114C6) --------------------------------------------------------
bool __stdcall sub_4114C6(char *a1, int a2, char *a3, int a4)
{
  return a2 == a4 && !sub_4116DD(a1, a3, a2);
}

//----- (004114EB) --------------------------------------------------------
int __fastcall sub_4114EB(int a1, unsigned int a2, unsigned int a3, __int16 *a4, int a5, int a6)
{
  unsigned int v8; // edi
  _WORD *v9; // esi
  int v10; // eax
  char v13[260]; // [esp+10h] [ebp-108h] BYREF

  if ( a3 >= a2 )
    return -1;
  memset(v13, 0, 0x100u);
  v8 = a1 + 2 * a2;
  v9 = (_WORD *)(a1 + 2 * a3);
  if ( !sub_411684(v13, a4, &a4[a5]) )
  {
    while ( (unsigned int)v9 < v8 )
    {
      if ( !sub_4116B4(a4, a5, v9) )
        return ((int)v9 - a1) >> 1;
      ++v9;
    }
    return -1;
  }
  if ( (unsigned int)v9 >= v8 )
    return -1;
  while ( 1 )
  {
    v10 = (unsigned __int16)*v9;
    if ( (unsigned __int16)v10 >= 0x100u || !v13[v10] )
      break;
    if ( (unsigned int)++v9 >= v8 )
      return -1;
  }
  return ((int)v9 - a1) >> 1;
}
// 4114EB: using guessed type char var_108[260];

//----- (004115AD) --------------------------------------------------------
int __fastcall sub_4115AD(_WORD *a1, int a2, int a3, __int16 *a4, int a5, int a6)
{
  unsigned int v8; // ebx
  _WORD *v9; // esi
  unsigned __int16 *v12; // ecx
  int v13; // eax
  char v14[260]; // [esp+10h] [ebp-108h] BYREF

  if ( !a5 || !a2 )
    return -1;
  memset(v14, 0, 0x100u);
  v8 = (unsigned int)&a1[a2];
  if ( !sub_411684(v14, a4, &a4[a5]) )
  {
    v9 = a1;
    if ( (unsigned int)a1 >= v8 )
      return -1;
    while ( !sub_4116B4(a4, a5, v9) )
    {
      if ( (unsigned int)++v9 >= v8 )
        return -1;
    }
    return v9 - a1;
  }
  v12 = a1;
  if ( (unsigned int)a1 >= v8 )
    return -1;
  while ( 1 )
  {
    v13 = *v12;
    if ( (unsigned __int16)v13 < 0x100u )
    {
      if ( v14[v13] )
        break;
    }
    if ( (unsigned int)++v12 >= v8 )
      return -1;
  }
  return v12 - a1;
}
// 4115AD: using guessed type char var_108[260];

//----- (00411684) --------------------------------------------------------
char __thiscall sub_411684(_BYTE *this, __int16 *a2, __int16 *a3)
{
  __int16 v4; // ax

  while ( 1 )
  {
    if ( a2 == a3 )
      return 1;
    v4 = *a2;
    if ( (unsigned __int16)*a2 >= 0x100u )
      break;
    ++a2;
    this[(unsigned __int8)v4] = 1;
  }
  return 0;
}

//----- (004116B4) --------------------------------------------------------
_WORD *__fastcall sub_4116B4(_WORD *a1, int a2, _WORD *a3)
{
  int v3; // esi

  v3 = 0;
  if ( a2 )
  {
    while ( *a1 != *a3 )
    {
      if ( a2 == 1 )
        return (_WORD *)v3;
      --a2;
      ++a1;
    }
    return a1;
  }
  return (_WORD *)v3;
}

//----- (004116DD) --------------------------------------------------------
int __fastcall sub_4116DD(char *a1, char *a2, int a3)
{
  int v3; // edi
  int result; // eax
  int v5; // ebx
  bool v6; // cc
  unsigned __int16 v7; // si

  v3 = a3;
  result = 0;
  if ( a3 )
  {
    if ( *(_WORD *)a1 < *(_WORD *)a2 )
    {
      return -1;
    }
    else
    {
      v5 = a1 - a2;
      v6 = *(_WORD *)a1 <= *(_WORD *)a2;
      while ( v6 )
      {
        if ( v3 == 1 )
          return result;
        a2 += 2;
        --v3;
        v7 = *(_WORD *)&a2[v5];
        v6 = v7 <= *(_WORD *)a2;
        if ( v7 < *(_WORD *)a2 )
          return -1;
      }
      return 1;
    }
  }
  return result;
}

//----- (00411724) --------------------------------------------------------
void __noreturn sub_411724()
{
  std::_Xlength_error("string too long");
}
// 4380C4: using guessed type void __cdecl __noreturn std::_Xlength_error(const char *);

//----- (00411730) --------------------------------------------------------
_DWORD *__thiscall sub_411730(_DWORD *this)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 0;
  this[1] = "bad array new length";
  *this = &off_402654;
  return result;
}
// 402654: using guessed type int (__thiscall *off_402654)(void *Block, char);

//----- (00411748) --------------------------------------------------------
int __thiscall sub_411748(_DWORD *this)
{
  *this = &off_402654;
  return _std_exception_destroy(this + 1);
}
// 402654: using guessed type int (__thiscall *off_402654)(void *Block, char);
// 4380F0: using guessed type int __cdecl _std_exception_destroy(_DWORD);

//----- (0041175A) --------------------------------------------------------
char *__thiscall sub_41175A(char *Block, char a2)
{
  *(_DWORD *)Block = &off_402654;
  _std_exception_destroy(Block + 4);
  if ( (a2 & 1) != 0 )
    sub_411C31(Block);
  return Block;
}
// 402654: using guessed type int (__thiscall *off_402654)(void *Block, char);
// 4380F0: using guessed type int __cdecl _std_exception_destroy(_DWORD);

//----- (00411788) --------------------------------------------------------
_DWORD *__thiscall sub_411788(_DWORD *this, int a2)
{
  sub_4117B0(this, a2);
  *this = &off_402654;
  return this;
}
// 402654: using guessed type int (__thiscall *off_402654)(void *Block, char);

//----- (004117B0) --------------------------------------------------------
_DWORD *__thiscall sub_4117B0(_DWORD *this, int a2)
{
  *this = &off_402654;
  this[1] = 0;
  this[2] = 0;
  _std_exception_copy(a2 + 4, this + 1);
  return this;
}
// 402654: using guessed type int (__thiscall *off_402654)(void *Block, char);
// 4380D8: using guessed type int __cdecl _std_exception_copy(_DWORD, _DWORD);

//----- (004117DD) --------------------------------------------------------
void __noreturn sub_4117DD()
{
  void *v0; // ecx
  int v1[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_411730(v1);
  CxxThrowException(v0, (_ThrowInfo *)&_TI3_AVbad_array_new_length_std__);
}
// 4117F3: variable 'v0' is possibly undefined
// 4117DD: using guessed type int var_C[3];

//----- (004117F9) --------------------------------------------------------
_DWORD *__thiscall sub_4117F9(void *this, unsigned int a2)
{
  size_t v2; // ecx
  void *v3; // eax
  void *v4; // ecx
  _DWORD *result; // eax

  if ( a2 > 0x7FFFFFFF )
    goto LABEL_10;
  v2 = 2 * a2;
  if ( 2 * a2 < 0x1000 )
  {
    if ( v2 )
      return sub_40B4E9(v2);
    else
      return 0;
  }
  if ( v2 + 35 <= v2 )
LABEL_10:
    sub_4117DD();
  v3 = sub_40B4E9(v2 + 35);
  v4 = v3;
  if ( !v3 )
    invalid_parameter_noinfo_noreturn();
  result = (_DWORD *)(((unsigned int)v3 + 35) & 0xFFFFFFE0);
  *(result - 1) = v4;
  return result;
}

//----- (0041184F) --------------------------------------------------------
void __stdcall sub_41184F(_DWORD *Block, int a2)
{
  void *v2; // eax

  v2 = Block;
  if ( (unsigned int)(2 * a2) >= 0x1000 )
  {
    if ( (unsigned int)Block - *(Block - 1) - 4 > 0x1F )
      invalid_parameter_noinfo_noreturn();
    v2 = (void *)*(Block - 1);
  }
  sub_411C31(v2);
}

//----- (00411889) --------------------------------------------------------
_DWORD **__thiscall sub_411889(_DWORD **this, unsigned int a2, int a3, void *Src)
{
  unsigned int v5; // esi
  unsigned int v6; // ebx
  void *v7; // ecx
  unsigned int v8; // edx
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v12; // [esp+10h] [ebp-4h]

  v5 = 2147483646;
  if ( a2 > 0x7FFFFFFE )
    sub_411724();
  v6 = (unsigned int)this[5];
  v7 = (void *)(a2 | 7);
  if ( (a2 | 7) <= 0x7FFFFFFE )
  {
    v8 = v6 >> 1;
    if ( v6 <= 2147483646 - (v6 >> 1) )
    {
      v5 = v8 + v6;
      if ( (unsigned int)v7 >= v8 + v6 )
        v5 = a2 | 7;
    }
  }
  v9 = sub_4117F9(v7, v5 + 1);
  this[5] = (_DWORD *)v5;
  v12 = v9;
  this[4] = (_DWORD *)a2;
  memcpy(v9, Src, 2 * a2);
  v10 = v12;
  *((_WORD *)v12 + a2) = 0;
  if ( v6 >= 8 )
  {
    sub_41184F(*this, v6 + 1);
    v10 = v12;
  }
  *this = v10;
  return this;
}

//----- (00411912) --------------------------------------------------------
int sub_411912(wchar_t *Buffer, size_t BufferCount, wchar_t *Format, ...)
{
  unsigned __int64 *v3; // eax
  int result; // eax
  va_list va; // [esp+14h] [ebp+14h] BYREF

  va_start(va, Format);
  v3 = (unsigned __int64 *)sub_40D136();
  result = _stdio_common_vswprintf_s(*v3, Buffer, BufferCount, Format, 0, va);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (00411940) --------------------------------------------------------
WCHAR *__thiscall sub_411940(wchar_t *FullPath)
{
  WCHAR *result; // eax
  wchar_t *v3; // esi
  _DWORD *v4; // edi
  _DWORD *v5; // esi
  void *v6; // eax
  WCHAR *Filename; // [esp+10h] [ebp-260h]
  HANDLE hFindFile; // [esp+14h] [ebp-25Ch] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+18h] [ebp-258h] BYREF

  result = sub_4081DE(FullPath, &FindFileData, &hFindFile);
  v3 = result;
  if ( result )
  {
    v4 = sub_40EB4F();
    v4[1] = sub_410C5A(FullPath, v3);
    while ( 1 )
    {
      Filename = sub_408369(&FindFileData, hFindFile);
      if ( !Filename )
        break;
      v5 = sub_40EB4F();
      v6 = sub_410C5A(FullPath, Filename);
      *v5 = v4;
      v4 = v5;
      v5[1] = v6;
    }
    return (WCHAR *)v4;
  }
  return result;
}

//----- (00411A7D) --------------------------------------------------------
int sub_411A7D()
{
  __scrt_initialize_default_local_stdio_options();
  return 0;
}
// 4121B4: using guessed type int __scrt_initialize_default_local_stdio_options(void);

//----- (00411C31) --------------------------------------------------------
void __cdecl sub_411C31(void *Block)
{
  free(Block);
}

//----- (00411E6B) --------------------------------------------------------
_DWORD *__thiscall sub_411E6B(_DWORD *Block, char a2)
{
  *Block = &type_info::`vftable';
  if ( (a2 & 1) != 0 )
    sub_411C31(Block);
  return Block;
}
// 40103C: using guessed type void *type_info::`vftable';

//----- (00412177) --------------------------------------------------------
int __cdecl UserMathErrorFunction()
{
  return 0;
}

//----- (0041217A) --------------------------------------------------------
int sub_41217A()
{
  return 1;
}

//----- (00412184) --------------------------------------------------------
void sub_412184()
{
  InitializeSListHead(&ListHead);
}

//----- (00412190) --------------------------------------------------------
char sub_412190()
{
  return 1;
}

//----- (004121D1) --------------------------------------------------------
BOOL sub_4121D1()
{
  return dword_413004 == 0;
}
// 413004: using guessed type int dword_413004;

//----- (004121DD) --------------------------------------------------------
void *sub_4121DD()
{
  return &unk_437EF0;
}

//----- (004121E3) --------------------------------------------------------
void *sub_4121E3()
{
  return &unk_437EEC;
}

//----- (0041234B) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_41234B()
{
  return SetUnhandledExceptionFilter(__scrt_unhandled_exception_filter);
}

//----- (004123AD) --------------------------------------------------------
void sub_4123AD()
{
  dword_4134E8 = 0;
}
// 4134E8: using guessed type int dword_4134E8;

//----- (004123B5) --------------------------------------------------------
void sub_4123B5()
{
  ;
}
// 4123B5: could not find valid save-restore pair for edi

//----- (004123E1) --------------------------------------------------------
void __cdecl sub_4123E1()
{
  ;
}
// 4123E1: could not find valid save-restore pair for edi

//----- (004126DD) --------------------------------------------------------
int sub_4126DD()
{
  _DWORD *v0; // eax
  int v1; // ecx
  _DWORD *v2; // eax
  int v3; // ecx

  v0 = sub_40D136();
  v1 = v0[1];
  *v0 |= 4u;
  v0[1] = v1;
  v2 = sub_40CF18();
  v3 = v2[1];
  *v2 |= 2u;
  v2[1] = v3;
  return 0;
}

// nfuncs=294 queued=225 decompiled=225 lumina nreq=0 worse=0 better=0
// ALL OK, 225 function(s) have been successfully decompiled
