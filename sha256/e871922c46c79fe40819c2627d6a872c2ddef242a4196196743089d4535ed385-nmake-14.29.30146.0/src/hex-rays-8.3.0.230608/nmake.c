/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

wchar_t *sub_402910();
_DWORD *sub_402937();
char sub_402A59();
void sub_402B16();
char __thiscall sub_402BF5(wchar_t *String1);
void __fastcall sub_402CD0(wchar_t *Control, int *a2, _DWORD *a3);
_WORD *__thiscall sub_402E3C(_DWORD *this);
char sub_402F02();
void sub_40301C();
void sub_403153();
char __fastcall sub_403260(wchar_t *Name, wchar_t *Str, int a3);
char __fastcall sub_403382(wchar_t *Name, wchar_t *Str, int a3);
void __fastcall sub_4034D5(wchar_t *Block, char a2, int a3);
void __thiscall sub_403596(_DWORD **this);
_DWORD *__thiscall sub_4036B0(_DWORD *this);
void *__thiscall sub_4036FA(void *this);
bool __fastcall sub_403702(wint_t C);
wchar_t *__fastcall sub_403727(wchar_t *Str, wchar_t Ch);
int sub_403732();
int __fastcall sub_403882(wchar_t *a1, char a2, unsigned int *a3, int a4);
int __fastcall sub_4038EE(wchar_t *a1, char a2, unsigned int *a3, wchar_t *a4, _DWORD *a5);
int __fastcall sub_403944(int a1, char a2, unsigned int *a3, char a4, wchar_t *a5, _DWORD *a6);
_DWORD *__fastcall sub_40470F(int a1, int a2);
char __fastcall sub_404AB4(__int16 **a1, _DWORD *a2);
int __thiscall sub_404BE9(_DWORD *this);
_DWORD *__fastcall sub_404C13(char *Src, char a2);
int __fastcall sub_404C5A(_DWORD *a1, int a2, int a3, int a4);
wchar_t **__thiscall sub_404D06(_DWORD *this);
int __thiscall sub_404E5B(_DWORD *this);
void __thiscall sub_404E79(_DWORD *this);
wchar_t *__fastcall sub_404EA8(wchar_t **a1, int *a2);
void *__fastcall sub_404FB3(char *a1, int a2, void **a3);
char *__fastcall sub_405021(wchar_t *Str, int *a2, void **a3);
void __fastcall sub_4050AD(wchar_t *a1, int *a2, void **a3);
void __thiscall sub_40525E(wchar_t *FileName);
int sub_4053F6(int a1, unsigned int a2, ...);
void sub_4054D0(unsigned int a1, ...);
int sub_40556C();
void sub_405598();
size_t __fastcall sub_4055D7(_DWORD *a1, const wchar_t **a2, wchar_t *String);
wchar_t **__fastcall sub_40573E(char *Src, _DWORD *a2, int a3, char a4, const wchar_t *a5);
wchar_t **__fastcall sub_405780(_DWORD *a1, _DWORD *a2, int a3, char a4, const wchar_t *a5);
wchar_t **__fastcall sub_405BD5(wchar_t *a1, int a2, wchar_t **ArgList);
wchar_t *__fastcall sub_405CF0(int a1, wchar_t **a2);
char *__thiscall sub_406308(wchar_t *Str);
char __fastcall sub_406406(int a1, wint_t **a2, int *a3);
char __fastcall sub_4065BD(wchar_t *FileName, int a2);
char __fastcall sub_4066DC(wchar_t *String, rsize_t a2, int *a3, int *a4);
int __stdcall sub_4068E0(int a1);
bool __fastcall sub_4068E6(_WORD *a1, _DWORD *a2);
char __fastcall sub_40699D(wchar_t *FullPath, wchar_t *a2, int a3);
wchar_t **__fastcall sub_406E33(wchar_t *Source, char a2, char a3, char a4, void **a5);
void *sub_4075C7();
char __fastcall sub_407663(__int16 *a1, int a2, char a3, unsigned __int8 a4, const wchar_t *a5, wchar_t ***a6);
void __fastcall sub_4078C7(int a1, __int16 **a2);
void __fastcall sub_407951(int ArgList, char a2);
__int64 __thiscall sub_4079E0(char *this);
WCHAR *__fastcall sub_4079FA(wchar_t *Str, LPWIN32_FIND_DATAW lpFindFileData, HANDLE *a3);
WCHAR *__fastcall sub_407B86(LPWIN32_FIND_DATAW lpFindFileData, HANDLE hFindFile);
void *__fastcall sub_407BA9(wchar_t *a1, wchar_t *a2, struct _WIN32_FIND_DATAW *lpFindFileData, HANDLE *a4);
char __fastcall sub_407C98(_WORD *Block, LPWIN32_FIND_DATAW lpFindFileData);
char __fastcall sub_407D27(wchar_t *Str, _DWORD *a2);
int sub_407E9D();
wchar_t *sub_408046();
wchar_t *__fastcall sub_408182(wchar_t *String1, char *a2);
int __thiscall sub_4082F1(wint_t *this);
char __fastcall sub_40846A(wchar_t *String1, int a2, wchar_t **a3);
// char __usercall sub_408646@<al>(char a1@<dl>, wchar_t *a2@<ecx>, int a3@<ebp>);
char sub_408888();
char __stdcall sub_408971(int a1);
wint_t *__fastcall sub_408A23(wint_t *a1, int a2);
wchar_t *__fastcall sub_408A91(const wchar_t *a1);
void *__thiscall sub_408B25(__int16 **this);
wchar_t *__fastcall sub_408C27(wchar_t *a1, _DWORD *a2, wchar_t **a3);
errno_t __fastcall sub_408F3E(void **a1, wchar_t *a2);
int __fastcall sub_40901B(wchar_t *Source, const unsigned __int16 *a2, char a3);
wchar_t *__fastcall sub_40918C(FILE *a1, int a2, const wchar_t **a3, char a4, _BYTE *a5);
char __fastcall sub_4093B0(wchar_t *Str, const wchar_t **a2, wchar_t *a3, char a4);
int sub_4097A9();
wint_t __fastcall sub_409811(char a1);
unsigned __int8 __fastcall sub_409896(wchar_t a1);
unsigned __int8 __fastcall sub_40997A(wint_t Character, _WORD *a2, int a3);
char __fastcall sub_409B97(int a1, char a2);
__int16 __fastcall sub_409C3C(char a1);
wint_t __fastcall sub_409D15(wint_t a1, char a2);
wchar_t *__fastcall sub_409DC6(char a1, int a2, int a3);
const unsigned __int16 *__fastcall sub_40A375(const unsigned __int16 *a1, unsigned int a2);
unsigned __int8 __thiscall sub_40A618(wchar_t *String);
wchar_t *__thiscall sub_40AABF(wchar_t *FullPath);
int __thiscall sub_40AB97(const unsigned __int16 *this);
int sub_40AC2B();
void *__thiscall sub_40AC3C(size_t Size);
void *__thiscall sub_40AC61(size_t Size);
void *__fastcall sub_40AC7F(void *Block, size_t Size);
int __fastcall sub_40ACB5(wchar_t *Source, wchar_t *a2, int a3, int a4, int a5, int a6, int a7, int a8);
wchar_t **__thiscall sub_40B29E(int this, wchar_t **String, int Radix, wchar_t ***a4);
void __cdecl Handler(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); // idb
void __thiscall sub_40B409(void *this);
BOOL __fastcall sub_40B410(const void **a1, void *a2, void *a3);
int __cdecl main(int argc, const char **argv, const char **envp);
char *sub_40B886();
int __fastcall sub_40B9E8(int a1, int a2, int a3);
int sub_40BBDD();
char *sub_40BD27();
void __fastcall sub_40BDF3(unsigned int a1, int a2);
void *sub_40C0FD();
int __fastcall sub_40C1CD(wint_t C, char a2);
void __cdecl Function();
int sub_40C479();
const unsigned __int16 *__fastcall sub_40C4B7(const unsigned __int16 *a1);
int __fastcall sub_40C50D(unsigned int a1);
void *sub_40C62E();
int sub_40C634(wchar_t *Buffer, wchar_t *Format, ...);
bool __thiscall sub_40C65E(FILE *Stream);
bool sub_40C69E();
int sub_40C6C9();
int sub_40C6E7(wchar_t *Format, ...);
int sub_40C6F6();
bool __thiscall sub_40C722(FILE *Stream);
int __fastcall sub_40C75F(wchar_t *Format, va_list ArgList); // idb
int sub_40C7A9();
int sub_40C7C7(wchar_t *Format, ...);
int sub_40C7D6();
int __fastcall sub_40C802(wchar_t *Format, va_list ArgList); // idb
void *sub_40C84C();
int __thiscall sub_40C852(void *this);
unsigned int __fastcall sub_40CA36(int a1, _WORD *a2);
void __fastcall sub_40CA65(int a1, int a2, FILETIME FileTime);
void __fastcall sub_40CB1F(int a1, int a2);
int sub_40CD28();
int sub_40CD99();
int sub_40CE39();
char __stdcall sub_40CF8E(char a1);
char __stdcall sub_40D1DE(char a1);
wchar_t *sub_40D21C();
wchar_t *sub_40D293();
int __fastcall sub_40D34A(char a1, int a2);
wchar_t *sub_40D3B8();
int sub_40D4C9();
int sub_40D7A4();
bool sub_40D815();
bool __thiscall sub_40D938(wchar_t *String);
bool __fastcall sub_40D9A7(wchar_t *String, char a2);
void **__fastcall sub_40DA04(wchar_t *Destination, rsize_t a2, wchar_t *Str, int a4, LPWIN32_FIND_DATAW lpFindFileData);
void sub_40DE73();
void **__fastcall sub_40E069(int a1, wchar_t *a2, int a3, unsigned __int64 a4, _DWORD **a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, wchar_t **a9);
_DWORD *sub_40E215();
void *__thiscall sub_40E267(char *Src);
_WORD *__thiscall sub_40E2AB(char *this);
wchar_t *__fastcall sub_40E311(char *Block, const wchar_t *a2);
_DWORD *__fastcall sub_40E36C(_DWORD **a1, _DWORD *a2);
int __thiscall sub_40E381(wint_t *this, int a2);
_DWORD *__thiscall sub_40E3B9(wchar_t *Source, int a2, int a3);
char __fastcall sub_40E549(_WORD *a1, int **a2, int *a3, const unsigned __int16 *a4, int a5, int a6, int a7);
wint_t *__fastcall sub_40EA82(wint_t *a1, wint_t *a2);
_WORD *__thiscall sub_40EB81(_WORD *this);
wchar_t *__thiscall sub_40EC1B(wchar_t *Str);
void *__fastcall sub_40EC83(__int16 *a1, char a2, _DWORD *a3);
char **__fastcall sub_40EFD8(const void **a1, _DWORD *a2, char **a3, unsigned int *a4, const void *a5);
void __fastcall sub_40F04C(const void **a1, __int16 **a2, char **a3, char **a4, unsigned int *a5, char *a6, const void *a7);
wchar_t *__fastcall sub_40F3BE(__int16 a1, wchar_t *a2, rsize_t SizeInWords, wchar_t *Source);
__int16 *__fastcall sub_40F516(const void **a1, __int16 **a2, char **a3, char **a4, wchar_t *String1, unsigned int *a6, const void *a7);
void __fastcall sub_40F646(const void **a1, __int16 **a2, char **a3, char **a4, wchar_t *String1, unsigned int *a6, const void *a7);
void *__fastcall sub_40F89E(wchar_t *FullPath, wchar_t *Filename);
char __thiscall sub_40F912(_WORD *this);
char __fastcall sub_40FA87(char *a1, int a2, unsigned __int16 *a3, const wchar_t *a4);
_DWORD *__thiscall sub_40FD85(wint_t *this, int a2);
int __fastcall sub_40FE3D(_WORD *a1, int a2);
_WORD *__fastcall sub_40FF51(_WORD *a1);
FILE *__fastcall sub_40FFC6(wchar_t *FileName, wchar_t *Mode);
void *__fastcall sub_41000E(void *Block, unsigned int a2);
int sub_41005A(wchar_t *Buffer, size_t BufferCount, wchar_t *Format, ...);
WCHAR *__thiscall sub_410088(wchar_t *FullPath);
int sub_4101BF();
// void __noreturn __report_rangecheckfailure(void); weak
int __cdecl UserMathErrorFunction();
int sub_41088B();
void sub_410895();
char sub_4108A1();
// int __scrt_initialize_default_local_stdio_options(void); weak
BOOL sub_4108E2();
void *sub_4108EE();
void *sub_4108F4();
LPTOP_LEVEL_EXCEPTION_FILTER sub_410A5D();
// LONG __stdcall __scrt_unhandled_exception_filter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
void sub_410ABF();
void sub_410AC7();
void __cdecl sub_410AF3(); // idb
// void *__cdecl memset(void *, int Val, size_t Size);
int sub_410DEA();
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl memmove(void *, const void *Src, size_t Size);

//-------------------------------------------------------------------------
// Data declarations

char byte_401060[] = { '\0' }; // weak
wchar_t **off_401170[12] =
{
  &off_401210,
  &off_401204,
  &off_4011F8,
  &off_4011EC,
  &off_4011E0,
  &off_4011EC,
  &off_4011E0,
  &off_4011D4,
  &off_4011C8,
  &off_4011BC,
  &off_4011B0,
  &off_4011A4
}; // weak
void *const off_401240 = &aSuffixes_0; // idb
char byte_401280[] = { '\x01' }; // weak
char byte_4013A0[] = { '\x01' }; // weak
char byte_4013A1[] = { '\x02' }; // weak
int (*funcs_40C8D0[6])() = { &sub_402910, &sub_402937, &sub_403153, &sub_402F02, &sub_402B16, &sub_40301C }; // weak
char byte_401480[] = { '\x01' }; // weak
char byte_4014A0[] = { '\"' }; // weak
_UNKNOWN off_4014E0; // weak
char byte_401570[] = { '\0' }; // weak
char byte_401590[] = { '\0' }; // weak
int dword_401690 = 0; // weak
const wchar_t aPa[] = L"PA"; // idb
const wchar_t aPa_0[] = L"PA"; // idb
int dword_401938 = 65279; // weak
void *off_4022D0 = (void *)0x41004D; // weak
void *off_4022DC = (void *)0x41004D; // weak
const wchar_t aMa[] = L"MA"; // idb
int dword_411004 = 1; // weak
char byte_411020 = '\x01'; // weak
char byte_411021 = '\x01'; // weak
int dword_411024 = -1; // weak
int dword_411028 = -1; // weak
wchar_t aMakeflags[29] = L"MAKEFLAGS=                  "; // weak
int dword_411068 = 1; // weak
wchar_t *off_411070 = L"("; // weak
_UNKNOWN unk_411118; // weak
union _SLIST_HEADER ListHead; // idb
int dword_411468; // weak
int dword_411480; // weak
int dword_411484; // weak
wchar_t *dword_411488; // idb
char byte_41148C; // weak
char byte_41148D; // weak
char byte_41148E; // weak
char byte_41148F; // weak
wchar_t Destination; // idb
wchar_t Str; // idb
int dword_421490[128]; // weak
int dword_421690; // weak
void *dword_421694; // idb
int dword_421698; // idb
int dword_42169C; // weak
int dword_4216A0; // weak
int dword_4216A4; // weak
int dword_4216A8; // weak
wchar_t *dword_4216AC; // idb
int dword_4216B0; // weak
char byte_4216B4; // weak
char byte_4216B5; // weak
char byte_4216B6; // weak
char byte_4216B7; // weak
wchar_t *Block; // idb
int dword_4216BC; // weak
wchar_t Src; // idb
wchar_t word_4216C2; // idb
__int16 word_421EBC; // weak
int dword_421EC0; // weak
int dword_421EC4; // weak
int dword_421EC8; // weak
void *dword_421ECC; // idb
int dword_421ED0; // weak
wchar_t *dword_421ED4; // idb
int dword_421ED8; // weak
FILE *Stream; // idb
char byte_421EE0; // weak
char byte_421EE1; // weak
char byte_421EE2; // weak
char byte_421EE3; // weak
void *ArgList; // idb
wchar_t *dword_421EE8; // idb
int dword_421EEC; // weak
wchar_t word_421EF0[32768]; // weak
int dword_431EF0; // weak
int dword_431EF4; // weak
void *dword_431EF8; // idb
wchar_t *dword_431EFC; // idb
char byte_431F00[]; // weak
_UNKNOWN unk_431F10; // weak
char byte_43230F[]; // weak
char byte_432310[]; // weak
char byte_432311[]; // weak
int dword_432320; // weak
int dword_432324; // weak
int dword_432328; // weak
int dword_43232C; // weak
int dword_432330[]; // weak
int dword_432334[]; // weak
int dword_432338[]; // weak
int dword_4323F0; // weak
int dword_4323F4; // weak
char byte_4323F8; // weak
char byte_4323F9; // weak
char byte_4323FA; // weak
char byte_4323FB; // weak
char byte_4323FC; // weak
char byte_4323FD; // weak
char byte_4323FE; // weak
char byte_4323FF; // weak
_UNKNOWN unk_432400; // weak
char byte_432602; // weak
int dword_432604; // weak
int dword_432608; // weak
int dword_43260C; // weak
int dword_432610; // weak
wchar_t *EndPtr; // idb
int dword_432618; // weak
_UNKNOWN unk_432620; // weak
_UNKNOWN unk_434618; // weak
unsigned __int8 byte_434620[4088]; // weak
_UNKNOWN unk_435618; // weak
int dword_435620; // weak
int dword_435624; // weak
int dword_435628; // weak
char byte_43562C; // weak
int dword_435630; // weak
_UNKNOWN unk_435638; // weak
PVOID dword_435640; // idb
PVOID Ptr; // idb
_UNKNOWN unk_435648; // weak
int dword_435654; // weak
wchar_t word_435660[1024]; // weak
char byte_435E60; // weak
HMODULE hModule; // idb
__int16 word_435E68; // weak
_UNKNOWN unk_435E6C; // weak
_UNKNOWN unk_435E70; // weak
// extern HRSRC (__stdcall *FindResourceExW)(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage);
// extern HGLOBAL (__stdcall *LoadResource)(HMODULE hModule, HRSRC hResInfo);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern BOOL (__stdcall *GetExitCodeProcess)(HANDLE hProcess, LPDWORD lpExitCode);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern UINT (__stdcall *GetTempFileNameW)(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *SetFileTime)(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *GetFileTime)(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern HMODULE (__stdcall *LoadLibraryExW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// extern DWORD (__stdcall *GetLastError)();
// extern DWORD (__stdcall *GetEnvironmentVariableW)(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// extern PVOID (__stdcall *EncodePointer)(PVOID Ptr);
// extern PVOID (__stdcall *DecodePointer)(PVOID Ptr);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern LANGID (__stdcall *GetUserDefaultUILanguage)();
// extern UINT (__stdcall *SetErrorMode)(UINT uMode);
// extern BOOL (__stdcall *GetFileSizeEx)(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// extern DWORD (__stdcall *GetFileType)(HANDLE hFile);
// extern BOOL (__stdcall *GetConsoleMode)(HANDLE hConsoleHandle, LPDWORD lpMode);
// extern BOOL (__stdcall *FileTimeToLocalFileTime)(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
// extern BOOL (__stdcall *FileTimeToSystemTime)(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
// extern int (__stdcall *GetDateFormatW)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate);
// extern int (__stdcall *GetTimeFormatW)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern wchar_t *(__cdecl *wcsstr)(const wchar_t *Str, const wchar_t *SubStr);
// extern wchar_t *(__cdecl *wcsrchr)(const wchar_t *Str, wchar_t Ch);
// extern wchar_t *(__cdecl *wcschr)(const wchar_t *Str, wchar_t Ch);
// extern wint_t (__cdecl *putwch)(wchar_t Character);
// extern int (__cdecl *_conio_common_vcwprintf)(unsigned __int64 Options, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern unsigned int (__cdecl *wcstoul)(const wchar_t *String, wchar_t **EndPtr, int Radix);
// extern errno_t (__cdecl *itow_s)(int Value, wchar_t *Buffer, size_t BufferCount, int Radix);
// extern int (__cdecl *wcstol)(const wchar_t *String, wchar_t **EndPtr, int Radix);
// extern errno_t (__cdecl *wgetenv_s)(size_t *RequiredCount, wchar_t *Buffer, size_t BufferCount, const wchar_t *VarName);
// extern errno_t (__cdecl *wputenv_s)(const wchar_t *Name, const wchar_t *Value);
// extern errno_t (__cdecl *wdupenv_s)(wchar_t **Buffer, size_t *BufferCount, const wchar_t *VarName);
// extern int (__cdecl *wputenv)(const wchar_t *EnvString);
// extern wchar_t *(__cdecl *wgetcwd)(wchar_t *DstBuf, int SizeInWords);
// extern wchar_t ***(__cdecl *_p__wenviron)();
// extern void (__cdecl *wsearchenv)(const wchar_t *Filename, const wchar_t *VarName, wchar_t *ResultPath);
// extern errno_t (__cdecl *wsplitpath_s)(const wchar_t *FullPath, wchar_t *Drive, size_t DriveCount, wchar_t *Dir, size_t DirCount, wchar_t *Filename, size_t FilenameCount, wchar_t *Ext, size_t ExtCount);
// extern int (__cdecl *wremove)(const wchar_t *FileName);
// extern int (__cdecl *chdrive)(int Drive);
// extern errno_t (__cdecl *waccess_s)(const wchar_t *FileName, int AccessMode);
// extern int (__cdecl *wunlink)(const wchar_t *FileName);
// extern int (__cdecl *waccess)(const wchar_t *FileName, int AccessMode);
// extern int (__cdecl *wchdir)(const wchar_t *Path);
// extern errno_t (__cdecl *wmakepath_s)(wchar_t *Buffer, size_t BufferCount, const wchar_t *Drive, const wchar_t *Dir, const wchar_t *Filename, const wchar_t *Ext);
// extern void (__cdecl *free)(void *Block);
// extern void *(__cdecl *malloc)(size_t Size);
// extern void *(__cdecl *realloc)(void *Block, size_t Size);
// extern char *(__cdecl *setlocale)(int Category, const char *Locale);
// extern intptr_t (__cdecl *wspawnvp)(int Mode, const wchar_t *FileName, const wchar_t *const *ArgList);
// extern errno_t (__cdecl *wcserror_s)(wchar_t *Buffer, size_t SizeInWords, int ErrorNumber);
// extern int *(__cdecl *errno)();
// extern _invalid_parameter_handler (__cdecl *set_invalid_parameter_handler)(_invalid_parameter_handler Handler);
// extern _crt_signal_t (__cdecl *signal)(int Signal, _crt_signal_t Function);
// extern void (__cdecl __noreturn *exit)(int Code);
// extern wchar_t **(__cdecl *_p__wpgmptr)();
// extern unsigned int *(__cdecl *_doserrno)();
// extern errno_t (__cdecl *wsopen_s)(int *FileHandle, const wchar_t *FileName, int OpenFlag, int ShareFlag, int PermissionFlag);
// extern int (__cdecl *_stdio_common_vfwprintf)(unsigned __int64 Options, FILE *Stream, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern int (__cdecl *dup2)(int FileHandleSrc, int FileHandleDst);
// extern int (__cdecl *fileno)(FILE *Stream);
// extern wint_t (__cdecl *fputwc)(wchar_t Character, FILE *Stream);
// extern FILE *(__cdecl *_acrt_iob_func)(unsigned int Ix);
// extern int (__cdecl *close)(int FileHandle);
// extern int (__cdecl *fflush)(FILE *Stream);
// extern int (__cdecl *fcloseall)();
// extern int (__cdecl *lseek)(int FileHandle, int Offset, int Origin);
// extern int (__cdecl *dup)(int FileHandle);
// extern errno_t (__cdecl *wfopen_s)(FILE **Stream, const wchar_t *FileName, const wchar_t *Mode);
// extern wint_t (__cdecl *ungetwc)(wint_t Character, FILE *Stream);
// extern int (__cdecl *setvbuf)(FILE *Stream, char *Buffer, int Mode, size_t Size);
// extern intptr_t (__cdecl *get_osfhandle)(int FileHandle);
// extern int (__cdecl *fclose)(FILE *Stream);
// extern int (__cdecl *_stdio_common_vswscanf)(unsigned __int64 Options, const wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern int (__cdecl *feof)(FILE *Stream);
// extern wint_t (__cdecl *getwc)(FILE *Stream);
// extern wchar_t *(__cdecl *fgetws)(wchar_t *Buffer, int BufferCount, FILE *Stream);
// extern int (__cdecl *_stdio_common_vswprintf_s)(unsigned __int64 Options, wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern FILE *(__cdecl *wfsopen)(const wchar_t *FileName, const wchar_t *Mode, int ShFlag);
// extern size_t (__cdecl *fwrite)(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// extern errno_t (__cdecl *wcsncat_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source, rsize_t MaxCount);
// extern errno_t (__cdecl *wcsncpy_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source, rsize_t MaxCount);
// extern wint_t (__cdecl *towupper)(wint_t C);
// extern int (__cdecl *wcsncmp)(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// extern int (__cdecl *iswalpha)(wint_t C);
// extern errno_t (__cdecl *wcscat_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// extern errno_t (__cdecl *wcscpy_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// extern int (__cdecl *wcsnicmp)(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// extern wchar_t *(__cdecl *wcstok_s)(wchar_t *String, const wchar_t *Delimiter, wchar_t **Context);
// extern int (__cdecl *iswdigit)(wint_t C);
// extern int (__cdecl *iswspace)(wint_t C);
// extern wchar_t *(__cdecl *wcspbrk)(const wchar_t *String, const wchar_t *Control);
// extern int (__cdecl *wcsicmp)(const wchar_t *String1, const wchar_t *String2);
// extern size_t (__cdecl *wcsspn)(const wchar_t *String, const wchar_t *Control);
// extern errno_t (__cdecl *wcsupr_s)(wchar_t *String, size_t Size);


//----- (00402910) --------------------------------------------------------
wchar_t *sub_402910()
{
  wchar_t *result; // eax

  sub_40E549(&Src, (int **)&dword_4216BC, 0, 0, 0, 0, 0);
  result = (wchar_t *)sub_40E267((char *)&Src);
  Block = result;
  return result;
}
// 4216BC: using guessed type int dword_4216BC;

//----- (00402937) --------------------------------------------------------
_DWORD *sub_402937()
{
  _DWORD *v0; // eax
  char v1; // dl
  _DWORD *v2; // esi
  void *v3; // eax
  int *v4; // esi
  int *v5; // eax
  int v6; // ecx
  _DWORD *v8; // [esp+Ch] [ebp-4h] BYREF

  if ( Block )
  {
    byte_4216B4 |= 0x20u;
    sub_402A59();
    Block = 0;
  }
  if ( (byte_4216B4 & 0x20) != 0 && sub_40F912(&Src) )
  {
    if ( (byte_4216B4 & 0x10) != 0 )
      sub_4053F6(dword_4216B0, 0x444u);
    sub_4053F6(dword_4216B0, 0x43Du);
  }
  v0 = sub_40E215();
  v1 = byte_4216B4;
  v2 = v0;
  if ( (byte_4216B4 & 0x40) != 0 )
  {
    v0[1] = dword_4216AC;
    dword_4216AC = 0;
  }
  else
  {
    v3 = sub_40E267((char *)&Src);
    v1 = byte_4216B4;
    v2[1] = v3;
  }
  v8 = v2;
  if ( (v1 & 0x30) != 16 )
  {
    sub_40E549((_WORD *)v2[1], (int **)&dword_4216BC, 0, 0, 0, 0, 0);
    v1 = byte_4216B4;
  }
  if ( (v1 & 0x20) != 0 )
  {
    v4 = (int *)dword_4216BC;
    sub_402CD0((wchar_t *)L"$", (int *)&v8, &dword_4216BC);
    sub_402CD0((wchar_t *)L"*?", (int *)&v8, 0);
    v5 = v4;
    dword_4216BC = (int)v4;
    if ( v4 )
    {
      v6 = dword_432618;
      do
      {
        v4 = (int *)*v4;
        *v5 = v6;
        v6 = (int)v5;
        v5 = v4;
        dword_4216BC = (int)v4;
      }
      while ( v4 );
      dword_432618 = v6;
    }
  }
  return sub_40E36C((_DWORD **)&dword_4216A8, v8);
}
// 4216A8: using guessed type int dword_4216A8;
// 4216B0: using guessed type int dword_4216B0;
// 4216B4: using guessed type char byte_4216B4;
// 4216BC: using guessed type int dword_4216BC;
// 432618: using guessed type int dword_432618;

//----- (00402A59) --------------------------------------------------------
char sub_402A59()
{
  _DWORD *v0; // eax
  int *v1; // esi
  int *v2; // eax
  int v3; // ecx
  int v4; // ecx

  byte_41148F = byte_41148E;
  v0 = sub_40E215();
  v0[1] = Block;
  v1 = (int *)dword_4216BC;
  dword_4216A8 = (int)v0;
  sub_402CD0((wchar_t *)L"$", &dword_4216A8, &dword_4216BC);
  sub_402CD0((wchar_t *)L"*?", &dword_4216A8, 0);
  v2 = v1;
  dword_4216BC = (int)v1;
  if ( v1 )
  {
    v3 = dword_432618;
    do
    {
      v1 = (int *)*v1;
      *v2 = v3;
      v3 = (int)v2;
      v2 = v1;
      dword_4216BC = (int)v1;
    }
    while ( v1 );
    dword_432618 = v3;
  }
  v4 = dword_4216A8;
  if ( dword_4216A8
    || (byte_4216B4 & 0x20) == 0 && (LOBYTE(v2) = sub_4053F6(dword_4216A4, 0x43Bu, Block), (v4 = dword_4216A8) != 0) )
  {
    LOBYTE(v2) = sub_40F912(*(_WORD **)(v4 + 4));
    if ( (_BYTE)v2 )
      byte_4216B4 |= 0x10u;
  }
  return (char)v2;
}
// 41148E: using guessed type char byte_41148E;
// 41148F: using guessed type char byte_41148F;
// 4216A4: using guessed type int dword_4216A4;
// 4216A8: using guessed type int dword_4216A8;
// 4216B4: using guessed type char byte_4216B4;
// 4216BC: using guessed type int dword_4216BC;
// 432618: using guessed type int dword_432618;

//----- (00402B16) --------------------------------------------------------
void sub_402B16()
{
  char v0; // bl
  int v1; // esi
  _DWORD *v2; // eax
  int v3; // eax

  if ( Block )
  {
    sub_402A59();
    Block = 0;
  }
  else
  {
    byte_4216B4 &= ~0x20u;
  }
  v0 = byte_41148F;
  if ( word_4216C2 )
  {
    v0 = byte_41148F | 0x20;
    byte_41148F |= 0x20u;
  }
  v1 = dword_4216A8;
  if ( !dword_4216A8 )
    sub_4053F6(dword_4216B0, 0x40Du);
  if ( (byte_4216B4 & 0x10) != 0 )
  {
    v2 = sub_40AC61(0x18u);
    v2[2] = *(_DWORD *)(v1 + 4);
    *((_BYTE *)v2 + 20) = (v0 & 0x20) != 0;
    *v2 = dword_421694;
    dword_421694 = v2;
    if ( *v2 )
      *(_DWORD *)(*v2 + 4) = v2;
    goto LABEL_14;
  }
  if ( *(_DWORD *)v1 )
  {
LABEL_16:
    dword_411480 = v1;
    goto LABEL_17;
  }
  if ( !sub_402BF5(*(wchar_t **)(v1 + 4)) )
  {
    v1 = dword_4216A8;
    goto LABEL_16;
  }
  free(*(void **)(dword_4216A8 + 4));
LABEL_14:
  v3 = dword_432618;
  dword_432618 = dword_4216A8;
  *(_DWORD *)dword_4216A8 = v3;
LABEL_17:
  dword_4216A8 = 0;
  byte_4216B4 |= 0x80u;
}
// 411480: using guessed type int dword_411480;
// 41148F: using guessed type char byte_41148F;
// 4216A8: using guessed type int dword_4216A8;
// 4216B0: using guessed type int dword_4216B0;
// 4216B4: using guessed type char byte_4216B4;
// 432618: using guessed type int dword_432618;

//----- (00402BF5) --------------------------------------------------------
char __thiscall sub_402BF5(wchar_t *String1)
{
  wchar_t *v1; // esi
  int v2; // ebx
  int v3; // eax
  const wchar_t *v5; // eax
  bool v6; // cf
  wchar_t v7; // cx
  char v8; // [esp+Fh] [ebp-1h]

  v1 = String1;
  v2 = 0;
  v8 = 0;
  if ( !wcsicmp(String1, L".SILENT") )
  {
    byte_4216B4 |= 2u;
    sub_40C1CD(0x73u, 1);
    v8 = 1;
  }
  if ( !wcsicmp(v1, L".IGNORE") )
  {
    byte_4216B4 |= 4u;
    sub_40C1CD(0x69u, 1);
    return 1;
  }
  v3 = wcscmp(v1, L".SUFFIXES");
  if ( v3 )
    v3 = v3 < 0 ? -1 : 1;
  if ( !v3 )
  {
    byte_4216B4 |= 1u;
    return 1;
  }
  v5 = L".PRECIOUS";
  while ( 1 )
  {
    v6 = *v1 < *v5;
    if ( *v1 != *v5 )
      break;
    if ( !*v1 )
      goto LABEL_17;
    v7 = v1[1];
    v6 = v7 < v5[1];
    if ( v7 != v5[1] )
      break;
    v1 += 2;
    v5 += 2;
    if ( !v7 )
      goto LABEL_17;
  }
  v2 = v6 ? -1 : 1;
LABEL_17:
  if ( !v2 )
  {
    byte_4216B4 |= 8u;
    return 1;
  }
  return v8;
}
// 401124: using guessed type wchar_t aPrecious[10];
// 401138: using guessed type wchar_t aSuffixes[10];
// 4216B4: using guessed type char byte_4216B4;

//----- (00402CD0) --------------------------------------------------------
void __fastcall sub_402CD0(wchar_t *Control, int *a2, _DWORD *a3)
{
  int v3; // esi
  int *v4; // ebx
  _DWORD *v5; // edi
  __int16 *v6; // ecx
  void *v7; // eax
  int v8; // eax
  int *v9; // edx
  int *v10; // eax
  void *v11; // eax
  int *v12; // ecx
  char *v13; // esi
  int *v14; // ecx
  void *v15; // [esp-4h] [ebp-2Ch]
  _DWORD *v16; // [esp+Ch] [ebp-1Ch] BYREF
  int *v17; // [esp+10h] [ebp-18h]
  void *Block; // [esp+14h] [ebp-14h]
  wchar_t *v19; // [esp+18h] [ebp-10h]
  void *v20; // [esp+1Ch] [ebp-Ch] BYREF
  void *v21; // [esp+20h] [ebp-8h]
  int v22; // [esp+24h] [ebp-4h]

  v17 = a2;
  v3 = *a2;
  v4 = 0;
  v5 = 0;
  v19 = Control;
  Block = 0;
  v16 = 0;
  v21 = 0;
  while ( v3 )
  {
    if ( !wcspbrk(*(const wchar_t **)(v3 + 4), Control) )
      goto LABEL_24;
    v6 = *(__int16 **)(v3 + 4);
    if ( *v19 == 36 )
    {
      v7 = sub_40EC83(v6, 255, a3);
      v15 = *(void **)(v3 + 4);
      Block = v7;
      free(v15);
    }
    else
    {
      if ( sub_40F912(v6) || (v5 = sub_410088(*(wchar_t **)(v3 + 4)), (v16 = v5) == 0) )
      {
LABEL_24:
        v4 = (int *)v3;
        v3 = *(_DWORD *)v3;
        goto LABEL_25;
      }
      v21 = *(void **)(v3 + 4);
    }
    v8 = *(_DWORD *)v3;
    v9 = v17;
    if ( v4 )
    {
      *v4 = v8;
      *(_DWORD *)v3 = dword_432618;
      v10 = v4;
    }
    else
    {
      *v17 = v8;
      *(_DWORD *)v3 = dword_432618;
      v10 = v9;
    }
    v22 = *v10;
    dword_432618 = v3;
    if ( *v19 == 36 )
    {
      v20 = Block;
      while ( 1 )
      {
        v13 = (char *)sub_402E3C(&v20);
        if ( !v13 )
          break;
        v5 = sub_40E215();
        v16 = v5;
        v11 = sub_40E267(v13);
        v12 = v17;
        v5[1] = v11;
        *v5 = *v12;
        *v12 = (int)v5;
        if ( !v4 )
          v4 = v5;
      }
      free(Block);
    }
    else
    {
      if ( v5 )
      {
        if ( !v4 )
        {
          v14 = (int *)*v5;
          v4 = v5;
          if ( *v5 )
          {
            do
            {
              v4 = v14;
              v14 = (int *)*v14;
            }
            while ( v14 );
          }
        }
        sub_40E36C(&v16, (_DWORD *)*v9);
        v5 = v16;
        *v17 = (int)v16;
      }
      free(v21);
    }
    v3 = v22;
LABEL_25:
    Control = v19;
  }
}
// 432618: using guessed type int dword_432618;

//----- (00402E3C) --------------------------------------------------------
_WORD *__thiscall sub_402E3C(_DWORD *this)
{
  _DWORD *v1; // edi
  _WORD *i; // ecx
  __int16 v3; // ax
  _WORD *v4; // ebx
  _WORD *result; // eax
  __int16 v6; // dx
  __int16 v7; // si
  _WORD *v8; // eax
  _WORD *v9; // [esp+10h] [ebp-8h]

  v1 = this;
  for ( i = (_WORD *)*this; ; ++i )
  {
    v3 = *i;
    if ( *i != 32 && v3 != 9 )
      break;
  }
  v4 = i;
  v9 = i;
  if ( !v3 )
    return 0;
  if ( v3 == 34 )
  {
    do
      ++i;
    while ( *i && *i != 34 );
    v6 = *i;
  }
  else
  {
    v7 = *i;
    do
    {
      v6 = v7;
      if ( v7 == 32 )
        break;
      v6 = v7;
      if ( v7 == 9 )
        break;
      v7 = *++i;
      v6 = *i;
    }
    while ( *i );
    v1 = this;
    v4 = v9;
  }
  v8 = i;
  if ( v6 == 32 || v6 == 9 )
    goto LABEL_23;
  if ( v6 != 34 )
  {
    if ( !v6 )
      --i;
    goto LABEL_24;
  }
  if ( *++i )
LABEL_23:
    *i = 0;
  else
    i = v8;
LABEL_24:
  result = v4;
  *v1 = i + 1;
  return result;
}

//----- (00402F02) --------------------------------------------------------
char sub_402F02()
{
  char v0; // al
  const wchar_t *v1; // ecx
  int *v2; // ecx
  int v3; // esi
  int *v4; // ecx
  char result; // al

  v0 = byte_4216B4;
  v1 = 0;
  if ( byte_4216B4 < 0 )
  {
    v0 = byte_4216B4 & 0x7F;
    byte_4216B4 &= ~0x80u;
  }
  if ( (v0 & 0x10) == 0 )
  {
    if ( (v0 & 6) != 0 )
    {
      if ( dword_4216A8 )
      {
        if ( (v0 & 2) != 0 )
        {
          v1 = L".SILENT";
        }
        else if ( (v0 & 4) != 0 )
        {
          v1 = L".IGNORE";
        }
        sub_4053F6(dword_4216B0, 0x442u, v1);
        goto LABEL_24;
      }
      goto LABEL_25;
    }
    if ( (v0 & 1) != 0 )
    {
      if ( !dword_4216A8 )
      {
        v2 = (int *)dword_4216A0;
        v3 = dword_4216A0;
        if ( dword_4216A0 )
        {
          do
          {
            dword_4216A0 = *v2;
            free(*(void **)(v3 + 4));
            *(_DWORD *)v3 = dword_432618;
            v2 = (int *)dword_4216A0;
            dword_432618 = v3;
            v3 = dword_4216A0;
          }
          while ( dword_4216A0 );
          goto LABEL_24;
        }
        goto LABEL_25;
      }
      v4 = &dword_4216A0;
    }
    else
    {
      if ( (v0 & 8) == 0 )
      {
        dword_421698 = (int)sub_40AC61(0x20u);
        *(_DWORD *)dword_421698 = dword_4216A8;
        *(_DWORD *)(dword_421698 + 4) = dword_4216BC;
        goto LABEL_24;
      }
      if ( !dword_4216A8 )
        goto LABEL_25;
      v4 = &dword_42169C;
    }
    sub_403596((_DWORD **)v4);
    goto LABEL_24;
  }
  if ( dword_4216A8 )
  {
    sub_4053F6(dword_4216B0, 0x43Eu);
LABEL_24:
    v0 = byte_4216B4;
  }
LABEL_25:
  dword_4216A8 = 0;
  result = v0 | 0x40;
  dword_4216BC = 0;
  byte_4216B4 = result;
  return result;
}
// 42169C: using guessed type int dword_42169C;
// 4216A0: using guessed type int dword_4216A0;
// 4216A8: using guessed type int dword_4216A8;
// 4216B0: using guessed type int dword_4216B0;
// 4216B4: using guessed type char byte_4216B4;
// 4216BC: using guessed type int dword_4216BC;
// 432618: using guessed type int dword_432618;

//----- (0040301C) --------------------------------------------------------
void sub_40301C()
{
  const wchar_t *v0; // ecx
  char v1; // bl
  int v2; // esi
  int v3; // ecx
  int v4; // ecx
  int v5; // [esp-4h] [ebp-10h]
  char v6; // [esp+Bh] [ebp-1h]

  v0 = 0;
  v1 = 1;
  v6 = 1;
  if ( (byte_4216B4 & 0x10) != 0 )
  {
    *((_DWORD *)dword_421694 + 3) = dword_4216A8;
  }
  else if ( (byte_4216B4 & 0xF) != 0 )
  {
    if ( dword_4216A8 )
    {
      if ( (byte_4216B4 & 2) != 0 )
      {
        v0 = L".SILENT";
      }
      else if ( (byte_4216B4 & 4) != 0 )
      {
        v0 = L".IGNORE";
      }
      else if ( (byte_4216B4 & 8) != 0 )
      {
        v0 = L".PRECIOUS";
      }
      else if ( (byte_4216B4 & 1) != 0 )
      {
        v0 = L".SUFFIXES";
      }
      sub_4053F6(dword_4216B0, 0x441u, v0);
    }
  }
  else
  {
    v2 = dword_411480;
    *(_DWORD *)(dword_421698 + 8) = dword_4216A8;
    *(_DWORD *)(dword_421698 + 12) = dword_4216BC;
    *(_BYTE *)(dword_421698 + 16) = byte_41148F;
    if ( v2 )
    {
      do
      {
        if ( sub_402BF5(*(wchar_t **)(v2 + 4)) )
        {
          sub_4053F6(dword_4216B0, 0x445u);
          v3 = v5;
        }
        sub_4034D5(*(wchar_t **)(v2 + 4), v6, v3);
        if ( !dword_421690 )
        {
          dword_421690 = v2;
          v1 = 0;
        }
        v4 = *(_DWORD *)v2;
        dword_411480 = *(_DWORD *)v2;
        if ( v1 )
        {
          *(_DWORD *)v2 = dword_432618;
          dword_432618 = v2;
        }
        v6 = 0;
        v2 = v4;
      }
      while ( v4 );
    }
  }
  dword_411480 = 0;
  dword_4216A8 = 0;
  dword_4216BC = 0;
  dword_421698 = 0;
  byte_4216B4 = 0;
}
// 4030A3: variable 'v5' is possibly undefined
// 4030AB: variable 'v3' is possibly undefined
// 401124: using guessed type wchar_t aPrecious[10];
// 401138: using guessed type wchar_t aSuffixes[10];
// 411480: using guessed type int dword_411480;
// 41148F: using guessed type char byte_41148F;
// 421690: using guessed type int dword_421690;
// 4216A8: using guessed type int dword_4216A8;
// 4216B0: using guessed type int dword_4216B0;
// 4216B4: using guessed type char byte_4216B4;
// 4216BC: using guessed type int dword_4216BC;
// 432618: using guessed type int dword_432618;

//----- (00403153) --------------------------------------------------------
void sub_403153()
{
  int *v0; // esi
  wchar_t *v1; // ebx
  int *v2; // eax
  int v3; // ecx
  wchar_t *v4; // esi
  wint_t v5; // cx

  if ( wcschr(Block, 0x24u) )
  {
    v0 = (int *)dword_4216BC;
    v1 = (wchar_t *)sub_40EC83((__int16 *)Block, 255, &dword_4216BC);
    if ( !*v1 )
      sub_4053F6(dword_4216B0, 0x3ECu);
    v2 = v0;
    dword_4216BC = (int)v0;
    if ( v0 )
    {
      v3 = dword_432618;
      do
      {
        v0 = (int *)*v0;
        *v2 = v3;
        v3 = (int)v2;
        v2 = v0;
        dword_4216BC = (int)v0;
      }
      while ( v0 );
      dword_432618 = v3;
    }
    free(Block);
    Block = v1;
  }
  v4 = Block;
  if ( *Block )
  {
    v5 = *Block;
    do
    {
      if ( !sub_403702(v5) )
        break;
      v5 = *++v4;
    }
    while ( *v4 );
    if ( *v4 )
      sub_4053F6(dword_4216B0, 0x3E9u, *v4);
  }
  byte_41148D = 1;
  if ( !sub_403382(Block, dword_4216AC, 0) )
  {
    free(Block);
    free(dword_4216AC);
  }
  dword_4216AC = 0;
  Block = 0;
}
// 41148D: using guessed type char byte_41148D;
// 4216B0: using guessed type int dword_4216B0;
// 4216BC: using guessed type int dword_4216BC;
// 432618: using guessed type int dword_432618;

//----- (00403260) --------------------------------------------------------
char __fastcall sub_403260(wchar_t *Name, wchar_t *Str, int a3)
{
  wchar_t *v4; // edi
  wchar_t *v5; // esi
  wint_t v6; // cx
  int v8; // esi
  wchar_t *v9; // eax
  wchar_t *v10; // ecx
  __int64 v12; // rax
  wchar_t *v13; // eax
  wchar_t v14; // dx
  wchar_t *v15; // esi
  wchar_t *v16; // ecx
  wchar_t *v17; // [esp+Ch] [ebp-8h]

  v4 = Str;
  v5 = Name;
  v6 = *Name;
  if ( v6 )
  {
    do
    {
      if ( !sub_403702(v6) )
        break;
      v6 = *++v5;
    }
    while ( *v5 );
    v4 = Str;
  }
  if ( *v5 )
  {
    if ( (a3 & 4) != 0 )
      return 0;
    sub_4053F6(dword_4216B0, 0x3E9u, *v5);
  }
  if ( (a3 & 0x40) != 0 )
  {
    v8 = 0;
    v9 = wcschr(v4, 0x24u);
    if ( v9 )
    {
      do
      {
        ++v8;
        v9 = wcschr(v9 + 1, 0x24u);
      }
      while ( v9 );
      v4 = Str;
      if ( v8 )
      {
        v10 = Str;
        while ( *v10++ )
          ;
        v12 = 2i64 * (unsigned int)(v10 - (Str + 1) + v8 + 1);
        v13 = (wchar_t *)sub_40AC3C(HIDWORD(v12) != 0 ? -1 : v12);
        v14 = *Str;
        v15 = Str;
        v17 = v13;
        v16 = v13;
        if ( *Str )
        {
          do
          {
            *v16 = v14;
            ++v15;
            ++v16;
            if ( v14 == 36 )
              *v16++ = 36;
            v14 = *v15;
          }
          while ( *v15 );
          v4 = Str;
        }
        *v16 = 0;
        free(v4);
        v4 = v17;
      }
    }
  }
  return sub_403382(Name, v4, a3);
}
// 4216B0: using guessed type int dword_4216B0;

//----- (00403382) --------------------------------------------------------
char __fastcall sub_403382(wchar_t *Name, wchar_t *Str, int a3)
{
  int v5; // eax
  unsigned __int8 v6; // al
  wchar_t *v7; // eax
  int v8; // eax
  _DWORD *v9; // esi
  unsigned __int8 v10; // al
  _DWORD *v12; // ecx
  _DWORD *v13; // eax
  bool v14; // zf
  _DWORD *v15; // ecx
  char v16; // al
  _DWORD *v17; // [esp+10h] [ebp-Ch]
  size_t RequiredCount; // [esp+14h] [ebp-8h] BYREF
  char v19; // [esp+1Bh] [ebp-1h]

  v19 = 0;
  RequiredCount = 0;
  if ( (a3 & 2) != 0 )
  {
    if ( !*Str )
      goto LABEL_13;
  }
  else
  {
    if ( !byte_41148D || (byte_41148C & 4) != 0 || wgetenv_s(&RequiredCount, 0, 0, Name) || !RequiredCount )
      goto LABEL_13;
    v5 = sub_40AB97(Name);
    if ( v5 )
    {
      v6 = *(_BYTE *)(v5 + 12);
      if ( (v6 & 2) != 0 || ((unsigned __int8)byte_41148C & v6 & 4) != 0 )
        return 0;
    }
  }
  v7 = sub_40EC1B(Str);
  if ( wputenv_s(Name, v7) )
    sub_4053F6(dword_4216B0, 0x41Fu);
LABEL_13:
  byte_41148D = 0;
  v8 = sub_40AB97(Name);
  v9 = (_DWORD *)v8;
  if ( v8 )
  {
    v10 = *(_BYTE *)(v8 + 12);
    if ( (v10 & 2) != 0 || ((unsigned __int8)byte_41148C & v10 & 4) != 0 )
      return 0;
  }
  v12 = sub_40E215();
  v17 = v12;
  v12[1] = Str;
  if ( v9 )
  {
    v19 = 1;
  }
  else
  {
    v13 = sub_40AC61(0x10u);
    v12 = v17;
    v9 = v13;
    v13[1] = Name;
  }
  v14 = v19 == 0;
  *((_BYTE *)v9 + 12) = a3 | v9[3] & 0xEF;
  *v12 = v9[2];
  v9[2] = v12;
  if ( v14 )
  {
    v15 = (_DWORD *)dword_435628;
    dword_435628 = 0;
    *v9 = *v15;
    *v15 = v9;
  }
  if ( (a3 & 0x40) == 0 && wcschr(Str, 0x24u) )
  {
    *((_BYTE *)v9 + 12) |= 1u;
    v16 = sub_40E549(Str, 0, 0, Name, 1, 0, a3);
    *((_BYTE *)v9 + 12) &= ~1u;
    if ( !v16 )
    {
      v9[2] = 0;
      *((_BYTE *)v9 + 12) |= 0x10u;
    }
  }
  return 1;
}
// 41148C: using guessed type char byte_41148C;
// 41148D: using guessed type char byte_41148D;
// 4216B0: using guessed type int dword_4216B0;
// 435628: using guessed type int dword_435628;

//----- (004034D5) --------------------------------------------------------
void __fastcall sub_4034D5(wchar_t *Block, char a2, int a3)
{
  _DWORD *v3; // eax
  _DWORD *v5; // eax
  int v6; // ecx
  _DWORD *v7; // edi
  _DWORD *v8; // eax
  _DWORD *v9; // esi
  int *v10; // eax
  int v11; // ecx
  int *v12; // esi
  int *v13; // ecx

  v3 = (_DWORD *)dword_421698;
  if ( !dword_421698 )
  {
    v3 = sub_40AC61(0x20u);
    dword_421698 = (int)v3;
  }
  if ( a2 )
  {
    v5 = sub_40AC61(8u);
    v6 = dword_421698;
    v7 = v5;
    v5[1] = dword_421698;
  }
  else
  {
    v7 = sub_4036B0(v3);
  }
  v8 = sub_40E3B9(Block, v6, v6);
  v9 = v8;
  if ( v8 )
  {
    if ( (((unsigned __int8)byte_41148F ^ *((_BYTE *)v8 + 8)) & 0x20) != 0 )
      sub_4053F6(dword_4216B0, 0x43Fu);
    sub_40E36C((_DWORD **)v9 + 6, v7);
    free(Block);
  }
  else
  {
    *v7 = 0;
    v10 = (int *)sub_40AC61(0x20u);
    LOBYTE(v11) = byte_41148F;
    v12 = v10;
    *((_BYTE *)v10 + 8) = byte_41148F;
    v10[1] = (int)Block;
    v10[6] = (int)v7;
    v13 = &dword_421490[sub_40E381(Block, v11)];
    *v12 = *v13;
    *v13 = (int)v12;
  }
}
// 40351F: variable 'v6' is possibly undefined
// 40357D: variable 'v11' is possibly undefined
// 41148F: using guessed type char byte_41148F;
// 421490: using guessed type int dword_421490[128];
// 4216B0: using guessed type int dword_4216B0;

//----- (00403596) --------------------------------------------------------
void __thiscall sub_403596(_DWORD **this)
{
  int v1; // edi
  _DWORD **v2; // esi
  _DWORD *v3; // ebx
  int *v4; // esi
  wchar_t *v5; // eax
  int v6; // edx
  int *v7; // ecx
  wchar_t *v8; // eax
  char *v9; // ebx
  _DWORD *v10; // esi
  wchar_t *Block; // [esp+Ch] [ebp-18h]
  int v12; // [esp+14h] [ebp-10h]
  wchar_t *Context; // [esp+1Ch] [ebp-8h] BYREF
  int v15; // [esp+20h] [ebp-4h]

  v1 = dword_4216A8;
  v2 = this;
  v3 = (_DWORD *)dword_4216A8;
  v15 = dword_4216A8;
  v12 = dword_4216A8;
  while ( v1 )
  {
    if ( wcschr(*(const wchar_t **)(v1 + 4), 0x24u) )
    {
      v4 = (int *)dword_4216BC;
      v5 = (wchar_t *)sub_40EC83(*(__int16 **)(v1 + 4), 255, &dword_4216BC);
      Block = v5;
      if ( v4 != (int *)dword_4216BC )
      {
        v6 = dword_432618;
        do
        {
          v7 = (int *)*v4;
          *v4 = v6;
          v6 = (int)v4;
          v4 = v7;
        }
        while ( v7 != (int *)dword_4216BC );
        dword_432618 = v6;
      }
      Context = 0;
      v8 = wcstok_s(v5, L" \t", &Context);
      if ( v8 )
      {
        v9 = (char *)v8;
        do
        {
          v10 = sub_40E215();
          v10[1] = sub_40E267(v9);
          sub_40E36C(this, v10);
          v9 = (char *)wcstok_s(0, L" \t", &Context);
        }
        while ( v9 );
        v1 = v15;
        v3 = (_DWORD *)v12;
      }
      free(Block);
      free(*(void **)(v1 + 4));
      v1 = *(_DWORD *)v1;
      v2 = this;
      v15 = v1;
      *v3 = dword_432618;
      dword_432618 = (int)v3;
    }
    else
    {
      v1 = *(_DWORD *)v1;
      *v3 = 0;
      v15 = v1;
      sub_40E36C(v2, v3);
    }
    v3 = (_DWORD *)v1;
    v12 = v1;
  }
}
// 4216A8: using guessed type int dword_4216A8;
// 4216BC: using guessed type int dword_4216BC;
// 432618: using guessed type int dword_432618;

//----- (004036B0) --------------------------------------------------------
_DWORD *__thiscall sub_4036B0(_DWORD *this)
{
  _DWORD *v2; // ebx
  _DWORD *v3; // eax
  int v4; // edx
  _DWORD *v5; // esi
  int v6; // ecx
  _DWORD *result; // eax

  v2 = sub_40AC61(8u);
  v3 = sub_40AC61(0x20u);
  v4 = *this;
  v5 = v3;
  v2[1] = v3;
  *v3 = v4;
  v3[1] = this[1];
  v3[2] = this[2];
  v3[3] = this[3];
  *((_BYTE *)v3 + 16) = *((_BYTE *)this + 16);
  v6 = this[7];
  v3[6] = this[6];
  result = v2;
  v5[7] = v6;
  return result;
}

//----- (004036FA) --------------------------------------------------------
void *__thiscall sub_4036FA(void *this)
{
  return sub_40AC3C((size_t)this);
}

//----- (00403702) --------------------------------------------------------
bool __fastcall sub_403702(wint_t C)
{
  if ( C >= 0x80u )
    return iswspace(C) == 0;
  else
    return byte_401060[C] & 1;
}

//----- (00403727) --------------------------------------------------------
wchar_t *__fastcall sub_403727(wchar_t *Str, wchar_t Ch)
{
  return wcschr(Str, Ch);
}

//----- (00403732) --------------------------------------------------------
int sub_403732()
{
  WCHAR *v0; // eax
  wchar_t *v1; // edi
  int v2; // ecx
  int v3; // esi
  int result; // eax
  int *v5; // ebx
  int v6; // esi
  int v7; // [esp-4h] [ebp-27Ch]
  __int64 v8; // [esp+10h] [ebp-268h] BYREF
  HANDLE hFindFile; // [esp+1Ch] [ebp-25Ch] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+20h] [ebp-258h] BYREF

  while ( 1 )
  {
    result = dword_421690;
    v5 = (int *)dword_421690;
    if ( !dword_421690 )
      return result;
    if ( wcspbrk(*(const wchar_t **)(dword_421690 + 4), L"*?") )
    {
      v0 = sub_4079FA(*(wchar_t **)(dword_421690 + 4), &FindFileData, &hFindFile);
      if ( v0 )
      {
        while ( 1 )
        {
          v1 = (wchar_t *)sub_40F89E(*(wchar_t **)(dword_421690 + 4), v0);
          v8 = sub_4079E0((char *)&FindFileData);
          v3 = sub_403882(v1, byte_41148E, (unsigned int *)&v8, v2);
          free(v1);
          if ( v3 < 0 && (byte_41148C & 8) != 0 )
            break;
          v0 = sub_407B86(&FindFileData, hFindFile);
          if ( !v0 )
            goto LABEL_11;
        }
        v6 = -1;
        goto LABEL_16;
      }
      sub_4053F6(0, 0x42Du, *(_DWORD *)(dword_421690 + 4));
    }
    else
    {
      v8 = 0i64;
      if ( sub_403882(*(wchar_t **)(dword_421690 + 4), byte_41148E, (unsigned int *)&v8, v7) < 0
        && (byte_41148C & 8) != 0 )
      {
        v6 = 255;
LABEL_16:
        sub_404BE9(v5);
        return v6;
      }
    }
LABEL_11:
    dword_421690 = *v5;
    *v5 = dword_432618;
    dword_432618 = (int)v5;
  }
}
// 4037B8: variable 'v2' is possibly undefined
// 403823: variable 'v7' is possibly undefined
// 41148C: using guessed type char byte_41148C;
// 41148E: using guessed type char byte_41148E;
// 421690: using guessed type int dword_421690;
// 432618: using guessed type int dword_432618;
// 403732: using guessed type __int64 var_268;

//----- (00403882) --------------------------------------------------------
int __fastcall sub_403882(wchar_t *a1, char a2, unsigned int *a3, int a4)
{
  int v4; // edi
  int v5; // eax
  _DWORD *v6; // esi
  int v7; // ebx
  wchar_t **v8; // eax
  _DWORD *v9; // esi
  _DWORD *v10; // ecx
  void *v12; // [esp-4h] [ebp-14h]
  void *Block; // [esp+Ch] [ebp-4h] BYREF

  v4 = 0;
  Block = 0;
  v5 = sub_4038EE(a1, a2, a3, 0, &Block);
  v6 = Block;
  v7 = v5;
  if ( Block )
  {
    do
    {
      v8 = sub_404D06(v6);
      v6 = (_DWORD *)*v6;
      v4 += (int)v8;
    }
    while ( v6 );
    v9 = Block;
    v7 += v4;
    while ( v9 )
    {
      v10 = (_DWORD *)v9[3];
      v12 = v9;
      *v10 = dword_432618;
      dword_432618 = v9[4];
      *(_DWORD *)dword_432618 = v10;
      v9 = (_DWORD *)*v9;
      free(v12);
    }
  }
  return v7;
}
// 432618: using guessed type int dword_432618;

//----- (004038EE) --------------------------------------------------------
int __fastcall sub_4038EE(wchar_t *a1, char a2, unsigned int *a3, wchar_t *a4, _DWORD *a5)
{
  _DWORD *v7; // eax
  int result; // eax
  char v9; // [esp+Ch] [ebp-4h]

  ++dword_411484;
  v9 = 1;
  v7 = sub_40E3B9(a1, (int)a1, (int)a1);
  if ( !v7 )
  {
    v7 = sub_404C13((char *)a1, a2);
    v9 = 0;
  }
  result = sub_403944((int)v7, a2, a3, v9, a4, a5);
  --dword_411484;
  return result;
}
// 411484: using guessed type int dword_411484;

//----- (00403944) --------------------------------------------------------
int __fastcall sub_403944(int a1, char a2, unsigned int *a3, char a4, wchar_t *a5, _DWORD *a6)
{
  unsigned int *v6; // esi
  int result; // eax
  _DWORD *v9; // ebx
  int v10; // esi
  unsigned int *v11; // edx
  unsigned int v12; // eax
  unsigned int v13; // ecx
  char v14; // al
  unsigned int v15; // ecx
  unsigned int v16; // ebx
  unsigned __int64 v17; // rax
  wchar_t *v18; // ecx
  unsigned int v19; // eax
  int v20; // eax
  unsigned int v21; // esi
  unsigned int *v22; // ecx
  int v23; // edx
  _DWORD *v24; // ebx
  int v25; // ecx
  int v26; // eax
  int v27; // ecx
  __int64 v28; // rax
  unsigned int v29; // ecx
  unsigned int v30; // esi
  _DWORD *v31; // esi
  void *v32; // eax
  int *v33; // edx
  int *v34; // ecx
  _DWORD *v35; // esi
  void *v36; // eax
  int *v37; // edx
  int *v38; // ecx
  _DWORD *v39; // esi
  int v40; // ebx
  wchar_t **v41; // eax
  _DWORD *v42; // esi
  _DWORD *v43; // ecx
  void **v44; // ebx
  void **v45; // esi
  char v46; // bl
  _DWORD *v47; // edx
  char v48; // cl
  wchar_t *v49; // esi
  int v50; // eax
  wchar_t *v51; // eax
  int v52; // ebx
  wchar_t **v53; // eax
  bool v54; // zf
  __int64 v55; // rax
  DWORD dwHighDateTime; // ecx
  int *v57; // ebx
  int v58; // esi
  int *v59; // ebx
  int v60; // esi
  int v61; // esi
  int v62; // ebx
  unsigned int v63; // ebx
  unsigned int v64; // eax
  unsigned int v65; // esi
  char v66; // al
  unsigned int v67; // ecx
  unsigned int v68; // esi
  unsigned int v69; // eax
  unsigned int *v70; // edx
  unsigned __int64 v71; // kr00_8
  unsigned __int64 v72; // kr08_8
  void **v73; // eax
  _DWORD *v74; // eax
  wchar_t *v75; // eax
  _DWORD *v76; // ebx
  _DWORD *v77; // esi
  int v78; // edx
  int v79; // eax
  char v80; // dl
  const wchar_t *v81; // eax
  wchar_t **v82; // eax
  DWORD v83; // eax
  unsigned int v84; // ecx
  DWORD *v85; // edx
  wchar_t **v86; // eax
  int v87; // edi
  int v88; // esi
  int v89; // edi
  char v90; // al
  char v91; // al
  char v92; // al
  unsigned int v93; // ecx
  unsigned int v94; // eax
  unsigned int *v95; // edx
  int v96; // edi
  int v97; // esi
  int v98; // edi
  char v99; // [esp-8h] [ebp-500h]
  int v100; // [esp-4h] [ebp-4FCh]
  void *v101; // [esp-4h] [ebp-4FCh]
  int v102; // [esp-4h] [ebp-4FCh]
  struct _FILETIME SystemTimeAsFileTime; // [esp+14h] [ebp-4E4h] BYREF
  DWORD *v104; // [esp+1Ch] [ebp-4DCh]
  void *v105; // [esp+20h] [ebp-4D8h]
  _DWORD *v106; // [esp+24h] [ebp-4D4h]
  unsigned __int64 v107; // [esp+28h] [ebp-4D0h]
  unsigned int *v108; // [esp+30h] [ebp-4C8h]
  int v109; // [esp+34h] [ebp-4C4h] BYREF
  wchar_t *v110; // [esp+38h] [ebp-4C0h]
  void *Block; // [esp+3Ch] [ebp-4BCh] BYREF
  unsigned __int64 v112; // [esp+40h] [ebp-4B8h] BYREF
  _DWORD *v113; // [esp+4Ch] [ebp-4ACh] BYREF
  unsigned __int64 v114; // [esp+50h] [ebp-4A8h] BYREF
  int v115; // [esp+58h] [ebp-4A0h]
  wchar_t *v116; // [esp+5Ch] [ebp-49Ch] BYREF
  _DWORD *v117; // [esp+60h] [ebp-498h] BYREF
  unsigned int v118; // [esp+64h] [ebp-494h]
  int *v119; // [esp+68h] [ebp-490h]
  unsigned int v120; // [esp+6Ch] [ebp-48Ch]
  unsigned int v121; // [esp+70h] [ebp-488h]
  int *v122; // [esp+74h] [ebp-484h]
  unsigned int v123; // [esp+78h] [ebp-480h]
  unsigned int v124; // [esp+7Ch] [ebp-47Ch]
  int v125; // [esp+80h] [ebp-478h]
  int v126; // [esp+84h] [ebp-474h] BYREF
  int v127; // [esp+88h] [ebp-470h]
  unsigned __int64 v128; // [esp+8Ch] [ebp-46Ch]
  char v129; // [esp+97h] [ebp-461h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+98h] [ebp-460h] BYREF
  __int16 v131[262]; // [esp+2E8h] [ebp-210h] BYREF

  v6 = a3;
  v110 = a5;
  v116 = a5;
  result = 0;
  v129 = a2;
  v108 = a3;
  v127 = 0;
  v126 = 0;
  if ( !a1 )
  {
    *a3 = 0;
    a3[1] = 0;
    return result;
  }
  if ( (*(_BYTE *)(a1 + 9) & 1) != 0 )
  {
    sub_4053F6(0, 0x42Fu, *(_DWORD *)(a1 + 4));
    a2 = v129;
  }
  v9 = *(_DWORD **)(a1 + 28);
  if ( v9 )
  {
    v10 = sub_404E5B((_DWORD *)*v9);
    sub_404E79(v9);
    v11 = v108;
    v12 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 28) = 0;
    v13 = *(_DWORD *)(a1 + 20);
    *v11 = v12;
    result = v10;
    v11[1] = v13;
    return result;
  }
  v14 = *(_BYTE *)(a1 + 9);
  if ( (v14 & 2) != 0 )
  {
    if ( (a2 & 1) != 0 )
      sub_40CA65(2 * dword_411484, *(_DWORD *)(a1 + 4), *(FILETIME *)(a1 + 16));
    v15 = *(_DWORD *)(a1 + 20);
    *a3 = *(_DWORD *)(a1 + 16);
    a3[1] = v15;
    if ( (byte_41148C & 8) == 0 && dword_411484 == 1 && (*(_BYTE *)(a1 + 9) & 4) == 0 )
    {
      if ( sub_4079FA(*(wchar_t **)(a1 + 4), &FindFileData, (HANDLE *)&v109) )
        sub_4054D0(2u, *(_DWORD *)(a1 + 4));
    }
    return (*(unsigned __int8 *)(a1 + 9) >> 2) & 1;
  }
  Block = 0;
  v16 = 0;
  HIDWORD(v17) = 0;
  *(_BYTE *)(a1 + 9) = v14 | 1;
  LODWORD(v17) = *(_DWORD *)(a1 + 24);
  v119 = 0;
  v113 = 0;
  v122 = 0;
  v117 = 0;
  v106 = 0;
  v115 = 0;
  v125 = 0;
  v124 = 0;
  v121 = 0;
  v112 = 0i64;
  v114 = 0i64;
  v107 = 0i64;
  v104 = 0;
  v18 = *(wchar_t **)(a1 + 4);
  v128 = 0i64;
  dword_421ED4 = v18;
  dword_421ED8 = (int)v18;
  v123 = v17;
  if ( !(_DWORD)v17 )
  {
LABEL_121:
    v63 = *v6;
    v64 = *v6;
    v65 = v6[1];
    dword_421EC8 = 0;
    dword_421ECC = 0;
    LODWORD(v128) = v63;
    v123 = v65;
    if ( !(v65 | v64) )
    {
      if ( *(_QWORD *)(a1 + 16) )
      {
        v63 = *(_DWORD *)(a1 + 16);
        v65 = *(_DWORD *)(a1 + 20);
        LODWORD(v128) = v63;
        v123 = v65;
      }
      else if ( sub_4079FA(v18, &FindFileData, (HANDLE *)&v109) )
      {
        v71 = sub_4079E0((char *)&FindFileData);
        v65 = HIDWORD(v71);
        v63 = v71;
        v72 = __PAIR64__(v65, v63);
        v123 = HIDWORD(v72);
        LODWORD(v128) = v72;
      }
    }
    if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
      sub_40CA65(2 * dword_411484, *(_DWORD *)(a1 + 4), (FILETIME)__PAIR64__(v65, v63));
    v73 = sub_40E069(a1, (wchar_t *)v131, (int)v18, __PAIR64__(v65, v63), &v113, &v117, &v126, &v114, &v116);
    v105 = v73;
    if ( v73 && !v115 )
    {
      v74 = v73[3];
      dword_421ECC = v131;
      v106 = v74;
    }
    v75 = *(wchar_t **)(a1 + 4);
    v76 = v113;
    v77 = v117;
    v78 = v126;
    dword_421ED4 = v75;
    dword_421ED8 = (int)v75;
    dword_421ED0 = (int)v113;
    dword_421EC4 = (int)v117;
    HIDWORD(v128) = v126;
    if ( byte_4216B7 && (*(_BYTE *)(a1 + 9) & 8) == 0 || !v126 )
    {
      v79 = v128;
      if ( __PAIR64__(v123, v128) < v114 || byte_4216B6 && __PAIR64__(v123, v128) == v114 )
      {
LABEL_150:
        v80 = byte_4323F8;
        v129 = byte_4323F8;
        byte_4323F8 = 1;
        if ( v115 )
        {
          v81 = v116;
          if ( !v116 )
          {
            if ( v117 )
              v81 = (const wchar_t *)v117[1];
            else
              v81 = 0;
          }
          v82 = sub_40573E(
                  *(char **)(a1 + 4),
                  *(_DWORD **)(v115 + 8),
                  *(_DWORD *)(v115 + 12),
                  *(_BYTE *)(v115 + 16),
                  v81);
          goto LABEL_171;
        }
        if ( v106 )
        {
          if ( *((_BYTE *)v105 + 20) && (byte_41148C & 0x40) == 0 )
          {
            sub_404C5A(a6, (int)v105, a1, v123);
LABEL_160:
            byte_4323F8 = v129;
            goto LABEL_161;
          }
          v82 = sub_40573E(*(char **)(a1 + 4), v106, *((_DWORD *)v105 + 4), *(_BYTE *)(a1 + 8), v116);
LABEL_171:
          HIDWORD(v128) = (char *)v82 + v126;
          goto LABEL_160;
        }
        if ( (byte_41148C & 0x10) != 0 )
        {
          if ( v125 )
          {
            v86 = sub_40573E(
                    *(char **)(a1 + 4),
                    *(_DWORD **)(v125 + 8),
                    *(_DWORD *)(v125 + 12),
                    *(_BYTE *)(v125 + 16),
                    v116);
            HIDWORD(v128) = (char *)v86 + v126;
            v80 = v129;
          }
        }
        else if ( !a4 && !(v123 | v79) )
        {
          if ( !byte_4216B7 )
          {
            sub_4053F6(0, 0x431u, *(_DWORD *)(a1 + 4));
            byte_4323F8 = v129;
LABEL_176:
            if ( dword_421EC4 )
            {
              v84 = HIDWORD(v114);
              v83 = v114;
LABEL_162:
              v85 = v104;
              v121 = v84;
              v124 = v83;
              if ( v104 && v115 )
              {
                *v104 = v83;
                v85[1] = v84;
              }
              v78 = HIDWORD(v128);
LABEL_166:
              if ( byte_4216B7 && v78 )
              {
                v54 = (*(_BYTE *)(a1 + 9) & 8) == 0;
                byte_411020 = 0;
                if ( v54 )
                {
                  if ( dword_411484 == 1 )
                    sub_4053F6(0, 0xFAAu, *(_DWORD *)(a1 + 4));
                }
                else
                {
                  sub_4053F6(0, 0xFABu, *(_DWORD *)(a1 + 4));
                }
              }
              if ( (byte_41148C & 8) != 0 && dword_411484 == 1 )
              {
                if ( v77 == v76 )
                {
                  if ( v77 )
                  {
                    v89 = (int)v77;
                    do
                    {
                      v77 = (_DWORD *)*v77;
                      free(*(void **)(v89 + 4));
                      *(_DWORD *)v89 = dword_432618;
                      dword_432618 = v89;
                      v89 = (int)v77;
                    }
                    while ( v77 );
                  }
                }
                else
                {
                  if ( v77 )
                  {
                    v87 = (int)v77;
                    do
                    {
                      v77 = (_DWORD *)*v77;
                      free(*(void **)(v87 + 4));
                      *(_DWORD *)v87 = dword_432618;
                      dword_432618 = v87;
                      v87 = (int)v77;
                    }
                    while ( v77 );
                  }
                  if ( v76 )
                  {
                    v88 = (int)v76;
                    do
                    {
                      v76 = (_DWORD *)*v76;
                      free(*(void **)(v88 + 4));
                      *(_DWORD *)v88 = dword_432618;
                      dword_432618 = v88;
                      v88 = (int)v76;
                    }
                    while ( v76 );
                  }
                }
                return -(dword_421EC0 != 0);
              }
              else
              {
                v90 = *(_BYTE *)(a1 + 9) & 0xFE;
                v54 = *(_DWORD *)(a1 + 28) == 0;
                *(_BYTE *)(a1 + 9) = v90;
                if ( v54 )
                {
                  v91 = v90 | 2;
                  if ( SHIDWORD(v128) <= 0 )
                    v92 = v91 & 0xFB;
                  else
                    v92 = v91 | 4;
                  *(_BYTE *)(a1 + 9) = v92;
                }
                v93 = v123;
                if ( v121 < v123 )
                {
                  v94 = v128;
                }
                else if ( v121 > v123 || (v94 = v128, v124 > (unsigned int)v128) )
                {
                  v93 = v121;
                  v94 = v124;
                }
                v95 = v108;
                *(_DWORD *)(a1 + 16) = v94;
                *(_DWORD *)(a1 + 20) = v93;
                *v95 = v94;
                v95[1] = v93;
                if ( v77 == v76 )
                {
                  if ( v77 )
                  {
                    v98 = (int)v77;
                    do
                    {
                      v77 = (_DWORD *)*v77;
                      free(*(void **)(v98 + 4));
                      *(_DWORD *)v98 = dword_432618;
                      dword_432618 = v98;
                      v98 = (int)v77;
                    }
                    while ( v77 );
                  }
                }
                else
                {
                  if ( v77 )
                  {
                    v96 = (int)v77;
                    do
                    {
                      v77 = (_DWORD *)*v77;
                      free(*(void **)(v96 + 4));
                      *(_DWORD *)v96 = dword_432618;
                      dword_432618 = v96;
                      v96 = (int)v77;
                    }
                    while ( v77 );
                  }
                  if ( v76 )
                  {
                    v97 = (int)v76;
                    do
                    {
                      v76 = (_DWORD *)*v76;
                      free(*(void **)(v97 + 4));
                      *(_DWORD *)v97 = dword_432618;
                      dword_432618 = v97;
                      v97 = (int)v76;
                    }
                    while ( v76 );
                  }
                }
                return HIDWORD(v128);
              }
            }
LABEL_161:
            GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
            v84 = (unsigned __int64)(*(_QWORD *)&SystemTimeAsFileTime + 2i64) >> 32;
            v83 = SystemTimeAsFileTime.dwLowDateTime + 2;
            goto LABEL_162;
          }
          HIDWORD(v128) = 1;
        }
        byte_4323F8 = v80;
        goto LABEL_176;
      }
      if ( !(v123 | (unsigned int)v128) && !v114 || (*(_BYTE *)(a1 + 8) & 0x10) != 0 )
      {
        v79 = v128;
        goto LABEL_150;
      }
      v75 = *(wchar_t **)(a1 + 4);
    }
    if ( (byte_41148C & 8) == 0 && dword_411484 == 1 && (*(_BYTE *)(a1 + 9) & 8) == 0 )
    {
      sub_4054D0(2u, v75);
      v78 = v126;
    }
    goto LABEL_166;
  }
  if ( (*(_BYTE *)(*(_DWORD *)(v17 + 4) + 16) & 0x20) != 0 )
  {
    if ( sub_4079FA(v18, &FindFileData, (HANDLE *)&v109) )
    {
      v17 = sub_4079E0((char *)&FindFileData);
      LODWORD(v128) = HIDWORD(v17);
      v16 = v17;
      HIDWORD(v128) = v17;
    }
    else
    {
      HIDWORD(v17) = 0;
    }
  }
  v19 = v123;
  while ( 1 )
  {
    v20 = *(_DWORD *)(v19 + 4);
    v21 = 0;
    v118 = 0;
    v125 = v20;
    v120 = 0;
    v22 = (unsigned int *)(v20 + 24);
    if ( *(_QWORD *)(v20 + 24) )
    {
      if ( __PAIR64__(HIDWORD(v17), v16) <= *(_QWORD *)v22 )
      {
        v16 = *v22;
        HIDWORD(v17) = *(_DWORD *)(v20 + 28);
        HIDWORD(v128) = *v22;
        LODWORD(v128) = HIDWORD(v17);
      }
      goto LABEL_119;
    }
    v23 = *(_DWORD *)(a1 + 4);
    v104 = (DWORD *)(v20 + 24);
    v24 = sub_40470F(v125, v23);
    v105 = v24;
    if ( v24 )
    {
      while ( 1 )
      {
        v25 = v24[3];
        LODWORD(v112) = v24[2];
        HIDWORD(v112) = v25;
        v26 = sub_4038EE((wchar_t *)v24[1], *(_BYTE *)(v125 + 16), (unsigned int *)&v112, 0, &Block);
        v27 = v26 + v127;
        v127 = v27;
        v126 = v27;
        if ( byte_4216B7 && v26 )
        {
          if ( (*((_BYTE *)sub_40E3B9((wchar_t *)v24[1], v27, v27) + 9) & 8) == 0 )
          {
            v100 = v24[1];
            byte_411020 = 0;
            sub_4053F6(0, 0xFAAu, v100);
          }
          *(_BYTE *)(a1 + 9) |= 8u;
        }
        HIDWORD(v28) = HIDWORD(v112);
        v29 = v112;
        if ( __PAIR64__(v118, v21) <= v112 )
        {
          v118 = HIDWORD(v112);
          v120 = v112;
        }
        v30 = v128;
        if ( !v128 && (*(_BYTE *)(v125 + 16) & 0x20) == 0 )
        {
          if ( sub_4079FA(*(wchar_t **)(a1 + 4), &FindFileData, (HANDLE *)&v109) )
          {
            v28 = sub_4079E0((char *)&FindFileData);
            v29 = v112;
            v30 = HIDWORD(v28);
            HIDWORD(v28) = HIDWORD(v112);
            v128 = __PAIR64__(v28, v30);
            *(_DWORD *)(a1 + 16) = v28;
            *(_DWORD *)(a1 + 20) = v30;
            goto LABEL_39;
          }
          HIDWORD(v28) = HIDWORD(v112);
          v29 = v112;
        }
        LODWORD(v28) = HIDWORD(v128);
LABEL_39:
        if ( (*(_BYTE *)(a1 + 8) & 0x10) != 0
          || v30 < HIDWORD(v28)
          || v30 <= HIDWORD(v28) && (unsigned int)v28 < v29
          || byte_4216B6 && __PAIR64__(v28, v30) == __PAIR64__(v29, HIDWORD(v28)) )
        {
          v31 = sub_40E215();
          v32 = sub_40E267((char *)v24[1]);
          v33 = v119;
          v34 = (int *)&v113;
          for ( v31[1] = v32; v33; v33 = (int *)*v33 )
            v34 = v33;
          *v34 = (int)v31;
          v119 = v113;
        }
        v35 = sub_40E215();
        v36 = sub_40E267((char *)v24[1]);
        v37 = v122;
        v38 = (int *)&v117;
        for ( v35[1] = v36; v37; v37 = (int *)*v37 )
          v38 = v37;
        *v38 = (int)v35;
        v24 = (_DWORD *)*v24;
        v122 = v117;
        if ( !v24 )
          break;
        v21 = v120;
      }
    }
    v39 = Block;
    if ( Block )
    {
      v40 = 0;
      do
      {
        v41 = sub_404D06(v39);
        v39 = (_DWORD *)*v39;
        v40 += (int)v41;
      }
      while ( v39 );
      v42 = Block;
      v127 += v40;
      v126 = v127;
      while ( v42 )
      {
        v43 = (_DWORD *)v42[3];
        v101 = v42;
        *v43 = dword_432618;
        dword_432618 = v42[4];
        *(_DWORD *)dword_432618 = v43;
        v42 = (_DWORD *)*v42;
        free(v101);
      }
      Block = 0;
    }
    v44 = (void **)v105;
    while ( 1 )
    {
      v45 = v44;
      if ( !v44 )
        break;
      free(v44[1]);
      v44 = (void **)*v44;
      free(v45);
    }
    v46 = *(_BYTE *)(v125 + 16);
    v47 = *(_DWORD **)(v125 + 8);
    if ( (v46 & 0x20) == 0 )
    {
      if ( v47 )
      {
        if ( v115 )
          sub_4053F6(0, 0xFA4u, *(_DWORD *)(a1 + 4));
        else
          v115 = v125;
      }
      if ( (unsigned int)v107 <= v118 && ((unsigned int)v107 < v118 || HIDWORD(v107) <= v120) )
      {
        v107 = __PAIR64__(v120, v118);
        v114 = __PAIR64__(v118, v120);
      }
LABEL_115:
      v62 = v127;
      goto LABEL_116;
    }
    if ( !v47 )
      goto LABEL_115;
    v48 = byte_4216B7;
    v49 = *(wchar_t **)(a1 + 4);
    dword_421EC8 = 0;
    dword_421ECC = 0;
    dword_421ED0 = (int)v119;
    v50 = (int)v122;
    dword_421ED4 = v49;
    dword_421ED8 = (int)v49;
    dword_421EC4 = (int)v122;
    if ( (!byte_4216B7 || (*(_BYTE *)(a1 + 9) & 8) != 0) && v127
      || (v49 = *(wchar_t **)(a1 + 4), (unsigned int)v128 >= v118)
      && ((unsigned int)v128 > v118 || (v49 = *(wchar_t **)(a1 + 4), HIDWORD(v128) >= v120)) )
    {
      if ( !byte_4216B6
        || (v49 = *(wchar_t **)(a1 + 4), HIDWORD(v128) != v120)
        || (v49 = *(wchar_t **)(a1 + 4), (_DWORD)v128 != v118) )
      {
        if ( (v128 || v118 | v120) && *(_DWORD *)v125 )
          goto LABEL_102;
        v50 = (int)v122;
      }
    }
    v129 = byte_4323F8;
    byte_4323F8 = 1;
    if ( v110 )
    {
      v51 = v110;
    }
    else
    {
      if ( v50 )
        v51 = *(wchar_t **)(v50 + 4);
      else
        v51 = 0;
      v110 = v51;
      v116 = v51;
    }
    v99 = v46;
    v52 = v125;
    v53 = sub_40573E((char *)v49, v47, *(_DWORD *)(v125 + 12), v99, v51);
    v54 = (*(_BYTE *)(a1 + 8) & 4) == 0;
    v127 += (int)v53;
    v126 = v127;
    if ( v54 && sub_4079FA(*(wchar_t **)(a1 + 4), &FindFileData, (HANDLE *)&v109) )
    {
      v55 = sub_4079E0((char *)&FindFileData);
      dwHighDateTime = HIDWORD(v55);
LABEL_89:
      v121 = dwHighDateTime;
      v124 = v55;
      goto LABEL_90;
    }
    if ( !v107 )
    {
      GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
      LODWORD(v55) = SystemTimeAsFileTime.dwLowDateTime;
      dwHighDateTime = SystemTimeAsFileTime.dwHighDateTime;
      goto LABEL_89;
    }
    LODWORD(v55) = HIDWORD(v107);
    v124 = HIDWORD(v107);
    dwHighDateTime = v107;
    v121 = v107;
LABEL_90:
    *(_DWORD *)(v52 + 24) = v55;
    *(_DWORD *)(v52 + 28) = dwHighDateTime;
    v57 = v122;
    if ( v122 == v119 )
    {
      if ( v122 )
      {
        v61 = (int)v122;
        do
        {
          v57 = (int *)*v57;
          free(*(void **)(v61 + 4));
          *(_DWORD *)v61 = dword_432618;
          dword_432618 = v61;
          v61 = (int)v57;
        }
        while ( v57 );
      }
    }
    else
    {
      if ( v122 )
      {
        v58 = (int)v122;
        do
        {
          v57 = (int *)*v57;
          free(*(void **)(v58 + 4));
          *(_DWORD *)v58 = dword_432618;
          dword_432618 = v58;
          v58 = (int)v57;
        }
        while ( v57 );
      }
      v59 = v119;
      if ( v119 )
      {
        v60 = (int)v119;
        do
        {
          v59 = (int *)*v59;
          free(*(void **)(v60 + 4));
          *(_DWORD *)v60 = dword_432618;
          dword_432618 = v60;
          v60 = (int)v59;
        }
        while ( v59 );
      }
    }
    v48 = byte_4216B7;
    v119 = 0;
    v113 = 0;
    v122 = 0;
    v117 = 0;
    byte_4323F8 = v129;
LABEL_102:
    if ( !v48 )
      goto LABEL_115;
    if ( (*(_BYTE *)(a1 + 9) & 8) != 0 )
    {
      sub_4053F6(0, 0xFABu, *(_DWORD *)(a1 + 4));
      *(_BYTE *)(a1 + 9) &= ~8u;
    }
    v62 = v127;
    if ( v127 )
    {
      v102 = *(_DWORD *)(a1 + 4);
      v62 = 0;
      byte_411020 = 0;
      v127 = 0;
      v126 = 0;
      sub_4053F6(0, 0xFAAu, v102);
    }
LABEL_116:
    if ( (*(_BYTE *)(v125 + 16) & 0x20) != 0 && !*(_DWORD *)v123 )
      break;
    v16 = HIDWORD(v128);
    HIDWORD(v17) = v128;
LABEL_119:
    v19 = *(_DWORD *)v123;
    v123 = v19;
    if ( !v19 )
    {
      v18 = *(wchar_t **)(a1 + 4);
      v6 = v108;
      goto LABEL_121;
    }
  }
  if ( v62 <= 0 )
    v66 = *(_BYTE *)(a1 + 9) & 0xF8 | 2;
  else
    v66 = *(_BYTE *)(a1 + 9) & 0xF8 | 6;
  v67 = v128;
  v68 = v121;
  *(_BYTE *)(a1 + 9) = v66;
  if ( v68 < v67 )
  {
    v69 = HIDWORD(v128);
  }
  else if ( v68 > v67 || (v69 = HIDWORD(v128), v124 > HIDWORD(v128)) )
  {
    v69 = v124;
    v67 = v68;
  }
  v70 = v108;
  *(_DWORD *)(a1 + 16) = v69;
  *(_DWORD *)(a1 + 20) = v67;
  *v70 = v69;
  result = v62;
  v70[1] = v67;
  return result;
}
// 404287: variable 'v18' is possibly undefined
// 411020: using guessed type char byte_411020;
// 411484: using guessed type int dword_411484;
// 41148C: using guessed type char byte_41148C;
// 4216B6: using guessed type char byte_4216B6;
// 4216B7: using guessed type char byte_4216B7;
// 421EC0: using guessed type int dword_421EC0;
// 421EC4: using guessed type int dword_421EC4;
// 421EC8: using guessed type int dword_421EC8;
// 421ED0: using guessed type int dword_421ED0;
// 421ED8: using guessed type int dword_421ED8;
// 4323F8: using guessed type char byte_4323F8;
// 432618: using guessed type int dword_432618;
// 403944: using guessed type wchar_t var_210[262];

//----- (0040470F) --------------------------------------------------------
_DWORD *__fastcall sub_40470F(int a1, int a2)
{
  _DWORD *v2; // ebx
  int v3; // esi
  int v4; // eax
  int v5; // edi
  __int16 *v6; // esi
  __int16 *v7; // ecx
  __int16 v8; // dx
  __int16 *v9; // edi
  wchar_t *v10; // esi
  char *v11; // edi
  __int16 v12; // cx
  wchar_t *v13; // ebx
  wchar_t *v14; // esi
  wchar_t *v15; // esi
  _DWORD *v16; // ebx
  wchar_t *v17; // ecx
  rsize_t v19; // esi
  wchar_t *v20; // eax
  __int64 v21; // rax
  bool v22; // zf
  _DWORD *v23; // ecx
  __int16 *v26; // [esp+10h] [ebp-288h]
  int v27; // [esp+18h] [ebp-280h] BYREF
  _DWORD *v28; // [esp+1Ch] [ebp-27Ch]
  __int16 *v29; // [esp+20h] [ebp-278h]
  __int16 *v30; // [esp+24h] [ebp-274h] BYREF
  unsigned int v31; // [esp+28h] [ebp-270h]
  HANDLE hFindFile; // [esp+2Ch] [ebp-26Ch] BYREF
  _DWORD *v33; // [esp+30h] [ebp-268h] BYREF
  wchar_t *v34; // [esp+34h] [ebp-264h] BYREF
  wchar_t *Source; // [esp+38h] [ebp-260h]
  char v36; // [esp+3Fh] [ebp-259h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+40h] [ebp-258h] BYREF

  v2 = *(_DWORD **)a1;
  hFindFile = 0;
  v28 = v2;
  v3 = 0;
  v4 = *(_DWORD *)(a1 + 4);
  v33 = 0;
  v27 = v4;
  v5 = a2;
  if ( v2 )
  {
    do
    {
      v6 = (__int16 *)v2[1];
      v7 = v6;
      v29 = v6;
      if ( *v6 )
      {
        v8 = *v6;
        while ( v8 != 36 )
        {
          if ( v8 == 94 )
            ++v7;
          v8 = *++v7;
          if ( !*v7 )
            goto LABEL_10;
        }
        dword_421EC8 = v5;
        v6 = (__int16 *)sub_40EC83(v6, 1, &v27);
        v29 = v6;
      }
LABEL_10:
      v9 = (__int16 *)sub_40E267((char *)v6);
      v26 = v9;
      v30 = v9;
      if ( sub_404AB4(&v30, &v34) )
      {
        do
        {
          v10 = v34;
          v11 = (char *)v34;
          if ( *v34 == 123 )
          {
            v12 = 123;
            while ( v12 != 125 )
            {
              if ( v12 == 94 )
                v11 += 2;
              v11 += 2;
              v12 = *(_WORD *)v11;
              if ( !*(_WORD *)v11 )
                goto LABEL_21;
            }
            *(_WORD *)v11 = 0;
            v11 += 2;
            ++v10;
          }
          else
          {
            v10 = 0;
          }
          v34 = v10;
LABEL_21:
          v36 = 0;
          FindFileData.ftCreationTime.dwLowDateTime = 0;
          FindFileData.ftCreationTime.dwHighDateTime = 0;
          FindFileData.ftLastWriteTime.dwLowDateTime = 0;
          FindFileData.ftLastWriteTime.dwHighDateTime = 0;
          v13 = (wchar_t *)sub_40E267(v11);
          Source = v13;
          if ( (wcspbrk((const wchar_t *)v11, L"*?") || v10)
            && (v14 = (wchar_t *)sub_407BA9(v10, (wchar_t *)v11, &FindFileData, &hFindFile)) != 0 )
          {
            v36 = 1;
            free(v13);
            v11 = (char *)v14;
            v15 = (wchar_t *)sub_40F89E(v14, FindFileData.cFileName);
            Source = v15;
          }
          else
          {
            v15 = Source;
          }
          do
          {
            v16 = sub_40AC61(0x10u);
            if ( !wcschr(v15, 0x20u) || wcschr(v15, 0x22u) )
            {
              v16[1] = sub_40E267((char *)v15);
            }
            else
            {
              v17 = v15 + 1;
              while ( *v15++ )
                ;
              v19 = v15 - v17 + 3;
              v20 = (wchar_t *)sub_40AC3C((unsigned __int64)v19 >> 31 != 0 ? -1 : 2 * v19);
              v16[1] = v20;
              wcscpy_s(v20, v19, L"\"");
              wcscat_s((wchar_t *)v16[1], v19, Source);
              wcscat_s((wchar_t *)v16[1], v19, L"\"");
              v15 = Source;
            }
            if ( !byte_4216B5 || sub_4079FA(v15, &FindFileData, &hFindFile) )
            {
              v21 = sub_4079E0((char *)&FindFileData);
              v31 = HIDWORD(v21);
              HIDWORD(v21) = v21;
              v16[3] = v31;
            }
            else
            {
              v21 = 0i64;
              v16[3] = 0;
              v31 = 0;
            }
            v22 = byte_4216B5 == 0;
            v16[2] = v21;
            if ( v22 )
            {
              sub_40E36C(&v33, v16);
            }
            else
            {
              v23 = v33;
              if ( !v33 )
                goto LABEL_43;
              LODWORD(v21) = v33;
              do
              {
                if ( __PAIR64__(v31, HIDWORD(v21)) > *(_QWORD *)(v21 + 8) )
                  break;
                v23 = (_DWORD *)v21;
                LODWORD(v21) = *(_DWORD *)v21;
              }
              while ( (_DWORD)v21 );
              v15 = Source;
              if ( v23 == (_DWORD *)v21 )
              {
LABEL_43:
                v33 = v16;
              }
              else
              {
                *v23 = v16;
                *v16 = v21;
              }
            }
            free(v15);
            if ( !v36 )
              break;
            if ( !wcspbrk((const wchar_t *)v11, L"*?") )
              break;
            if ( !sub_407B86(&FindFileData, hFindFile) )
              break;
            v15 = (wchar_t *)sub_40F89E((wchar_t *)v11, FindFileData.cFileName);
            Source = v15;
          }
          while ( v15 );
        }
        while ( sub_404AB4(&v30, &v34) );
        v2 = v28;
        v6 = v29;
        v9 = v26;
      }
      if ( v6 != (__int16 *)v2[1] )
        free(v6);
      free(v9);
      v2 = (_DWORD *)*v2;
      v5 = a2;
      v28 = v2;
    }
    while ( v2 );
    return v33;
  }
  return (_DWORD *)v3;
}
// 4216B5: using guessed type char byte_4216B5;
// 421EC8: using guessed type int dword_421EC8;

//----- (00404AB4) --------------------------------------------------------
char __fastcall sub_404AB4(__int16 **a1, _DWORD *a2)
{
  __int16 **v2; // ebx
  unsigned __int16 *v3; // esi
  __int16 v4; // di
  __int16 v5; // cx
  __int16 v7; // cx
  bool v8; // zf
  __int16 v9; // ax
  __int16 v10; // ax
  int v11; // eax
  __int16 v12; // cx
  __int16 v13; // cx
  __int16 v14; // dx

  v2 = a1;
  v3 = (unsigned __int16 *)*a1;
  v4 = **a1;
  if ( v4 )
  {
    v5 = **a1;
    do
    {
      if ( v5 != 32 )
      {
        v4 = v5;
        if ( v5 != 9 )
          break;
      }
      v5 = *++v3;
      v4 = *v3;
    }
    while ( *v3 );
    v2 = a1;
  }
  *a2 = v3;
  if ( !v4 )
    return 0;
  if ( v4 == 34 )
  {
    v7 = 34;
    while ( v7 )
    {
      v7 = *++v3;
      if ( *v3 == 34 )
        goto LABEL_15;
    }
LABEL_14:
    sub_4053F6(0, 0x40Eu);
LABEL_15:
    v8 = *++v3 == 0;
LABEL_35:
    if ( v8 )
      goto LABEL_37;
    goto LABEL_36;
  }
  v9 = v4;
  if ( v4 != 123 )
    goto LABEL_30;
  while ( 1 )
  {
    if ( *++v3 == 34 )
    {
      ++v3;
      do
      {
        v10 = *v3;
        if ( !*v3 )
          break;
        ++v3;
      }
      while ( v10 != 34 );
    }
    v11 = *v3;
    if ( v11 == 125 )
      break;
    if ( !(_WORD)v11 )
    {
      sub_4053F6(0, 0x423u);
      break;
    }
  }
  v9 = *++v3;
  if ( *v3 == 34 )
  {
    v12 = 34;
    while ( v12 )
    {
      v12 = *++v3;
      if ( *v3 == 34 )
        goto LABEL_15;
    }
    goto LABEL_14;
  }
  if ( v9 )
  {
LABEL_30:
    v13 = v9;
    while ( v13 != 32 )
    {
      v14 = v13;
      if ( v13 != 9 )
      {
        v13 = *++v3;
        v14 = *v3;
        if ( *v3 )
          continue;
      }
      v8 = v14 == 0;
      goto LABEL_35;
    }
LABEL_36:
    *v3++ = 0;
  }
LABEL_37:
  *v2 = (__int16 *)v3;
  return 1;
}

//----- (00404BE9) --------------------------------------------------------
int __thiscall sub_404BE9(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // edi
  int result; // eax

  v1 = this;
  v2 = (int)this;
  while ( v1 )
  {
    v1 = (_DWORD *)*v1;
    free(*(void **)(v2 + 4));
    result = dword_432618;
    *(_DWORD *)v2 = dword_432618;
    dword_432618 = v2;
    v2 = (int)v1;
  }
  return result;
}
// 432618: using guessed type int dword_432618;

//----- (00404C13) --------------------------------------------------------
_DWORD *__fastcall sub_404C13(char *Src, char a2)
{
  _DWORD *v4; // edi
  int v5; // ecx
  int *v6; // ecx
  _DWORD *result; // eax

  v4 = sub_40AC61(0x20u);
  v4[1] = sub_40E267(Src);
  *((_BYTE *)v4 + 8) = a2;
  *((_BYTE *)v4 + 9) = 0;
  v4[4] = 0;
  v4[5] = 0;
  v4[6] = 0;
  v6 = &dword_421490[sub_40E381((wint_t *)Src, v5)];
  *v4 = *v6;
  result = v4;
  *v6 = (int)v4;
  return result;
}
// 404C42: variable 'v5' is possibly undefined
// 421490: using guessed type int dword_421490[128];

//----- (00404C5A) --------------------------------------------------------
int __fastcall sub_404C5A(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // eax
  _DWORD *v6; // esi
  _DWORD *v7; // edi
  _DWORD *v8; // esi
  _DWORD *v9; // esi
  int result; // eax

  v5 = a2;
  v6 = 0;
  v7 = (_DWORD *)*a1;
  if ( !*a1 )
    goto LABEL_7;
  do
  {
    if ( v7[1] == v5 )
    {
      if ( *((_BYTE *)v7 + 8) == *(_BYTE *)(a3 + 8) )
        break;
      v5 = a2;
    }
    v6 = v7;
    v7 = (_DWORD *)*v7;
  }
  while ( v7 );
  if ( !v7 )
  {
LABEL_7:
    v7 = sub_40AC61(0x14u);
    v7[1] = a2;
    *((_BYTE *)v7 + 8) = *(_BYTE *)(a3 + 8);
    if ( v6 )
    {
      *v6 = v7;
    }
    else if ( *a1 )
    {
      *(_DWORD *)*a1 = v7;
    }
    else
    {
      *a1 = v7;
    }
  }
  v8 = sub_40E215();
  v8[1] = sub_40E267(*(char **)(a3 + 4));
  sub_40E36C((_DWORD **)v7 + 3, v8);
  v9 = sub_40E215();
  v9[1] = sub_40E267((char *)dword_421ECC);
  sub_40E36C((_DWORD **)v7 + 4, v9);
  result = a3;
  *(_DWORD *)(a3 + 28) = a1;
  return result;
}

//----- (00404D06) --------------------------------------------------------
wchar_t **__thiscall sub_404D06(_DWORD *this)
{
  _DWORD *v1; // ebx
  int v2; // edi
  _DWORD *v3; // esi
  const unsigned __int16 *v4; // edx
  wchar_t *v5; // edi
  int **v6; // esi
  const wchar_t *v7; // eax
  const wchar_t *v8; // eax
  int v9; // edx
  _DWORD *v10; // ecx
  _DWORD *v11; // edx
  int v12; // ecx
  int **i; // esi
  _DWORD *v14; // eax
  int v16; // [esp-Ch] [ebp-2Ch]
  char v17; // [esp-8h] [ebp-28h]
  rsize_t SizeInWords; // [esp+10h] [ebp-10h]
  wchar_t **SizeInWordsa; // [esp+10h] [ebp-10h]
  char v21; // [esp+1Fh] [ebp-1h]

  v1 = this;
  v2 = 0;
  v3 = (_DWORD *)this[4];
  if ( v3 )
  {
    do
    {
      v4 = (const unsigned __int16 *)v3[1];
      v2 += wcslen(v4) + 1;
      if ( *v4 != 34 && wcschr(v4, 0x20u) )
        v2 += 2;
      v3 = (_DWORD *)*v3;
    }
    while ( v3 );
    v1 = this;
  }
  SizeInWords = v2 + 1;
  v5 = (wchar_t *)sub_40AC3C((unsigned __int64)(unsigned int)(v2 + 1) >> 31 != 0 ? -1 : 2 * (v2 + 1));
  *v5 = 0;
  v6 = (int **)v1[4];
  if ( v6 )
  {
    do
    {
      v7 = (const wchar_t *)v6[1];
      if ( *v7 == 34 || !wcschr(v7, 0x20u) )
      {
        v21 = 0;
      }
      else
      {
        v21 = 1;
        wcscat_s(v5, SizeInWords, L"\"");
      }
      wcscat_s(v5, SizeInWords, (const wchar_t *)v6[1]);
      v8 = L"\" ";
      if ( !v21 )
        v8 = L" ";
      wcscat_s(v5, SizeInWords, v8);
      v6 = (int **)*v6;
    }
    while ( v6 );
    v1 = this;
  }
  v9 = v1[1];
  v10 = (_DWORD *)v1[3];
  v17 = *((_BYTE *)v1 + 8);
  v16 = *(_DWORD *)(v9 + 16);
  v11 = *(_DWORD **)(v9 + 12);
  dword_421ECC = v5;
  SizeInWordsa = sub_405780(v10, v11, v16, v17, 0);
  if ( !SizeInWordsa )
  {
    for ( i = (int **)v1[3]; i; i = (int **)*i )
    {
      v14 = sub_40E3B9((wchar_t *)i[1], v12, v12);
      LOBYTE(v12) = *((_BYTE *)v14 + 9) & 0xFB;
      v14[7] = 0;
      LOBYTE(v12) = v12 | 2;
      *((_BYTE *)v14 + 9) = v12;
    }
  }
  free(v5);
  return SizeInWordsa;
}
// 404E2E: variable 'v12' is possibly undefined

//----- (00404E5B) --------------------------------------------------------
int __thiscall sub_404E5B(_DWORD *this)
{
  int v2; // edi
  wchar_t **v3; // eax

  v2 = 0;
  while ( this )
  {
    v3 = sub_404D06(this);
    this = (_DWORD *)*this;
    v2 += (int)v3;
  }
  return v2;
}

//----- (00404E79) --------------------------------------------------------
void __thiscall sub_404E79(_DWORD *this)
{
  _DWORD *v2; // esi
  _DWORD *v3; // ecx
  void *v4; // [esp-4h] [ebp-Ch]

  v2 = (_DWORD *)*this;
  while ( v2 )
  {
    v3 = (_DWORD *)v2[3];
    v4 = v2;
    *v3 = dword_432618;
    dword_432618 = v2[4];
    *(_DWORD *)dword_432618 = v3;
    v2 = (_DWORD *)*v2;
    free(v4);
  }
  *this = 0;
}
// 432618: using guessed type int dword_432618;

//----- (00404EA8) --------------------------------------------------------
wchar_t *__fastcall sub_404EA8(wchar_t **a1, int *a2)
{
  wchar_t *result; // eax
  unsigned int v5; // ecx
  int v6; // esi
  unsigned int v7; // kr00_4
  wchar_t *v8; // ecx
  wchar_t *v9; // ecx
  int v10; // eax

  for ( result = *a1; (*a1)[*a2 - 1] != 10; result = *a1 )
  {
    result = fgetws(&Src, 1024, Stream);
    if ( !result )
      break;
    v5 = wcslen(&Src);
    if ( *((_WORD *)&dword_4216BC + v5) == 92 && *((_WORD *)&dword_4216BC + v5 + 1) == 10 )
    {
      *((_WORD *)&dword_4216BC + v5 + 1) = 0;
      *((_WORD *)&dword_4216BC + v5) = 32;
    }
    v6 = *a2;
    v7 = wcslen(&Src);
    v8 = *a1;
    *a2 += v7;
    v9 = (wchar_t *)sub_40AC7F(v8, 2 * (v7 + v6) + 2);
    if ( !v9 )
    {
      sub_4053F6(dword_4216A4, 0x419u);
      v9 = 0;
    }
    v10 = *a2 - v6;
    *a1 = v9;
    wcscpy_s(&v9[v6], v10 + 1, &Src);
  }
  return result;
}
// 4216A4: using guessed type int dword_4216A4;
// 4216BC: using guessed type int dword_4216BC;

//----- (00404FB3) --------------------------------------------------------
void *__fastcall sub_404FB3(char *a1, int a2, void **a3)
{
  void *v4; // edi
  void *result; // eax

  if ( *a3 )
  {
    if ( (a2 & 7) == 0 )
    {
      v4 = 0;
      if ( (unsigned int)(a2 + 8) > 0x3FFFFFFE || (v4 = realloc(*a3, 4 * (a2 + 8))) == 0 )
        sub_4053F6(dword_4216B0, 0x41Bu);
      *a3 = v4;
    }
  }
  else
  {
    *a3 = sub_40AC3C(0x20u);
  }
  result = sub_40E267(a1);
  *((_DWORD *)*a3 + a2) = result;
  return result;
}
// 4216B0: using guessed type int dword_4216B0;

//----- (00405021) --------------------------------------------------------
char *__fastcall sub_405021(wchar_t *Str, int *a2, void **a3)
{
  wchar_t *v5; // eax
  int v6; // ecx
  char *result; // eax
  wchar_t *Context; // [esp+8h] [ebp-4h] BYREF

  v5 = wcschr(Str, 0x5Cu);
  if ( v5 )
  {
    v6 = *(v5 - 1);
    if ( (v6 == 32 || v6 == 9) && v5[1] == 10 )
      *v5 = 0;
  }
  Context = 0;
  for ( result = (char *)wcstok_s(Str, L" \t\n", &Context); result; result = (char *)wcstok_s(0, L" \t\n", &Context) )
  {
    if ( *(_WORD *)result == 64 )
      return (char *)sub_4053F6(0, 0xFA1u, result + 2);
    sub_404FB3(result, *a2, a3);
    ++*a2;
  }
  return result;
}

//----- (004050AD) --------------------------------------------------------
void __fastcall sub_4050AD(wchar_t *a1, int *a2, void **a3)
{
  int *v4; // esi
  wchar_t *v5; // eax
  wchar_t *v6; // ebx
  wchar_t *v7; // esi
  bool v8; // zf
  wchar_t v9; // ax
  int *v10; // edx
  unsigned int v11; // ebx
  wchar_t *v12; // edi
  wchar_t v13; // cx
  wchar_t *v14; // ecx
  wchar_t v15; // ax
  __int16 v16; // ax
  int v17; // ebx
  int *v18; // eax
  int v19; // [esp+Ch] [ebp-10h] BYREF
  wchar_t *v20; // [esp+10h] [ebp-Ch] BYREF
  int *v21; // [esp+14h] [ebp-8h]
  char v22; // [esp+1Bh] [ebp-1h]

  v22 = 0;
  v4 = a2;
  v21 = a2;
  v5 = wcschr(a1, 0x22u);
  v6 = v5;
  if ( !v5 )
  {
    sub_405021(a1, v4, a3);
    return;
  }
  if ( v5 == a1 )
    goto LABEL_14;
  v7 = v5 - 1;
  if ( *(v5 - 1) != 61 )
  {
    v4 = v21;
LABEL_14:
    *v5 = 0;
    sub_405021(a1, v4, a3);
    v7 = v6 + 1;
    goto LABEL_15;
  }
  *v5 = 32;
  v8 = v7 == a1;
  if ( v7 > a1 )
  {
    while ( 1 )
    {
      v9 = *v7;
      if ( *v7 == 32 )
        goto LABEL_12;
      if ( v9 != 9 && v9 != 10 && --v7 > a1 )
        continue;
      v8 = v7 == a1;
      break;
    }
  }
  if ( !v8 )
  {
LABEL_12:
    v10 = v21;
    *v7++ = 0;
    sub_405021(a1, v10, a3);
  }
LABEL_15:
  v20 = v7;
  v11 = wcslen(v7);
  v12 = v7;
  if ( !*v7 )
    goto LABEL_32;
  v13 = *v7;
  while ( 1 )
  {
    if ( v13 != 34 )
    {
      if ( v13 == 92 )
      {
        v16 = *(v12 - 1);
        if ( (v16 == 32 || v16 == 9) && v12[1] == 10 )
        {
          v17 = v11 - 2;
          *v12 = 0;
          v19 = v17;
          if ( !v22 )
          {
            v22 = 1;
            v20 = (wchar_t *)sub_40E267((char *)v7);
          }
          sub_404EA8(&v20, &v19);
          v7 = v20;
          v12 = &v20[v17];
          v11 = v19;
        }
      }
      goto LABEL_29;
    }
    if ( v12[1] != 34 )
      break;
    v14 = v12;
    *v12 = 34;
    do
    {
      ++v14;
      v15 = v14[1];
      *v14 = v15;
    }
    while ( v15 );
LABEL_29:
    v13 = *++v12;
    if ( !*v12 )
      goto LABEL_32;
  }
  v18 = v21;
  *v12++ = 0;
  sub_404FB3((char *)v7, *v18, a3);
  ++*v21;
  sub_4050AD(a3);
LABEL_32:
  if ( v12 == &v7[v11] )
    sub_4053F6(0, 0x3EEu);
  if ( v22 )
    free(v7);
}

//----- (0040525E) --------------------------------------------------------
void __thiscall sub_40525E(wchar_t *FileName)
{
  void **v2; // edi
  unsigned int v3; // esi
  FILE *v4; // eax
  wchar_t *v5; // esi
  unsigned int v6; // ecx
  unsigned int v7; // edx
  void **v8; // [esp+10h] [ebp-10h] BYREF
  unsigned int v9; // [esp+14h] [ebp-Ch] BYREF
  wchar_t *v10; // [esp+18h] [ebp-8h] BYREF
  unsigned int v11; // [esp+1Ch] [ebp-4h] BYREF

  v2 = 0;
  v3 = 0;
  v9 = 0;
  v4 = wfsopen(FileName, L"rt,ccs=unicode", 32);
  Stream = v4;
  if ( !v4 )
    v4 = (FILE *)sub_4053F6(0, 0x41Cu, FileName);
  v8 = 0;
  if ( fgetws(&Src, 1024, v4) )
  {
    v5 = &Src;
    do
    {
      v6 = wcslen(&Src);
      v11 = v6;
      if ( v6 == 1023 && word_421EBC != 10
        || *((_WORD *)&dword_4216BC + v6 + 1) == 10 && *((_WORD *)&dword_4216BC + v6) == 92 )
      {
        if ( *((_WORD *)&dword_4216BC + v6 + 1) == 10 && *((_WORD *)&dword_4216BC + v6) == 92 )
        {
          v7 = 2 * (v6 - 1);
          if ( v7 >= 0x800 )
            __report_rangecheckfailure();
          v11 = v6 - 1;
          *(wchar_t *)((char *)&Src + v7) = 0;
          *((_WORD *)&dword_4216BC + v6) = 32;
        }
        v10 = (wchar_t *)sub_40E267((char *)&Src);
        sub_404EA8(&v10, (int *)&v11);
        v5 = v10;
      }
      sub_4050AD(v5, (int *)&v9, (void **)&v8);
      if ( v5 != &Src )
        free(v5);
      v5 = &Src;
    }
    while ( fgetws(&Src, 1024, Stream) );
    v3 = v9;
    v2 = v8;
  }
  if ( fclose(Stream) == -1 )
    sub_4053F6(0, 0x424u, FileName);
  sub_40BDF3(v3, (int)v2);
  while ( v3 )
  {
    if ( v2[--v3] )
      free(v2[v3]);
  }
}
// 410495: using guessed type void __noreturn __report_rangecheckfailure(void);
// 4216BC: using guessed type int dword_4216BC;
// 421EBC: using guessed type __int16 word_421EBC;

//----- (004053F6) --------------------------------------------------------
int sub_4053F6(int a1, unsigned int a2, ...)
{
  int v2; // esi
  int result; // eax
  unsigned int v4; // edi
  wchar_t *v5; // eax
  va_list ArgList; // [esp+18h] [ebp+10h] BYREF

  va_start(ArgList, a2);
  v2 = 2;
  if ( (byte_41148C & 0x20) == 0 || (result = a2 - 4000, a2 - 4000 >= 0x3E8) )
  {
    sub_40556C();
    if ( a1 )
      sub_40C6E7((wchar_t *)L"%s(%u) : ", ::ArgList, a1);
    else
      sub_40C6E7((wchar_t *)L"NMAKE : ");
    v4 = a2 / 0x3E8;
    if ( a2 / 0x3E8 == 1 )
    {
      sub_4054D0(0x14u);
      if ( a2 == 1051 )
        v2 = 4;
    }
    else if ( v4 == 2 )
    {
      sub_4054D0(0x15u);
    }
    else if ( v4 == 4 )
    {
      sub_4054D0(0x16u);
    }
    sub_40C6E7((wchar_t *)L" U%04d: ", a2);
    v5 = (wchar_t *)sub_40C50D(a2);
    sub_40C75F(v5, ArgList);
    sub_40C6F6();
    result = sub_40C6C9();
    if ( v4 == 1 )
    {
      sub_40C6E7((wchar_t *)L"Stop.\n");
      sub_40C479();
      exit(v2);
    }
  }
  return result;
}
// 41148C: using guessed type char byte_41148C;
// 4053F6: using guessed type unsigned int arg_4;

//----- (004054D0) --------------------------------------------------------
void sub_4054D0(unsigned int a1, ...)
{
  unsigned int v1; // ecx
  unsigned int v2; // esi
  wchar_t *v3; // eax
  wchar_t *v4; // eax
  va_list va; // [esp+14h] [ebp+Ch] BYREF

  va_start(va, a1);
  if ( a1 != 13 && (byte_41148C & 0x20) != 0 )
    return;
  sub_40556C();
  v1 = a1;
  v2 = a1 - 20;
  if ( a1 == 24 )
  {
    if ( v2 > 5 )
    {
      sub_40C7D6();
      v1 = 24;
LABEL_14:
      v4 = (wchar_t *)sub_40C50D(v1);
      sub_40C802(v4, va);
      goto LABEL_8;
    }
    sub_40C6F6();
    v1 = 24;
  }
  else if ( v2 > 5 )
  {
    goto LABEL_14;
  }
  v3 = (wchar_t *)sub_40C50D(v1);
  sub_40C75F(v3, va);
LABEL_8:
  if ( a1 >= 0xA && a1 <= 0x17 || a1 == 124 )
  {
    if ( v2 > 5 )
      goto LABEL_19;
  }
  else
  {
    if ( v2 > 5 )
    {
      sub_40C7D6();
LABEL_19:
      sub_40C7A9();
      return;
    }
    sub_40C6F6();
  }
  sub_40C6C9();
}
// 41148C: using guessed type char byte_41148C;

//----- (0040556C) --------------------------------------------------------
int sub_40556C()
{
  int result; // eax

  if ( !byte_421EE0 )
  {
    byte_421EE0 = 1;
    sub_4054D0(0x18u, L"14.29.30146.0");
    sub_4054D0(0x19u);
    return sub_40C6C9();
  }
  return result;
}
// 401638: using guessed type wchar_t a1429301460[14];
// 421EE0: using guessed type char byte_421EE0;

//----- (00405598) --------------------------------------------------------
void sub_405598()
{
  unsigned int v0; // edi
  unsigned int v1; // esi
  int v2; // [esp-4h] [ebp-Ch]

  v0 = 100;
  v1 = 103;
  do
    sub_4054D0(v0++, L"NMAKE");
  while ( v0 < 0x67 );
  do
  {
    if ( v1 == 113 )
    {
      v2 = 114;
    }
    else
    {
      if ( v1 != 121 )
        goto LABEL_8;
      v2 = 122;
    }
    v1 = v2;
LABEL_8:
    sub_4054D0(v1++);
  }
  while ( v1 <= 0x7C );
}
// 401654: using guessed type wchar_t aNmake_1[6];

//----- (004055D7) --------------------------------------------------------
size_t __fastcall sub_4055D7(_DWORD *a1, const wchar_t **a2, wchar_t *String)
{
  wchar_t *v3; // esi
  size_t result; // eax
  wchar_t *i; // edi
  const wchar_t *v7; // esi
  int v8; // eax
  char v10; // [esp+13h] [ebp-1h]

  v3 = String;
  result = (size_t)a1;
  v10 = 1;
  for ( i = String; *i; ++i )
    ;
  *a1 = 0;
  if ( String < i )
  {
    while ( 1 )
    {
      result = wcsspn(v3, L" \t");
      v7 = &v3[result];
      if ( v7 >= i )
        goto LABEL_36;
      if ( a2 )
        *a2++ = v7;
      if ( *v7 == 34 )
        break;
      v3 = wcspbrk(v7, L" \t\"/");
      if ( v3 )
      {
        while ( v3 < i )
        {
          if ( *v3 == 47 )
          {
            if ( v10 )
              break;
            v3 = wcspbrk(v3 + 1, L" \t\"/");
            if ( v3 )
              continue;
          }
          if ( !v3 )
            goto LABEL_26;
          break;
        }
        if ( *v3 == 34 )
        {
          do
            ++v3;
          while ( v3 < i && *v3 != 34 );
          v3 = wcspbrk(v3, L" \t");
        }
      }
LABEL_26:
      if ( !v10 )
        goto LABEL_31;
      v10 = 0;
      if ( !v3 )
        goto LABEL_32;
      if ( *v3 != 47 )
        goto LABEL_33;
      if ( a2 )
      {
        *v3 = 0;
        *(a2 - 1) = (const wchar_t *)sub_40E267((char *)*(a2 - 1));
        *v3-- = 47;
        goto LABEL_31;
      }
LABEL_35:
      result = (size_t)a1;
      ++*a1;
      if ( v3 >= i )
        goto LABEL_36;
    }
    v3 = (wchar_t *)(v7 + 1);
    if ( v3 >= i )
      goto LABEL_35;
    do
    {
      v8 = *v3;
      if ( v8 == 92 )
      {
        ++v3;
      }
      else if ( (_WORD)v8 == 34 )
      {
        break;
      }
      ++v3;
    }
    while ( v3 < i );
    if ( v3 >= i )
      goto LABEL_35;
    v3 = wcspbrk(v3 + 1, L" \t");
LABEL_31:
    if ( !v3 )
LABEL_32:
      v3 = i;
LABEL_33:
    if ( a2 )
      *v3++ = 0;
    goto LABEL_35;
  }
LABEL_36:
  if ( a2 )
    *a2 = 0;
  return result;
}

//----- (0040573E) --------------------------------------------------------
wchar_t **__fastcall sub_40573E(char *Src, _DWORD *a2, int a3, char a4, const wchar_t *a5)
{
  _DWORD *v7; // ebx
  wchar_t **result; // eax

  v7 = sub_40E215();
  v7[1] = sub_40E267(Src);
  result = sub_405780(v7, a2, a3, a4, a5);
  *v7 = dword_432618;
  dword_432618 = (int)v7;
  return result;
}
// 432618: using guessed type int dword_432618;

//----- (00405780) --------------------------------------------------------
wchar_t **__fastcall sub_405780(_DWORD *a1, _DWORD *a2, int a3, char a4, const wchar_t *a5)
{
  wchar_t **v5; // esi
  _DWORD *v6; // ebx
  _DWORD *v7; // edi
  bool v8; // bl
  bool v10; // al
  char v11; // bl
  char v12; // bh
  wchar_t *v13; // ecx
  wchar_t i; // ax
  BOOL v15; // eax
  wchar_t *v16; // esi
  wchar_t *v17; // eax
  wchar_t *v18; // esi
  int j; // eax
  bool v20; // zf
  wchar_t *v21; // eax
  wchar_t *v22; // edx
  unsigned int v24; // esi
  wchar_t *v25; // edi
  char v26; // bl
  bool v27; // cl
  char v28; // al
  char v29; // dl
  wchar_t **v30; // eax
  int v31; // [esp-Ch] [ebp-60h]
  bool v32; // [esp+10h] [ebp-44h]
  wchar_t *v33; // [esp+14h] [ebp-40h]
  _DWORD *v34; // [esp+20h] [ebp-34h]
  wchar_t *v35; // [esp+24h] [ebp-30h] BYREF
  int v36; // [esp+28h] [ebp-2Ch]
  int v37; // [esp+2Ch] [ebp-28h]
  int v38; // [esp+30h] [ebp-24h]
  int v39; // [esp+34h] [ebp-20h]
  int v40; // [esp+38h] [ebp-1Ch]
  int v41; // [esp+3Ch] [ebp-18h] BYREF
  unsigned int v42; // [esp+40h] [ebp-14h]
  int v43; // [esp+44h] [ebp-10h]
  wchar_t **v44; // [esp+48h] [ebp-Ch] BYREF
  wchar_t *Str; // [esp+4Ch] [ebp-8h] BYREF
  char v46; // [esp+53h] [ebp-1h]

  ++dword_421EC0;
  v5 = 0;
  v42 = 0;
  v6 = a2;
  v34 = a2;
  v44 = 0;
  v7 = a1;
  if ( (byte_41148C & 8) != 0 )
    return 0;
  if ( (byte_41148C & 0x10) != 0 )
  {
    if ( a1 )
    {
      v8 = (a4 & 4) != 0;
      do
      {
        sub_407951(v7[1], v8);
        v7 = (_DWORD *)*v7;
      }
      while ( v7 );
    }
    return 0;
  }
  if ( !a2 )
    goto LABEL_52;
  v10 = (a4 & 0x40) != 0;
  v40 = 33;
  v32 = v10;
  v39 = 45;
  v38 = 64;
  v37 = 32;
  v36 = 9;
  do
  {
    v11 = sub_4093B0((wchar_t *)v6[1], (const wchar_t **)&v35, (wchar_t *)&a3, v10);
    v12 = 0;
    dword_431EF0 = 0;
    v13 = v35;
    LOBYTE(v43) = 0;
    Str = v35;
    for ( i = *v35; ; i = *v13 )
    {
      if ( i == (_WORD)v40 )
      {
LABEL_40:
        v12 |= 4u;
LABEL_41:
        LOBYTE(v43) = v12;
        goto LABEL_42;
      }
      if ( i != (_WORD)v39 )
      {
        if ( i == (_WORD)v38 )
          break;
        if ( i == 94 )
          goto LABEL_19;
        if ( i == (_WORD)v37 )
          goto LABEL_42;
        if ( i != (_WORD)v36 )
          goto LABEL_25;
        if ( i == (_WORD)v40 )
          goto LABEL_40;
      }
      if ( i != (_WORD)v39 )
        break;
      v12 |= 2u;
      Str = v13 + 1;
      LOBYTE(v43) = v12;
      if ( iswdigit(v13[1]) )
      {
        v18 = Str;
        dword_431EF0 = wcstoul(Str, &Str, 10);
        if ( *errno() == 34 )
        {
          v31 = dword_4216A4;
          *Str = 0;
          sub_4053F6(v31, 0x436u, v18);
        }
        for ( j = iswspace(*Str); j; j = iswspace(*Str) )
          ++Str;
      }
      else
      {
        dword_431EF0 = -1;
      }
      v13 = Str - 1;
LABEL_42:
      Str = ++v13;
    }
    if ( i == (_WORD)v38 )
    {
      if ( (byte_41148E & 4) != 0 )
        goto LABEL_42;
      v12 |= 1u;
      goto LABEL_41;
    }
LABEL_19:
    if ( i != 94 )
      goto LABEL_42;
    Str = ++v13;
    v15 = *v13 == (_WORD)v37 || *v13 == (_WORD)v36;
    if ( (v15 ? 0xFFC2 : 0) != 0 )
      goto LABEL_42;
LABEL_25:
    if ( (v12 & 4) != 0 )
    {
      if ( sub_407663((__int16 *)v13, a3, a4, v43, a5, &v44) )
      {
        v16 = Str;
        if ( wcschr(Str, 0x24u) )
        {
          v17 = (wchar_t *)sub_40EC83((__int16 *)Str, 255, &a3);
          Str = v17;
        }
        else
        {
          v17 = Str;
        }
        if ( v16 != v17 )
          free(v17);
        v5 = v44;
        v20 = (a4 & 2) == 0;
        goto LABEL_47;
      }
      v13 = Str;
    }
    v33 = v13;
    if ( !v11 )
    {
      v21 = wcschr(v13, 0x24u);
      v13 = Str;
      if ( v21 )
      {
        v13 = (wchar_t *)sub_40EC83((__int16 *)Str, 255, &a3);
        Str = v13;
      }
    }
    v22 = v13 + 1;
    while ( *v13++ )
      ;
    v24 = v13 - v22 + 1;
    if ( v24 <= 0x8000 )
      v24 = 0x8000;
    v25 = (wchar_t *)sub_40AC3C((unsigned __int64)v24 >> 31 != 0 ? -1 : 2 * v24);
    wcscpy_s(v25, v24, Str);
    if ( sub_40FA87((char *)v25, v24, Str, a5) )
      sub_4053F6(0, 0x447u, Str);
    v26 = a4 & 4;
    v27 = (v12 & 2) != 0;
    v46 = a4 & 2;
    while ( 2 )
    {
      if ( v26 && (v12 & 8) == 0 )
      {
        v28 = 0;
        goto LABEL_70;
      }
      v28 = 1;
      if ( !v26 && ((a4 & 8) != 0 || (v12 & 1) != 0) )
      {
        v28 = 1;
        v29 = 0;
      }
      else
      {
LABEL_70:
        v29 = 1;
      }
      v30 = sub_406E33(v25, v29, v28, v27, (void **)&v41);
      v5 = v30;
      v44 = v30;
      if ( v46 )
        goto LABEL_85;
      if ( v30 != (wchar_t **)259 )
        goto LABEL_81;
      if ( byte_4323F9 )
      {
        if ( v42 >= 0xA )
          goto LABEL_82;
        sub_4053F6(0, 0xFADu, v41);
        v27 = (v12 & 2) != 0;
        ++v42;
        continue;
      }
      break;
    }
    sub_4053F6(0, 0xFACu, v41);
    v5 = 0;
    v44 = 0;
LABEL_81:
    if ( !v5 )
      goto LABEL_85;
LABEL_82:
    if ( (unsigned int)v5 > dword_431EF0 && !byte_4216B7 )
      sub_4053F6(0, 0x435u, v41, v5);
LABEL_85:
    if ( v33 != Str )
      free(Str);
    free(v35);
    free(v25);
    v20 = v46 == 0;
LABEL_47:
    if ( v20 && byte_4216B7 && v5 && (unsigned int)v5 > dword_431EF0 )
    {
LABEL_53:
      if ( !byte_4216B7 || (unsigned int)v5 <= dword_431EF0 )
        return 0;
      return v5;
    }
    v10 = v32;
    v6 = (_DWORD *)*v34;
    v34 = v6;
  }
  while ( v6 );
LABEL_52:
  if ( (a4 & 2) == 0 )
    goto LABEL_53;
  return 0;
}
// 41148C: using guessed type char byte_41148C;
// 41148E: using guessed type char byte_41148E;
// 4216A4: using guessed type int dword_4216A4;
// 4216B7: using guessed type char byte_4216B7;
// 421EC0: using guessed type int dword_421EC0;
// 431EF0: using guessed type int dword_431EF0;
// 4323F9: using guessed type char byte_4323F9;

//----- (00405BD5) --------------------------------------------------------
wchar_t **__fastcall sub_405BD5(wchar_t *a1, int a2, wchar_t **ArgList)
{
  unsigned int v3; // ebx
  int v4; // esi
  wchar_t **v5; // edi
  char v6; // cl
  wchar_t *v7; // edx
  wchar_t *v8; // ecx
  int v10; // eax
  const wchar_t *v11; // eax
  wchar_t **result; // eax
  wchar_t **v13; // esi
  int v14; // [esp+Ch] [ebp-8h]

  v3 = 0;
  v4 = a2;
  v5 = ArgList;
  if ( a1 )
  {
    ArgList[a2] = L">";
    v5[a2 + 1] = a1;
    v4 = a2 + 2;
    v5[a2 + 2] = 0;
LABEL_3:
    v5[v4] = (wchar_t *)L"\"";
    v6 = 1;
    v5[++v4] = 0;
    goto LABEL_13;
  }
  v7 = *ArgList;
  if ( **ArgList == 34 )
  {
    v8 = *ArgList;
    ArgList = (wchar_t **)(v7 + 1);
    while ( *v8++ )
      ;
    if ( v7[(((char *)v8 - (char *)ArgList) >> 1) - 1] == 34 )
    {
      v10 = v4 - 1;
      v14 = v4 - 1;
      if ( v4 - 1 >= 1 )
      {
        while ( !wcspbrk(v5[v10], L"\"") )
        {
          v10 = v14 - 1;
          v14 = v10;
          if ( v10 < 1 )
          {
            v6 = 0;
            goto LABEL_14;
          }
        }
        goto LABEL_3;
      }
    }
  }
  v6 = 0;
LABEL_13:
  while ( v4 >= 0 )
  {
LABEL_14:
    v5[v4 + 2] = v5[v4];
    --v4;
  }
  *v5 = (wchar_t *)dword_421EEC;
  v11 = L"/c \"";
  if ( !v6 )
    v11 = L"/c";
  v5[1] = (wchar_t *)v11;
  *errno() = 0;
  result = (wchar_t **)wspawnvp(1, *v5, (const wchar_t *const *)v5);
  v13 = result;
  if ( result != (wchar_t **)-1 )
  {
    WaitForSingleObject(result, 0xFFFFFFFF);
    ArgList = 0;
    do
    {
      GetExitCodeProcess(v13, (LPDWORD)&ArgList);
      if ( ArgList != (wchar_t **)259 )
        break;
      Sleep(0x3E8u);
      ++v3;
    }
    while ( v3 < 0xA );
    CloseHandle(v13);
    return ArgList;
  }
  return result;
}
// 40166C: using guessed type wchar_t asc_40166C[2];
// 401670: using guessed type wchar_t aC[5];
// 40167C: using guessed type wchar_t aC_0[3];
// 421EEC: using guessed type int dword_421EEC;

//----- (00405CF0) --------------------------------------------------------
wchar_t *__fastcall sub_405CF0(int a1, wchar_t **a2)
{
  char v2; // bl
  wchar_t *v3; // edi
  wchar_t *i; // esi
  wchar_t v5; // ax
  wchar_t v6; // ax
  wchar_t v8; // cx
  int v9; // eax
  wchar_t *v10; // ecx
  wchar_t *v11; // edi
  unsigned int v12; // kr00_4
  FILE *v13; // esi
  wchar_t v14; // cx
  char *v15; // ecx
  wchar_t v16; // bx
  wchar_t v17; // dx
  wchar_t *v18; // ecx
  __int16 v19; // ax
  wchar_t *v20; // ebx
  unsigned int v21; // kr08_4
  wchar_t *v22; // ebx
  unsigned int v23; // kr10_4
  wchar_t *v25; // [esp+10h] [ebp-106B8h]
  size_t RequiredCount; // [esp+18h] [ebp-106B0h] BYREF
  wchar_t *v28; // [esp+1Ch] [ebp-106ACh] BYREF
  wchar_t Destination[4]; // [esp+20h] [ebp-106A8h] BYREF
  wchar_t v30; // [esp+28h] [ebp-106A0h] BYREF
  char v31; // [esp+2Ah] [ebp-1069Eh] BYREF
  WCHAR TempFileName[260]; // [esp+10020h] [ebp-6A8h] BYREF
  wchar_t VarName[257]; // [esp+10228h] [ebp-4A0h] BYREF
  char v34; // [esp+1042Ah] [ebp-29Eh] BYREF
  wchar_t Source[64]; // [esp+10430h] [ebp-298h] BYREF
  wchar_t Buffer; // [esp+104B0h] [ebp-218h] BYREF
  __int16 v37[265]; // [esp+104B2h] [ebp-216h] BYREF

  v2 = 0;
  RequiredCount = 0;
  v28 = 0;
  wcscpy_s(Destination, 0x8000u, L"set ");
  v3 = &v30;
  for ( i = &Str; ; ++i )
  {
    v5 = *i;
    if ( *i != 32 && v5 != 9 )
      break;
  }
  if ( v5 == 47 && i[1] == 65 )
  {
    v6 = i[2];
    if ( v6 == 32 || v6 == 9 )
    {
      v2 = 1;
      i += 3;
    }
  }
  if ( !wcschr(i, 0x3Du) )
    return (wchar_t *)&dword_401690;
  v25 = &v30;
  if ( *i != 61 )
  {
    v8 = *i;
    do
    {
      *v3++ = v8;
      if ( v3 >= TempFileName )
        return 0;
      v8 = *++i;
    }
    while ( *i != 61 );
  }
  if ( v2 )
  {
    v9 = *(v3 - 1);
    if ( v9 == 42 || (_WORD)v9 == 47 || v9 == 37 || v9 == 43 || v9 == 45 || v9 == 38 || v9 == 94 || v9 == 124 )
    {
      --v3;
    }
    else
    {
      v10 = v3 - 2;
      if ( (_WORD)v9 == 62 && *v10 == 62 || (_WORD)v9 == 60 && *v10 == 60 )
        v3 -= 2;
    }
    if ( v30 == 34 )
      v25 = (wchar_t *)&v31;
    *v3 = 61;
    v11 = v3 + 1;
    if ( v11 < TempFileName )
    {
      RequiredCount = 0;
      if ( wgetenv_s(&RequiredCount, &Buffer, 0x106u, L"TMP") || !RequiredCount )
        wcscpy_s(&Buffer, 0x106u, L".");
      if ( !GetTempFileNameW(&Buffer, L"nm", 0, TempFileName) )
        sub_4053F6(dword_4216A4, 0x43Cu, &Buffer);
      wcscpy_s(&Buffer, 0x106u, TempFileName);
      if ( wcschr(&Buffer, 0x20u) && !wcschr(&Buffer, 0x22u) )
      {
        v12 = wcslen(&Buffer);
        memmove(v37, &Buffer, 2 * v12);
        Buffer = 34;
        v37[v12] = 34;
        if ( 2 * v12 + 4 >= 0x20C )
          __report_rangecheckfailure();
        v37[v12 + 1] = 0;
      }
      if ( !sub_405BD5(&Buffer, a1, a2) )
      {
        v13 = wfsopen(&Buffer, L"rt", 32);
        if ( !v13 )
          sub_4053F6(0, 0x41Cu, &Buffer);
        if ( !fgetws(Source, 64, v13) )
          sub_4053F6(0, 0x41Du, &Buffer);
        if ( fclose(v13) == -1 )
          sub_4053F6(0, 0x424u, &Buffer);
        if ( wremove(&Buffer) == -1 )
          sub_4053F6(0, 0x421u, &Buffer);
        if ( &v11[wcslen(Source) + 1] <= TempFileName )
        {
          wcscpy_s(v11, TempFileName - v11, Source);
          goto LABEL_77;
        }
      }
    }
    return 0;
  }
  if ( !*i )
    goto LABEL_76;
  v14 = *i;
  while ( 1 )
  {
    ++i;
    if ( v14 != 94 )
      break;
    if ( *i )
    {
      *v3 = *i++;
      goto LABEL_74;
    }
LABEL_75:
    v14 = *i;
    if ( !*i )
      goto LABEL_76;
  }
  if ( v14 != 37 )
  {
    *v3 = v14;
LABEL_74:
    if ( ++v3 >= TempFileName )
      return 0;
    goto LABEL_75;
  }
  v15 = (char *)VarName;
  v16 = *i;
  if ( *i != 37 )
  {
    v17 = *i;
    do
    {
      v16 = v17;
      if ( !v17 )
        break;
      *(_WORD *)v15 = v17;
      v15 += 2;
      if ( v15 == &v34 )
        return 0;
      v17 = *++i;
      v16 = *i;
    }
    while ( *i != 37 );
  }
  ++i;
  *(_WORD *)v15 = 0;
  if ( v16 )
  {
    wdupenv_s(&v28, 0, VarName);
    if ( v28 )
    {
      v18 = v28;
      do
        v19 = *v18++;
      while ( v19 != (_WORD)RequiredCount );
      v20 = &v3[v18 - (v28 + 1)];
      if ( v20 >= TempFileName )
        return 0;
      wcscpy_s(v3, TempFileName - v3, v28);
      v3 = v20;
      free(v28);
      v28 = 0;
    }
    else
    {
      v21 = wcslen(VarName);
      v22 = &v3[v21 + 2];
      if ( v22 >= TempFileName )
        return 0;
      *v3 = 37;
      wcscpy_s(v3 + 1, TempFileName - (v3 + 1), VarName);
      v3 += v21 + 2;
      *(v22 - 1) = 37;
    }
    goto LABEL_75;
  }
  v23 = wcslen(VarName);
  if ( &v3[v23 + 1] >= TempFileName )
    return 0;
  *v3 = 37;
  wcscpy_s(v3 + 1, TempFileName - (v3 + 1), VarName);
  v3 += v23 + 1;
LABEL_76:
  *v3 = 0;
LABEL_77:
  wcscpy_s(&::Destination, 0x8000u, Destination);
  *v25 = 0;
  return &::Destination + wcslen(Destination);
}
// 401690: using guessed type int dword_401690;
// 410495: using guessed type void __noreturn __report_rangecheckfailure(void);
// 4216A4: using guessed type int dword_4216A4;
// 405CF0: using guessed type __int16 var_216[265];

//----- (00406308) --------------------------------------------------------
char *__thiscall sub_406308(wchar_t *Str)
{
  char *v2; // ebx
  wchar_t *v3; // edi
  wchar_t *v4; // eax
  char *v5; // esi
  char *v6; // eax
  wchar_t *v8; // [esp+10h] [ebp-8h]
  wchar_t *Buffer; // [esp+14h] [ebp-4h] BYREF

  v2 = (char *)sub_40E267((char *)&dword_401690);
  while ( *Str )
  {
    v3 = wcschr(Str, 0x25u);
    if ( v3 && (v4 = wcschr(v3 + 1, 0x25u), (v8 = v4) != 0) )
    {
      *v3 = 0;
      Buffer = 0;
      *v4 = 0;
      v5 = (char *)sub_40E311(v2, Str);
      wdupenv_s(&Buffer, 0, v3 + 1);
      if ( Buffer )
      {
        v2 = (char *)sub_40E311(v5, Buffer);
        free(Buffer);
        Buffer = 0;
      }
      else
      {
        *v3 = 37;
        v6 = (char *)sub_40E311(v5, v3);
        v2 = (char *)sub_40E311(v6, L"%");
      }
      *v3 = 37;
      *v8 = 37;
      Str = v8 + 1;
    }
    else
    {
      v2 = (char *)sub_40E311(v2, Str);
      Str += wcslen(Str);
    }
  }
  return v2;
}
// 401690: using guessed type int dword_401690;
// 4016B0: using guessed type wchar_t asc_4016B0[2];

//----- (00406406) --------------------------------------------------------
char __fastcall sub_406406(int a1, wint_t **a2, int *a3)
{
  wint_t *v3; // esi
  wint_t *v5; // edi
  wint_t v6; // ax
  char *v8; // eax
  const wchar_t *v9; // eax
  int v10; // eax
  int *v11; // edi
  wchar_t *v12; // esi
  int v13; // eax
  char *v14; // esi
  char *v15; // esi
  int v16; // [esp-4h] [ebp-18h]

  v3 = *a2;
  v5 = a2[1];
  if ( iswalpha(**a2) && v3[1] == 58 && !v3[2] )
  {
    v6 = towupper(*v3);
    chdrive(v6 - 64);
    *a3 = 0;
    return 1;
  }
  if ( wcsicmp(v3, L"set") )
  {
    if ( wcsnicmp(v3, L"cd", 2u) )
    {
      if ( wcsnicmp(v3, L"chdir", 5u) )
        return 0;
      v16 = 5;
    }
    else
    {
      v16 = 2;
    }
    v12 = &v3[v16];
    if ( a1 <= 2 )
    {
      sub_4078C7(a1, (__int16 **)a2);
      v13 = *v12;
      if ( (_WORD)v13 )
      {
        if ( v13 != 46 && v13 != 92 && v13 != 47 )
          return 0;
        v15 = sub_406308(v12);
        v11 = a3;
        *a3 = wchdir((const wchar_t *)v15);
        free(v15);
      }
      else
      {
        if ( !v5 || iswalpha(*v5) && v5[1] == 58 && !v5[2] )
          return 0;
        v14 = sub_406308(v5);
        v11 = a3;
        *a3 = wchdir((const wchar_t *)v14);
        free(v14);
      }
LABEL_28:
      if ( *v11 )
        *v11 = 1;
      return 1;
    }
  }
  else if ( a1 != 1 )
  {
    if ( Destination )
    {
      v8 = (char *)sub_405CF0(a1, a2);
      if ( v8 )
      {
        if ( *(_WORD *)v8 )
        {
          v9 = (const wchar_t *)sub_40E267(v8);
          v10 = wputenv(v9);
          v11 = a3;
          *a3 = v10;
          if ( v10 == -1 )
            sub_4053F6(dword_4216B0, 0x41Fu);
          goto LABEL_28;
        }
      }
    }
  }
  return 0;
}
// 4216B0: using guessed type int dword_4216B0;

//----- (004065BD) --------------------------------------------------------
char __fastcall sub_4065BD(wchar_t *FileName, int a2)
{
  int v4; // eax
  wchar_t *v5; // eax
  wchar_t *v6; // edi
  FILE *v7; // eax
  int v8; // ecx
  errno_t v9; // eax
  char v10; // dl
  int v11; // eax
  int v12; // eax
  wchar_t v14; // [esp+10h] [ebp-10h]
  FILE *Stream; // [esp+14h] [ebp-Ch]
  int FileHandle; // [esp+18h] [ebp-8h] BYREF
  bool v17; // [esp+1Fh] [ebp-1h]

  while ( 1 )
  {
    v4 = *FileName;
    if ( (_WORD)v4 != 32 && v4 != 9 )
      break;
    ++FileName;
  }
  v14 = 0;
  v5 = wcspbrk(FileName, L" \t<>\r");
  v6 = v5;
  if ( v5 )
  {
    v14 = *v5;
    *v5 = 0;
  }
  if ( a2 == 4 )
  {
    v7 = _acrt_iob_func(0);
    v8 = 0;
  }
  else
  {
    v7 = _acrt_iob_func(1u);
    v8 = a2 != 2 ? 265 : 769;
  }
  FileHandle = 0;
  Stream = v7;
  v9 = wsopen_s(&FileHandle, FileName, v8, 64, 384);
  v10 = v9 == 0;
  v17 = v9 == 0;
  if ( !v9 )
  {
    v11 = fileno(Stream);
    if ( dup2(FileHandle, v11) == -1 )
      sub_4053F6(0, 0x411u);
    close(FileHandle);
    v10 = v17;
  }
  if ( v10 && a2 == 3 )
  {
    v12 = fileno(Stream);
    lseek(v12, 0, 2);
    v10 = v17;
  }
  for ( ; *FileName; ++FileName )
    *FileName = 32;
  if ( v6 )
    *v6 = v14;
  return v10;
}

//----- (004066DC) --------------------------------------------------------
char __fastcall sub_4066DC(wchar_t *String, rsize_t a2, int *a3, int *a4)
{
  char v4; // bh
  char v5; // bl
  wchar_t *v6; // edi
  wchar_t *v7; // esi
  wchar_t *v8; // esi
  FILE *v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // edx
  FILE *v13; // eax
  int v14; // eax
  int v15; // eax
  FILE *v16; // eax
  int v17; // eax
  FILE *v18; // eax
  int v19; // eax
  int v23; // [esp+14h] [ebp-Ch]
  wchar_t *Stringa; // [esp+18h] [ebp-8h]
  char v25; // [esp+1Fh] [ebp-1h]

  v4 = 0;
  v25 = 0;
  v5 = 0;
  Stringa = String;
  v6 = 0;
  v7 = wcspbrk(String, L"<>|");
  if ( !v7 )
    return v5;
  while ( *v7 != 60 )
  {
    if ( *v7 != 62 )
    {
      if ( *v7 == 124 )
        goto LABEL_22;
      sub_4053F6(0, 0x411u);
      goto LABEL_20;
    }
    if ( v25 )
      goto LABEL_22;
    if ( !v6 )
      v6 = (wchar_t *)sub_40E267((char *)Stringa);
    *v7 = 32;
    v8 = v7 + 1;
    Stringa = v8;
    v25 = 1;
    if ( *v8 == 62 )
    {
      *v8++ = 32;
      v23 = 3;
    }
    else
    {
      v23 = 2;
    }
    v9 = _acrt_iob_func(1u);
    v10 = fileno(v9);
    v11 = dup(v10);
    *a4 = v11;
    if ( v11 == -1 )
      goto LABEL_22;
    v12 = v23;
LABEL_19:
    if ( !sub_4065BD(v8, v12) )
      goto LABEL_22;
LABEL_20:
    v7 = wcspbrk(Stringa, L"<>|");
    if ( !v7 )
      return v5;
  }
  if ( !v4 )
  {
    if ( !v6 )
      v6 = (wchar_t *)sub_40E267((char *)Stringa);
    *v7 = 32;
    v4 = 1;
    v8 = v7 + 1;
    Stringa = v8;
    v13 = _acrt_iob_func(0);
    v14 = fileno(v13);
    v15 = dup(v14);
    *a3 = v15;
    if ( v15 != -1 )
    {
      v12 = 4;
      goto LABEL_19;
    }
  }
LABEL_22:
  if ( v6 )
  {
    wcscpy_s(String, a2, v6);
    free(v6);
  }
  if ( v4 && *a3 != -1 )
  {
    v16 = _acrt_iob_func(0);
    v17 = fileno(v16);
    if ( dup2(*a3, v17) == -1 )
      sub_4053F6(0, 0x411u);
    close(*a3);
    *a3 = -1;
  }
  v5 = 1;
  if ( v25 && *a4 != -1 )
  {
    v18 = _acrt_iob_func(1u);
    v19 = fileno(v18);
    if ( dup2(*a4, v19) == -1 )
      sub_4053F6(0, 0x411u);
    close(*a4);
    *a4 = -1;
    return 1;
  }
  return v5;
}

//----- (004068E0) --------------------------------------------------------
int __stdcall sub_4068E0(int a1)
{
  return 1;
}

//----- (004068E6) --------------------------------------------------------
bool __fastcall sub_4068E6(_WORD *a1, _DWORD *a2)
{
  _WORD *v2; // edi
  _WORD *v4; // edx
  __int16 v5; // si
  __int16 v6; // bx
  __int16 v7; // si
  _WORD *v9; // [esp+8h] [ebp-4h]

  v2 = a1;
  v9 = a1;
  if ( !a1 )
    return 0;
  v4 = a1;
  v5 = *a1;
  if ( *a1 == 59 )
  {
    do
      ++a1;
    while ( *a1 == 59 );
    v5 = *a1;
  }
  v6 = v5;
  if ( v5 )
  {
    do
    {
      v6 = v5;
      if ( v5 == 59 )
        break;
      ++a1;
      if ( v5 == 34 )
      {
        if ( *a1 )
        {
          v7 = *a1;
          do
          {
            ++a1;
            if ( v7 == 34 )
              break;
            *v4++ = v7;
            v7 = *a1;
          }
          while ( *a1 );
        }
      }
      else
      {
        *v4++ = v5;
      }
      v5 = *a1;
      v6 = *a1;
    }
    while ( *a1 );
    v2 = v9;
  }
  *a2 = v6 != 0 ? a1 + 1 : 0;
  *v4 = 0;
  return v4 != v2;
}

//----- (0040699D) --------------------------------------------------------
char __fastcall sub_40699D(wchar_t *FullPath, wchar_t *a2, int a3)
{
  wchar_t *v3; // ebx
  unsigned int v4; // eax
  wchar_t *v5; // ebx
  BOOL (__stdcall *NeedCurrentDirectoryForExePathW)(LPCWSTR); // eax
  HMODULE ModuleHandleW; // eax
  size_t v8; // eax
  wchar_t *v9; // edi
  wchar_t *v10; // esi
  size_t v11; // eax
  wchar_t *v12; // esi
  wchar_t *v13; // ecx
  size_t v14; // esi
  wchar_t *v15; // ecx
  unsigned int v17; // edi
  wchar_t *v18; // eax
  wchar_t *v19; // [esp+10h] [ebp-63Ch]
  wchar_t *v20; // [esp+14h] [ebp-638h] BYREF
  wchar_t *v21; // [esp+18h] [ebp-634h]
  wchar_t *v22; // [esp+1Ch] [ebp-630h]
  wchar_t *v23; // [esp+20h] [ebp-62Ch]
  BOOL v24; // [esp+24h] [ebp-628h] BYREF
  wchar_t *Buffer; // [esp+28h] [ebp-624h]
  size_t RequiredCount; // [esp+2Ch] [ebp-620h] BYREF
  size_t SizeInWords; // [esp+30h] [ebp-61Ch] BYREF
  char v28; // [esp+37h] [ebp-615h]
  wchar_t Filename[256]; // [esp+38h] [ebp-614h] BYREF
  wchar_t Dir[256]; // [esp+238h] [ebp-414h] BYREF
  wchar_t Ext[258]; // [esp+438h] [ebp-214h] BYREF
  wchar_t Drive[4]; // [esp+63Ch] [ebp-10h] BYREF

  Buffer = a2;
  v23 = 0;
  v28 = 0;
  if ( *FullPath == 34 )
  {
    v3 = &FullPath[wcslen(FullPath) - 1];
    v23 = v3;
    if ( *v3 == 34 )
    {
      v28 = 1;
      do
        ++FullPath;
      while ( *FullPath == 34 );
      if ( v3 > FullPath )
      {
        do
        {
          v4 = (unsigned int)(v3 - 1);
          if ( *(v3 - 1) != 34 )
            break;
          --v3;
        }
        while ( v4 > (unsigned int)FullPath );
        v23 = v3;
      }
      *v3 = 0;
    }
  }
  wsplitpath_s(FullPath, Drive, 3u, Dir, 0x100u, Filename, 0x100u, Ext, 0x100u);
  if ( !Ext[0] )
  {
    if ( !wgetenv_s(&RequiredCount, 0, 0, aPa) && RequiredCount )
    {
      v5 = (wchar_t *)sub_40AC3C((unsigned __int64)RequiredCount >> 31 != 0 ? -1 : 2 * RequiredCount);
      if ( wgetenv_s(&RequiredCount, v5, RequiredCount, aPa) )
      {
        free(v5);
      }
      else if ( v5 )
      {
        goto LABEL_18;
      }
    }
    RequiredCount = 33;
    v5 = (wchar_t *)sub_40AC3C(0x42u);
    wcscpy_s(v5, RequiredCount, L".COM;.EXE;.BAT;.CMD;.VBS;.JS;.WS");
    goto LABEL_18;
  }
  v5 = Ext;
  RequiredCount = wcslen(Ext) + 1;
LABEL_18:
  if ( Drive[0] || Dir[0] )
  {
    v14 = wcslen(Dir) + wcslen(Drive) + 1;
    v9 = (wchar_t *)sub_40AC3C((unsigned __int64)v14 >> 31 != 0 ? -1 : 2 * v14);
    v22 = v9;
    if ( wmakepath_s(v9, v14, Drive, Dir, 0, 0) )
    {
      free(v9);
      v12 = 0;
      v9 = 0;
      v22 = 0;
      goto LABEL_35;
    }
  }
  else
  {
    if ( wgetenv_s(&SizeInWords, 0, 0, aPa_0) || !SizeInWords )
      SizeInWords = 1;
    NeedCurrentDirectoryForExePathW = (BOOL (__stdcall *)(LPCWSTR))dword_435654;
    if ( !dword_435654 )
    {
      ModuleHandleW = GetModuleHandleW(L"KERNEL32.DLL");
      NeedCurrentDirectoryForExePathW = (BOOL (__stdcall *)(LPCWSTR))GetProcAddress(
                                                                       ModuleHandleW,
                                                                       "NeedCurrentDirectoryForExePathW");
      dword_435654 = (int)NeedCurrentDirectoryForExePathW;
      if ( !NeedCurrentDirectoryForExePathW )
      {
        NeedCurrentDirectoryForExePathW = (BOOL (__stdcall *)(LPCWSTR))sub_4068E0;
        dword_435654 = (int)sub_4068E0;
      }
    }
    v24 = NeedCurrentDirectoryForExePathW(Filename);
    v8 = SizeInWords;
    if ( v24 )
    {
      v8 = SizeInWords + 2;
      SizeInWords += 2;
    }
    v9 = (wchar_t *)sub_40AC3C((unsigned __int64)v8 >> 31 != 0 ? -1 : 2 * v8);
    v22 = v9;
    v10 = v9;
    if ( v24 )
    {
      wcscpy_s(v9, SizeInWords, L".;");
      v10 = v9 + 2;
      v11 = SizeInWords - 2;
      SizeInWords -= 2;
    }
    else
    {
      v11 = SizeInWords;
    }
    if ( wgetenv_s(&SizeInWords, v10, v11, aPa_0) || !SizeInWords )
      *v10 = 0;
  }
  v12 = 0;
LABEL_35:
  v19 = v9;
  v13 = v9;
LABEL_44:
  if ( sub_4068E6(v13, &v24) )
  {
    v12 = (wchar_t *)sub_40AC3C((unsigned __int64)RequiredCount >> 31 != 0 ? -1 : 2 * RequiredCount);
    wcscpy_s(v12, RequiredCount, v5);
    v21 = v12;
    v15 = v12;
    while ( 1 )
    {
      if ( !sub_4068E6(v15, &v20) )
      {
        v13 = (wchar_t *)v24;
        v19 = (wchar_t *)v24;
        goto LABEL_44;
      }
      if ( !wmakepath_s(Buffer, 0x104u, 0, v19, Filename, v21) && !waccess_s(Buffer, 0) )
        break;
      v15 = v20;
      v21 = v20;
    }
    if ( v28 )
    {
      v17 = wcslen(Buffer);
      memmove(Buffer + 1, Buffer, 2 * v17);
      v18 = Buffer;
      *Buffer = 34;
      v18[v17 + 1] = 34;
      v18[v17 + 2] = 0;
      v9 = v22;
      *v23 = 34;
    }
    free(v12);
    free(v9);
    if ( v5 != Ext )
      free(v5);
    return 1;
  }
  else
  {
    free(v12);
    free(v9);
    if ( v5 != Ext )
      free(v5);
    return 0;
  }
}
// 435654: using guessed type int dword_435654;

//----- (00406E33) --------------------------------------------------------
wchar_t **__fastcall sub_406E33(wchar_t *Source, char a2, char a3, char a4, void **a5)
{
  char v5; // bl
  void *v7; // eax
  int v8; // eax
  wchar_t *v9; // esi
  wchar_t *i; // eax
  wchar_t **result; // eax
  const wchar_t **v12; // edi
  wchar_t *v13; // eax
  wchar_t *v14; // esi
  wchar_t **v15; // esi
  int v16; // esi
  const wchar_t *v17; // ebx
  unsigned int v18; // kr00_4
  bool v19; // bl
  char v20; // bl
  wchar_t *v21; // esi
  unsigned int v22; // ecx
  FILE *v23; // eax
  int v24; // eax
  FILE *v25; // eax
  int v26; // eax
  unsigned int v27; // kr08_4
  unsigned int v28; // esi
  int v29; // eax
  int v30; // eax
  int *v31; // eax
  const wchar_t **v32; // eax
  char **v33; // ecx
  int v34; // ecx
  char v35; // al
  char v36; // [esp+14h] [ebp-440h]
  wchar_t *Block; // [esp+1Ch] [ebp-438h]
  int FileHandleSrc; // [esp+20h] [ebp-434h] BYREF
  wchar_t **v39; // [esp+24h] [ebp-430h] BYREF
  int v40; // [esp+28h] [ebp-42Ch] BYREF
  int FileHandle; // [esp+2Ch] [ebp-428h] BYREF
  char v42; // [esp+32h] [ebp-422h]
  char v43; // [esp+33h] [ebp-421h]
  wchar_t *String; // [esp+34h] [ebp-420h] BYREF
  wchar_t v45; // [esp+38h] [ebp-41Ch] BYREF
  wchar_t Destination[59]; // [esp+3Ah] [ebp-41Ah] BYREF
  wchar_t Buffer[200]; // [esp+B0h] [ebp-3A4h] BYREF
  wchar_t Str; // [esp+240h] [ebp-214h] BYREF
  char Src[522]; // [esp+242h] [ebp-212h] BYREF

  v5 = a2;
  String = Source;
  if ( !dword_421EEC )
  {
    v7 = sub_4075C7();
    Source = String;
    dword_421EEC = (int)v7;
  }
  v8 = *Source;
  v36 = 1;
  if ( v8 == 45 )
  {
    v42 = 1;
    String = Source + 1;
    if ( iswdigit(Source[1]) )
    {
      v9 = String;
      dword_431EF0 = wcstoul(String, &String, 10);
      if ( *errno() == 34 )
      {
        *String = 0;
        sub_4053F6(0, 0x436u, v9);
      }
      for ( i = String; iswspace(*i); i = ++String )
        ;
    }
    else
    {
      dword_431EF0 = -1;
    }
    Source = String;
  }
  else
  {
    if ( v8 == 64 )
    {
      String = ++Source;
      v5 = a3 != 0 ? 0 : a2;
    }
    v42 = a4;
  }
  result = 0;
  if ( !*Source )
    return result;
  v12 = 0;
  if ( wcslen(Source) >= 0x8000 )
  {
    ::Destination = 0;
  }
  else
  {
    wcscpy_s(&::Destination, 0x8000u, Source);
    Source = String;
  }
  v13 = (wchar_t *)sub_40E267((char *)Source);
  v14 = v13;
  Block = v13;
  if ( v5 )
  {
    sub_40C7C7((wchar_t *)L"\t%s\n", v13);
    sub_40C7A9();
  }
  sub_4055D7(&v40, 0, v14);
  if ( !v40 )
    goto LABEL_23;
  v16 = v40;
  FileHandle = v40;
  v12 = (const wchar_t **)sub_40AC3C((unsigned __int64)(unsigned int)(v40 + 8) >> 30 != 0 ? -1 : 4 * (v40 + 8));
  sub_4055D7(&v40, v12, Block);
  if ( *v12 && dword_421EE8 && !wcsicmp(*v12, dword_421EE8) )
  {
    if ( !dword_411488 )
    {
      dword_411488 = *_p__wpgmptr();
      v17 = dword_411488;
      if ( wcspbrk(dword_411488, L" ") )
      {
        v18 = wcslen(dword_411488);
        dword_411488 = (wchar_t *)sub_40AC3C((unsigned __int64)(v18 + 3) >> 31 != 0 ? -1 : 2 * (v18 + 3));
        wcscpy_s(dword_411488, v18 + 3, L"\"");
        wcscat_s(dword_411488, v18 + 3, v17);
        wcscat_s(dword_411488, v18 + 3, L"\"");
        v16 = FileHandle;
      }
    }
    *v12 = dword_411488;
  }
  if ( !a3 )
  {
    if ( sub_406406(v16, (wint_t **)v12, (int *)&v39) )
    {
      v15 = v39;
      if ( v39 && a5 )
        *a5 = sub_40E267((char *)*v12);
      goto LABEL_89;
    }
    goto LABEL_23;
  }
  v19 = wcspbrk(String, L"<>|&%") == 0;
  if ( sub_406406(v16, (wint_t **)v12, (int *)&v39) )
  {
    v15 = v39;
    v20 = 0;
    goto LABEL_74;
  }
  v21 = String;
  if ( wcslen(String) < 0x1000 && !v19 )
  {
    v20 = 1;
LABEL_60:
    if ( wcslen(v21) >= 0x1000 )
      sub_4053F6(0, 0x447u, v21);
    else
      wcscpy_s(&::Destination, 0x8000u, v21);
    v15 = sub_405BD5(0, v40, (wchar_t **)v12);
    goto LABEL_74;
  }
  FileHandleSrc = -1;
  FileHandle = -1;
  v43 = sub_4066DC(String, wcslen(String) + 1, &FileHandleSrc, &FileHandle);
  if ( v43 )
    goto LABEL_49;
  v22 = wcslen(String);
  if ( v22 >= 0x8000 )
    sub_4053F6(0, 0x447u, String);
  if ( FileHandleSrc != -1 || FileHandle != -1 )
  {
    free(Block);
    Block = (wchar_t *)sub_40E267((char *)String);
    sub_4055D7(&v40, v12, Block);
  }
  if ( !sub_40699D((wchar_t *)*v12, &Str, v22) )
  {
    v43 = 1;
LABEL_49:
    v15 = v39;
    goto LABEL_50;
  }
  if ( Str == 34 )
  {
    v27 = wcslen(&Str);
    if ( Buffer[v27 + 199] == 34 )
    {
      memmove(&Str, Src, 2 * v27);
      v28 = 2 * v27 - 4;
      if ( v28 >= 0x208 )
        __report_rangecheckfailure();
      *(_WORD *)&Src[v28 - 2] = 0;
    }
  }
  *v12 = &Str;
  if ( wcschr(&Str, 0x20u) )
  {
    v45 = 34;
    wcscpy_s(Destination, 0x103u, &Str);
    wcscat_s(&v45, 0x104u, L"\"");
    *v12 = &v45;
  }
  *errno() = 0;
  v15 = (wchar_t **)wspawnvp(0, &Str, v12);
  if ( v15 == (wchar_t **)-1 && *errno() != 12 && *_doserrno() == 193 )
    v43 = 1;
LABEL_50:
  if ( FileHandleSrc != -1 )
  {
    v23 = _acrt_iob_func(0);
    v24 = fileno(v23);
    if ( dup2(FileHandleSrc, v24) == -1 )
      sub_4053F6(0, 0x411u);
    close(FileHandleSrc);
  }
  if ( FileHandle != -1 )
  {
    v25 = _acrt_iob_func(1u);
    v26 = fileno(v25);
    if ( dup2(FileHandle, v26) == -1 )
      sub_4053F6(0, 0x411u);
    close(FileHandle);
  }
  v20 = v43;
  if ( v43 )
  {
    v21 = String;
    goto LABEL_60;
  }
LABEL_74:
  if ( v15 != (wchar_t **)-1 )
    goto LABEL_84;
  if ( !v42 )
  {
    v29 = *errno();
    if ( !v29 )
      goto LABEL_85;
    v30 = v29 - 2;
    if ( v30 )
    {
      if ( v30 == 10 )
      {
        v32 = v12 + 2;
        if ( !v20 )
          v32 = v12;
        sub_4053F6(0, 0x43Au, *v32);
      }
      else
      {
        v31 = errno();
        wcserror_s(Buffer, 0xC8u, *v31);
        sub_4053F6(0, 0x415u, Buffer);
      }
      goto LABEL_85;
    }
    sub_4053F6(0, 0x439u, *v12);
LABEL_84:
    if ( !v15 )
      goto LABEL_89;
LABEL_85:
    if ( a5 )
    {
      v33 = (char **)(v12 + 2);
      if ( !v20 )
        v33 = (char **)v12;
      *a5 = sub_40E267(*v33);
    }
    goto LABEL_89;
  }
LABEL_23:
  v15 = 0;
LABEL_89:
  v34 = 0;
  if ( v40 == -8 )
  {
    v35 = 1;
    v36 = 1;
    if ( v12 )
    {
LABEL_97:
      free(v12);
      v35 = v36;
    }
  }
  else
  {
    while ( v12 )
    {
      if ( !v12[v34] )
        goto LABEL_97;
      if ( v12[v34] == Block )
      {
        v36 = 0;
        goto LABEL_97;
      }
      if ( ++v34 >= (unsigned int)(v40 + 8) )
        goto LABEL_97;
    }
    v35 = 1;
  }
  if ( Block )
  {
    if ( v35 )
      free(Block);
  }
  return v15;
}
// 40725C: variable 'v22' is possibly undefined
// 410495: using guessed type void __noreturn __report_rangecheckfailure(void);
// 421EEC: using guessed type int dword_421EEC;
// 431EF0: using guessed type int dword_431EF0;
// 406E33: using guessed type char Src[522];
// 406E33: using guessed type wchar_t Destination[59];

//----- (004075C7) --------------------------------------------------------
void *sub_4075C7()
{
  void *v0; // esi
  wchar_t *Buffer; // [esp+4h] [ebp-214h] BYREF
  wchar_t ResultPath[262]; // [esp+8h] [ebp-210h] BYREF

  Buffer = 0;
  wdupenv_s(&Buffer, 0, L"COMSPEC");
  if ( Buffer )
  {
    v0 = sub_40E267((char *)Buffer);
    free(Buffer);
    return v0;
  }
  else
  {
    wsearchenv(L"CMD.EXE", aPa_0, ResultPath);
    if ( !ResultPath[0] )
      sub_4053F6(0, 0x420u);
    return sub_40E267((char *)ResultPath);
  }
}

//----- (00407663) --------------------------------------------------------
char __fastcall sub_407663(__int16 *a1, int a2, char a3, unsigned __int8 a4, const wchar_t *a5, wchar_t ***a6)
{
  int v6; // edi
  int v7; // ebx
  unsigned __int16 *v8; // esi
  int v9; // eax
  __int16 v10; // cx
  unsigned __int16 v11; // dx
  unsigned __int16 *v12; // edi
  unsigned __int16 v13; // cx
  __int16 v14; // si
  char v16; // bl
  char v17; // bh
  int *v18; // eax
  int v19; // edi
  __int16 *v20; // ecx
  char v21; // al
  char v22; // dl
  wchar_t **v23; // eax
  int *v24; // eax
  void *v25; // [esp-4h] [ebp-2Ch]
  int v26; // [esp+Ch] [ebp-1Ch] BYREF
  char v27[4]; // [esp+10h] [ebp-18h]
  __int16 *v28; // [esp+14h] [ebp-14h]
  int v29; // [esp+18h] [ebp-10h]
  int v30; // [esp+1Ch] [ebp-Ch]
  void *Block; // [esp+20h] [ebp-8h]
  char v32; // [esp+27h] [ebp-1h]

  v30 = a2;
  v6 = (unsigned __int16)*a1;
  v7 = 0;
  v28 = a1;
  v8 = (unsigned __int16 *)a1;
  Block = 0;
  v9 = v6;
  v29 = 0;
  if ( !(_WORD)v6 )
  {
LABEL_12:
    v14 = (__int16)Block;
    goto LABEL_13;
  }
  v10 = v6;
  Block = (void *)63;
  while ( 1 )
  {
    if ( v10 != 36 )
      goto LABEL_21;
    v11 = v8[1];
    if ( v11 == 40 )
      ++v8;
    v12 = v8 + 1;
    v13 = v8[1];
    if ( v13 != 63 )
      break;
    if ( v11 != 40 || wcschr(L"DFBR", v8[2]) && v8[3] == 41 || v8[2] == 41 )
    {
      v7 = dword_421ED0;
      v9 = *v8;
      a2 = v30;
      v29 = dword_421ED0;
      goto LABEL_12;
    }
LABEL_21:
    v10 = *++v8;
    if ( !*v8 )
      return 0;
  }
  ++v8;
  if ( v13 != 42 || v12[1] != 42 || v11 == 40 && (!wcschr(L"DFBR", v12[2]) || v12[3] != 41) && v12[2] != 41 )
    goto LABEL_21;
  v7 = dword_421EC4;
  v9 = *v12;
  a2 = v30;
  v29 = dword_421EC4;
  v14 = 42;
LABEL_13:
  if ( !(_WORD)v9 )
    return 0;
  if ( !v7 )
    goto LABEL_52;
  v32 = a3 & 4;
  v16 = a3 & 4;
  LOBYTE(v9) = a4 >> 1;
  v17 = a3 & 2;
  *(_DWORD *)v27 = v9 & 0xFFFFFF01;
  while ( 2 )
  {
    dword_4216BC = a2;
    v18 = (int *)dword_421EC4;
    if ( v14 != 42 )
      v18 = (int *)dword_421ED0;
    v19 = *v18;
    v20 = v28;
    *v18 = 0;
    Block = sub_40EC83(v20, 255, &dword_4216BC);
    if ( sub_40FA87((char *)word_421EF0, 0x8000, (unsigned __int16 *)Block, a5) )
      sub_4053F6(0, 0x447u, Block);
    if ( v16 && (a4 & 8) == 0 )
    {
      v21 = 0;
      goto LABEL_33;
    }
    v21 = 1;
    if ( !v16 && ((a3 & 8) != 0 || (a4 & 1) != 0) )
    {
      v22 = 0;
      v21 = 1;
    }
    else
    {
LABEL_33:
      v22 = 1;
    }
    v23 = sub_406E33(word_421EF0, v22, v21, v27[0], (void **)&v26);
    *a6 = v23;
    if ( !v17 && v23 && (unsigned int)v23 > dword_431EF0 && !byte_4216B7 )
      sub_4053F6(0, 0x435u, v26, v23);
    if ( v14 == 42 )
    {
      v24 = (int *)dword_421EC4;
      dword_421EC4 = v19;
    }
    else
    {
      v24 = (int *)dword_421ED0;
      dword_421ED0 = v19;
    }
    v25 = Block;
    *v24 = v19;
    free(v25);
    if ( v17 || !byte_4216B7 || !*a6 || (unsigned int)*a6 <= dword_431EF0 )
    {
      a2 = v30;
      if ( v19 )
        continue;
    }
    break;
  }
  v7 = v29;
LABEL_52:
  if ( v14 == 42 )
    dword_421EC4 = v7;
  else
    dword_421ED0 = v7;
  return 1;
}
// 4216B7: using guessed type char byte_4216B7;
// 4216BC: using guessed type int dword_4216BC;
// 421EC4: using guessed type int dword_421EC4;
// 421ED0: using guessed type int dword_421ED0;
// 421EF0: using guessed type wchar_t word_421EF0[32768];
// 431EF0: using guessed type int dword_431EF0;

//----- (004078C7) --------------------------------------------------------
void __fastcall sub_4078C7(int a1, __int16 **a2)
{
  int v2; // esi
  __int16 **v3; // ebx
  __int16 *v4; // ecx
  __int16 *v5; // edi
  __int16 v6; // dx
  __int16 *v7; // eax
  __int16 v8; // ax
  __int16 **v9; // [esp+10h] [ebp-4h]

  v2 = a1;
  v3 = a2;
  v9 = a2;
  if ( !a1 )
    return;
  do
  {
    v4 = *v3;
    --v2;
    v5 = *v3;
    if ( !**v3 )
      goto LABEL_15;
    v6 = *v4;
    do
    {
      if ( v6 == 92 || v6 == 94 )
      {
        v7 = v5 + 1;
        if ( v5[1] == 34 )
        {
          *v4 = v6;
          ++v5;
          v8 = *v7;
          ++v4;
        }
        else
        {
          v8 = v6;
        }
        *v4 = v8;
      }
      else
      {
        if ( v6 == 34 )
          goto LABEL_13;
        *v4 = v6;
      }
      ++v4;
LABEL_13:
      v6 = *++v5;
    }
    while ( *v5 );
    v3 = v9;
LABEL_15:
    ++v3;
    *v4 = 0;
    v9 = v3;
  }
  while ( v2 );
}

//----- (00407951) --------------------------------------------------------
void __fastcall sub_407951(int ArgList, char a2)
{
  wchar_t *v4; // eax
  __int16 *v5; // edx
  __int16 v6; // ax
  __int16 *v7; // ecx
  HANDLE FileW; // esi
  struct _FILETIME SystemTimeAsFileTime; // [esp+10h] [ebp-8h] BYREF

  if ( *(_WORD *)ArgList == 34 )
  {
    v4 = wcsrchr((const wchar_t *)ArgList, 0x22u);
    v5 = (__int16 *)(ArgList + 2);
    *v4 = 0;
    v6 = *(_WORD *)(ArgList + 2);
    *(_WORD *)ArgList = v6;
    while ( v6 )
    {
      v7 = v5++;
      v6 = *v5;
      *v7 = *v5;
    }
  }
  sub_4054D0(5u, ArgList);
  if ( !a2 )
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    FileW = CreateFileW((LPCWSTR)ArgList, 0x100u, 0, 0, 3u, 0x80u, 0);
    if ( FileW != (HANDLE)-1 )
    {
      SetFileTime(FileW, 0, 0, &SystemTimeAsFileTime);
      CloseHandle(FileW);
    }
  }
}

//----- (004079E0) --------------------------------------------------------
__int64 __thiscall sub_4079E0(char *this)
{
  __int64 result; // rax

  if ( (*this & 0x10) == 0 )
    return *(_QWORD *)(this + 20);
  result = *(_QWORD *)(this + 4);
  if ( !result )
    return *(_QWORD *)(this + 20);
  return result;
}

//----- (004079FA) --------------------------------------------------------
WCHAR *__fastcall sub_4079FA(wchar_t *Str, LPWIN32_FIND_DATAW lpFindFileData, HANDLE *a3)
{
  unsigned __int16 *v3; // ebx
  LPWIN32_FIND_DATAW v4; // edi
  char *v5; // esi
  wchar_t *v6; // eax
  unsigned int v7; // ecx
  unsigned __int16 *v8; // ecx
  unsigned __int16 v9; // dx
  HANDLE FirstFileW; // eax
  bool v13; // [esp+1Fh] [ebp-215h]
  char Block[524]; // [esp+20h] [ebp-214h] BYREF

  v3 = Str;
  v4 = lpFindFileData;
  v5 = Block;
  v6 = wcspbrk(Str, L"\"^*?");
  v13 = v6 != 0;
  if ( v6 )
  {
    v7 = wcslen(v3);
    if ( v7 + 1 > 0x104 )
    {
      v5 = (char *)sub_40AC3C((unsigned __int64)(v7 + 1) >> 31 != 0 ? -1 : 2 * (v7 + 1));
      if ( !v5 )
        sub_4053F6(dword_4216B0, 0x41Bu);
    }
    v8 = (unsigned __int16 *)v5;
    v9 = *v3;
    if ( *v3 )
    {
      do
      {
        if ( v9 != 94 && v9 != 34 )
          *v8++ = v9;
        v9 = *++v3;
      }
      while ( *v3 );
      v4 = lpFindFileData;
    }
    v3 = (unsigned __int16 *)v5;
    *v8 = 0;
  }
  FirstFileW = FindFirstFileW(v3, v4);
  *a3 = FirstFileW;
  if ( FirstFileW != (HANDLE)-1 && sub_407D27(v3, v4) )
  {
    if ( !v13 || !wcschr(v3, 0x2Au) && !wcschr(v3, 0x3Fu) )
    {
      FindClose(*a3);
      *a3 = (HANDLE)-1;
    }
    if ( v5 != Block )
      free(v5);
    if ( (v4->dwFileAttributes & 0x10) == 0 && !v4->ftLastWriteTime.dwLowDateTime && !v4->ftLastWriteTime.dwHighDateTime )
    {
      v4->ftLastWriteTime.dwLowDateTime = -1;
      v4->ftLastWriteTime.dwHighDateTime = -1;
    }
    return v4->cFileName;
  }
  else
  {
    if ( v5 != Block )
      free(v5);
    return 0;
  }
}
// 4216B0: using guessed type int dword_4216B0;

//----- (00407B86) --------------------------------------------------------
WCHAR *__fastcall sub_407B86(LPWIN32_FIND_DATAW lpFindFileData, HANDLE hFindFile)
{
  if ( FindNextFileW(hFindFile, lpFindFileData) )
    return lpFindFileData->cFileName;
  FindClose(hFindFile);
  return 0;
}

//----- (00407BA9) --------------------------------------------------------
void *__fastcall sub_407BA9(wchar_t *a1, wchar_t *a2, struct _WIN32_FIND_DATAW *lpFindFileData, HANDLE *a4)
{
  char *v6; // ecx
  wchar_t *v8; // esi
  wchar_t v9; // ax
  wchar_t v10; // cx
  int v11; // eax

  if ( sub_4079FA(a2, lpFindFileData, a4) )
  {
    v6 = (char *)a2;
    return sub_40E267(v6);
  }
  if ( a1 )
  {
LABEL_5:
    v8 = &Src;
    do
    {
LABEL_6:
      v9 = *a1;
      while ( 1 )
      {
        if ( v9 )
        {
          v10 = v9;
          while ( 1 )
          {
            ++a1;
            if ( v10 != 34 )
              break;
            v10 = *a1;
            if ( !*a1 )
              goto LABEL_11;
          }
          *v8 = v10;
          if ( v10 != 59 )
          {
            ++v8;
            goto LABEL_6;
          }
        }
LABEL_11:
        if ( v8 != &Src )
          break;
        v9 = *a1;
        if ( !*a1 )
          return 0;
      }
      v11 = *(v8 - 1);
      if ( (_WORD)v11 != 92 && v11 != 47 )
        *v8++ = 92;
      *v8 = 0;
      if ( wcspbrk(&Src, L"*?") )
        goto LABEL_5;
      wcscpy_s(v8, 1024 - (v8 - &Src), a2);
      v8 = &Src;
    }
    while ( !sub_4079FA(&Src, lpFindFileData, a4) );
    v6 = (char *)&Src;
    return sub_40E267(v6);
  }
  return 0;
}

//----- (00407C98) --------------------------------------------------------
char __fastcall sub_407C98(_WORD *Block, LPWIN32_FIND_DATAW lpFindFileData)
{
  WCHAR *v3; // esi
  char *v4; // edx
  char v5; // bl
  int v7; // ecx
  HANDLE hFindFile; // [esp+Ch] [ebp-4h]

  v3 = Block;
  v4 = (char *)(Block + 1);
  v5 = 0;
  while ( *Block++ )
    ;
  v7 = ((char *)Block - v4) >> 1;
  if ( *v3 == 34 && v3[v7 - 1] == 34 )
  {
    v3 = sub_40FF51(v3);
    v5 = 1;
  }
  hFindFile = FindFirstFileW(v3, lpFindFileData);
  if ( hFindFile != (HANDLE)-1 && sub_407D27(v3, lpFindFileData) )
  {
    FindClose(hFindFile);
    if ( (lpFindFileData->dwFileAttributes & 0x10) == 0
      && !lpFindFileData->ftLastWriteTime.dwLowDateTime
      && !lpFindFileData->ftLastWriteTime.dwHighDateTime )
    {
      lpFindFileData->ftLastWriteTime.dwLowDateTime = -1;
      lpFindFileData->ftLastWriteTime.dwHighDateTime = -1;
    }
    return 1;
  }
  else
  {
    if ( v5 )
      free(v3);
    return 0;
  }
}

//----- (00407D27) --------------------------------------------------------
char __fastcall sub_407D27(wchar_t *Str, _DWORD *a2)
{
  _DWORD *v2; // ebx
  const unsigned __int16 *v3; // edi
  WCHAR *v4; // esi
  wchar_t *v5; // edx
  unsigned int v6; // ecx
  _WORD *v8; // ebx
  int v9; // edx
  __int64 v11; // rax
  WCHAR *v12; // eax
  unsigned __int16 *v13; // ecx
  unsigned __int16 v14; // ax
  WCHAR *v15; // ecx
  WCHAR v16; // dx
  HANDLE FileW; // edi
  wchar_t *v19; // [esp+10h] [ebp-10h]
  wchar_t *v20; // [esp+14h] [ebp-Ch]
  WCHAR *v22; // [esp+1Ch] [ebp-4h]

  v2 = a2;
  v3 = Str;
  if ( (*a2 & 0x400) != 0 && a2[9] == -1610612724 )
  {
    v4 = (WCHAR *)(a2 + 11);
    v5 = wcsrchr(Str, 0x5Cu);
    v20 = v5;
    if ( v5 )
    {
      v6 = wcslen(v3);
      v19 = v5 + 1;
      while ( *v5++ )
        ;
      v8 = v2 + 11;
      v9 = v5 - v19;
      while ( *v8++ )
        ;
      v11 = 2i64 * (v6 + 2 + v8 - (v4 + 1) - v9);
      v12 = (WCHAR *)sub_40AC3C(HIDWORD(v11) != 0 ? -1 : v11);
      v2 = a2;
      v22 = v12;
      if ( !v12 )
      {
        sub_4053F6(dword_4216B0, 0x41Bu);
        v12 = 0;
      }
      v13 = v12;
      if ( v3 != v20 )
      {
        do
        {
          v14 = *v3++;
          *v13++ = v14;
        }
        while ( v3 != v20 );
        v2 = a2;
      }
      *v13 = 92;
      v15 = v13 + 1;
      if ( *v4 )
      {
        v16 = *v4;
        do
        {
          ++v4;
          *v15++ = v16;
          v16 = *v4;
        }
        while ( *v4 );
      }
      v4 = v22;
      *v15 = 0;
    }
    FileW = CreateFileW(v4, 0x80000000, 1u, 0, 3u, 0, 0);
    if ( v20 )
      free(v4);
    if ( FileW == (HANDLE)-1 )
      return 0;
    if ( !GetFileTime(FileW, (LPFILETIME)(v2 + 1), (LPFILETIME)(v2 + 3), (LPFILETIME)(v2 + 5)) )
    {
      CloseHandle(FileW);
      return 0;
    }
    CloseHandle(FileW);
  }
  return 1;
}
// 4216B0: using guessed type int dword_4216B0;

//----- (00407E9D) --------------------------------------------------------
int sub_407E9D()
{
  int result; // eax
  wchar_t *v1; // edi
  wchar_t *v2; // eax
  wchar_t *v3; // esi
  wchar_t *v4; // esi
  int v5; // eax
  char v6; // [esp+Ah] [ebp-6h] BYREF
  bool v7; // [esp+Bh] [ebp-5h]
  wchar_t *Context; // [esp+Ch] [ebp-4h] BYREF
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  while ( 1 )
  {
    result = getwc(Stream);
    if ( !dword_431EF8 && (!byte_411021 || (_WORD)result != 33) )
      break;
    byte_411021 = 0;
    if ( dword_431EF8 )
    {
      ungetwc(result, Stream);
      v1 = (wchar_t *)dword_431EF8;
      dword_431EF8 = 0;
    }
    else
    {
      v1 = sub_408046();
    }
    v7 = v1 != dword_431EFC;
    v2 = sub_408182(v1, &v6);
    v3 = v2;
    switch ( v6 )
    {
      case 9:
        if ( byte_421EE1 )
          sub_4053F6(dword_4216A4, 0x409u, v1);
        if ( sub_40A618(v3) == 18 )
          return 32;
        break;
      case 10:
        sub_4082F1(v2);
        break;
      case 11:
        sub_4053F6(dword_4216A4, 0x41Au, v2);
        break;
      case 12:
        if ( !wcsnicmp(v2, L"\\t", 2u) )
        {
          sub_40C7C7((wchar_t *)L"\t");
          v3 += 2;
        }
        sub_4054D0(0xDu, v3);
        break;
      case 13:
        Context = 0;
        v4 = wcstok_s(v2, L" \t", &Context);
        if ( wcstok_s(0, L" \t", &Context) )
          sub_4053F6(dword_4216A4, 0x409u, v4);
        v5 = sub_40AB97(v4);
        if ( v5 )
          *(_BYTE *)(v5 + 12) |= 0x10u;
        break;
      default:
        sub_408646(v6, v2, (int)&savedregs);
        break;
    }
    byte_411021 = 1;
    if ( v7 )
      free(v1);
    ++dword_4216A4;
  }
  return result;
}
// 411021: using guessed type char byte_411021;
// 4216A4: using guessed type int dword_4216A4;
// 421EE1: using guessed type char byte_421EE1;

//----- (00408046) --------------------------------------------------------
wchar_t *sub_408046()
{
  __int16 v0; // si
  unsigned int v1; // edi
  wint_t i; // ax
  wchar_t *v3; // eax
  int v4; // edx
  wint_t v5; // ax
  wint_t v6; // si
  wint_t v7; // ax
  FILE *v9; // [esp-4h] [ebp-10h]

  v0 = sub_409C3C(1);
  if ( v0 == 10 || v0 == -1 )
    sub_4053F6(dword_4216A4, 0x3FAu);
  v1 = 0;
  for ( i = sub_409D15(v0, 1); ; i = sub_409D15(v5, 1) )
  {
    v6 = i;
    if ( i == 35 || i == 10 || i == 0xFFFF )
      break;
    if ( (unsigned int)dword_431EF4 < 2 || v1 > dword_431EF4 - 2 )
    {
      v4 = dword_431EF4 + 1024;
      dword_431EF4 += 1024;
      if ( dword_431EFC )
        v3 = (wchar_t *)sub_40AC7F(dword_431EFC, 2 * v4 + 2);
      else
        v3 = (wchar_t *)sub_40AC3C((unsigned __int64)(unsigned int)(v4 + 1) >> 31 != 0 ? -1 : 2 * (v4 + 1));
      dword_431EFC = v3;
    }
    else
    {
      v3 = dword_431EFC;
    }
    v9 = Stream;
    v3[v1++] = v6;
    v5 = getwc(v9);
  }
  dword_431EFC[v1] = 0;
  if ( i == 35 )
  {
    while ( 1 )
    {
      v7 = getwc(Stream);
      v6 = v7;
      if ( v7 == 10 )
        break;
      if ( v7 == 0xFFFF )
        goto LABEL_21;
    }
  }
  if ( v6 == 0xFFFF )
LABEL_21:
    ungetwc(v6, Stream);
  return sub_40EC1B(dword_431EFC);
}
// 4216A4: using guessed type int dword_4216A4;
// 431EF4: using guessed type int dword_431EF4;

//----- (00408182) --------------------------------------------------------
wchar_t *__fastcall sub_408182(wchar_t *String1, char *a2)
{
  wchar_t *v2; // eax
  char *v3; // ebx
  wchar_t *v4; // esi
  wchar_t v5; // di
  wchar_t *v6; // edx
  wchar_t v7; // ax
  wchar_t v8; // dx
  int v9; // edi
  wchar_t v10; // ax
  char v11; // al
  int v14; // [esp+18h] [ebp-8h] BYREF
  wchar_t *String1a; // [esp+1Ch] [ebp-4h]

  v2 = String1;
  v3 = a2;
  v4 = String1;
  v5 = *String1;
  String1a = String1;
  *a2 = 0;
  v14 = (int)String1;
  if ( v5 )
  {
    v6 = String1;
    do
    {
      String1 = v6;
      if ( v5 == 32 )
        break;
      if ( v5 == 9 )
        break;
      v4 = v6 + 1;
      v7 = v6[1];
      v6 = v4;
      String1 = v4;
      v5 = v7;
    }
    while ( v7 );
    v3 = a2;
    v2 = String1a;
    v14 = (int)v4;
  }
  v8 = *v4;
  v9 = String1 - v2;
  if ( *v4 )
  {
    do
    {
      if ( v8 != 32 && v8 != 9 )
        break;
      v4 = String1 + 1;
      v10 = String1[1];
      ++String1;
      v8 = v10;
    }
    while ( v10 );
    v3 = a2;
    v2 = String1a;
    v14 = (int)v4;
  }
  if ( wcsnicmp(v2, L"INCLUDE", 7u) || v9 != 7 )
  {
    if ( wcsnicmp(String1a, L"CMDSWITCHES", 0xBu) || v9 != 11 )
    {
      if ( wcsnicmp(String1a, L"ERROR", 5u) || v9 != 5 )
      {
        if ( wcsnicmp(String1a, L"MESSAGE", 7u) || v9 != 7 )
        {
          if ( wcsnicmp(String1a, L"UNDEF", 5u) || v9 != 5 )
          {
            v11 = sub_40846A(String1a, v9, (wchar_t **)&v14);
            *v3 = v11;
            if ( !v11 )
              sub_4053F6(dword_4216A4, 0x3F9u, dword_431EFC);
            return (wchar_t *)v14;
          }
          else
          {
            *v3 = 13;
          }
        }
        else
        {
          *v3 = 12;
        }
      }
      else
      {
        *v3 = 11;
      }
    }
    else
    {
      *v3 = 10;
    }
  }
  else
  {
    *v3 = 9;
  }
  return v4;
}
// 4216A4: using guessed type int dword_4216A4;

//----- (004082F1) --------------------------------------------------------
int __thiscall sub_4082F1(wint_t *this)
{
  wint_t *v1; // esi
  int result; // eax
  wint_t v3; // cx
  wint_t v4; // dx
  wint_t v5; // cx
  wchar_t v6; // ax
  wchar_t v7; // ax
  wint_t v8; // cx
  wchar_t v9; // ax
  wchar_t v10; // ax

  v1 = this;
  result = *this;
  if ( (_WORD)result )
  {
    v3 = *this;
    do
    {
      if ( v3 == 43 )
      {
        result = *++v1;
        if ( !(_WORD)result )
          return result;
        v5 = *v1;
        while ( v5 != 45 )
        {
          v6 = towupper(v5);
          if ( wcschr(L"DINSU", v6) || byte_421EE1 && (v7 = towupper(*v1), wcschr(L"ABCEKLPQRTY", v7)) )
            sub_40C1CD(*v1, 1);
          else
            sub_4053F6(dword_4216A4, 0x400u);
          result = *++v1;
          v5 = result;
          if ( !(_WORD)result )
            return result;
        }
      }
      else
      {
        result = v3 - 45;
        if ( v3 != 45 )
        {
          v4 = v3;
          if ( v3 != 32 )
          {
            v4 = v3;
            if ( v3 != 9 )
            {
              result = sub_4053F6(dword_4216A4, 0x400u);
              v4 = *v1;
            }
          }
LABEL_27:
          if ( !v4 )
            return result;
          goto LABEL_28;
        }
      }
      result = *++v1;
      v4 = result;
      if ( !(_WORD)result )
        goto LABEL_27;
      v8 = *v1;
      while ( v8 != 43 )
      {
        v9 = towupper(v8);
        if ( wcschr(L"DINSU", v9) || byte_421EE1 && (v10 = towupper(*v1), wcschr(L"ABCEKLMPQRTV", v10)) )
          sub_40C1CD(*v1, 0);
        else
          sub_4053F6(dword_4216A4, 0x400u);
        result = *++v1;
        v8 = result;
        v4 = *v1;
        if ( !(_WORD)result )
          goto LABEL_27;
      }
LABEL_28:
      result = *++v1;
      v3 = result;
    }
    while ( (_WORD)result );
  }
  return result;
}
// 4216A4: using guessed type int dword_4216A4;
// 421EE1: using guessed type char byte_421EE1;

//----- (0040846A) --------------------------------------------------------
char __fastcall sub_40846A(wchar_t *String1, int a2, wchar_t **a3)
{
  char v4; // bl
  wchar_t *v5; // ecx
  wchar_t v6; // dx
  wchar_t v7; // ax
  int (__cdecl *v8)(const wchar_t *, const wchar_t *, size_t); // edi
  int v9; // esi
  wchar_t v10; // di
  wchar_t *String1b; // [esp+10h] [ebp-4h]

  v4 = 0;
  if ( !wcsnicmp(String1, L"IF", 2u) && a2 == 2 )
    return 1;
  if ( !wcsnicmp(String1, L"IFDEF", 5u) && a2 == 5 )
    return 6;
  if ( !wcsnicmp(String1, L"IFNDEF", 6u) && a2 == 6 )
    return 7;
  if ( wcsnicmp(String1, L"ELSE", 4u) || a2 != 4 )
  {
    if ( wcsnicmp(String1, L"ELSEIF", 6u) || a2 != 6 )
    {
      if ( wcsnicmp(String1, L"ELSEIFDEF", 9u) || a2 != 9 )
      {
        if ( !wcsnicmp(String1, L"ELSEIFNDEF", 0xAu) && a2 == 10 )
          return 5;
        if ( !wcsnicmp(String1, L"ENDIF", 5u) && a2 == 5 )
          return 8;
        return v4;
      }
      return 4;
    }
    return 3;
  }
  v5 = *a3;
  if ( !**a3 )
    return 2;
  String1b = *a3;
  v6 = **a3;
  do
  {
    v7 = v6;
    if ( v6 == 32 )
      break;
    v7 = v6;
    if ( v6 == 9 )
      break;
    v7 = *++v5;
    v6 = *v5;
  }
  while ( *v5 );
  v8 = wcsnicmp;
  v9 = v5 - String1b;
  if ( v7 )
  {
    v10 = v7;
    do
    {
      if ( v10 != 32 && v10 != 9 )
        break;
      v10 = *++v5;
    }
    while ( *v5 );
    v8 = wcsnicmp;
  }
  *a3 = v5;
  if ( !v8(String1b, L"IF", 2u) && v9 == 2 )
    return 3;
  if ( !v8(String1b, L"IFDEF", 5u) && v9 == 5 )
    return 4;
  if ( !v8(String1b, L"IFNDEF", 6u) && v9 == 6 )
    return 5;
  return v4;
}

//----- (00408646) --------------------------------------------------------
char __usercall sub_408646@<al>(char a1@<dl>, wchar_t *a2@<ecx>, int a3@<ebp>)
{
  int v3; // eax
  wchar_t *v4; // esi
  int v5; // eax
  int v6; // eax
  char v7; // al
  char v8; // al
  bool v9; // zf
  char v10; // al
  char v11; // al
  wint_t v12; // ax
  _DWORD v14[2]; // [esp-4h] [ebp-8h] BYREF

  LOBYTE(v3) = a1 - 1;
  v4 = a2;
  switch ( a1 )
  {
    case 1:
    case 6:
    case 7:
      v5 = dword_411024;
      if ( dword_411024 != 15 )
        goto LABEL_5;
      v5 = sub_4053F6(dword_4216A4, 0x3FBu);
      goto LABEL_4;
    case 2:
      a2 = (wchar_t *)dword_411024;
      if ( dword_411024 < 0 )
        goto LABEL_21;
      v7 = byte_431F00[dword_411024];
      if ( (v7 & 9) == 0 )
        goto LABEL_21;
      v8 = v7 & 0xF6;
      byte_431F00[dword_411024] = v8;
      if ( (v8 & 4) != 0 )
        goto LABEL_8;
      if ( (v8 & 2) != 0 )
        LOBYTE(v3) = v8 & 0xFD;
      else
        LOBYTE(v3) = v8 | 2;
      byte_431F00[(_DWORD)a2] = v3;
      v9 = (v3 & 2) == 0;
      goto LABEL_19;
    case 3:
    case 4:
    case 5:
      a2 = (wchar_t *)dword_411024;
      if ( dword_411024 < 0 || (v10 = byte_431F00[dword_411024], (v10 & 9) == 0) )
      {
LABEL_21:
        v5 = sub_4053F6(dword_4216A4, 0x3FDu);
        goto LABEL_4;
      }
      v11 = v10 & 0xF6 | 8;
      byte_431F00[dword_411024] = v11;
      if ( (v11 & 4) != 0 )
        goto LABEL_8;
      if ( (v11 & 2) != 0 )
      {
        byte_431F00[(_DWORD)a2] = v11 & 0xF9 | 4;
        goto LABEL_8;
      }
      a2 = v4;
      goto LABEL_9;
    case 8:
      if ( dword_411024 >= 0 )
      {
        v3 = dword_411024 - 1;
        dword_411024 = v3;
        if ( v3 < 0 )
          return v3;
        v9 = (byte_431F00[v3] & 2) == 0;
LABEL_19:
        if ( !v9 )
          return v3;
      }
      else
      {
        v5 = sub_4053F6(dword_4216A4, 0x401u);
LABEL_4:
        a2 = (wchar_t *)v14[0];
LABEL_5:
        v9 = v5 == -1;
        v6 = v5 + 1;
        dword_411024 = v6;
        byte_431F00[v6] = 1;
        if ( v9 || (*((_BYTE *)&dword_431EFC + v6 + 3) & 2) != 0 )
        {
LABEL_9:
          if ( sub_40D9A7(a2, a1) )
          {
            LOBYTE(v3) = dword_411024;
            byte_431F00[dword_411024] |= 2u;
            return v3;
          }
        }
        else
        {
          byte_431F00[v6] = 5;
        }
      }
LABEL_8:
      v14[1] = a3;
      HIBYTE(v14[0]) = HIBYTE(a2);
      while ( 1 )
      {
        v12 = getwc(Stream);
        if ( v12 != 33 )
        {
          do
          {
            if ( v12 == 0xFFFF )
              goto LABEL_52;
            ++dword_4216A4;
            while ( 1 )
            {
              if ( v12 == 92 )
              {
                v12 = sub_409D15(0x5Cu, 1);
                if ( v12 == 33 && byte_411021 )
                  goto LABEL_47;
                byte_411021 = 0;
              }
              if ( v12 == 35 )
                break;
              if ( v12 == 10 )
                goto LABEL_45;
              if ( v12 == 0xFFFF )
                goto LABEL_46;
              v12 = getwc(Stream);
            }
            while ( 1 )
            {
              v12 = getwc(Stream);
              if ( v12 == 10 )
                break;
              if ( v12 == 0xFFFF )
                goto LABEL_46;
            }
LABEL_45:
            v12 = getwc(Stream);
          }
          while ( v12 != 33 );
LABEL_46:
          if ( v12 != 33 )
          {
LABEL_52:
            LOBYTE(v3) = sub_4053F6(dword_4216A4, 0x3FCu);
            return v3;
          }
        }
LABEL_47:
        if ( dword_431EF8 && dword_431EF8 != dword_431EFC )
          free(dword_431EF8);
        dword_431EF8 = sub_408046();
        LOBYTE(v3) = (unsigned __int8)sub_408182((wchar_t *)dword_431EF8, (char *)v14 + 3);
        if ( HIBYTE(v14[0]) <= 8u )
          return v3;
        ++dword_4216A4;
      }
    default:
      return v3;
  }
}
// 408646: could not find valid save-restore pair for ebp
// 40886F: conditional instruction was optimized away because ax.2==FFFF
// 40877D: variable 'a2' is possibly undefined
// 40869C: variable 'a1' is possibly undefined
// 411021: using guessed type char byte_411021;
// 411024: using guessed type int dword_411024;
// 4216A4: using guessed type int dword_4216A4;

//----- (00408888) --------------------------------------------------------
char sub_408888()
{
  char v0; // bl
  wchar_t *i; // eax
  const wchar_t *v2; // ecx
  wchar_t *v3; // edx
  int v5; // edx
  wchar_t *v7; // [esp+4h] [ebp-Ch]
  wchar_t *Context; // [esp+Ch] [ebp-4h] BYREF

  v0 = 0;
  for ( dword_4216A4 = 0; ; ++dword_4216A4 )
  {
    if ( !fgetws(&Src, 1024, Stream) )
    {
      if ( !feof(Stream) )
      {
        dword_4216B0 = dword_4216A4;
        sub_4053F6(0, 0x41Du);
      }
      return 0;
    }
    if ( Src == 91 )
      break;
LABEL_13:
    ;
  }
  Context = 0;
  for ( i = wcstok_s(&word_4216C2, L" \t\n", &Context); ; i = wcstok_s(0, L" \t\n", &Context) )
  {
    v2 = i;
    if ( !i || v0 )
    {
      v0 = 0;
      goto LABEL_13;
    }
    v3 = i;
    v7 = i + 1;
    while ( *v3++ )
      ;
    v5 = v3 - v7;
    if ( v2[v5 - 1] == 93 )
    {
      v0 = 1;
      v2[v5 - 1] = 0;
    }
    if ( !wcsicmp(v2, L"nmake") )
      break;
  }
  return 1;
}
// 4216A4: using guessed type int dword_4216A4;
// 4216B0: using guessed type int dword_4216B0;

//----- (00408971) --------------------------------------------------------
char __stdcall sub_408971(int a1)
{
  wchar_t ResultPath[260]; // [esp+0h] [ebp-20Ch] BYREF

  wsearchenv(L"tools.ini", L"INIT", ResultPath);
  if ( ResultPath[0] )
  {
    Stream = wfsopen(ResultPath, L"rt,ccs=unicode", 32);
    if ( !Stream )
      sub_4053F6(0, 0x41Du, ResultPath);
    if ( sub_408888() )
      return 1;
    if ( fclose(Stream) == -1 )
      sub_4053F6(0, 0x424u, ResultPath);
  }
  return 0;
}

//----- (00408A23) --------------------------------------------------------
wint_t *__fastcall sub_408A23(wint_t *a1, int a2)
{
  wint_t *v2; // esi
  wint_t *v3; // edi
  wint_t v4; // ax
  wint_t *result; // eax
  FILE *v6; // [esp-4h] [ebp-Ch]

  v2 = a1;
  v3 = &a1[a2];
  while ( 1 )
  {
    v4 = sub_407E9D();
    if ( !v4 )
      return v2;
    if ( v4 == 0xFFFF )
      break;
    *v2++ = v4;
    if ( v2 == v3 )
    {
      v6 = Stream;
      *(v2 - 1) = 0;
      ungetwc(v4, v6);
      return v2;
    }
    if ( v4 == 10 )
    {
      ++dword_4216A4;
      byte_411021 = 1;
      *v2 = 0;
      return v2;
    }
    byte_411021 = 0;
  }
  result = 0;
  *v2 = 0;
  return result;
}
// 411021: using guessed type char byte_411021;
// 4216A4: using guessed type int dword_4216A4;

//----- (00408A91) --------------------------------------------------------
wchar_t *__fastcall sub_408A91(const wchar_t *a1)
{
  wchar_t *result; // eax
  const wchar_t *v3; // esi

  for ( result = wcschr(a1, 0xAu); result && (result <= a1 || *(result - 1) == 94); result = wcschr(v3, 0xAu) )
  {
    v3 = result + 1;
    if ( !fgetws(result + 1, 1024 - (result + 1 - a1), Stream) )
    {
      if ( feof(Stream) )
        sub_4053F6(dword_4216A4, 0x409u, L"EOF");
      sub_4053F6(dword_4216A4, 0x41Du);
    }
    ++dword_4216A4;
  }
  return result;
}
// 4018A8: using guessed type wchar_t aEof[4];
// 4216A4: using guessed type int dword_4216A4;

//----- (00408B25) --------------------------------------------------------
void *__thiscall sub_408B25(__int16 **this)
{
  __int16 **v1; // edi
  __int16 *v2; // esi
  bool v3; // bl
  const wchar_t *v4; // edx
  wchar_t *v5; // eax
  __int16 *v6; // edx
  __int16 v7; // ax
  __int16 v8; // cx
  void *result; // eax
  __int16 v10; // cx

  v1 = this;
  v2 = (__int16 *)&unk_432400;
  v3 = 0;
  v4 = (const wchar_t *)*this;
  do
  {
    v5 = wcschr(v4, 0x3Cu);
    if ( !v5 )
      return 0;
    v4 = v5 + 1;
  }
  while ( v5[1] != 60 );
  v6 = (__int16 *)(v5 + 2);
  v7 = *v6;
  if ( !*v6 )
    goto LABEL_16;
  while ( v7 != 62 && v7 != 60 && v7 != 94 && v7 != 44 && v7 != 9 && v7 != 10 )
  {
    if ( v7 == 34 )
    {
      v3 = !v3;
LABEL_13:
      *v2++ = v7;
      v8 = *++v6;
      goto LABEL_14;
    }
    if ( v7 == 32 && !v3 )
      break;
    if ( v7 != 36 || v6[1] != 40 )
      goto LABEL_13;
    *v2 = 36;
    ++v6;
    *++v2 = 40;
    if ( *v6 == 10 )
      break;
    v10 = *v6;
    while ( v10 != 41 )
    {
      ++v6;
      *v2++ = v10;
      v10 = *v6;
      if ( *v6 == 10 )
        goto LABEL_15;
    }
    v8 = 41;
LABEL_14:
    v7 = v8;
    if ( !v8 )
      break;
  }
LABEL_15:
  v1 = this;
LABEL_16:
  result = &unk_432400;
  *v2 = 0;
  *v1 = v6;
  return result;
}

//----- (00408C27) --------------------------------------------------------
wchar_t *__fastcall sub_408C27(wchar_t *a1, _DWORD *a2, wchar_t **a3)
{
  _DWORD *v4; // ebx
  int *v5; // edx
  int *v6; // ecx
  char *v7; // esi
  wchar_t v8; // cx
  wchar_t *v9; // ebx
  _WORD *v10; // esi
  char *v11; // eax
  char *v12; // eax
  char *v15; // [esp+1Ch] [ebp-820h]
  unsigned int v16; // [esp+20h] [ebp-81Ch]
  wchar_t *v17; // [esp+24h] [ebp-818h] BYREF
  void *Block; // [esp+28h] [ebp-814h]
  char v19; // [esp+2Fh] [ebp-80Dh]
  wchar_t Destination[2]; // [esp+30h] [ebp-80Ch] BYREF
  wint_t v21[1024]; // [esp+34h] [ebp-808h] BYREF

  v15 = 0;
  v16 = 0;
  v19 = 0;
  Block = 0;
  wcscpy_s(Destination, 0x400u, L"<<");
  if ( !sub_408A23(v21, 1022) )
  {
    if ( feof(Stream) )
      sub_4053F6(dword_4216A4, 0x409u, L"EOF");
    sub_4053F6(dword_4216A4, 0x41Du);
  }
  v17 = Destination;
  sub_408A91(Destination);
  while ( 1 )
  {
    v7 = (char *)sub_408B25((__int16 **)&v17);
    if ( !v7 )
      break;
    v4 = sub_40AC61(0xCu);
    v4[1] = sub_40E267(v7);
    v5 = &dword_432320;
    v6 = (int *)dword_432320;
    if ( dword_432320 )
    {
      do
      {
        v5 = v6;
        v6 = (int *)*v6;
      }
      while ( v6 );
    }
    *v5 = (int)v4;
  }
  if ( dword_432320 )
  {
    v17 = (wchar_t *)wcsncpy_s;
    do
    {
      while ( 1 )
      {
        v8 = Destination[0];
        v9 = Destination;
        do
        {
          ++v9;
          *a1++ = v8;
          if ( a1 == *a3 )
          {
            if ( Block )
            {
              if ( v16 + 1024 < v16 || (v12 = (char *)sub_40AC7F(Block, 2 * v16 + 2048), (v15 = v12) == 0) )
              {
                sub_4053F6(dword_4216A4, 0x419u);
                v12 = v15;
              }
              Block = v12;
              v10 = v12;
              a1 = (wchar_t *)&v12[2 * v16];
              v16 += 1024;
              v11 = &v12[2 * v16];
            }
            else
            {
              v10 = sub_40AC3C(0x1000u);
              Block = v10;
              ((void (__cdecl *)(_WORD *, int, _DWORD, int))v17)(v10, 2048, *a2, 1024);
              a1 = v10 + 1024;
              v16 = 2048;
              v11 = (char *)(v10 + 2048);
            }
            *a3 = (wchar_t *)v11;
            *a2 = v10;
          }
          v8 = *v9;
        }
        while ( *v9 );
        if ( v19 && Destination[0] == 60 && Destination[1] == 60 )
          break;
        v19 = 1;
        if ( !sub_408A23(Destination, 1024) )
        {
          if ( feof(Stream) )
            sub_4053F6(dword_4216A4, 0x409u, L"EOF");
          sub_4053F6(dword_4216A4, 0x41Du);
        }
      }
      if ( *(_DWORD *)dword_432320 && !sub_408A23(Destination, 1024) )
      {
        if ( feof(Stream) )
          sub_4053F6(dword_4216A4, 0x409u, L"EOF");
        sub_4053F6(dword_4216A4, 0x41Du);
      }
      dword_432320 = *(_DWORD *)dword_432320;
    }
    while ( dword_432320 );
  }
  *a1 = 0;
  return a1;
}
// 4018A8: using guessed type wchar_t aEof[4];
// 4216A4: using guessed type int dword_4216A4;
// 432320: using guessed type int dword_432320;
// 408C27: using guessed type wint_t var_808[1024];

//----- (00408F3E) --------------------------------------------------------
errno_t __fastcall sub_408F3E(void **a1, wchar_t *a2)
{
  char *v2; // edi
  _WORD *v3; // esi
  int v4; // ecx
  int v6; // esi
  wchar_t *v7; // ecx
  int v8; // esi
  wchar_t *v9; // edx
  rsize_t v11; // esi
  void *v12; // esp
  wchar_t *i; // eax
  __int16 v14; // cx
  unsigned int v15; // kr00_4
  void **v16; // edi
  wchar_t *v17; // eax
  wchar_t *v19; // [esp-4h] [ebp-24h]
  wchar_t v20[8]; // [esp+0h] [ebp-20h] BYREF
  void **v21; // [esp+10h] [ebp-10h]
  rsize_t SizeInWords; // [esp+14h] [ebp-Ch]
  wchar_t *Source; // [esp+18h] [ebp-8h]

  Source = a2;
  v21 = a1;
  v2 = (char *)*a1;
  v3 = *a1;
  v4 = (int)*a1 + 2;
  while ( *v3++ )
    ;
  v6 = (int)v3 - v4;
  v7 = a2;
  v8 = v6 >> 1;
  v9 = a2 + 1;
  while ( *v7++ )
    ;
  v11 = v7 - v9 - 1 + v8;
  SizeInWords = v11;
  v12 = alloca(2 * v11);
  for ( i = v20; ; ++i )
  {
    v14 = *(_WORD *)v2;
    if ( *(_WORD *)v2 != 60 )
      goto LABEL_9;
    if ( *((_WORD *)v2 + 1) == 60 )
      break;
    v14 = 60;
LABEL_9:
    *i = v14;
    v2 += 2;
  }
  v19 = Source;
  *i = 0;
  wcscat_s(v20, v11, v19);
  wcscat_s(v20, SizeInWords, (const wchar_t *)v2 + 2);
  v15 = wcslen(v20);
  v16 = v21;
  v17 = (wchar_t *)sub_40AC7F(*v21, 2 * (v15 + 1));
  *v16 = v17;
  return wcscpy_s(v17, v15 + 1, v20);
}

//----- (0040901B) --------------------------------------------------------
int __fastcall sub_40901B(wchar_t *Source, const unsigned __int16 *a2, char a3)
{
  const wchar_t *v3; // edi
  wint_t *v4; // esi
  wint_t v5; // cx
  const wchar_t *v6; // eax
  int result; // eax
  int v8; // esi
  int v9; // edi
  wint_t v10; // cx
  unsigned int v11; // esi
  const wchar_t *v12; // eax
  unsigned int v13; // [esp+Ch] [ebp-10h]
  wchar_t *v14; // [esp+10h] [ebp-Ch]
  wint_t *v15; // [esp+14h] [ebp-8h]
  const unsigned __int16 *v16; // [esp+18h] [ebp-4h]
  char v17; // [esp+27h] [ebp+Bh]

  v3 = Source;
  v14 = Source;
  v16 = a2;
  v4 = Source;
  v5 = *Source;
  if ( v5 )
  {
    while ( iswspace(v5) )
    {
      v5 = *++v4;
      if ( !*v4 )
      {
        a2 = v16;
        goto LABEL_5;
      }
    }
    result = 1012 - wcslen(v16);
    v13 = result;
    if ( *v3 )
    {
      v17 = a3;
      do
      {
        wcsncpy_s(word_435660, 0x400u, v3, result);
        v8 = wcslen(word_435660);
        if ( v13 < wcslen(v3) )
        {
          v15 = word_435660;
          if ( word_435660[0] )
          {
            v9 = 0;
            v10 = word_435660[0];
            do
            {
              if ( iswspace(v10) )
                v8 = (v9 >> 1) + 1;
              v9 += 2;
              v10 = *++v15;
            }
            while ( *v15 );
            v3 = v14;
          }
        }
        v11 = v8;
        if ( v11 >= 1024 )
          __report_rangecheckfailure();
        word_435660[v11] = 0;
        v12 = L">>";
        if ( !v17 )
          v12 = L">";
        sub_40C7C7((wchar_t *)L"\techo %s %s %s\n", word_435660, v12, v16);
        v3 = (const wchar_t *)((char *)v3 + v11 * 2);
        v17 = 1;
        v14 = (wchar_t *)v3;
        result = v13;
      }
      while ( *v3 );
    }
  }
  else
  {
LABEL_5:
    v6 = L">>";
    if ( !a3 )
      v6 = L">";
    return sub_40C7C7((wchar_t *)L"\techo. %s %s\n", v6, a2);
  }
  return result;
}
// 40166C: using guessed type wchar_t asc_40166C[2];
// 4018C0: using guessed type wchar_t asc_4018C0[3];
// 410495: using guessed type void __noreturn __report_rangecheckfailure(void);
// 435660: using guessed type wchar_t word_435660[1024];

//----- (0040918C) --------------------------------------------------------
wchar_t *__fastcall sub_40918C(FILE *a1, int a2, const wchar_t **a3, char a4, _BYTE *a5)
{
  const wchar_t **v5; // edi
  const unsigned __int16 *v6; // esi
  wchar_t *v7; // eax
  char *v8; // ebx
  wchar_t *v9; // esi
  void *v10; // eax
  wchar_t *v11; // esi
  wchar_t *result; // eax
  wchar_t *v13; // ebx
  wchar_t *v14; // ecx
  const wchar_t *v15; // esi
  FILE *v16; // edi
  int v17; // eax
  void *Block; // [esp+10h] [ebp-14h] BYREF
  wchar_t *Context; // [esp+14h] [ebp-10h] BYREF
  const unsigned __int16 *v20; // [esp+18h] [ebp-Ch]
  FILE *Stream; // [esp+1Ch] [ebp-8h]
  char v22; // [esp+23h] [ebp-1h]
  char v23; // [esp+34h] [ebp+10h]

  v5 = a3;
  v6 = (const unsigned __int16 *)a2;
  v20 = (const unsigned __int16 *)a2;
  Stream = a1;
  v7 = wcsstr(*a3, L"<<");
  v22 = 0;
  if ( v7 && (v7 == *a3 || *(v7 - 1) == 10) )
  {
    v8 = (char *)(v7 + 2);
    v9 = wcschr(v7 + 2, 0xAu);
    if ( v9 )
      *v9 = 0;
    v10 = sub_40E267(v8);
    Block = v10;
    if ( v9 )
      *v9 = 10;
    Context = 0;
    v11 = wcstok_s((wchar_t *)v10, L", \t", &Context);
    if ( v11 )
    {
      do
      {
        if ( wcsicmp(v11, L"keep") )
        {
          if ( wcsicmp(v11, L"nokeep") )
          {
            if ( wcsicmp(v11, L"unicode") )
              sub_4053F6(dword_4216A4, 0x446u);
            else
              v22 = 1;
          }
          else
          {
            *a5 = 0;
          }
        }
        else
        {
          *a5 = 1;
        }
        v11 = wcstok_s(0, L", \t", &Context);
      }
      while ( v11 );
      v5 = a3;
    }
    free(Block);
    if ( v22 )
      fwrite(&dword_401938, 2u, 1u, Stream);
    v6 = v20;
  }
  result = (wchar_t *)wcsncmp(*v5, L"<<", 2u);
  if ( result )
  {
    v23 = 0;
    while ( 1 )
    {
      result = wcschr(*v5, 0xAu);
      v13 = result;
      if ( !result )
        break;
      if ( a4 )
      {
        v14 = (wchar_t *)*v5;
        *result = 0;
        sub_40901B(v14, v6, v23);
        *v13 = 10;
      }
      v15 = *v5;
      if ( v22 )
      {
        fwrite(v15, v13 - v15, 2u, Stream);
        fwrite("\r", 4u, 1u, Stream);
      }
      else
      {
        if ( v15 < v13 )
        {
          v16 = Stream;
          do
          {
            v17 = WideCharToMultiByte(0, 0, v15, 1, (LPSTR)&Block, 4, 0, 0);
            if ( v17 )
              fwrite(&Block, v17, 1u, v16);
            ++v15;
          }
          while ( v15 < v13 );
          v5 = a3;
        }
        fwrite("\r\n", 2u, 1u, Stream);
      }
      v23 = 1;
      *v5 = v13 + 1;
      result = (wchar_t *)wcsncmp(v13 + 1, L"<<", 2u);
      v6 = v20;
      if ( !result )
        goto LABEL_36;
    }
  }
  else
  {
LABEL_36:
    *v5 += 2;
  }
  return result;
}
// 401938: using guessed type int dword_401938;
// 4216A4: using guessed type int dword_4216A4;

//----- (004093B0) --------------------------------------------------------
char __fastcall sub_4093B0(wchar_t *Str, const wchar_t **a2, wchar_t *a3, char a4)
{
  const wchar_t **v5; // edi
  wchar_t *v6; // ebx
  __int16 *v8; // ebx
  __int16 *v9; // eax
  wchar_t *v10; // esi
  char *v11; // eax
  _WORD *v12; // esi
  FILE *v13; // eax
  unsigned int v14; // kr00_4
  wchar_t *v15; // edx
  const wchar_t *v16; // eax
  _WORD *v17; // ecx
  wchar_t *v19; // esi
  wchar_t *v20; // eax
  wchar_t *v21; // eax
  _DWORD *v22; // esi
  wchar_t *v23; // [esp-4h] [ebp-44Ch]
  wchar_t *v24; // [esp+Ch] [ebp-43Ch]
  size_t RequiredCount; // [esp+18h] [ebp-430h] BYREF
  const wchar_t *v27; // [esp+1Ch] [ebp-42Ch] BYREF
  void *Block; // [esp+20h] [ebp-428h]
  FILE *Stream; // [esp+24h] [ebp-424h]
  wchar_t *Stra; // [esp+28h] [ebp-420h] BYREF
  char v31; // [esp+2Fh] [ebp-419h] BYREF
  WCHAR TempFileName[260]; // [esp+30h] [ebp-418h] BYREF
  wchar_t Buffer; // [esp+238h] [ebp-210h] BYREF
  __int16 v34[261]; // [esp+23Ah] [ebp-20Eh] BYREF

  Stra = a3;
  v5 = a2;
  v6 = wcschr(Str, 0xAu);
  if ( v6 )
  {
    v23 = Stra;
    *v6 = 0;
    *v5 = (const wchar_t *)sub_40EC83((__int16 *)Str, 255, v23);
    *v6 = 10;
    v8 = (__int16 *)(v6 + 1);
    v9 = (__int16 *)*v5;
    if ( *v5 == Str )
    {
      v9 = (__int16 *)sub_40E267((char *)Str);
      *v5 = (const wchar_t *)v9;
    }
    v27 = (const wchar_t *)v9;
    v10 = (wchar_t *)sub_40EC83(v8, 255, Stra);
    v24 = v10;
    Stra = v10;
    v11 = (char *)sub_408B25((__int16 **)&v27);
    if ( v11 )
    {
      do
      {
        v31 = 0;
        v12 = sub_40E267(v11);
        Block = v12;
        if ( *v12 )
        {
          Stream = sub_40FFC6(v12, (wchar_t *)L"wb");
          if ( Stream )
          {
            v15 = wcschr(*v5, 0x3Cu);
            v16 = v15 + 1;
            if ( v15[1] != 60 )
            {
              do
              {
                v15 = wcschr(v16, 0x3Cu);
                v16 = v15 + 1;
              }
              while ( v15[1] != 60 );
              v5 = a2;
            }
            v17 = v15 + 2;
            v27 = v15 + 3;
            while ( *v17++ )
              ;
            memmove(v15, v15 + 2, 2 * (v17 - v27) + 2);
            v12 = Block;
          }
          else
          {
            sub_4053F6(dword_4216A4, 0x41Eu, v12);
          }
        }
        else
        {
          RequiredCount = 0;
          if ( wgetenv_s(&RequiredCount, &Buffer, 0x103u, L"TMP") || !RequiredCount )
            wcscpy_s(&Buffer, 0x103u, L".");
          Stream = 0;
          if ( GetTempFileNameW(&Buffer, L"nm", 0, TempFileName) )
          {
            wcscpy_s(&Buffer, 0x103u, TempFileName);
            v13 = wfsopen(&Buffer, L"wb", 32);
            Stream = v13;
          }
          else
          {
            v13 = Stream;
          }
          if ( !v13 )
            sub_4053F6(dword_4216A4, 0x41Eu, &Buffer);
          if ( wcschr(&Buffer, 0x20u) && !wcschr(&Buffer, 0x22u) )
          {
            v14 = wcslen(&Buffer);
            memmove(v34, &Buffer, 2 * v14);
            Buffer = 34;
            v34[v14] = 34;
            if ( 2 * v14 + 4 >= 0x206 )
              __report_rangecheckfailure();
            v12 = Block;
            v34[v14 + 1] = 0;
            v5 = a2;
          }
          sub_408F3E((void **)v5, &Buffer);
          free(v12);
          v12 = sub_40E267((char *)&Buffer);
          Block = v12;
        }
        v27 = *v5;
        sub_40918C(Stream, (int)v12, (const wchar_t **)&Stra, a4, &v31);
        v19 = Stra;
        v20 = wcschr(Stra, 0xAu);
        if ( v20 )
          v21 = v20 + 1;
        else
          v21 = &v19[wcslen(v19)];
        Stra = v21;
        fclose(Stream);
        if ( !v31 )
        {
          v22 = sub_40E215();
          v22[1] = sub_40E267((char *)Block);
          sub_40E36C((_DWORD **)&dword_4323F4, v22);
        }
        free(Block);
        v11 = (char *)sub_408B25((__int16 **)&v27);
      }
      while ( v11 );
      v10 = v24;
    }
    if ( v10 != (wchar_t *)v8 )
      free(v10);
    return 1;
  }
  else
  {
    *v5 = (const wchar_t *)sub_40E267((char *)Str);
    return 0;
  }
}
// 410495: using guessed type void __noreturn __report_rangecheckfailure(void);
// 4216A4: using guessed type int dword_4216A4;
// 4323F4: using guessed type int dword_4323F4;
// 4093B0: using guessed type __int16 var_20E[261];

//----- (004097A9) --------------------------------------------------------
int sub_4097A9()
{
  int v0; // ecx
  int result; // eax

  if ( fclose(Stream) == 0xFFFF )
    sub_4053F6(0, 0x424u, ArgList);
  free(ArgList);
  v0 = 3 * --dword_432324;
  Stream = (FILE *)dword_432338[v0];
  ArgList = (void *)dword_432334[v0];
  result = dword_432330[v0];
  dword_4216A4 = result;
  return result;
}
// 4216A4: using guessed type int dword_4216A4;
// 432324: using guessed type int dword_432324;
// 432330: using guessed type int dword_432330[];
// 432334: using guessed type int dword_432334[];
// 432338: using guessed type int dword_432338[];

//----- (00409811) --------------------------------------------------------
wint_t __fastcall sub_409811(char a1)
{
  wint_t result; // ax
  wint_t v3; // ax

LABEL_1:
  byte_411021 = 0;
  while ( 1 )
  {
    result = a1 ? getwc(Stream) : sub_407E9D();
    if ( result == 0xFFFF )
      return result;
    if ( result == 10 )
    {
      byte_411021 = 1;
      if ( a1 )
        v3 = getwc(Stream);
      else
        v3 = sub_407E9D();
      if ( v3 == 59 && byte_421EE1 || v3 == 35 )
      {
        ++dword_4216A4;
        goto LABEL_1;
      }
      return ungetwc(v3, Stream);
    }
  }
}
// 411021: using guessed type char byte_411021;
// 4216A4: using guessed type int dword_4216A4;
// 421EE1: using guessed type char byte_421EE1;

//----- (00409896) --------------------------------------------------------
unsigned __int8 __fastcall sub_409896(wchar_t a1)
{
  wchar_t *v2; // ecx
  unsigned int v3; // edx
  int v4; // eax

  if ( a1 == 10 || a1 == 0xFFFF )
    sub_4053F6(dword_4216A4, 0x407u);
  Src = a1;
  if ( !fgetws(&word_4216C2, 1023, Stream) )
  {
    if ( feof(Stream) )
      sub_4053F6(dword_4216A4, 0x409u, L"EOF");
    sub_4053F6(dword_4216A4, 0x41Du);
  }
  v2 = &Src;
  v3 = 2 * wcslen(&Src) - 2;
  if ( *(wchar_t *)((char *)&Src + v3) == 10 )
  {
    if ( v3 >= 0x800 )
      __report_rangecheckfailure();
    *(wchar_t *)((char *)&Src + v3) = 0;
  }
  while ( 1 )
  {
    v4 = *v2;
    if ( v4 != 32 && v4 != 9 )
      break;
    ++v2;
  }
  return sub_40A618(v2);
}
// 4018A8: using guessed type wchar_t aEof[4];
// 410495: using guessed type void __noreturn __report_rangecheckfailure(void);
// 4216A4: using guessed type int dword_4216A4;

//----- (0040997A) --------------------------------------------------------
unsigned __int8 __fastcall sub_40997A(wint_t Character, _WORD *a2, int a3)
{
  char v4; // dl
  wint_t v5; // ax
  char v6; // bl
  unsigned __int8 result; // al
  __int16 v8; // ax
  wchar_t v9; // si

  v4 = byte_411021;
  while ( 1 )
  {
    switch ( Character )
    {
      case 0xAu:
        goto LABEL_15;
      case 0x3Au:
        byte_411021 = 0;
        Character = sub_407E9D();
        if ( Character == 58 )
        {
          *a2 = 58;
          result = 21;
          a2[1] = 0;
          return result;
        }
        v6 = 20;
LABEL_23:
        ungetwc(Character, Stream);
        return v6;
      case 0x3Bu:
        result = 19;
LABEL_44:
        byte_411021 = 0;
        return result;
      case 0x3Du:
        result = 22;
        goto LABEL_44;
    }
    if ( Character == 91 )
      break;
    if ( Character == 94 )
      goto LABEL_27;
    if ( Character != 0xFFFF )
      goto LABEL_28;
    if ( !feof(Stream) )
      sub_4053F6(dword_4216A4, 0x40Eu);
    if ( dword_432324 )
    {
      sub_4097A9();
    }
    else
    {
      if ( dword_411024 < 0 )
        return 23;
      sub_4053F6(dword_4216A4, 0x3FCu);
    }
LABEL_15:
    ++dword_4216A4;
    byte_411021 = 1;
    v5 = sub_407E9D();
    Character = v5;
    if ( v5 == 59 && byte_421EE1 || v5 == 35 )
    {
      sub_409811(0);
      ++dword_4216A4;
      byte_411021 = 1;
      Character = sub_407E9D();
    }
    if ( Character == 32 || Character == 9 )
    {
      result = 18;
      goto LABEL_44;
    }
    v4 = 1;
    byte_411021 = 1;
    if ( Character != 0xFFFF )
    {
      v6 = 17;
      goto LABEL_23;
    }
  }
  if ( byte_421EE1 && v4 )
    return 23;
LABEL_27:
  ungetwc(Character, Stream);
  --a2;
LABEL_28:
  sub_40A375(a2 - 1, a3);
  if ( !byte_411021 || wcsicmp(&Src, L"include") )
  {
    byte_411021 = 0;
    return 16;
  }
  byte_411021 = 0;
  v8 = sub_409C3C(0);
  v9 = v8;
  if ( v8 == 58 || v8 == 61 )
  {
    ungetwc(v8, Stream);
    return 16;
  }
  if ( byte_421EE1 )
    sub_4053F6(dword_4216A4, 0x409u, a2);
  return sub_409896(v9);
}
// 411021: using guessed type char byte_411021;
// 411024: using guessed type int dword_411024;
// 4216A4: using guessed type int dword_4216A4;
// 421EE1: using guessed type char byte_421EE1;
// 432324: using guessed type int dword_432324;

//----- (00409B97) --------------------------------------------------------
char __fastcall sub_409B97(int a1, char a2)
{
  wint_t v3; // ax
  __int16 v4; // cx
  wchar_t *v5; // edx

  if ( byte_421EE2 )
  {
    ++dword_4216A4;
    byte_421EE2 = 0;
    v3 = sub_407E9D();
    if ( v3 == 32 || v3 == 9 )
    {
      byte_411021 = 0;
      return 18;
    }
    else
    {
      v4 = -1;
      byte_411021 = 1;
      if ( v3 == 0xFFFF )
      {
        v5 = &Src;
        return sub_40997A(v4, v5, (int)&dword_421EC0);
      }
      ungetwc(v3, Stream);
      return 17;
    }
  }
  else
  {
    if ( a2 != 24 && a2 != 25 )
    {
      v4 = sub_409C3C(0);
      v5 = &word_4216C2;
      Src = v4;
      word_4216C2 = 0;
      return sub_40997A(v4, v5, (int)&dword_421EC0);
    }
    sub_409DC6(a2, a2, (int)&dword_421EC0);
    return a2;
  }
}
// 411021: using guessed type char byte_411021;
// 4216A4: using guessed type int dword_4216A4;
// 421EC0: using guessed type int dword_421EC0;
// 421EE2: using guessed type char byte_421EE2;

//----- (00409C3C) --------------------------------------------------------
__int16 __fastcall sub_409C3C(char a1)
{
  __int16 v2; // si
  wint_t v3; // ax

  v2 = 94;
  do
  {
    if ( a1 )
      v3 = getwc(Stream);
    else
      v3 = sub_407E9D();
    if ( v3 != 32 && v3 != 9 )
    {
      if ( v3 != 94 )
        goto LABEL_14;
      if ( a1 )
        v3 = getwc(Stream);
      else
        v3 = sub_407E9D();
      if ( v3 != 32 && v3 != 9 )
      {
        ungetwc(v3, Stream);
        return v2;
      }
    }
    byte_411021 = 0;
LABEL_14:
    if ( v3 == 92 )
      v3 = sub_409D15(0x5Cu, a1);
  }
  while ( v3 == 32 || v3 == 9 );
  v2 = v3;
  if ( v3 == 59 )
  {
    if ( !byte_411021 )
      return v2;
    if ( byte_421EE1 )
      goto LABEL_22;
  }
  if ( v3 == 35 )
  {
LABEL_22:
    sub_409811(a1);
    v2 = 10;
    byte_411021 = 1;
  }
  return v2;
}
// 411021: using guessed type char byte_411021;
// 421EE1: using guessed type char byte_421EE1;

//----- (00409D15) --------------------------------------------------------
wint_t __fastcall sub_409D15(wint_t a1, char a2)
{
  wint_t v3; // ax
  wint_t v4; // ax
  wint_t v5; // ax

  if ( a1 != 92 )
    return a1;
  while ( 1 )
  {
    v3 = a2 ? getwc(Stream) : sub_407E9D();
    if ( v3 != 10 )
      break;
    ++dword_4216A4;
    byte_411021 = 1;
    if ( a2 )
      v4 = getwc(Stream);
    else
      v4 = sub_407E9D();
    a1 = v4;
    if ( v4 == 59 && byte_421EE1 || v4 == 35 )
    {
      sub_409811(a2);
      ++dword_4216A4;
      if ( a2 )
        v5 = getwc(Stream);
      else
        v5 = sub_407E9D();
      a1 = v5;
    }
    if ( a1 != 92 )
      return a1;
  }
  ungetwc(v3, Stream);
  return 92;
}
// 411021: using guessed type char byte_411021;
// 4216A4: using guessed type int dword_4216A4;
// 421EE1: using guessed type char byte_421EE1;

//----- (00409DC6) --------------------------------------------------------
wchar_t *__fastcall sub_409DC6(char a1, int a2, int a3)
{
  wchar_t *v3; // esi
  wchar_t *v5; // edi
  char v6; // bl
  int v7; // ecx
  unsigned __int8 v8; // bh
  wint_t v9; // ax
  wchar_t *v10; // eax
  unsigned int v11; // esi
  unsigned int v12; // edi
  wchar_t *v13; // eax
  unsigned __int8 v14; // dl
  wint_t v15; // ax
  int v16; // eax
  wint_t v17; // ax
  unsigned __int8 v18; // bl
  wint_t v19; // ax
  wchar_t *v20; // eax
  unsigned int v21; // edi
  wchar_t *v22; // eax
  int v23; // eax
  wchar_t *v24; // ecx
  wchar_t *result; // eax
  __int16 v26; // [esp-4h] [ebp-30h]
  wchar_t *v27; // [esp+10h] [ebp-1Ch]
  wchar_t *v28; // [esp+14h] [ebp-18h] BYREF
  unsigned int v29; // [esp+18h] [ebp-14h]
  wchar_t *v30; // [esp+1Ch] [ebp-10h]
  int v31; // [esp+20h] [ebp-Ch]
  wchar_t *Source; // [esp+24h] [ebp-8h]
  char v33; // [esp+2Ah] [ebp-2h]
  bool v34; // [esp+2Bh] [ebp-1h]

  v27 = 0;
  v3 = &Src;
  v29 = 0;
  v5 = &Src;
  v6 = 0;
  v33 = a1;
  v34 = 0;
  Source = &Src;
  v28 = &Src;
  v7 = (unsigned __int16)sub_407E9D();
  v31 = v7;
  v30 = (wchar_t *)32;
  if ( a1 != 24 )
  {
    if ( (_WORD)v7 == (_WORD)v30 || (_WORD)v7 == 9 )
      goto LABEL_10;
    if ( (_WORD)v7 != 94 )
    {
      v8 = 1;
      goto LABEL_12;
    }
    v9 = sub_407E9D();
    if ( v9 == 32 || v9 == 9 )
    {
LABEL_10:
      v8 = 2;
      v7 = (unsigned __int16)sub_409C3C(0);
    }
    else
    {
      ungetwc(v9, Stream);
      v8 = 1;
      v7 = 94;
    }
    v31 = v7;
    goto LABEL_12;
  }
  v8 = 2;
LABEL_12:
  v30 = (wchar_t *)a3;
  while ( 1 )
  {
    if ( (_WORD)v7 == 34 )
    {
      v34 = !v34;
    }
    else
    {
      v34 = v6;
      if ( (_WORD)v7 == 94 )
      {
        if ( v6 || v33 != 25 )
        {
          v15 = sub_407E9D();
          ungetwc(v15, Stream);
          LOWORD(v7) = 94;
          v31 = 94;
          v34 = v6;
        }
        else
        {
          LOWORD(v7) = sub_407E9D();
          v31 = (unsigned __int16)v7;
          if ( (unsigned __int16)v7 > 0x29u )
          {
            v34 = 0;
            switch ( (unsigned __int16)v7 )
            {
              case '-':
              case '@':
                goto LABEL_33;
              case '\\':
                goto LABEL_41;
              case '^':
              case '{':
              case '}':
LABEL_33:
                *v3++ = 94;
                if ( v3 == v30 )
                {
                  if ( dword_4216AC )
                  {
                    v11 = v29;
                    v12 = v29 + 1024;
                    if ( v29 + 1024 < v29 || (v13 = (wchar_t *)sub_40AC7F(dword_4216AC, 2 * v12), (v27 = v13) == 0) )
                    {
                      sub_4053F6(dword_4216A4, 0x419u);
                      v13 = v27;
                    }
                    dword_4216AC = v13;
                    v3 = &v13[v11];
                    v29 = v12;
                    v10 = &v13[v12];
                  }
                  else
                  {
                    dword_4216AC = (wchar_t *)sub_40AC3C(0x1000u);
                    wcsncpy_s(dword_4216AC, 0x800u, v5, 0x400u);
                    v29 = 2048;
                    v3 = dword_4216AC + 1024;
                    v10 = dword_4216AC + 2048;
                  }
                  v30 = v10;
                  a3 = (int)v10;
                  Source = dword_4216AC;
                  v28 = dword_4216AC;
                }
LABEL_41:
                v14 = 0;
                v34 = 0;
                goto LABEL_76;
            }
          }
          else
          {
            if ( (unsigned __int16)v7 == 41 )
              goto LABEL_33;
            v34 = 0;
            switch ( (unsigned __int16)v7 )
            {
              case 0xAu:
                goto LABEL_41;
              case 0x21u:
                goto LABEL_33;
              case 0x22u:
              case 0x23u:
                goto LABEL_41;
              case 0x24u:
              case 0x28u:
                goto LABEL_33;
            }
          }
        }
      }
    }
    if ( (unsigned __int16)v7 > 0x3Cu )
    {
      if ( (unsigned __int16)v7 > 0x44u )
      {
        if ( (unsigned __int16)v7 != 70 && (unsigned __int16)v7 != 82 )
        {
          if ( (unsigned __int16)v7 == 92 )
          {
            v14 = 3;
          }
          else
          {
            if ( (unsigned __int16)v7 != 0xFFFF )
              goto LABEL_103;
LABEL_104:
            v14 = 6;
          }
LABEL_76:
          v7 = 14 * v8;
          v16 = v14;
          goto LABEL_77;
        }
      }
      else if ( (unsigned __int16)v7 != 68 )
      {
        if ( (unsigned __int16)v7 == 61 )
        {
          v14 = 2;
          goto LABEL_76;
        }
        if ( (unsigned __int16)v7 != 63 && (unsigned __int16)v7 != 64 )
        {
          if ( (unsigned __int16)v7 != 66 )
            goto LABEL_103;
          goto LABEL_75;
        }
LABEL_92:
        v18 = 12;
        v14 = 12;
        if ( v33 != 24 || (_WORD)v7 != 60 )
          goto LABEL_76;
        v19 = sub_407E9D();
        if ( v19 == 60 )
        {
          v3 = sub_408C27(v3, &v28, (wchar_t **)&a3);
          v18 = 6;
          --dword_4216A4;
          v31 = 10;
          v30 = (wchar_t *)a3;
          Source = v28;
        }
        else
        {
          ungetwc(v19, Stream);
        }
        v7 = 14 * v8;
        v16 = v18;
LABEL_77:
        v8 = byte_4013A0[v7 + v16];
        LOWORD(v7) = v31;
        goto LABEL_78;
      }
LABEL_75:
      v14 = 13;
      goto LABEL_76;
    }
    if ( (unsigned __int16)v7 == 60 )
      goto LABEL_92;
    if ( (unsigned __int16)v7 > 0x28u )
    {
      switch ( (unsigned __int16)v7 )
      {
        case ')':
          v14 = 9;
          break;
        case '*':
          v14 = 11;
          break;
        case ':':
          v14 = 4;
          break;
        case ';':
          if ( !v8 && byte_421EE1 )
          {
LABEL_64:
            v6 = 0;
            v34 = 0;
            sub_409811(0);
            ++dword_4216A4;
            goto LABEL_91;
          }
          v14 = 0;
          break;
        default:
          goto LABEL_103;
      }
      goto LABEL_76;
    }
    switch ( (unsigned __int16)v7 )
    {
      case 0x28u:
        v14 = 8;
        goto LABEL_76;
      case 9u:
        goto LABEL_56;
      case 0xAu:
        goto LABEL_104;
      case 0x20u:
LABEL_56:
        v14 = 5;
        goto LABEL_76;
    }
    if ( (unsigned __int16)v7 != 35 )
    {
      if ( (unsigned __int16)v7 == 36 )
      {
        v14 = 7;
        goto LABEL_76;
      }
LABEL_103:
      v14 = sub_403702(v7) ? 0xA : 0;
      goto LABEL_76;
    }
    if ( !v8 )
      goto LABEL_64;
    if ( v33 == 25 )
      goto LABEL_115;
    v8 = byte_4013A1[14 * v8];
LABEL_78:
    if ( v8 == 64 )
      goto LABEL_114;
    if ( (v8 & 0x20) != 0 )
      sub_4053F6(dword_4216A4, (v8 & 0xDF) + 1000, (unsigned __int16)v7);
    if ( !v8 )
    {
      ++dword_4216A4;
      *(v3 - 1) = 32;
      v31 = (int)v3;
      byte_411021 = 1;
      v17 = sub_407E9D();
      byte_411021 = 0;
      if ( v17 == 32 || v17 == 9 )
      {
        v8 = 2;
        do
        {
          do
            v17 = sub_407E9D();
          while ( v17 == 32 );
        }
        while ( v17 == 9 );
        v3 = (wchar_t *)v31;
      }
      ungetwc(v17, Stream);
      goto LABEL_89;
    }
    *v3++ = v31;
    if ( v3 == v30 )
      break;
LABEL_89:
    v5 = Source;
LABEL_90:
    v6 = v34;
LABEL_91:
    v7 = (unsigned __int16)sub_407E9D();
    v31 = v7;
  }
  if ( !dword_4216AC )
  {
    dword_4216AC = (wchar_t *)sub_40AC3C(0x1000u);
    wcsncpy_s(dword_4216AC, 0x800u, Source, 0x400u);
    v5 = dword_4216AC;
    Source = dword_4216AC;
    v29 = 2048;
    v3 = dword_4216AC + 1024;
    v20 = dword_4216AC + 2048;
LABEL_112:
    v30 = v20;
    a3 = (int)v20;
    v28 = v5;
    goto LABEL_90;
  }
  v3 = (wchar_t *)v29;
  v21 = v29 + 1024;
  if ( v29 + 1024 >= v29 )
  {
    v22 = (wchar_t *)sub_40AC7F(dword_4216AC, 2 * v21);
    v27 = v22;
    if ( v22 )
    {
      Source = v22;
      dword_4216AC = v22;
      v3 = &v22[(_DWORD)v3];
      v29 = v21;
      v5 = v22;
      v20 = &v22[v29];
      goto LABEL_112;
    }
  }
  sub_4053F6(dword_4216A4, 0x419u);
  LOWORD(v7) = v26;
LABEL_114:
  v5 = Source;
LABEL_115:
  ungetwc(v7, Stream);
  while ( v3 > v5 )
  {
    v23 = iswspace(*(v3 - 1));
    v5 = Source;
    if ( !v23 )
      break;
    --v3;
  }
  v24 = dword_4216AC;
  *v3 = 0;
  if ( !v24 )
  {
    result = (wchar_t *)sub_40E267((char *)v5);
    goto LABEL_123;
  }
  result = (wchar_t *)sub_40AC7F(v24, 2 * (v3 - v24) + 2);
  if ( result )
LABEL_123:
    dword_4216AC = result;
  return result;
}
// 40A30E: variable 'v26' is possibly undefined
// 411021: using guessed type char byte_411021;
// 4216A4: using guessed type int dword_4216A4;
// 421EE1: using guessed type char byte_421EE1;

//----- (0040A375) --------------------------------------------------------
const unsigned __int16 *__fastcall sub_40A375(const unsigned __int16 *a1, unsigned int a2)
{
  char v2; // bh
  wchar_t *v3; // edi
  unsigned __int8 v4; // bl
  wint_t v5; // si
  wint_t v6; // ax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  unsigned __int8 v10; // dl
  int v11; // eax
  int v12; // eax
  int v13; // eax
  unsigned __int16 *v17; // [esp+18h] [ebp-8h]
  char v18; // [esp+1Fh] [ebp-1h]

  v2 = 0;
  v3 = (wchar_t *)(a1 + 1);
  v18 = 0;
  v17 = (unsigned __int16 *)(a1 + 1);
  switch ( *a1 )
  {
    case '"':
      v18 = 1;
      v4 = 16;
      break;
    case '$':
      v4 = 2;
      break;
    case '{':
      v4 = 8;
      break;
    default:
      v4 = 0;
      break;
  }
  while ( 1 )
  {
    v5 = sub_407E9D();
    if ( v5 == 94 )
    {
      v6 = sub_407E9D();
      v5 = v6;
      if ( v6 > 0x29u )
      {
        v11 = v6 - 92;
        if ( !v11 )
          goto LABEL_30;
        v12 = v11 - 2;
        if ( !v12 || (v13 = v12 - 29) == 0 || v13 == 2 )
        {
LABEL_29:
          *v3++ = 94;
          v17 = v3;
          goto LABEL_30;
        }
      }
      else
      {
        if ( v6 == 41 )
          goto LABEL_29;
        v7 = v6 - 10;
        if ( !v7 )
          goto LABEL_30;
        v8 = v7 - 25;
        if ( !v8 )
          goto LABEL_30;
        v9 = v8 - 1;
        if ( !v9 || v9 == 4 )
          goto LABEL_29;
      }
    }
    if ( v5 > 0x29u )
    {
      switch ( v5 )
      {
        case 0x3Au:
          v10 = 4;
          goto LABEL_57;
        case 0x3Bu:
          v10 = 3;
          goto LABEL_57;
        case 0x3Du:
          v10 = 2;
          goto LABEL_57;
        case 0x5Cu:
          v10 = 13;
          goto LABEL_57;
        case 0x7Bu:
          v10 = 11;
          goto LABEL_57;
        case 0x7Du:
          v10 = 12;
          goto LABEL_57;
        case 0xFFFFu:
LABEL_50:
          v10 = 6;
          goto LABEL_57;
      }
LABEL_44:
      if ( byte_4216B4 >= 0 )
      {
        v10 = sub_403702(v5) ? 0xA : 0;
        goto LABEL_57;
      }
      if ( sub_403702(v5) || v5 == 42 || v5 == 64 )
      {
        v10 = 10;
        goto LABEL_57;
      }
LABEL_30:
      v10 = 0;
      goto LABEL_57;
    }
    switch ( v5 )
    {
      case 0x29u:
        v10 = 9;
        break;
      case 9u:
        goto LABEL_35;
      case 0xAu:
        goto LABEL_50;
      case 0x20u:
LABEL_35:
        v10 = v18 != 0 ? 0 : 5;
        break;
      case 0x22u:
        v10 = 14;
        if ( v4 == 18 )
          v18 = 1;
        break;
      case 0x23u:
        v10 = 1;
        break;
      case 0x24u:
        v10 = 7;
        break;
      case 0x28u:
        v10 = 8;
        break;
      default:
        goto LABEL_44;
    }
LABEL_57:
    v4 = byte_401280[15 * v4 + v10];
    if ( v18 && v4 == 1 )
      v4 = 16;
    if ( v2 )
    {
      if ( v10 == 6 )
      {
        ++dword_4216A4;
        byte_411021 = 1;
        v5 = sub_407E9D();
        byte_411021 = 0;
        if ( v5 == 32 || v5 == 9 )
        {
          v4 = 64;
          do
          {
            do
              v5 = sub_407E9D();
            while ( v5 == 32 );
          }
          while ( v5 == 9 );
          v3 = v17;
        }
        else
        {
          v4 = v3 != &word_4216C2;
        }
      }
      else
      {
        *v3++ = 92;
        v17 = v3;
      }
    }
    v2 = 0;
    if ( (unsigned int)v3 >= a2 )
      sub_4053F6(dword_4216A4, 0x434u);
    if ( v4 == 64 )
      break;
    if ( (v4 & 0x20) != 0 )
      sub_4053F6(dword_4216A4, (v4 & 0xDF) + 1000, v5);
    if ( v4 == 15 )
    {
      v2 = 1;
    }
    else
    {
      *v3++ = v5;
      v17 = v3;
    }
  }
  ungetwc(v5, Stream);
  *v3 = 0;
  return sub_40C4B7(a1);
}
// 411021: using guessed type char byte_411021;
// 4216A4: using guessed type int dword_4216A4;
// 4216B4: using guessed type char byte_4216B4;

//----- (0040A618) --------------------------------------------------------
unsigned __int8 __thiscall sub_40A618(wchar_t *String)
{
  unsigned __int16 *v1; // edi
  wchar_t *v2; // eax
  unsigned __int16 *v3; // esi
  wchar_t v4; // cx
  _WORD *v5; // ebx
  wchar_t v6; // ax
  wchar_t *i; // ebx
  unsigned __int16 *v8; // eax
  __int16 v9; // cx
  int v10; // eax
  wchar_t *v11; // edi
  wchar_t *v12; // esi
  int v13; // eax
  char *v14; // ecx
  wchar_t *v15; // edi
  wchar_t *v16; // ebx
  int v17; // edx
  int v18; // eax
  wchar_t **v19; // ecx
  wchar_t *v20; // ecx
  wchar_t *v21; // eax
  wchar_t *v22; // ecx
  wchar_t *v23; // edx
  int v25; // ecx
  wchar_t *v26; // edx
  int v27; // ecx
  rsize_t v29; // esi
  wchar_t *v30; // esi
  int v31; // edx
  int v32; // esi
  const wchar_t **v33; // ebx
  int v34; // ecx
  bool v35; // zf
  wint_t v36; // ax
  rsize_t v38; // [esp-8h] [ebp-288h]
  wchar_t *v39; // [esp-4h] [ebp-284h]
  int v40; // [esp+14h] [ebp-26Ch] BYREF
  wchar_t *Destination; // [esp+18h] [ebp-268h]
  wchar_t *(__cdecl *v42)(const wchar_t *, const wchar_t *); // [esp+1Ch] [ebp-264h]
  int v43; // [esp+20h] [ebp-260h]
  wchar_t *Source; // [esp+24h] [ebp-25Ch]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+28h] [ebp-258h] BYREF

  v1 = String;
  if ( !*String || *String == 35 )
  {
    sub_4053F6(dword_4216A4, 0x407u);
    return (unsigned __int8)sub_40AABF(v39);
  }
  else
  {
    v42 = wcspbrk;
    v2 = wcspbrk(String, L"\t#");
    v3 = v2;
    v43 = 32;
    Source = (wchar_t *)9;
    if ( !v2 )
      goto LABEL_26;
    v4 = *v2;
    *v2 = 0;
    if ( v4 != 35 )
    {
      v5 = v2 + 1;
      v6 = v2[1];
      if ( v6 )
      {
        do
        {
          if ( v6 == 35 )
            break;
          if ( v6 != (_WORD)v43 && v6 != (_WORD)Source )
            sub_4053F6(dword_4216A4, 0x409u, v5);
          v6 = *++v5;
        }
        while ( *v5 );
      }
    }
    for ( i = 0; ; i = 0 )
    {
      if ( v3 > v1 )
      {
        do
        {
          v8 = v3 - 1;
          v9 = *(v3 - 1);
          if ( v9 != (_WORD)v43 && v9 != (_WORD)Source )
            break;
          --v3;
        }
        while ( v8 > v1 );
      }
      *v3 = 0;
      v10 = *v1;
      if ( v10 != 60 )
        break;
      if ( *(v3 - 1) != 62 )
        goto LABEL_33;
      v11 = v1 + 1;
      *(v3 - 1) = 0;
      v12 = sub_40EC1B(v11);
      if ( v12 == v11 )
        v12 = (wchar_t *)sub_40E267((char *)v11);
      v13 = sub_40AB97(L"INCLUDE");
      if ( v13 )
      {
        v14 = *(char **)(*(_DWORD *)(v13 + 8) + 4);
        if ( v14 )
        {
          v15 = (wchar_t *)sub_40E267(v14);
          i = sub_40EC1B(v15);
          if ( i != v15 )
            free(v15);
        }
      }
      v1 = (unsigned __int16 *)sub_407BA9(i, v12, &FindFileData, (HANDLE *)&v40);
      if ( v1 )
      {
        if ( i )
          free(i);
        free(v12);
        goto LABEL_55;
      }
      sub_4053F6(dword_4216A4, 0x41Cu, v12);
LABEL_26:
      v3 = &v1[wcslen(v1)];
    }
    if ( (_WORD)v10 == 34 && *(v3 - 1) == 34 )
    {
      ++v1;
      *(v3 - 1) = 0;
    }
LABEL_33:
    v16 = sub_40EC1B(v1);
    if ( v16 == v1 )
      v16 = (wchar_t *)sub_40E267((char *)v1);
    if ( !sub_4079FA(v16, &FindFileData, (HANDLE *)&v40) )
    {
      if ( (int)v42(v16, L"\\/:") )
      {
        sub_4053F6(dword_4216A4, 0x41Cu, v16);
      }
      else
      {
        v17 = dword_432324;
        v18 = dword_432324;
        v43 = dword_432324;
        if ( dword_432324 >= 0 )
        {
          v19 = (wchar_t **)&dword_432334[3 * dword_432324];
          v42 = (wchar_t *(__cdecl *)(const wchar_t *, const wchar_t *))v19;
          while ( 1 )
          {
            if ( v18 == v17 )
              v20 = (wchar_t *)ArgList;
            else
              v20 = *v19;
            v21 = sub_40AABF(v20);
            Source = v21;
            if ( v21 )
            {
              v22 = v21;
              v23 = v21 + 1;
              while ( *v22++ )
                ;
              v25 = (char *)v22 - (char *)v23;
              v26 = v16;
              v27 = v25 >> 1;
              while ( *v26++ )
                ;
              v29 = v26 - (v16 + 1) + v27 + 2;
              Destination = (wchar_t *)sub_40AC3C((unsigned __int64)v29 >> 31 != 0 ? -1 : 2 * v29);
              wcscpy_s(Destination, v29, Source);
              wcscat_s(Destination, v29, L"\\");
              v38 = v29;
              v30 = Destination;
              wcscat_s(Destination, v38, v16);
              if ( sub_4079FA(v30, &FindFileData, (HANDLE *)&v40) )
              {
                v1 = v30;
                free(Source);
                break;
              }
              free(Source);
              free(v30);
            }
            v18 = v43 - 1;
            v19 = (wchar_t **)((char *)v42 - 12);
            v43 = v18;
            v42 = (wchar_t *(__cdecl *)(const wchar_t *, const wchar_t *))((char *)v42 - 12);
            if ( v18 < 0 )
              break;
            v17 = dword_432324;
          }
        }
        free(v16);
        if ( v43 < 0 )
          sub_4053F6(dword_4216A4, 0x41Cu, v1);
      }
    }
LABEL_55:
    v31 = dword_432324;
    v32 = 0;
    if ( dword_432324 > 0 )
    {
      v33 = (const wchar_t **)dword_432334;
      do
      {
        if ( !wcsicmp(v1, *v33) )
          sub_4053F6(dword_4216A4, 0x430u, v1);
        v31 = dword_432324;
        ++v32;
        v33 += 3;
      }
      while ( v32 < dword_432324 );
    }
    v34 = 3 * v31;
    v35 = byte_421EE3 == 0;
    dword_432324 = v31 + 1;
    dword_4216B0 = 0;
    dword_432338[v34] = (int)Stream;
    dword_432330[v34] = dword_4216A4;
    dword_432334[v34] = (int)ArgList;
    if ( !v35 )
      sub_40C7C7((wchar_t *)L"Included: %s\n", v1);
    Stream = sub_40FFC6(v1, (wchar_t *)L"rt,ccs=unicode");
    if ( !Stream )
      sub_4053F6(dword_4216A4, 0x41Cu, v1);
    ArgList = sub_40E267((char *)v1);
    dword_4216A4 = 1;
    byte_411021 = 1;
    v36 = sub_407E9D();
    if ( v36 == 32 || v36 == 9 )
    {
      byte_411021 = 0;
      return 18;
    }
    else
    {
      byte_411021 = 1;
      ungetwc(v36, Stream);
      --dword_4216A4;
      return 17;
    }
  }
}
// 40AABE: variable 'v39' is possibly undefined
// 40195C: using guessed type wchar_t asc_40195C[4];
// 411021: using guessed type char byte_411021;
// 4216A4: using guessed type int dword_4216A4;
// 4216B0: using guessed type int dword_4216B0;
// 421EE3: using guessed type char byte_421EE3;
// 432324: using guessed type int dword_432324;
// 432330: using guessed type int dword_432330[];
// 432334: using guessed type int dword_432334[];
// 432338: using guessed type int dword_432338[];

//----- (0040AABF) --------------------------------------------------------
wchar_t *__thiscall sub_40AABF(wchar_t *FullPath)
{
  size_t v1; // esi
  wchar_t *v2; // edi
  unsigned int v3; // ecx
  wchar_t v4; // ax
  wchar_t Dir[258]; // [esp+10h] [ebp-210h] BYREF
  wchar_t Drive[4]; // [esp+214h] [ebp-Ch] BYREF

  wsplitpath_s(FullPath, Drive, 3u, Dir, 0x100u, 0, 0, 0, 0);
  v1 = wcslen(Dir) + wcslen(Drive) + 1;
  v2 = (wchar_t *)sub_40AC3C((unsigned __int64)v1 >> 31 != 0 ? -1 : 2 * v1);
  wmakepath_s(v2, v1, Drive, Dir, 0, 0);
  v3 = wcslen(v2);
  v4 = v2[v3 - 1];
  if ( v4 == 92 || v4 == 47 )
    v2[v3 - 1] = 0;
  return v2;
}

//----- (0040AB97) --------------------------------------------------------
int __thiscall sub_40AB97(const unsigned __int16 *this)
{
  const unsigned __int16 *v2; // edx
  unsigned __int16 v3; // ax
  unsigned __int8 v4; // cl
  unsigned __int16 v5; // di
  int ***v6; // eax
  int **v7; // ecx
  int v8; // eax

  v2 = this;
  v3 = *this;
  if ( *this )
  {
    v4 = 0;
    LOBYTE(v5) = v3;
    do
    {
      ++v2;
      v4 += v5;
      v5 = *v2;
    }
    while ( *v2 );
    v6 = (int ***)((char *)&unk_431F10 + 4 * v4);
    v7 = *v6;
    dword_435628 = (int)v6;
    while ( v7 )
    {
      v8 = wcscmp((const unsigned __int16 *)v7[1], this);
      if ( v8 )
        v8 = v8 < 0 ? -1 : 1;
      if ( !v8 )
        return ((_BYTE)v7[3] & 0x10) == 0 ? (unsigned int)v7 : 0;
      v7 = (int **)*v7;
    }
  }
  else
  {
    dword_435628 = (int)&unk_431F10;
  }
  return 0;
}
// 435628: using guessed type int dword_435628;

//----- (0040AC2B) --------------------------------------------------------
int sub_40AC2B()
{
  int result; // eax

  result = 0;
  memset(&unk_431F10, 0, 0x400u);
  return result;
}

//----- (0040AC3C) --------------------------------------------------------
void *__thiscall sub_40AC3C(size_t Size)
{
  void *v1; // esi

  v1 = malloc(Size);
  if ( !v1 )
    sub_4053F6(dword_4216B0, 0x41Bu);
  return v1;
}
// 4216B0: using guessed type int dword_4216B0;

//----- (0040AC61) --------------------------------------------------------
void *__thiscall sub_40AC61(size_t Size)
{
  void *v2; // edi

  v2 = sub_40AC3C(Size);
  memset(v2, 0, Size);
  return v2;
}

//----- (0040AC7F) --------------------------------------------------------
void *__fastcall sub_40AC7F(void *Block, size_t Size)
{
  void *v2; // esi

  if ( !Block )
    return sub_40AC3C(Size);
  v2 = realloc(Block, Size);
  if ( !v2 )
    sub_4053F6(dword_4216B0, 0x41Bu);
  return v2;
}
// 4216B0: using guessed type int dword_4216B0;

//----- (0040ACB5) --------------------------------------------------------
int __fastcall sub_40ACB5(wchar_t *Source, wchar_t *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // esi
  DWORD EnvironmentVariableW; // eax
  HMODULE ModuleHandleW; // eax
  BOOL (__stdcall *SetThreadPreferredUILanguages)(DWORD, PCZZWSTR, PULONG); // esi
  HMODULE v12; // eax
  BOOL (__stdcall *GetThreadPreferredUILanguages)(DWORD, PULONG, PZZWSTR, PULONG); // esi
  HANDLE ProcessHeap; // eax
  WCHAR *v15; // eax
  wchar_t **v16; // edi
  int result; // eax
  wchar_t **v18; // esi
  int v19; // ebx
  HANDLE v20; // eax
  LANGID UserDefaultUILanguage; // ax
  int v22; // ebx
  HANDLE FirstFileW; // edi
  unsigned int v24; // kr04_4
  int v25; // eax
  int v26; // eax
  HMODULE Library; // ecx
  SIZE_T v28; // [esp-4h] [ebp-6E4h]
  int v29; // [esp+10h] [ebp-6D0h] BYREF
  char ArgList[4]; // [esp+14h] [ebp-6CCh] BYREF
  int v31; // [esp+18h] [ebp-6C8h] BYREF
  wchar_t *v32; // [esp+1Ch] [ebp-6C4h] BYREF
  int v33; // [esp+20h] [ebp-6C0h] BYREF
  wchar_t *Sourcea; // [esp+24h] [ebp-6BCh] BYREF
  DWORD dwFlags; // [esp+28h] [ebp-6B8h] BYREF
  HMODULE *v36; // [esp+2Ch] [ebp-6B4h] BYREF
  __int16 *v37; // [esp+30h] [ebp-6B0h] BYREF
  rsize_t SizeInWords; // [esp+34h] [ebp-6ACh] BYREF
  char v39[4]; // [esp+38h] [ebp-6A8h] BYREF
  int v40[7]; // [esp+3Ch] [ebp-6A4h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+58h] [ebp-688h] BYREF
  __int16 v42[4]; // [esp+2A8h] [ebp-438h]
  wchar_t *Buffer[3]; // [esp+2B0h] [ebp-430h] BYREF
  wchar_t String[6]; // [esp+2BCh] [ebp-424h] BYREF
  wchar_t FileName[260]; // [esp+2C8h] [ebp-418h] BYREF
  wchar_t Destination[262]; // [esp+4D0h] [ebp-210h] BYREF

  v8 = 0;
  Sourcea = a2;
  v37 = &word_435E68;
  SizeInWords = 0;
  v32 = 0;
  v36 = &hModule;
  dwFlags = 96;
  if ( !Source || !*Source || !a2 || !*a2 )
    return -2147024809;
  hModule = 0;
  if ( wcsncpy_s(Destination, 0x104u, Source, 0xFFFFFFFF)
    || FileName[wcslen(Destination) + 259] != 92 && wcsncat_s(Destination, 0x104u, L"\\", 0xFFFFFFFF) )
  {
    return -2147467259;
  }
  v29 = -2147024894;
  v40[0] = (int)Destination;
  v40[1] = (int)&Sourcea;
  v40[2] = (int)&dwFlags;
  v40[3] = (int)&v36;
  v40[4] = (int)&v37;
  v40[5] = (int)&v32;
  v40[6] = (int)&SizeInWords;
  memset(Buffer, 0, sizeof(Buffer));
  EnvironmentVariableW = GetEnvironmentVariableW(L"VSLANG", (LPWSTR)Buffer, 6u);
  if ( EnvironmentVariableW )
  {
    if ( EnvironmentVariableW < 6 )
    {
      sub_40B29E((int)v40, Buffer, 10, (wchar_t ***)&v29);
      if ( !v29 )
        return 0;
    }
  }
  if ( Ptr )
  {
    SetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PCZZWSTR, PULONG))DecodePointer(Ptr);
  }
  else
  {
    ModuleHandleW = GetModuleHandleW(L"kernel32.dll");
    if ( !ModuleHandleW )
    {
LABEL_35:
      UserDefaultUILanguage = GetUserDefaultUILanguage();
      if ( (UserDefaultUILanguage & 0x3FF) == 1 || (UserDefaultUILanguage & 0x3FF) == 13 )
        UserDefaultUILanguage = 1033;
      v42[0] = UserDefaultUILanguage;
      v42[2] = 1033;
      v42[1] = UserDefaultUILanguage & 0x3FF | 0x400;
      while ( 1 )
      {
        itow_s((unsigned __int16)v42[v8], String, 6u, 10);
        sub_40B29E((int)v40, (wchar_t **)String, 10, (wchar_t ***)&v29);
        if ( !v29 )
          return 0;
        if ( (unsigned int)++v8 >= 3 )
          goto LABEL_41;
      }
    }
    SetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PCZZWSTR, PULONG))GetProcAddress(
                                                                                   ModuleHandleW,
                                                                                   "SetThreadPreferredUILanguages");
    Ptr = EncodePointer(SetThreadPreferredUILanguages);
  }
  if ( !SetThreadPreferredUILanguages )
  {
    v8 = 0;
    goto LABEL_35;
  }
  if ( !GetEnvironmentVariableW(L"VS_UNICODE_OUTPUT", 0, 0) && !SetThreadPreferredUILanguages(256, 0, 0) )
    return -2147467259;
  v31 = 0;
  v33 = 0;
  if ( dword_435640 )
  {
    GetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PULONG, PZZWSTR, PULONG))DecodePointer(dword_435640);
  }
  else
  {
    v12 = GetModuleHandleW(L"kernel32.dll");
    if ( !v12 )
      goto LABEL_41;
    GetThreadPreferredUILanguages = (BOOL (__stdcall *)(DWORD, PULONG, PZZWSTR, PULONG))GetProcAddress(
                                                                                          v12,
                                                                                          "GetThreadPreferredUILanguages");
    dword_435640 = EncodePointer(GetThreadPreferredUILanguages);
  }
  if ( GetThreadPreferredUILanguages )
  {
    if ( GetThreadPreferredUILanguages(52, (PULONG)&v33, 0, (PULONG)&v31) )
    {
      v28 = 2 * v31;
      ProcessHeap = GetProcessHeap();
      v15 = (WCHAR *)HeapAlloc(ProcessHeap, 0, v28);
      v16 = (wchar_t **)v15;
      if ( !v15 )
        return -2147024882;
      if ( GetThreadPreferredUILanguages(52, (PULONG)&v33, v15, (PULONG)&v31) )
      {
        v18 = v16;
        if ( *(_WORD *)v16 )
        {
          do
          {
            sub_40B29E((int)v40, v18, 16, (wchar_t ***)&v29);
            v19 = v29;
            if ( !v29 )
              break;
            v18 = (wchar_t **)((char *)v18 + 10);
          }
          while ( *(_WORD *)v18 );
        }
        else
        {
          v19 = v29;
        }
        v20 = GetProcessHeap();
        HeapFree(v20, 0, v16);
        if ( !v19 )
          return 0;
        goto LABEL_41;
      }
    }
    return -2147467259;
  }
LABEL_41:
  sub_40B29E((int)v40, (wchar_t **)L"1033", 10, (wchar_t ***)&v29);
  v22 = v29;
  if ( !v29 )
    return 0;
  if ( wcsncpy_s(FileName, 0x104u, Destination, 0xFFFFFFFF) || wcsncat_s(FileName, 0x104u, L"*", 0xFFFFFFFF) )
    return -2147024893;
  FirstFileW = FindFirstFileW(FileName, &FindFileData);
  if ( FirstFileW == (HANDLE)-1 )
  {
    result = GetLastError();
    if ( result > 0 )
      return (unsigned __int16)result | 0x80070000;
  }
  else
  {
    v24 = wcslen(Destination);
    while ( FindNextFileW(FirstFileW, &FindFileData) )
    {
      if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
      {
        v25 = wcscmp(FindFileData.cFileName, L".");
        if ( v25 )
          v25 = v25 < 0 ? -1 : 1;
        if ( v25 )
        {
          v26 = wcscmp(FindFileData.cFileName, L"..");
          if ( v26 )
            v26 = v26 < 0 ? -1 : 1;
          if ( v26 && sub_40C634(FindFileData.cFileName, (wchar_t *)L"%hu%c", ArgList, v39, 1) != -1 )
          {
            if ( 2 * v24 >= 0x208 )
              __report_rangecheckfailure();
            FileName[v24] = 0;
            if ( !wcsncat_s(FileName, 0x104u, FindFileData.cFileName, 0xFFFFFFFF)
              && !wcsncat_s(FileName, 0x104u, L"\\", 0xFFFFFFFF)
              && !wcsncat_s(FileName, 0x104u, Sourcea, 0xFFFFFFFF) )
            {
              Library = LoadLibraryExW(FileName, 0, dwFlags);
              if ( Library )
              {
                *v36 = Library;
                if ( v37 )
                  *v37 = *(_WORD *)ArgList;
                if ( v32 )
                  wcscpy_s(v32, SizeInWords, FileName);
                v22 = 0;
                break;
              }
            }
          }
        }
      }
    }
    FindClose(FirstFileW);
    return v22;
  }
  return result;
}
// 401A24: using guessed type wchar_t asc_401A24[3];
// 410495: using guessed type void __noreturn __report_rangecheckfailure(void);
// 435E68: using guessed type __int16 word_435E68;
// 40ACB5: using guessed type char var_6A8[4];

//----- (0040B29E) --------------------------------------------------------
wchar_t **__thiscall sub_40B29E(int this, wchar_t **String, int Radix, wchar_t ***a4)
{
  wchar_t **result; // eax
  _WORD *v6; // eax
  __int16 v7; // [esp+Ch] [ebp-220h]
  wchar_t *EndPtr; // [esp+10h] [ebp-21Ch] BYREF
  wchar_t Destination[260]; // [esp+14h] [ebp-218h] BYREF
  wchar_t Buffer[6]; // [esp+21Ch] [ebp-10h] BYREF

  result = String;
  if ( *(_WORD *)String )
  {
    result = (wchar_t **)wcstoul((const wchar_t *)String, &EndPtr, Radix);
    v7 = (__int16)result;
    if ( !*EndPtr )
    {
      itow_s((unsigned __int16)result, Buffer, 6u, 10);
      result = (wchar_t **)wcsncpy_s(Destination, 0x104u, *(const wchar_t **)this, 0xFFFFFFFF);
      if ( !result )
      {
        result = (wchar_t **)wcsncat_s(Destination, 0x104u, Buffer, 0xFFFFFFFF);
        if ( !result )
        {
          result = (wchar_t **)wcsncat_s(Destination, 0x104u, L"\\", 0xFFFFFFFF);
          if ( !result )
          {
            result = (wchar_t **)wcsncat_s(Destination, 0x104u, **(const wchar_t ***)(this + 4), 0xFFFFFFFF);
            if ( !result )
            {
              result = (wchar_t **)LoadLibraryExW(Destination, 0, **(_DWORD **)(this + 8));
              if ( result )
              {
                ***(_DWORD ***)(this + 12) = result;
                v6 = **(_WORD ***)(this + 16);
                if ( v6 )
                  *v6 = v7;
                result = *(wchar_t ***)(this + 20);
                if ( *result )
                  result = (wchar_t **)wcscpy_s(*result, **(_DWORD **)(this + 24), Destination);
                *a4 = 0;
              }
              else if ( *a4 == (wchar_t **)-2147024894 )
              {
                result = (wchar_t **)GetLastError();
                if ( (int)result > 0 )
                  result = (wchar_t **)((unsigned __int16)result | 0x80070000);
                *a4 = result;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (0040B409) --------------------------------------------------------
void __thiscall sub_40B409(void *this)
{
  dword_411068 = (int)this;
}
// 411068: using guessed type int dword_411068;

//----- (0040B410) --------------------------------------------------------
BOOL __fastcall sub_40B410(const void **a1, void *a2, void *a3)
{
  int v5; // ecx

  if ( !byte_421EE0 )
    sub_40556C();
  sub_40C7C7((wchar_t *)L"\nNMAKE : fatal error U1038: Internal error\n");
  sub_40C7A9();
  qmemcpy(a2, *a1, 0x50u);
  if ( a3 )
    qmemcpy(a3, a1[1], 0x2CCu);
  v5 = 0;
  if ( *(_DWORD *)*a1 != -2147483645 )
    return dword_411068 == 0;
  return v5;
}
// 411068: using guessed type int dword_411068;
// 421EE0: using guessed type char byte_421EE0;

//----- (0040B47B) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl main(int argc, const char **argv, const char **envp)
{
  const char **v3; // edi
  int v4; // esi
  int v5; // ebx
  const char *v6; // ecx
  int v7; // eax
  const char **v8; // edi
  int v9; // ecx
  const void *v10; // eax
  wchar_t *v11; // esi
  wchar_t *v12; // ebx
  rsize_t v14; // ebx
  wchar_t *v15; // edi
  int v16; // esi
  int v18; // [esp-10h] [ebp-584h]
  int v19; // [esp-10h] [ebp-584h]
  int v20[179]; // [esp+10h] [ebp-564h] BYREF
  int v21; // [esp+2F8h] [ebp-27Ch]
  const char **v22; // [esp+2FCh] [ebp-278h]
  char ArgList[80]; // [esp+300h] [ebp-274h] BYREF
  CPPEH_RECORD ms_exc; // [esp+55Ch] [ebp-18h]

  v3 = argv;
  v22 = argv;
  SetErrorMode(1u);
  memset(ArgList, 0, sizeof(ArgList));
  memset(v20, 0, sizeof(v20));
  ms_exc.registration.TryLevel = 0;
  setlocale(2, ".ACP");
  sub_40C69E();
  set_invalid_parameter_handler(Handler);
  v4 = 1;
  v5 = argc;
  while ( 1 )
  {
    v21 = v4;
    if ( v4 >= v5 )
    {
      if ( byte_4323FB )
        MEMORY[0] = 0;
      sub_40AC2B();
      if ( !dword_421EE8 )
      {
        v11 = *_p__wpgmptr();
        if ( sub_403727(v11, 0x20u) )
        {
          v12 = v11;
          while ( *v12++ )
            ;
          v14 = v12 - (v11 + 1) + 3;
          v15 = (wchar_t *)sub_4036FA((void *)((unsigned __int64)v14 >> 31 != 0 ? -1 : 2 * v14));
          wcscpy_s(v15, v14, L"\"");
          wcscat_s(v15, v14, v11);
          wcscat_s(v15, v14, L"\"");
          v11 = v15;
          v5 = argc;
          v3 = v22;
        }
        dword_421EE8 = (wchar_t *)sub_40E267((char *)v11);
      }
      signal(2, (_crt_signal_t)Function);
      signal(15, (_crt_signal_t)Function);
      v16 = sub_40B9E8(v5, (int)v3, v19);
      sub_40C479();
      if ( !byte_411020 )
        v16 = 1;
      exit(v16);
    }
    v6 = v3[v4];
    v7 = *(unsigned __int16 *)v6;
    if ( v7 == 45 || v7 == 47 )
    {
      v8 = &v3[v4];
      if ( !wcsicmp((const wchar_t *)v6 + 1, L"errorreport:none") )
      {
        v9 = 0;
        goto LABEL_7;
      }
      if ( !wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:prompt") )
      {
        v9 = 1;
        goto LABEL_7;
      }
      if ( !wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:queue") )
      {
        v18 = 2;
        goto LABEL_14;
      }
      if ( !wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:send") )
      {
        v18 = 3;
LABEL_14:
        v9 = v18;
LABEL_7:
        sub_40B409((void *)v9);
        memmove(v8, v8 + 1, 4 * (v5 - v4) - 4);
        argc = --v5;
        v21 = --v4;
LABEL_8:
        v3 = v22;
        goto LABEL_9;
      }
      if ( wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:test") )
      {
        if ( wcsicmp((const wchar_t *)*v8 + 1, L"errorreport:internal") )
          goto LABEL_8;
        byte_4323FA = 1;
        v3 = v22;
        memmove(&v22[v4], &v22[v4 + 1], 4 * (v5 - v4) - 4);
      }
      else
      {
        byte_4323FB = 1;
        v10 = v8 + 1;
        v3 = v22;
        memmove(&v22[v4], v10, 4 * (v5 - v4) - 4);
      }
      argc = --v5;
      v21 = --v4;
    }
LABEL_9:
    ++v4;
  }
}
// 40B884: positive sp value C has been found
// 40B6FB: variable 'v19' is possibly undefined
// 411020: using guessed type char byte_411020;
// 4323FA: using guessed type char byte_4323FA;
// 4323FB: using guessed type char byte_4323FB;

//----- (0040B886) --------------------------------------------------------
char *sub_40B886()
{
  wchar_t *v0; // esi
  wchar_t *v1; // eax
  int v2; // edi
  wchar_t *v3; // esi
  wchar_t *v4; // eax
  wchar_t *v5; // esi
  wchar_t *v6; // eax
  wchar_t *v7; // esi
  wchar_t *v8; // eax
  wchar_t *v9; // esi
  wchar_t *v10; // eax
  wchar_t *v11; // esi
  wchar_t *v12; // eax
  wchar_t *v13; // esi
  wchar_t *v14; // eax
  char *result; // eax
  int v16; // esi
  wchar_t *v17; // eax
  const wchar_t **v18; // esi
  const wchar_t **i; // esi

  v0 = (wchar_t *)sub_40E267((char *)L"CC");
  v1 = (wchar_t *)sub_40E267((char *)L"cl");
  v2 = 0;
  sub_403260(v0, v1, 0);
  v3 = (wchar_t *)sub_40E267((char *)L"CXX");
  v4 = (wchar_t *)sub_40E267((char *)L"cl");
  sub_403260(v3, v4, 0);
  v5 = (wchar_t *)sub_40E267((char *)L"CPP");
  v6 = (wchar_t *)sub_40E267((char *)L"cl");
  sub_403260(v5, v6, 0);
  v7 = (wchar_t *)sub_40E267((char *)L"AS");
  v8 = (wchar_t *)sub_40E267((char *)L"ml");
  sub_403260(v7, v8, 0);
  v9 = (wchar_t *)sub_40E267((char *)L"RC");
  v10 = (wchar_t *)sub_40E267((char *)L"rc");
  sub_403260(v9, v10, 0);
  v11 = (wchar_t *)sub_40E267((char *)L"_NMAKE_VER");
  v12 = (wchar_t *)sub_40E267((char *)L"14.29.30146.0");
  sub_403260(v11, v12, 2);
  v13 = (wchar_t *)sub_40E267((char *)&off_4022D0);
  v14 = (wchar_t *)sub_40E267((char *)dword_421EE8);
  sub_403260(v13, v14, 76);
  result = (char *)L".SUFFIXES";
  if ( L".SUFFIXES" )
  {
    v16 = 0;
    do
    {
      v17 = (wchar_t *)sub_40E267(result);
      v18 = (const wchar_t **)off_401170[v16];
      Block = v17;
      wcscpy_s(&Src, 0x400u, *v18);
      sub_402B16();
      for ( i = v18 + 1; *i; ++i )
      {
        wcscpy_s(&Src, 0x400u, *i);
        sub_402937();
      }
      if ( !v2 )
        sub_402F02();
      sub_40301C();
      v16 = ++v2;
      result = (char *)*((_DWORD *)&off_401240 + v2);
    }
    while ( result );
  }
  return result;
}
// 401170: using guessed type wchar_t **off_401170[12];
// 401638: using guessed type wchar_t a1429301460[14];
// 401A38: using guessed type wchar_t aSuffixes_0[10];
// 402278: using guessed type wchar_t aCc[3];
// 402280: using guessed type wchar_t aCl[3];
// 402288: using guessed type wchar_t aCxx[4];
// 402290: using guessed type wchar_t aCpp[4];
// 402298: using guessed type wchar_t aAs[3];
// 4022A0: using guessed type wchar_t aMl[3];
// 4022A8: using guessed type wchar_t aRc[3];
// 4022B0: using guessed type wchar_t aRc_0[3];
// 4022B8: using guessed type wchar_t aNmakeVer[11];
// 4022D0: using guessed type void *off_4022D0;

//----- (0040B9E8) --------------------------------------------------------
int __fastcall sub_40B9E8(int a1, int a2, int a3)
{
  wchar_t *v3; // esi
  wchar_t *v4; // ebx
  wchar_t *v5; // edi
  wchar_t *v6; // esi
  wchar_t *v7; // eax
  int v8; // ecx
  void *v9; // ecx
  const wchar_t *v10; // eax
  int v11; // esi
  size_t RequiredCount; // [esp+18h] [ebp-8h] BYREF
  wchar_t *Buffer; // [esp+1Ch] [ebp-4h] BYREF

  Buffer = 0;
  v3 = (wchar_t *)sub_40E267((char *)&off_4022DC);
  v4 = wgetcwd(0, 0);
  sub_403260(v3, v4, 66);
  wdupenv_s(&Buffer, 0, aMa);
  v5 = Buffer;
  if ( Buffer )
    wcsncpy_s(&aMakeflags[10], wcslen(aMakeflags) - 9, Buffer, 0xFFFFFFFF);
  byte_41148D = 1;
  v6 = (wchar_t *)sub_40E267((char *)&aMakeflags[10]);
  v7 = (wchar_t *)sub_40E267((char *)aMa);
  sub_403260(v7, v6, 6);
  for ( ; v5; ++v5 )
  {
    if ( !*v5 )
      break;
    sub_40C1CD(*v5, 1);
  }
  free(Buffer);
  Buffer = 0;
  if ( !wgetenv_s(&RequiredCount, 0, 0, L"NTMAKEENV") && RequiredCount )
    byte_4323F9 = 1;
  sub_40BDF3(a1 - 1, a2 + 4);
  if ( !byte_421EE0 )
    sub_40556C();
  if ( (byte_41148C & 2) == 0 )
  {
    sub_40B886();
    ArgList = (void *)L"tools.ini";
    if ( sub_408971(v8) )
    {
      ++dword_4216A4;
      byte_421EE1 = 1;
      sub_40C852(v9);
      if ( fclose(Stream) == -1 )
        sub_4053F6(0, 0x424u, ArgList);
    }
  }
  v10 = (const wchar_t *)sub_40E267((char *)&aMakeflags[10]);
  if ( wputenv_s(aMa, v10) )
    sub_4053F6(0, 0x41Fu);
  if ( !dword_4323F0 )
    sub_40C0FD();
  sub_40BD27();
  sub_40BBDD();
  dword_4216B0 = 0;
  sub_40DE73();
  if ( (byte_41148C & 1) != 0 )
  {
    sub_40CD28();
    sub_40CD99();
    sub_40CE39();
  }
  if ( dword_431EFC )
    free(dword_431EFC);
  v11 = sub_403732();
  wchdir(v4);
  return v11;
}
// 40BB14: variable 'v8' is possibly undefined
// 40BB2A: variable 'v9' is possibly undefined
// 4022DC: using guessed type void *off_4022DC;
// 41102C: using guessed type wchar_t aMakeflags[29];
// 41148C: using guessed type char byte_41148C;
// 41148D: using guessed type char byte_41148D;
// 4216A4: using guessed type int dword_4216A4;
// 4216B0: using guessed type int dword_4216B0;
// 421EE0: using guessed type char byte_421EE0;
// 421EE1: using guessed type char byte_421EE1;
// 4323F0: using guessed type int dword_4323F0;
// 4323F9: using guessed type char byte_4323F9;

//----- (0040BBDD) --------------------------------------------------------
int sub_40BBDD()
{
  _DWORD *v0; // esi
  int v1; // ecx
  FILE *v2; // eax
  void *v3; // ecx
  FILE *v4; // eax
  int v5; // eax
  void *osfhandle; // eax
  void *v8; // [esp-4h] [ebp-14h]
  void *v9; // [esp-4h] [ebp-14h]
  LARGE_INTEGER FileSize; // [esp+8h] [ebp-8h] BYREF

  v0 = (_DWORD *)dword_4323F0;
  if ( dword_4323F0 )
  {
    do
    {
      v1 = v0[1];
      if ( *(_WORD *)v1 != 45 || *(_WORD *)(v1 + 2) )
      {
        ArgList = sub_40E267((char *)v1);
        v4 = wfsopen((const wchar_t *)ArgList, L"rt,ccs=unicode", 32);
        Stream = v4;
        if ( !v4 )
        {
          sub_4053F6(0, 0x41Cu, ArgList);
          v4 = Stream;
        }
        FileSize.QuadPart = 0i64;
        v5 = fileno(v4);
        osfhandle = (void *)get_osfhandle(v5);
        v3 = v9;
        if ( osfhandle != (void *)-1 )
        {
          if ( GetFileSizeEx(osfhandle, &FileSize) )
          {
            v3 = (void *)(FileSize.LowPart + 1);
            if ( (unsigned __int64)(FileSize.QuadPart - 1) <= 0x7FFFFFFD )
              setvbuf(Stream, 0, 0, FileSize.LowPart + 1);
          }
        }
      }
      else
      {
        ArgList = sub_40E267((char *)L"STDIN");
        v2 = _acrt_iob_func(0);
        v3 = v8;
        Stream = v2;
      }
      dword_4216A4 = 0;
      byte_421EE1 = 0;
      sub_40C852(v3);
      if ( Stream != _acrt_iob_func(0) && fclose(Stream) == -1 )
        sub_4053F6(0, 0x424u, ArgList);
      v0 = (_DWORD *)*v0;
    }
    while ( v0 );
    v0 = (_DWORD *)dword_4323F0;
  }
  return sub_404BE9(v0);
}
// 40BC1C: variable 'v8' is possibly undefined
// 40BC7B: variable 'v9' is possibly undefined
// 40BCD2: variable 'v3' is possibly undefined
// 402340: using guessed type wchar_t aStdin[6];
// 4216A4: using guessed type int dword_4216A4;
// 421EE1: using guessed type char byte_421EE1;
// 4323F0: using guessed type int dword_4323F0;

//----- (0040BD27) --------------------------------------------------------
char *sub_40BD27()
{
  char ***v0; // eax
  char **v1; // esi
  char *result; // eax
  wchar_t *v3; // edi
  wchar_t *v4; // eax
  wchar_t *v5; // ebx
  _WORD *v6; // edx
  wchar_t *v8; // eax
  wchar_t *Block; // [esp+4h] [ebp-8h]

  v0 = (char ***)_p__wenviron();
  v1 = *v0;
  result = **v0;
  if ( result )
  {
    do
    {
      v3 = wcschr((const wchar_t *)result, 0x3Du);
      if ( v3 )
      {
        if ( wcsnicmp((const wchar_t *)*v1, aMa, 8u) )
        {
          *v3 = 0;
          if ( *(_WORD *)*v1 )
          {
            v4 = (wchar_t *)sub_40E267(*v1);
            v5 = v4;
            v6 = v4 + 1;
            while ( *v4++ )
              ;
            wcsupr_s(v5, v4 - v6 + 1);
            v8 = (wchar_t *)sub_40E267((char *)v3 + 2);
            *v3 = 61;
            Block = v8;
            byte_41148D = 0;
            if ( !sub_403260(v5, v8, 4) )
            {
              free(v5);
              free(Block);
            }
          }
        }
      }
      result = *++v1;
    }
    while ( *v1 );
  }
  return result;
}
// 41148D: using guessed type char byte_41148D;

//----- (0040BDF3) --------------------------------------------------------
void __fastcall sub_40BDF3(unsigned int a1, int a2)
{
  int v2; // edi
  int (__cdecl *v3)(const wchar_t *, const wchar_t *); // ecx
  wchar_t *(__cdecl *v4)(const wchar_t *, wchar_t); // esi
  wchar_t *v5; // ebx
  int v6; // eax
  wchar_t *v7; // eax
  wchar_t *v8; // esi
  wchar_t *v9; // eax
  _WORD *v10; // esi
  int v11; // ecx
  int v12; // eax
  wchar_t *v13; // esi
  int v14; // eax
  wchar_t *v15; // eax
  _DWORD *v16; // esi
  void *v17; // eax
  const wchar_t *v18; // esi
  int v19; // ecx
  const wchar_t *v20; // esi
  wchar_t v21; // cx
  FILE *v22; // eax
  char *v23; // ebx
  _DWORD *v24; // esi
  char v25; // cl
  char v26; // [esp+1Bh] [ebp-25h]
  int v27; // [esp+1Ch] [ebp-24h]
  FILE *Stream; // [esp+30h] [ebp-10h] BYREF
  FILE *(__cdecl *v30)(unsigned int); // [esp+34h] [ebp-Ch]
  errno_t (__cdecl *v31)(FILE **, const wchar_t *, const wchar_t *); // [esp+38h] [ebp-8h]
  int (__cdecl *v32)(FILE *); // [esp+3Ch] [ebp-4h]

  v27 = a2;
  v26 = 0;
  v2 = 0;
  if ( !a1 )
    return;
  v3 = wcsicmp;
  v4 = wcschr;
  v30 = _acrt_iob_func;
  v31 = wfopen_s;
  v32 = fclose;
  while ( 1 )
  {
    v5 = *(wchar_t **)(a2 + 4 * v2);
    v6 = *v5;
    if ( v6 == 64 )
    {
      sub_40525E(v5 + 1);
    }
    else
    {
      if ( (_WORD)v6 != 45 && v6 != 47 )
      {
        v7 = v4(v5, 0x3Du);
        v8 = v7;
        if ( v7 )
        {
          if ( v7 == v5 )
            sub_4053F6(0, 0x427u);
          *v8 = 0;
          v9 = v8 - 1;
          v10 = v8 + 1;
          while ( 1 )
          {
            v11 = *v9;
            if ( (_WORD)v11 != 32 && v11 != 9 )
              break;
            --v9;
          }
          byte_41148D = 1;
          v9[1] = 0;
          v12 = ((int (__cdecl *)(_WORD *))wcsspn)(v10);
          v13 = (wchar_t *)sub_40E267((char *)&v10[v12]);
          v14 = ((int (__cdecl *)(wchar_t *))wcsspn)(v5);
          v15 = (wchar_t *)sub_40E267((char *)&v5[v14]);
          sub_403260(v15, v13, 2);
        }
        else
        {
          sub_40C4B7(v5);
          if ( *v5 )
          {
            v16 = sub_40E215();
            if ( (int)wcschr(v5, 32) )
              v17 = sub_40E2AB((char *)v5);
            else
              v17 = sub_40E267((char *)v5);
            v16[1] = v17;
            sub_40E36C((_DWORD **)&dword_421690, v16);
          }
        }
        a2 = v27;
        v4 = wcschr;
        *(_DWORD *)(v27 + 4 * v2) = 0;
        goto LABEL_51;
      }
      v18 = v5 + 1;
      if ( !v3(v5 + 1, L"help") )
        goto LABEL_54;
      if ( *v18 )
      {
        while ( 1 )
        {
          if ( !wcsicmp(v18, L"nologo") )
          {
            sub_40C1CD(v18[2], 1);
            goto LABEL_49;
          }
          v19 = *v18;
          if ( v19 == 63 )
          {
            a2 = v27;
            v25 = 1;
            v4 = wcschr;
            v26 = 1;
            goto LABEL_52;
          }
          if ( v19 == 102 || v19 == 70 )
            break;
          if ( v19 == 120 || v19 == 88 )
          {
            v20 = v18 + 1;
            v21 = *v20;
            if ( !*v20 )
            {
              if ( ++v2 >= a1 || (v20 = *(const wchar_t **)(v27 + 4 * v2), (v21 = *v20) == 0) )
              {
                sub_4053F6(0, 0x426u);
                v21 = *v20;
              }
            }
            if ( v21 != 45 || v20[1] )
            {
              if ( v31(&Stream, v20, L"wt") )
                sub_4053F6(0, 0x418u, v20);
              sub_40C722(Stream);
              v32(Stream);
            }
            else
            {
              v22 = v30(1u);
              sub_40C722(v22);
            }
            goto LABEL_49;
          }
          sub_40C1CD(v19, 1);
          if ( !*++v18 )
            goto LABEL_49;
        }
        v23 = (char *)(v18 + 1);
        if ( !v18[1] )
        {
          if ( ++v2 >= a1 || (v23 = *(char **)(v27 + 4 * v2), !*(_WORD *)v23) )
            sub_4053F6(0, 0x425u);
        }
        v24 = sub_40E215();
        v24[1] = sub_40E267(v23);
        sub_40E36C((_DWORD **)&dword_4323F0, v24);
      }
LABEL_49:
      v4 = wcschr;
    }
    a2 = v27;
LABEL_51:
    v25 = v26;
LABEL_52:
    if ( ++v2 >= a1 )
      break;
    v3 = wcsicmp;
  }
  if ( v25 )
  {
LABEL_54:
    sub_405598();
    exit(0);
  }
}
// 402358: using guessed type wchar_t aNologo[7];
// 402368: using guessed type wchar_t aWt[3];
// 41148D: using guessed type char byte_41148D;
// 421690: using guessed type int dword_421690;
// 4323F0: using guessed type int dword_4323F0;

//----- (0040C0FD) --------------------------------------------------------
void *sub_40C0FD()
{
  void *result; // eax
  _DWORD *v1; // esi
  wchar_t *v2; // esi
  wchar_t *v3; // eax
  int v4; // ecx
  struct _WIN32_FIND_DATAW FindFileData; // [esp+8h] [ebp-460h] BYREF
  wchar_t Destination[262]; // [esp+258h] [ebp-210h] BYREF

  result = (void *)waccess(L"makefile", 4);
  if ( result )
  {
    if ( dword_421690 )
    {
      v2 = *(wchar_t **)(dword_421690 + 4);
      result = (void *)waccess(v2, 4);
      if ( !result )
      {
        v3 = wcsrchr(v2, 0x2Eu);
        if ( !v3 || (result = sub_40DA04(Destination, 0x101u, v2, (int)v3, &FindFileData)) == 0 )
        {
          v4 = dword_421690;
          result = *(void **)dword_421690;
          dword_421690 = *(_DWORD *)dword_421690;
          dword_4323F0 = v4;
        }
      }
    }
    else if ( (byte_41148C & 1) == 0 )
    {
      return (void *)sub_4053F6(0, 0x428u);
    }
  }
  else
  {
    v1 = sub_40E215();
    result = sub_40E267((char *)L"makefile");
    v1[1] = result;
    dword_4323F0 = (int)v1;
  }
  return result;
}
// 41148C: using guessed type char byte_41148C;
// 421690: using guessed type int dword_421690;
// 4323F0: using guessed type int dword_4323F0;
// 40C0FD: using guessed type wchar_t Destination[262];

//----- (0040C1CD) --------------------------------------------------------
int __fastcall sub_40C1CD(wint_t C, char a2)
{
  char v2; // bl
  char *v3; // esi
  int v4; // edi
  int result; // eax
  int v6; // ecx
  char v7; // al
  wchar_t *v8; // eax
  wchar_t *v9; // eax
  wchar_t v10; // dx
  const wchar_t *v11; // eax

  v2 = 0;
  v3 = &byte_41148E;
  v4 = towupper(C);
  result = v4;
  if ( (unsigned __int16)v4 <= 0x4Cu )
  {
    if ( (unsigned __int16)v4 == 76 )
    {
      v2 = 0x80;
      goto LABEL_10;
    }
    if ( (unsigned __int16)v4 <= 0x44u )
    {
      if ( v4 == 68 )
      {
        v2 = 1;
        goto LABEL_32;
      }
      result = (unsigned __int16)v4 - 32;
      if ( (unsigned __int16)v4 == 32 )
        return result;
      result = (unsigned __int16)v4 - 65;
      if ( (unsigned __int16)v4 == 65 )
      {
        v2 = 16;
        goto LABEL_32;
      }
      result = (unsigned __int16)v4 - 66;
      if ( (unsigned __int16)v4 == 66 )
      {
        byte_4216B6 = 1;
        return result;
      }
      result = (unsigned __int16)v4 - 67;
      if ( (unsigned __int16)v4 == 67 )
      {
        v2 = 32;
LABEL_10:
        v3 = &byte_41148C;
        byte_421EE0 = 1;
        goto LABEL_32;
      }
      goto LABEL_42;
    }
    result = (unsigned __int16)v4 - 69;
    if ( (unsigned __int16)v4 != 69 )
    {
      result = (unsigned __int16)v4 - 71;
      if ( (unsigned __int16)v4 == 71 )
      {
        byte_421EE3 = 1;
        return result;
      }
      result = (unsigned __int16)v4 - 73;
      if ( (unsigned __int16)v4 == 73 )
      {
        v2 = 2;
        goto LABEL_32;
      }
      result = (unsigned __int16)v4 - 75;
      if ( (unsigned __int16)v4 == 75 )
      {
        byte_4216B7 = 1;
        return result;
      }
      goto LABEL_42;
    }
    v2 = 4;
LABEL_22:
    v3 = &byte_41148C;
    goto LABEL_32;
  }
  if ( (unsigned __int16)v4 <= 0x52u )
  {
    if ( v4 == 82 )
    {
      v2 = 2;
      goto LABEL_22;
    }
    result = (unsigned __int16)v4 - 78;
    if ( (unsigned __int16)v4 == 78 )
    {
      v2 = 4;
      goto LABEL_32;
    }
    result = (unsigned __int16)v4 - 79;
    if ( (unsigned __int16)v4 == 79 )
    {
      byte_4216B5 = 1;
      return result;
    }
    result = (unsigned __int16)v4 - 80;
    if ( (unsigned __int16)v4 == 80 )
    {
      v2 = 1;
      goto LABEL_22;
    }
    result = (unsigned __int16)v4 - 81;
    if ( (unsigned __int16)v4 == 81 )
    {
      v3 = &byte_41148C;
LABEL_31:
      v2 = 8;
      goto LABEL_32;
    }
LABEL_42:
    result = sub_4053F6(0, 0x429u, C);
    goto LABEL_32;
  }
  result = (unsigned __int16)v4 - 83;
  if ( (unsigned __int16)v4 == 83 )
    goto LABEL_31;
  result = (unsigned __int16)v4 - 84;
  if ( (unsigned __int16)v4 == 84 )
  {
    v2 = 16;
    goto LABEL_22;
  }
  result = (unsigned __int16)v4 - 85;
  if ( (unsigned __int16)v4 != 85 )
  {
    result = (unsigned __int16)v4 - 89;
    if ( (unsigned __int16)v4 == 89 )
    {
      v2 = 64;
      goto LABEL_22;
    }
    goto LABEL_42;
  }
  v2 = 64;
LABEL_32:
  if ( dword_43232C )
  {
    v6 = dword_432328;
  }
  else
  {
    result = sub_40AB97(aMa);
    dword_43232C = result;
    v6 = *(_DWORD *)(result + 8);
    dword_432328 = v6;
  }
  if ( a2 )
  {
    v7 = v2 | *v3;
    *v3 = v7;
    if ( v4 == 81 )
      *v3 = v7 | 0x20;
    if ( !wcschr(*(const wchar_t **)(v6 + 4), v4) )
    {
      v8 = wcschr(*(const wchar_t **)(dword_432328 + 4), 0x20u);
      if ( v8 )
        *v8 = v4;
    }
  }
  else
  {
    if ( v3 != &byte_41148E )
      return result;
    *v3 &= ~v2;
    v9 = wcschr(*(const wchar_t **)(v6 + 4), v4);
    if ( v9 )
    {
      do
      {
        v10 = v9[1];
        *v9++ = v10;
      }
      while ( v10 );
    }
  }
  v11 = (const wchar_t *)sub_40E267((char *)&aMakeflags[10]);
  result = wputenv_s(aMa, v11);
  if ( result )
    return sub_4053F6(dword_4216A4, 0x41Fu);
  return result;
}
// 41102C: using guessed type wchar_t aMakeflags[29];
// 41148C: using guessed type char byte_41148C;
// 41148E: using guessed type char byte_41148E;
// 4216A4: using guessed type int dword_4216A4;
// 4216B5: using guessed type char byte_4216B5;
// 4216B6: using guessed type char byte_4216B6;
// 4216B7: using guessed type char byte_4216B7;
// 421EE0: using guessed type char byte_421EE0;
// 421EE3: using guessed type char byte_421EE3;
// 432328: using guessed type int dword_432328;
// 43232C: using guessed type int dword_43232C;

//----- (0040C3C9) --------------------------------------------------------
void __cdecl Function()
{
  int v0; // esi
  const wchar_t *v1; // edi

  signal(2, (_crt_signal_t)1);
  signal(15, (_crt_signal_t)1);
  if ( byte_4323F8 && (byte_41148E & 4) == 0 && (byte_41148C & 0x10) == 0 && dword_421ED4 && waccess(dword_421ED4, 0) )
  {
    v0 = dword_42169C;
    v1 = dword_421ED4;
    if ( dword_42169C )
    {
      while ( wcsicmp(*(const wchar_t **)(v0 + 4), v1) )
      {
        v0 = *(_DWORD *)v0;
        if ( !v0 )
        {
          v1 = dword_421ED4;
          goto LABEL_10;
        }
      }
    }
    else
    {
LABEL_10:
      if ( !wunlink(v1) )
        sub_4053F6(dword_4216A4, 0xFA8u, dword_421ED4);
    }
  }
  sub_4053F6(0, 0x422u);
  sub_40C479();
}
// 41148C: using guessed type char byte_41148C;
// 41148E: using guessed type char byte_41148E;
// 42169C: using guessed type int dword_42169C;
// 4216A4: using guessed type int dword_4216A4;
// 4323F8: using guessed type char byte_4323F8;

//----- (0040C479) --------------------------------------------------------
int sub_40C479()
{
  int result; // eax
  int i; // esi

  result = fcloseall();
  for ( i = dword_4323F4; i; i = *(_DWORD *)i )
  {
    result = wunlink(*(const wchar_t **)(i + 4));
    if ( (byte_41148E & 4) != 0 )
    {
      sub_40C7C7((wchar_t *)L"\tdel %s\n", *(_DWORD *)(i + 4));
      result = sub_40C7A9();
    }
  }
  return result;
}
// 41148E: using guessed type char byte_41148E;
// 4323F4: using guessed type int dword_4323F4;

//----- (0040C4B7) --------------------------------------------------------
const unsigned __int16 *__fastcall sub_40C4B7(const unsigned __int16 *a1)
{
  char v1; // bl
  const unsigned __int16 *result; // eax
  int v3; // edx

  v1 = 0;
  result = &a1[wcslen(a1) - 1];
  if ( *a1 != 34 || *result != 34 )
    goto LABEL_7;
  v1 = 1;
  do
  {
    --result;
LABEL_7:
    if ( result <= a1 )
      break;
    v3 = *result;
  }
  while ( v3 == 32 || v3 == 46 );
  if ( v1 )
    *++result = 34;
  *((_WORD *)result + 1) = 0;
  return result;
}

//----- (0040C50D) --------------------------------------------------------
int __fastcall sub_40C50D(unsigned int a1)
{
  int v1; // esi
  wchar_t **v3; // eax
  HMODULE v4; // edi
  HRSRC Resource; // eax
  _WORD *v6; // edx
  int i; // ebx
  int v9; // [esp-18h] [ebp-640h]
  int v10; // [esp-14h] [ebp-63Ch]
  int v11; // [esp-10h] [ebp-638h]
  int v12; // [esp-Ch] [ebp-634h]
  int v13; // [esp-8h] [ebp-630h]
  int v14; // [esp-4h] [ebp-62Ch]
  wchar_t Buffer[260]; // [esp+10h] [ebp-618h] BYREF
  wchar_t Dir[256]; // [esp+218h] [ebp-410h] BYREF
  wchar_t Filename[258]; // [esp+418h] [ebp-210h] BYREF
  wchar_t Drive[4]; // [esp+61Ch] [ebp-Ch] BYREF

  v1 = 0;
  if ( byte_435E60 )
  {
    v4 = hModule;
  }
  else
  {
    v3 = _p__wpgmptr();
    wsplitpath_s(*v3, Drive, 3u, Dir, 0x100u, Filename, 0x100u, 0, 0);
    wmakepath_s(Buffer, 0x104u, Drive, Dir, 0, 0);
    if ( wcsncat_s(Filename, 0x100u, L"UI.DLL", 0xFFFFFFFF)
      || sub_40ACB5(Buffer, Filename, v9, v10, v11, v12, v13, v14) < 0 )
    {
      v4 = 0;
      hModule = 0;
    }
    else
    {
      v4 = hModule;
    }
    byte_435E60 = 1;
  }
  Resource = FindResourceExW(v4, (LPCWSTR)6, (LPCWSTR)(unsigned __int16)((a1 >> 4) + 1), word_435E68);
  if ( Resource )
  {
    v6 = LoadResource(v4, Resource);
    if ( v6 )
    {
      for ( i = a1 & 0xF; i; --i )
        v6 += (unsigned __int16)*v6 + 1;
      return *v6 != 0 ? (unsigned int)(v6 + 1) : 0;
    }
  }
  return v1;
}
// 40C5A9: variable 'v9' is possibly undefined
// 40C5A9: variable 'v10' is possibly undefined
// 40C5A9: variable 'v11' is possibly undefined
// 40C5A9: variable 'v12' is possibly undefined
// 40C5A9: variable 'v13' is possibly undefined
// 40C5A9: variable 'v14' is possibly undefined
// 435E60: using guessed type char byte_435E60;
// 435E68: using guessed type __int16 word_435E68;

//----- (0040C62E) --------------------------------------------------------
void *sub_40C62E()
{
  return &unk_435638;
}

//----- (0040C634) --------------------------------------------------------
int sub_40C634(wchar_t *Buffer, wchar_t *Format, ...)
{
  _DWORD *v2; // eax
  unsigned __int64 v4; // [esp-1Ch] [ebp-1Ch]
  va_list va; // [esp+10h] [ebp+10h] BYREF

  va_start(va, Format);
  v2 = sub_40C62E();
  HIDWORD(v4) = v2[1];
  LODWORD(v4) = *v2 | 1;
  return _stdio_common_vswscanf(v4, Buffer, 0xFFFFFFFF, Format, 0, va);
}

//----- (0040C65E) --------------------------------------------------------
bool __thiscall sub_40C65E(FILE *Stream)
{
  int v1; // eax
  void *osfhandle; // esi
  DWORD Mode; // [esp+4h] [ebp-4h] BYREF

  v1 = fileno(Stream);
  osfhandle = (void *)get_osfhandle(v1);
  return (GetFileType(osfhandle) & 0xFFFF7FFF) == 2 && GetConsoleMode(osfhandle, &Mode);
}

//----- (0040C69E) --------------------------------------------------------
bool sub_40C69E()
{
  FILE *v0; // eax
  FILE *v1; // eax
  bool result; // al

  v0 = _acrt_iob_func(1u);
  byte_4323FD = sub_40C65E(v0);
  v1 = _acrt_iob_func(2u);
  result = sub_40C65E(v1);
  byte_4323FC = result;
  return result;
}
// 4323FC: using guessed type char byte_4323FC;
// 4323FD: using guessed type char byte_4323FD;

//----- (0040C6C9) --------------------------------------------------------
int sub_40C6C9()
{
  FILE *v1; // eax

  if ( byte_4323FC )
    return 0;
  v1 = _acrt_iob_func(2u);
  return fflush(v1);
}
// 4323FC: using guessed type char byte_4323FC;

//----- (0040C6E7) --------------------------------------------------------
int sub_40C6E7(wchar_t *Format, ...)
{
  va_list va; // [esp+Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  return sub_40C75F(Format, va);
}

//----- (0040C6F6) --------------------------------------------------------
int sub_40C6F6()
{
  int result; // eax
  FILE *v1; // eax

  if ( byte_4323FC )
  {
    LOWORD(result) = putwch(0xAu);
  }
  else
  {
    v1 = _acrt_iob_func(2u);
    LOWORD(result) = fputwc(0xAu, v1);
  }
  return (unsigned __int16)result;
}
// 4323FC: using guessed type char byte_4323FC;

//----- (0040C722) --------------------------------------------------------
bool __thiscall sub_40C722(FILE *Stream)
{
  FILE *v2; // eax
  int v3; // eax
  FILE *v4; // eax
  bool result; // al
  int v6; // [esp-4h] [ebp-8h]

  v2 = _acrt_iob_func(2u);
  v6 = fileno(v2);
  v3 = fileno(Stream);
  dup2(v3, v6);
  v4 = _acrt_iob_func(2u);
  result = sub_40C65E(v4);
  byte_4323FC = result;
  return result;
}
// 4323FC: using guessed type char byte_4323FC;

//----- (0040C75F) --------------------------------------------------------
int __fastcall sub_40C75F(wchar_t *Format, va_list ArgList)
{
  unsigned __int64 *v4; // eax
  unsigned __int64 *v5; // esi
  FILE *v7; // eax

  v4 = (unsigned __int64 *)sub_40C84C();
  v5 = v4;
  if ( byte_4323FC )
    return _conio_common_vcwprintf(*v4, Format, 0, ArgList);
  v7 = _acrt_iob_func(2u);
  return _stdio_common_vfwprintf(*v5, v7, Format, 0, ArgList);
}
// 4323FC: using guessed type char byte_4323FC;

//----- (0040C7A9) --------------------------------------------------------
int sub_40C7A9()
{
  FILE *v1; // eax

  if ( byte_4323FD )
    return 0;
  v1 = _acrt_iob_func(1u);
  return fflush(v1);
}
// 4323FD: using guessed type char byte_4323FD;

//----- (0040C7C7) --------------------------------------------------------
int sub_40C7C7(wchar_t *Format, ...)
{
  va_list va; // [esp+Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  return sub_40C802(Format, va);
}

//----- (0040C7D6) --------------------------------------------------------
int sub_40C7D6()
{
  int result; // eax
  FILE *v1; // eax

  if ( byte_4323FD )
  {
    LOWORD(result) = putwch(0xAu);
  }
  else
  {
    v1 = _acrt_iob_func(1u);
    LOWORD(result) = fputwc(0xAu, v1);
  }
  return (unsigned __int16)result;
}
// 4323FD: using guessed type char byte_4323FD;

//----- (0040C802) --------------------------------------------------------
int __fastcall sub_40C802(wchar_t *Format, va_list ArgList)
{
  unsigned __int64 *v4; // eax
  unsigned __int64 *v5; // esi
  FILE *v7; // eax

  v4 = (unsigned __int64 *)sub_40C84C();
  v5 = v4;
  if ( byte_4323FD )
    return _conio_common_vcwprintf(*v4, Format, 0, ArgList);
  v7 = _acrt_iob_func(1u);
  return _stdio_common_vfwprintf(*v5, v7, Format, 0, ArgList);
}
// 4323FD: using guessed type char byte_4323FD;

//----- (0040C84C) --------------------------------------------------------
void *sub_40C84C()
{
  return &unk_435648;
}

//----- (0040C852) --------------------------------------------------------
int __thiscall sub_40C852(void *this)
{
  int v1; // eax
  unsigned int v2; // eax
  int result; // eax
  int v4; // edx
  char v5; // bh
  int v6; // ecx
  unsigned __int8 i; // bl
  char v8; // al
  int v9; // eax
  char v10; // al
  _BYTE *v11; // esi
  int v12; // [esp+10h] [ebp-8h]
  int v13; // [esp+10h] [ebp-8h]
  char v14; // [esp+17h] [ebp-1h]

  v1 = dword_411028;
  byte_421EE2 = 1;
  byte_432311[dword_411028] = 23;
  v2 = v1 + 2;
  dword_411028 = v2;
  if ( v2 >= 0x10 )
    __report_rangecheckfailure();
  byte_432310[v2] = 0;
  dword_4216B0 = dword_4216A4;
  LOBYTE(result) = sub_409B97((int)this, 0);
  v4 = dword_411028;
  BYTE1(v6) = result;
  v5 = 0;
  v14 = result;
  LOBYTE(v6) = byte_432310[dword_411028];
  for ( i = v6; (_BYTE)v6 != 23; i = v6 )
  {
    if ( (i & 0x40) != 0 )
    {
      dword_411028 = v4 - 1;
      result = funcs_40C8D0[v6 & 0xF]();
    }
    else
    {
      if ( (i & 0x10) == 0 )
      {
        result = (unsigned __int8)byte_4014A0[8 * i + (BYTE1(v6) & 0xF)];
        v12 = result;
        if ( (result & 0x20) != 0 )
        {
          sub_4053F6(dword_4216B0, result + 1000, &Src);
          v4 = dword_411028;
          result = v12;
        }
        dword_411028 = --v4;
        if ( (result & 0x80u) != 0 )
        {
          v9 = result & 0xF;
          v13 = v9;
          if ( !v5 )
          {
            v10 = sub_409B97(v6, i);
            v4 = dword_411028;
            v5 = v10;
            v9 = v13;
          }
          result = (unsigned __int8)byte_401480[8 * i + (v5 & 0xF)] + v9;
        }
        v11 = (_BYTE *)*((_DWORD *)&off_4014E0 + result);
        v6 = (unsigned __int8)*v11;
        if ( *v11 )
        {
          do
          {
            LOBYTE(result) = v11[v6];
            byte_432310[++v4] = result;
            --v6;
          }
          while ( v6 );
          dword_411028 = v4;
        }
        goto LABEL_25;
      }
      if ( i == BYTE1(v6) )
      {
        LOBYTE(v6) = byte_43230F[v4--];
        dword_411028 = v4;
        if ( (v6 & 0x40) != 0 )
        {
          dword_411028 = v4 - 1;
          funcs_40C8D0[v6 & 0xF]();
          v4 = dword_411028;
        }
        result = dword_4216A4;
        dword_4216B0 = dword_4216A4;
        if ( v5 )
        {
          if ( Src == 10 )
          {
            result = dword_4216A4 - 1;
            dword_4216B0 = dword_4216A4 - 1;
          }
          BYTE1(v6) = v5;
          v5 = 0;
          v14 = BYTE1(v6);
        }
        else
        {
          v8 = sub_409B97(v6, byte_432310[v4]);
          v4 = dword_411028;
          BYTE1(v6) = v8;
          result = dword_4216A4;
          v14 = BYTE1(v6);
          dword_4216B0 = dword_4216A4;
        }
        goto LABEL_26;
      }
      result = sub_4053F6(dword_4216B0, 0x409u, &Src);
    }
    v4 = dword_411028;
LABEL_25:
    BYTE1(v6) = v14;
LABEL_26:
    LOBYTE(v6) = byte_432310[v4];
  }
  dword_411028 = v4 - 1;
  return result;
}
// 40C960: variable 'v6' is possibly undefined
// 401460: using guessed type int (*funcs_40C8D0[6])();
// 410495: using guessed type void __noreturn __report_rangecheckfailure(void);
// 411028: using guessed type int dword_411028;
// 4216A4: using guessed type int dword_4216A4;
// 4216B0: using guessed type int dword_4216B0;
// 421EE2: using guessed type char byte_421EE2;

//----- (0040CA36) --------------------------------------------------------
unsigned int __fastcall sub_40CA36(int a1, _WORD *a2)
{
  _WORD *v2; // esi
  unsigned int v4; // ecx

  v2 = a2 + 1;
  while ( *a2++ )
    ;
  v4 = a2 - v2 + a1;
  if ( v4 > 0x28 )
  {
    sub_40C7C7((wchar_t *)L"\n\t\t\t");
    return 0;
  }
  return v4;
}

//----- (0040CA65) --------------------------------------------------------
void __fastcall sub_40CA65(int a1, int a2, FILETIME FileTime)
{
  struct _FILETIME LocalFileTime; // [esp+Ch] [ebp-5Ch] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+14h] [ebp-54h] BYREF
  WCHAR DateStr[20]; // [esp+24h] [ebp-44h] BYREF
  WCHAR TimeStr[12]; // [esp+4Ch] [ebp-1Ch] BYREF

  if ( FileTime )
  {
    if ( FileTimeToLocalFileTime(&FileTime, &LocalFileTime)
      && FileTimeToSystemTime(&LocalFileTime, &SystemTime)
      && GetDateFormatW(0x400u, 0, &SystemTime, L"ddd, MMM dd yyyy", DateStr, 20) )
    {
      if ( GetTimeFormatW(0x400u, 0, &SystemTime, L"HH:mm:ss", TimeStr, 12) )
        sub_4054D0(4u, DateStr, TimeStr, a1, 32, a2);
    }
  }
  else
  {
    sub_4054D0(6u, a1 + 26, 32, a2);
  }
}

//----- (0040CB1F) --------------------------------------------------------
void __fastcall sub_40CB1F(int a1, int a2)
{
  int v2; // edi
  int v3; // ebx
  __int16 *v4; // ecx
  wchar_t *v5; // ebx
  int v6; // edi
  WCHAR *i; // eax
  _WORD *v8; // esi
  WCHAR *v9; // eax
  _WORD *v10; // esi
  wchar_t *Block; // [esp+10h] [ebp-270h]
  int v12; // [esp+14h] [ebp-26Ch] BYREF
  int v13; // [esp+18h] [ebp-268h]
  wchar_t *Context; // [esp+1Ch] [ebp-264h] BYREF
  HANDLE hFindFile; // [esp+20h] [ebp-260h] BYREF
  int v16; // [esp+24h] [ebp-25Ch]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+28h] [ebp-258h] BYREF

  v2 = a1;
  v13 = a1;
  v12 = a2;
  sub_4054D0(0xCu);
  v3 = 0;
  v16 = 0;
  while ( v2 )
  {
    if ( wcschr(*(const wchar_t **)(v2 + 4), 0x24u) )
    {
      v4 = *(__int16 **)(v2 + 4);
      Context = 0;
      Block = (wchar_t *)sub_40EC83(v4, 1, &v12);
      v5 = wcstok_s(Block, L" \t", &Context);
      if ( v5 )
      {
        v6 = v16;
        do
        {
          if ( wcspbrk(v5, L"*?") )
          {
            for ( i = sub_4079FA(v5, &FindFileData, &hFindFile); i; i = sub_407B86(&FindFileData, hFindFile) )
            {
              v8 = sub_40F89E(v5, i);
              sub_40C7C7((wchar_t *)L"%s ", v8);
              v6 = sub_40CA36(v6, v8);
              free(v8);
            }
          }
          else
          {
            sub_40C7C7((wchar_t *)L"%s ", v5);
            v6 = sub_40CA36(v6, v5);
          }
          v5 = wcstok_s(0, L" \t", &Context);
        }
        while ( v5 );
        v16 = v6;
        v2 = v13;
      }
      free(Block);
      v3 = v16;
    }
    else
    {
      if ( wcspbrk(*(const wchar_t **)(v2 + 4), L"*?") )
      {
        v9 = sub_4079FA(*(wchar_t **)(v2 + 4), &FindFileData, &hFindFile);
        if ( !v9 )
          goto LABEL_20;
        do
        {
          v10 = sub_40F89E(*(wchar_t **)(v2 + 4), v9);
          sub_40C7C7((wchar_t *)L"%s ", v10);
          v3 = sub_40CA36(v3, v10);
          free(v10);
          v9 = sub_407B86(&FindFileData, hFindFile);
        }
        while ( v9 );
      }
      else
      {
        sub_40C7C7((wchar_t *)L"%s ", *(_DWORD *)(v2 + 4));
        v3 = sub_40CA36(v3, *(_WORD **)(v2 + 4));
      }
      v16 = v3;
    }
LABEL_20:
    v2 = *(_DWORD *)v2;
    v13 = v2;
  }
}

//----- (0040CD28) --------------------------------------------------------
int sub_40CD28()
{
  _DWORD *v0; // edi
  _DWORD *i; // esi
  int v2; // eax
  _DWORD *j; // ebx

  sub_4054D0(8u);
  v0 = &unk_431F10;
  do
  {
    for ( i = (_DWORD *)*v0; i; i = (_DWORD *)*i )
    {
      v2 = i[2];
      if ( v2 && *(_DWORD *)(v2 + 4) )
      {
        sub_4054D0(0xEu, i[1], *(_DWORD *)(v2 + 4));
        for ( j = *(_DWORD **)i[2]; j; j = (_DWORD *)*j )
        {
          if ( j[1] )
            sub_40C7C7((wchar_t *)L"\t\t%s\n", j[1]);
        }
      }
    }
    ++v0;
  }
  while ( (int)v0 < (int)byte_432310 );
  sub_40C7D6();
  return sub_40C7A9();
}

//----- (0040CD99) --------------------------------------------------------
int sub_40CD99()
{
  _BYTE *v0; // esi
  wchar_t *v1; // eax
  _DWORD *v2; // edi
  _DWORD *i; // esi

  sub_4054D0(7u);
  v0 = dword_421694;
  if ( dword_421694 )
  {
    do
    {
      v1 = (wchar_t *)L"%s::";
      if ( !v0[20] )
        v1 = L"%s:";
      sub_40C7C7(v1, *((_DWORD *)v0 + 2));
      sub_4054D0(0xAu);
      v2 = (_DWORD *)*((_DWORD *)v0 + 3);
      if ( v2 )
      {
        sub_40C7C7(L"%s\n", v2[1]);
        while ( 1 )
        {
          v2 = (_DWORD *)*v2;
          if ( !v2 )
            break;
          sub_40C7C7((wchar_t *)L"\t\t\t%s\n", v2[1]);
        }
      }
      sub_40C7D6();
      v0 = *(_BYTE **)v0;
    }
    while ( v0 );
  }
  sub_40C7C7((wchar_t *)L"%s: ", L".SUFFIXES");
  for ( i = (_DWORD *)dword_4216A0; i; i = (_DWORD *)*i )
    sub_40C7C7((wchar_t *)L"%s ", i[1]);
  sub_40C7D6();
  return sub_40C7A9();
}
// 401138: using guessed type wchar_t aSuffixes[10];
// 40240C: using guessed type wchar_t aS_3[4];
// 402414: using guessed type wchar_t aS_4[4];
// 4216A0: using guessed type int dword_4216A0;

//----- (0040CE39) --------------------------------------------------------
int sub_40CE39()
{
  unsigned int v0; // ebx
  _DWORD *v1; // esi
  _DWORD *v2; // ebx
  int v3; // edi
  unsigned __int16 *v4; // esi
  unsigned int v5; // eax
  _DWORD *v6; // edi
  int result; // eax
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]
  unsigned int v10; // [esp+14h] [ebp-4h]

  sub_4054D0(9u);
  v0 = 0;
  v10 = 0;
  do
  {
    v1 = *(_DWORD **)((char *)dword_421490 + v0);
    v9 = v1;
    if ( v1 )
    {
      do
      {
        sub_40C7C7((wchar_t *)L"%s:%c", v1[1], (*(_BYTE *)(*(_DWORD *)(v1[6] + 4) + 16) & 0x20) != 0 ? 58 : 32);
        v2 = (_DWORD *)v1[6];
        dword_421EC8 = v1[1];
        dword_421ED4 = (wchar_t *)dword_421EC8;
        dword_421ED8 = dword_421EC8;
        if ( v2 )
        {
          do
          {
            v3 = v2[1];
            sub_4054D0(0xBu);
            v4 = L"dinsb";
            v5 = 1;
            v8 = 1;
            do
            {
              if ( ((unsigned __int8)v5 & *(_BYTE *)(v3 + 16)) != 0 )
              {
                sub_40C7C7((wchar_t *)L"-%c ", *v4);
                v5 = v8;
              }
              v5 *= 2;
              ++v4;
              v8 = v5;
            }
            while ( v5 < 0x10 );
            sub_40CB1F(*(_DWORD *)v3, *(_DWORD *)(v3 + 4));
            sub_4054D0(0xAu);
            v6 = *(_DWORD **)(v3 + 8);
            if ( v6 )
            {
              if ( v6[1] )
                sub_40C7C7(L"%s\n", v6[1]);
              while ( 1 )
              {
                v6 = (_DWORD *)*v6;
                if ( !v6 )
                  break;
                if ( v6[1] )
                  sub_40C7C7((wchar_t *)L"\t\t\t%s\n", v6[1]);
              }
            }
            else
            {
              sub_40C7D6();
            }
            v2 = (_DWORD *)*v2;
          }
          while ( v2 );
          v1 = v9;
        }
        v1 = (_DWORD *)*v1;
        v9 = v1;
        sub_40C7D6();
      }
      while ( v1 );
      v0 = v10;
    }
    v0 += 4;
    v10 = v0;
  }
  while ( v0 < 0x200 );
  sub_40C7D6();
  sub_40C7A9();
  result = 0;
  dword_421EC8 = 0;
  dword_421ED4 = 0;
  dword_421ED8 = 0;
  return result;
}
// 402414: using guessed type wchar_t aS_4[4];
// 402450: using guessed type wchar_t aDinsb[6];
// 421490: using guessed type int dword_421490[128];
// 421EC8: using guessed type int dword_421EC8;
// 421ED8: using guessed type int dword_421ED8;

//----- (0040CF8E) --------------------------------------------------------
char __stdcall sub_40CF8E(char a1)
{
  int v1; // edi
  char v2; // al
  int v3; // esi
  int v4; // eax
  BOOL v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  BOOL v9; // eax
  unsigned int v10; // eax

  v1 = dword_432610;
  v2 = *(_BYTE *)dword_432610;
  v3 = dword_432610 - 8;
  dword_432610 -= 8;
  if ( v2 != 22 )
  {
    if ( v2 != 23 || *(_BYTE *)v3 != 23 )
      return 0;
    v8 = wcscmp(*(const unsigned __int16 **)(v3 + 4), *(const unsigned __int16 **)(v1 + 4));
    if ( v8 )
      v8 = v8 < 0 ? -1 : 1;
    switch ( a1 )
    {
      case 6:
        v9 = v8 != 0;
        goto LABEL_48;
      case 7:
        v9 = v8 == 0;
        goto LABEL_48;
      case 8:
        v9 = v8 > 0;
        goto LABEL_48;
      case 9:
        v10 = v8;
        break;
      case 10:
        v10 = ~v8;
        break;
      case 11:
        v9 = v8 <= 0;
LABEL_48:
        *(_DWORD *)(v3 + 4) = v9;
        *(_BYTE *)v3 = 22;
        return 1;
      default:
        return 0;
    }
    v9 = v10 >> 31;
    goto LABEL_48;
  }
  if ( *(_BYTE *)v3 == 22 )
  {
    switch ( a1 )
    {
      case 1:
        v4 = 0;
        if ( !*(_DWORD *)(v3 + 4) )
          goto LABEL_5;
        goto LABEL_6;
      case 2:
        v4 = 0;
        if ( *(_DWORD *)(v3 + 4) )
        {
LABEL_5:
          if ( *(_DWORD *)(v1 + 4) )
LABEL_6:
            v4 = 1;
        }
        goto LABEL_30;
      case 3:
        *(_DWORD *)(v3 + 4) |= *(_DWORD *)(v1 + 4);
        return 1;
      case 4:
        *(_DWORD *)(v3 + 4) ^= *(_DWORD *)(v1 + 4);
        return 1;
      case 5:
        *(_DWORD *)(v3 + 4) &= *(_DWORD *)(v1 + 4);
        return 1;
      case 6:
        v5 = *(_DWORD *)(v1 + 4) != *(_DWORD *)(v3 + 4);
        goto LABEL_13;
      case 7:
        v4 = *(_DWORD *)(v3 + 4) == *(_DWORD *)(v1 + 4);
        goto LABEL_30;
      case 8:
        v5 = *(_DWORD *)(v3 + 4) > *(_DWORD *)(v1 + 4);
        goto LABEL_13;
      case 9:
        v5 = *(_DWORD *)(v3 + 4) < *(_DWORD *)(v1 + 4);
        goto LABEL_13;
      case 10:
        v5 = *(_DWORD *)(v3 + 4) >= *(_DWORD *)(v1 + 4);
        goto LABEL_13;
      case 11:
        v5 = *(_DWORD *)(v3 + 4) <= *(_DWORD *)(v1 + 4);
LABEL_13:
        *(_DWORD *)(v3 + 4) = v5;
        return 1;
      case 12:
        *(int *)(v3 + 4) >>= *(_DWORD *)(v1 + 4);
        return 1;
      case 13:
        *(_DWORD *)(v3 + 4) <<= *(_DWORD *)(v1 + 4);
        return 1;
      case 14:
        *(_DWORD *)(v3 + 4) -= *(_DWORD *)(v1 + 4);
        return 1;
      case 15:
        *(_DWORD *)(v3 + 4) += *(_DWORD *)(v1 + 4);
        return 1;
      case 16:
        v6 = *(_DWORD *)(v1 + 4);
        if ( !v6 )
        {
          sub_4053F6(dword_4216A4, 0x437u);
          v6 = *(_DWORD *)(v1 + 4);
        }
        *(int *)(v3 + 4) %= v6;
        return 1;
      case 17:
        v7 = *(_DWORD *)(v1 + 4);
        if ( !v7 )
        {
          sub_4053F6(dword_4216A4, 0x437u);
          v7 = *(_DWORD *)(v1 + 4);
        }
        v4 = *(_DWORD *)(v3 + 4) / v7;
        goto LABEL_30;
      case 18:
        v4 = *(_DWORD *)(v1 + 4) * *(_DWORD *)(v3 + 4);
LABEL_30:
        *(_DWORD *)(v3 + 4) = v4;
        break;
      default:
        return 0;
    }
    return 1;
  }
  return 0;
}
// 4216A4: using guessed type int dword_4216A4;
// 432610: using guessed type int dword_432610;

//----- (0040D1DE) --------------------------------------------------------
char __stdcall sub_40D1DE(char a1)
{
  if ( *(_BYTE *)dword_432610 == 22 )
  {
    switch ( a1 )
    {
      case 19:
        *(_DWORD *)(dword_432610 + 4) = -*(_DWORD *)(dword_432610 + 4);
        return 1;
      case 20:
        *(_DWORD *)(dword_432610 + 4) = ~*(_DWORD *)(dword_432610 + 4);
        return 1;
      case 21:
        *(_DWORD *)(dword_432610 + 4) = *(_DWORD *)(dword_432610 + 4) == 0;
        return 1;
    }
  }
  return 0;
}
// 432610: using guessed type int dword_432610;

//----- (0040D21C) --------------------------------------------------------
wchar_t *sub_40D21C()
{
  wchar_t *v0; // esi
  wchar_t *v1; // ecx
  wchar_t *v2; // edx
  wchar_t v3; // di
  wchar_t *result; // eax

  v0 = EndPtr + 1;
  v1 = EndPtr + 1;
  EndPtr = v1;
  if ( !*v1 )
    goto LABEL_7;
  v2 = v0;
  v3 = *v1;
  do
  {
    if ( v3 == 34 )
    {
      v2 = v1 + 1;
      if ( v1[1] != 34 )
        break;
    }
    v1 = v2 + 1;
    EndPtr = v1;
    ++v2;
    v3 = *v1;
  }
  while ( *v1 );
  if ( !*v1 )
  {
LABEL_7:
    sub_4053F6(dword_4216A4, 0x3FEu, 34);
    v1 = EndPtr;
  }
  *v1 = 0;
  result = v0;
  ++EndPtr;
  return result;
}
// 4216A4: using guessed type int dword_4216A4;

//----- (0040D293) --------------------------------------------------------
wchar_t *sub_40D293()
{
  wchar_t *v0; // esi
  wchar_t *v1; // ecx
  wchar_t *v2; // edi
  wchar_t v3; // dx
  _WORD *v4; // edx
  wchar_t *v5; // ecx
  wchar_t *result; // eax

  v0 = EndPtr + 1;
  v1 = EndPtr + 1;
  EndPtr = v1;
  if ( !*v1 )
    goto LABEL_11;
  v2 = v0;
  v3 = *v1;
  do
  {
    if ( v3 == 94 )
    {
      v4 = v1 + 1;
      if ( v1[1] == 93 )
      {
        v5 = v1 + 2;
        while ( *v4++ )
          ;
        memmove(v2, v2 + 1, 2 * (v4 - v5) + 2);
        v1 = EndPtr;
      }
    }
    else if ( v3 == 93 )
    {
      break;
    }
    EndPtr = ++v1;
    v2 = v1;
    v3 = *v1;
  }
  while ( *v1 );
  if ( !*v1 )
  {
LABEL_11:
    sub_4053F6(dword_4216A4, 0x3FEu, 93);
    v1 = EndPtr;
  }
  *v1 = 0;
  result = v0;
  ++EndPtr;
  return result;
}
// 4216A4: using guessed type int dword_4216A4;

//----- (0040D34A) --------------------------------------------------------
int __fastcall sub_40D34A(char a1, int a2)
{
  unsigned __int8 v4; // bl
  int result; // eax

  if ( a1 == 25 )
  {
    v4 = 3;
  }
  else if ( a1 )
  {
    if ( (unsigned __int8)a1 <= 0x15u )
      v4 = ((unsigned __int8)a1 > 0x12u) + 1;
    else
      v4 = 0;
  }
  else
  {
    v4 = 4;
  }
  result = v4;
  if ( !byte_401570[5 * (unsigned __int8)byte_4323FE + v4] )
    result = sub_4053F6(dword_4216A4, 0x3FFu);
  dword_432608 = a2;
  byte_4323FE = v4;
  byte_432602 = a1;
  LOBYTE(dword_432604) = a1;
  return result;
}
// 4216A4: using guessed type int dword_4216A4;
// 4323FE: using guessed type char byte_4323FE;
// 432602: using guessed type char byte_432602;
// 432604: using guessed type int dword_432604;
// 432608: using guessed type int dword_432608;

//----- (0040D3B8) --------------------------------------------------------
wchar_t *sub_40D3B8()
{
  wchar_t *i; // eax
  wchar_t v1; // cx
  wchar_t *v2; // esi
  wchar_t v3; // cx
  wchar_t *v4; // eax
  wchar_t *j; // ecx
  wchar_t v6; // dx
  wchar_t *v7; // edx
  wchar_t v8; // cx

  for ( i = EndPtr; ; EndPtr = i )
  {
    v1 = *i;
    if ( *i != 32 && v1 != 9 )
      break;
    ++i;
  }
  if ( v1 != 40 )
  {
    sub_4053F6(dword_4216A4, 0x3FFu);
    i = EndPtr;
  }
  do
  {
    do
    {
      EndPtr = ++i;
      v2 = i;
      v3 = *i;
    }
    while ( *i == 32 );
  }
  while ( v3 == 9 );
  if ( v3 != 34 )
  {
    v7 = i;
    while ( 1 )
    {
      v8 = *i++;
      EndPtr = i;
      if ( !v8 )
        break;
      if ( v8 == 41 )
      {
        *v7 = 0;
        return v2;
      }
      if ( v8 != 32 && v8 != 9 )
LABEL_23:
        v7 = i;
    }
    sub_4053F6(dword_4216A4, 0x3FFu);
    i = EndPtr;
    goto LABEL_23;
  }
  v4 = sub_40D21C();
  for ( j = EndPtr; ; EndPtr = j )
  {
    v6 = *j;
    if ( *j != 32 && v6 != 9 )
      break;
    ++j;
  }
  v2 = v4;
  if ( v6 != 41 )
  {
    sub_4053F6(dword_4216A4, 0x3FFu);
    j = EndPtr;
  }
  EndPtr = j + 1;
  return v2;
}
// 4216A4: using guessed type int dword_4216A4;

//----- (0040D4C9) --------------------------------------------------------
int sub_40D4C9()
{
  wchar_t *i; // ecx
  wint_t v1; // si
  wchar_t *v2; // edx
  wchar_t **v3; // edi
  wchar_t *v4; // ebx
  wchar_t v5; // cx
  char v7; // cl
  int v8; // edx
  wchar_t *v9; // edx
  wchar_t *v10; // edx
  wchar_t *v11; // ebx
  int v12; // edi
  wchar_t *v13; // eax
  wchar_t *v14; // eax
  int v15; // [esp-Ch] [ebp-18h]

  for ( i = EndPtr; ; EndPtr = i )
  {
    v1 = *i;
    if ( *i != 32 && v1 != 9 )
      break;
    ++i;
  }
  if ( v1 < 0x80u && (byte_401060[v1] & 2) != 0 )
  {
    v2 = off_411070;
    v3 = &off_411070;
    if ( off_411070 )
    {
      while ( 1 )
      {
        v4 = i;
        if ( *v2 )
        {
          v5 = *v2;
          do
          {
            if ( *v4 != v5 )
              break;
            ++v2;
            ++v4;
            v5 = *v2;
          }
          while ( *v2 );
          i = EndPtr;
        }
        if ( !*v2 )
          break;
        v3 += 2;
        v2 = *v3;
        if ( !*v3 )
          goto LABEL_15;
      }
      i = v4;
      EndPtr = v4;
    }
  }
  else
  {
    v3 = (wchar_t **)&unk_411118;
  }
  if ( *v3 )
  {
    v7 = *((_BYTE *)v3 + 4);
    v8 = 0;
    return sub_40D34A(v7, v8);
  }
LABEL_15:
  switch ( v1 )
  {
    case '-':
      EndPtr = i + 1;
      return sub_40D34A(byte_432602 != 22 ? 19 : 14, 0);
    case '"':
      v9 = sub_40D21C();
      return sub_40D34A(23, (int)v9);
    case '[':
      v10 = sub_40D293();
      return sub_40D34A(24, (int)v10);
  }
  if ( iswdigit(v1) )
  {
    v11 = EndPtr;
    *errno() = 0;
    v12 = wcstol(EndPtr, &EndPtr, 0);
    if ( *errno() == 34 )
    {
      v15 = dword_4216A4;
      *EndPtr = 0;
      sub_4053F6(v15, 0x436u, v11);
    }
    if ( towupper(*EndPtr) == 76 )
      ++EndPtr;
    v8 = v12;
    goto LABEL_32;
  }
  if ( !v1 )
  {
    byte_4323FF = 1;
    return sub_40D34A(0, 0);
  }
  if ( !wcsnicmp(EndPtr, L"DEFINED", 7u) )
  {
    EndPtr += 7;
    v13 = sub_40D3B8();
    v8 = sub_40D938(v13);
LABEL_32:
    v7 = 22;
    return sub_40D34A(v7, v8);
  }
  if ( !wcsnicmp(EndPtr, L"EXISTS", 6u) )
  {
    EndPtr += 6;
LABEL_39:
    v14 = sub_40D3B8();
    v8 = waccess(v14, 0) == 0;
    goto LABEL_32;
  }
  if ( !wcsnicmp(EndPtr, L"EXIST", 5u) )
  {
    EndPtr += 5;
    goto LABEL_39;
  }
  return sub_4053F6(dword_4216A4, 0x3FFu);
}
// 411070: using guessed type wchar_t *off_411070;
// 4216A4: using guessed type int dword_4216A4;
// 4323FF: using guessed type char byte_4323FF;
// 432602: using guessed type char byte_432602;

//----- (0040D7A4) --------------------------------------------------------
int sub_40D7A4()
{
  int *v0; // edx
  int *v1; // esi
  int result; // eax
  int v3; // ecx

  v0 = (int *)dword_432610;
  if ( dword_432610 < (unsigned int)byte_434620 )
  {
    sub_4053F6(dword_4216A4, 0x3FFu);
    v0 = (int *)dword_432610;
  }
  v1 = (int *)dword_43260C;
  if ( dword_43260C > (unsigned int)&unk_434618 )
  {
    sub_4053F6(dword_4216A4, 0x412u);
    v0 = (int *)dword_432610;
    v1 = (int *)dword_43260C;
  }
  result = *v0;
  v3 = v0[1];
  *v1 = *v0;
  v1[1] = v3;
  dword_43260C = (int)(v1 + 2);
  dword_432610 = (int)(v0 - 2);
  return result;
}
// 4216A4: using guessed type int dword_4216A4;
// 43260C: using guessed type int dword_43260C;
// 432610: using guessed type int dword_432610;
// 434620: using guessed type unsigned __int8 byte_434620[4088];

//----- (0040D815) --------------------------------------------------------
bool sub_40D815()
{
  int v0; // edx
  char *v1; // esi
  char v2; // al
  wchar_t *v3; // ecx
  wchar_t **v4; // eax
  char (__stdcall *v5)(char); // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // ecx
  unsigned __int8 *v10; // edx
  unsigned __int8 v11; // bl
  int v12; // eax

  dword_43260C = (int)&unk_432620;
  dword_432610 = (int)byte_434620;
  byte_4323FF = 0;
  byte_4323FE = 3;
  byte_432602 = 25;
  sub_40D34A(25, 0);
  v7 = dword_432610;
  v8 = dword_432608;
  *(_DWORD *)dword_432610 = dword_432604;
  *(_DWORD *)(v7 + 4) = v8;
  while ( !byte_4323FF )
  {
    sub_40D4C9();
    v9 = dword_432604;
    v10 = (unsigned __int8 *)dword_432610;
    if ( (_BYTE)dword_432604 != 25 )
    {
      while ( 1 )
      {
        v11 = byte_401590[(unsigned __int8)v9];
        if ( v11 > (unsigned __int8)byte_401590[*v10] )
          break;
        if ( !v11 )
        {
          while ( *v10 != 25 )
          {
            sub_40D7A4();
            v10 = (unsigned __int8 *)dword_432610;
          }
          if ( v10 < byte_434620 )
          {
            sub_4053F6(dword_4216A4, 0x3FFu);
            v10 = (unsigned __int8 *)dword_432610;
          }
          v7 = (int)(v10 - 8);
          goto LABEL_15;
        }
        sub_40D7A4();
        v9 = dword_432604;
        v10 = (unsigned __int8 *)dword_432610;
      }
    }
    if ( v10 == (unsigned __int8 *)&unk_435618 )
    {
      sub_4053F6(dword_4216A4, 0x412u);
      v7 = dword_432610;
    }
    else
    {
      v12 = dword_432608;
      v7 = (int)(v10 + 8);
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 4) = v12;
LABEL_15:
      dword_432610 = v7;
    }
  }
  if ( (unsigned __int8 *)v7 != &byte_434620[-8] )
    sub_4053F6(dword_4216A4, 0x3FFu);
  v0 = dword_432610;
  v1 = (char *)&unk_432620;
  if ( dword_43260C > (unsigned int)&unk_432620 )
  {
    do
    {
      v2 = *v1;
      if ( (unsigned __int8)*v1 <= 0x15u )
      {
        v5 = sub_40D1DE;
        if ( (unsigned __int8)v2 <= 0x12u )
          v5 = sub_40CF8E;
        if ( !v5(v2) )
          sub_4053F6(dword_4216A4, 0x438u);
        v0 = dword_432610;
      }
      else
      {
        v3 = (wchar_t *)*((_DWORD *)v1 + 1);
        v0 += 8;
        dword_432610 = v0;
        if ( v2 == 24 )
        {
          v4 = sub_406E33(v3, 0, 1, 0, 0);
          v0 = dword_432610;
          *(_DWORD *)(dword_432610 + 4) = v4;
          *(_BYTE *)v0 = 22;
        }
        else
        {
          *(_DWORD *)v0 = *(_DWORD *)v1;
          *(_DWORD *)(v0 + 4) = v3;
        }
      }
      v1 += 8;
    }
    while ( (unsigned int)v1 < dword_43260C );
  }
  if ( (unsigned __int8 *)v0 == byte_434620 && *(_BYTE *)v0 == 22 )
    return *(_DWORD *)(v0 + 4) != 0;
  sub_4053F6(dword_4216A4, 0x3FFu);
  return 0;
}
// 4216A4: using guessed type int dword_4216A4;
// 4323FE: using guessed type char byte_4323FE;
// 4323FF: using guessed type char byte_4323FF;
// 432602: using guessed type char byte_432602;
// 432604: using guessed type int dword_432604;
// 432608: using guessed type int dword_432608;
// 43260C: using guessed type int dword_43260C;
// 432610: using guessed type int dword_432610;
// 434620: using guessed type unsigned __int8 byte_434620[4088];

//----- (0040D938) --------------------------------------------------------
bool __thiscall sub_40D938(wchar_t *String)
{
  wchar_t *v1; // edi
  wchar_t *Context; // [esp+Ch] [ebp-4h] BYREF

  Context = 0;
  v1 = wcstok_s(String, L" \t", &Context);
  if ( wcstok_s(0, L" \t", &Context) )
    sub_4053F6(dword_4216A4, 0x409u, v1);
  if ( !v1 )
    sub_4053F6(dword_4216A4, 0x417u);
  return sub_40AB97(v1) != 0;
}
// 4216A4: using guessed type int dword_4216A4;

//----- (0040D9A7) --------------------------------------------------------
bool __fastcall sub_40D9A7(wchar_t *String, char a2)
{
  if ( !*String )
    sub_4053F6(dword_4216A4, 0x3FAu);
  if ( a2 != 4 )
  {
    if ( a2 == 5 )
      return !sub_40D938(String);
    if ( a2 != 6 )
    {
      if ( a2 != 7 )
      {
        EndPtr = String;
        return sub_40D815();
      }
      return !sub_40D938(String);
    }
  }
  return sub_40D938(String);
}
// 4216A4: using guessed type int dword_4216A4;

//----- (0040DA04) --------------------------------------------------------
void **__fastcall sub_40DA04(wchar_t *Destination, rsize_t a2, wchar_t *Str, int a4, LPWIN32_FIND_DATAW lpFindFileData)
{
  void *v5; // eax
  wchar_t *v6; // edi
  const wchar_t *v7; // ebx
  _WORD *v8; // esi
  wchar_t v9; // cx
  char *v10; // edx
  int v11; // ebx
  wchar_t *v12; // ecx
  int v13; // edx
  const wchar_t *v14; // edi
  int v15; // ecx
  __int16 v16; // ax
  const wchar_t *v17; // edi
  wchar_t *v18; // eax
  __int16 v19; // ax
  const wchar_t *v20; // esi
  wchar_t v21; // cx
  int v22; // esi
  wchar_t *v23; // edi
  wchar_t *v24; // eax
  int v25; // eax
  const wchar_t *v26; // edi
  int v27; // esi
  wchar_t *v28; // edi
  wchar_t v29; // cx
  wchar_t v30; // dx
  wchar_t *v31; // eax
  int v32; // ebx
  int v33; // esi
  int v34; // ebx
  wchar_t *v35; // eax
  int v36; // edi
  _DWORD *v37; // eax
  DWORD v39; // ecx
  DWORD v40; // edx
  const wchar_t *v41; // [esp-8h] [ebp-44h]
  int v42; // [esp+10h] [ebp-2Ch]
  char *v43; // [esp+1Ch] [ebp-20h]
  wchar_t *v44; // [esp+20h] [ebp-1Ch]
  int v45; // [esp+20h] [ebp-1Ch]
  void **v46; // [esp+2Ch] [ebp-10h]
  wchar_t *Source; // [esp+30h] [ebp-Ch]

  v5 = dword_421694;
  v46 = (void **)dword_421694;
  v6 = Destination;
  if ( !dword_421694 )
    return 0;
  while ( 1 )
  {
    Source = (wchar_t *)*((_DWORD *)v5 + 2);
    v44 = wcsrchr(Source, 0x2Eu);
    if ( sub_40FE3D(v44, a4) )
      goto LABEL_89;
    v7 = Source + 1;
    *v6 = 0;
    v8 = Source + 1;
    if ( !Source[1] )
      break;
    v9 = *v7;
    while ( v9 != 123 )
    {
      if ( v9 == 94 )
      {
        ++v8;
      }
      else if ( v9 == 34 )
      {
        do
          ++v8;
        while ( *v8 != 34 );
      }
      v9 = *++v8;
      if ( !*v8 )
        goto LABEL_36;
    }
    v10 = (char *)v8;
    do
    {
      if ( v9 == 125 )
        break;
      if ( v9 == 94 )
        v10 += 2;
      v10 += 2;
      v9 = *(_WORD *)v10;
    }
    while ( *(_WORD *)v10 );
    v43 = v10;
    v11 = (v10 - (char *)v8 - 2) >> 1;
    v12 = Str;
    v13 = v11;
    v45 = v11;
    if ( *Str == 34 )
      v12 = Str + 1;
    v14 = v8 + 1;
    if ( v11 )
    {
      v15 = (char *)v12 - (char *)v14;
      v42 = v15;
      do
      {
        if ( *v14 == 92 || *v14 == 47 )
        {
          v16 = *(const wchar_t *)((char *)v14 + v15);
          if ( v16 != 92 && v16 != 47 )
            goto LABEL_88;
        }
        else
        {
          if ( wcsnicmp(v14, (const wchar_t *)((char *)v14 + v15), 1u) )
            goto LABEL_88;
          v15 = v42;
          v13 = v45;
        }
        --v13;
        ++v14;
        v45 = v13;
      }
      while ( v13 );
    }
    v44 = v8;
    v17 = &Str[v11 + 1];
    v18 = wcschr(v17, 0x5Cu);
    if ( !v18 )
    {
      v18 = wcschr(v17, 0x2Fu);
      if ( !v18 )
      {
        v6 = Destination;
LABEL_35:
        v7 = Source + 1;
        break;
      }
    }
    if ( v18 != v17 || (v19 = *((_WORD *)v43 - 1), v19 == 92) )
    {
LABEL_88:
      v6 = Destination;
      goto LABEL_89;
    }
    v6 = Destination;
    if ( v19 != 47 )
      goto LABEL_35;
LABEL_89:
    v5 = *v46;
    v46 = (void **)v5;
    if ( !v5 )
      return 0;
  }
LABEL_36:
  if ( *Source == 123 )
  {
    v20 = v7;
    if ( *v7 )
    {
      v21 = *v7;
      do
      {
        if ( v21 == 125 )
          break;
        if ( v21 == 94 )
          ++v20;
        v21 = *++v20;
      }
      while ( *v20 );
      v6 = Destination;
    }
    v22 = v20 - v7;
    if ( v22 )
    {
      wcsncpy_s(v6, a2, v7, v22);
      v7 += v22;
      if ( *(v7 - 1) != 92 )
        v6[v22++] = 92;
    }
    else if ( *Str == 34 )
    {
      v22 = 3;
      wcsncpy_s(v6, a2, L"\".\\", 3u);
    }
    else
    {
      v22 = 2;
      wcsncpy_s(v6, a2, L".\\", 2u);
    }
    Source = (wchar_t *)(v7 + 1);
    v23 = wcsrchr(Str, 0x5Cu);
    v24 = wcsrchr(Str, 0x2Fu);
    if ( v24 > v23 )
      v23 = v24;
    if ( v23 )
    {
      wcscpy_s(&Destination[v22], a2 - v22, v23 + 1);
      v25 = a4 - (_DWORD)v23 - 2;
    }
    else
    {
      v26 = Str + 1;
      if ( *Str != 34 )
        v26 = Str;
      wcscpy_s(&Destination[v22], a2 - v22, v26);
      v25 = a4 - (_DWORD)v26;
    }
    v6 = Destination;
    v27 = (v25 >> 1) + v22;
    goto LABEL_76;
  }
  if ( *v8 )
  {
    v28 = wcsrchr(Str, 0x2Eu);
    v29 = *v28;
    if ( *v28 == 58 )
    {
LABEL_65:
      if ( v29 == 58 )
      {
LABEL_68:
        ++v28;
LABEL_69:
        v31 = Str;
        goto LABEL_70;
      }
    }
    else
    {
      v30 = *v28;
      while ( 1 )
      {
        v29 = v30;
        if ( v30 == 92 )
          break;
        v29 = v30;
        if ( v30 != 47 )
        {
          v29 = v30;
          if ( v28 > Str )
          {
            v30 = *--v28;
            v29 = *v28;
            if ( *v28 != 58 )
              continue;
          }
        }
        goto LABEL_65;
      }
    }
    if ( v29 != 92 && v29 != 47 )
      goto LABEL_69;
    goto LABEL_68;
  }
  v31 = Str;
  v28 = Str;
LABEL_70:
  v32 = 0;
  v33 = (a4 - (int)v28) >> 1;
  if ( v28 != v31 && *v31 == 34 )
  {
    v32 = 1;
    *Destination = 34;
  }
  if ( v33 >= (int)(a2 - v32) )
    sub_4053F6(0, 0x434u);
  v41 = v28;
  v6 = Destination;
  wcsncpy_s(&Destination[v32], a2 - v32, v41, v33);
  v27 = v32 + v33;
LABEL_76:
  v34 = v44 - Source;
  if ( v34 >= (int)(a2 - v27) )
    sub_4053F6(0, 0x434u);
  wcsncpy_s(&v6[v27], a2 - v27, Source, v34);
  if ( *v6 == 34 )
  {
    v35 = Destination;
    v36 = v34 + v27;
    if ( Destination[v34 - 1 + v27] != 34 )
    {
      if ( (int)(a2 - v34 - v27) <= 1 )
        sub_4053F6(0, 0x434u);
      v35 = Destination;
      ++v34;
      Destination[v36] = 34;
    }
    v6 = v35;
  }
  v6[v34 + v27] = 0;
  v37 = sub_40E3B9(v6, 0, 0);
  if ( !v37 )
  {
    if ( sub_407C98(v6, lpFindFileData) )
      return v46;
    goto LABEL_89;
  }
  v39 = v37[4];
  v40 = v37[5];
  lpFindFileData->ftCreationTime.dwLowDateTime = v39;
  lpFindFileData->ftCreationTime.dwHighDateTime = v40;
  lpFindFileData->ftLastWriteTime.dwLowDateTime = v39;
  lpFindFileData->ftLastWriteTime.dwHighDateTime = v40;
  return v46;
}
// 4024E4: using guessed type wchar_t asc_4024E4[4];

//----- (0040DE73) --------------------------------------------------------
void sub_40DE73()
{
  int v0; // eax
  void *v1; // esi
  wchar_t *v2; // edx
  _WORD *v3; // ecx
  _DWORD *v5; // ebx
  int v6; // edx
  const wchar_t *v7; // edi
  int v8; // ecx
  int v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // edi
  _DWORD *v12; // ecx
  const wchar_t *v13; // ebx
  int **v14; // ebx
  int v15; // ebx
  void **v16; // edx
  void **v17; // ecx
  void *v18; // edi
  wchar_t *String1; // [esp+Ch] [ebp-14h]
  int *v20; // [esp+10h] [ebp-10h]
  int v21; // [esp+14h] [ebp-Ch]
  _DWORD *v22; // [esp+18h] [ebp-8h]
  int *v23; // [esp+1Ch] [ebp-4h] BYREF

  v0 = dword_4216A0;
  v20 = (int *)dword_4216A0;
  v23 = 0;
  v1 = dword_421694;
  for ( dword_421694 = 0; v0; v20 = (int *)v0 )
  {
    v2 = *(wchar_t **)(v0 + 4);
    String1 = v2;
    v3 = v2 + 1;
    while ( *v2++ )
      ;
    v5 = v1;
    v6 = v2 - v3;
    v21 = v6;
    if ( v1 )
    {
      do
      {
        v7 = (const wchar_t *)v5[2];
        if ( *v7 == 123 )
        {
          LOWORD(v8) = 123;
          do
          {
            if ( (_WORD)v8 == 94 )
              ++v7;
            v8 = *++v7;
          }
          while ( v8 != 125 );
          ++v7;
        }
        if ( !wcsnicmp(String1, v7, v6) && ((v9 = v7[v21], v9 == 46) || (_WORD)v9 == 123) )
        {
          v10 = (_DWORD *)v5[1];
          v11 = v5;
          v12 = (_DWORD *)*v5;
          if ( v10 )
          {
            *v10 = v12;
            v12 = (_DWORD *)*v5;
          }
          else
          {
            v1 = (void *)*v5;
          }
          if ( v12 )
          {
            v12[1] = v5[1];
            v12 = (_DWORD *)*v5;
          }
          v22 = v12;
          *v5 = 0;
          v13 = (const wchar_t *)dword_421694;
          if ( dword_421694 )
          {
            while ( wcsicmp(*((const wchar_t **)v13 + 2), (const wchar_t *)v11[2]) )
            {
              v13 = *(const wchar_t **)v13;
              if ( !v13 )
                goto LABEL_22;
            }
            free((void *)v11[2]);
            while ( 1 )
            {
              v15 = v11[3];
              if ( !v15 )
                break;
              v11[3] = *(_DWORD *)v15;
              free(*(void **)(v15 + 4));
              *(_DWORD *)v15 = dword_432618;
              dword_432618 = v15;
            }
            free(v11);
          }
          else
          {
LABEL_22:
            v14 = (int **)v11[3];
            while ( v14 )
            {
              byte_43562C = *((_BYTE *)v11 + 20);
              if ( byte_43562C )
                dword_435630 = v11[2];
              sub_40E549(v14[1], &v23, 0, 0, 0, 0, 0);
              v14 = (int **)*v14;
              byte_43562C = 0;
            }
            v16 = &dword_421694;
            v11[4] = v23;
            v23 = 0;
            v17 = (void **)dword_421694;
            if ( dword_421694 )
            {
              do
              {
                v16 = v17;
                v17 = (void **)*v17;
              }
              while ( v17 );
            }
            *v16 = v11;
          }
          v5 = v22;
        }
        else
        {
          v5 = (_DWORD *)*v5;
        }
        v6 = v21;
      }
      while ( v5 );
    }
    v0 = *v20;
  }
  if ( v1 )
  {
    v18 = v1;
    do
    {
      if ( (byte_41148C & 1) != 0 )
        sub_4053F6(0, 0xFA5u, *((_DWORD *)v1 + 2));
      free(*((void **)v1 + 2));
      sub_404BE9(*((_DWORD **)v1 + 3));
      sub_404BE9(*((_DWORD **)v1 + 4));
      v1 = *(void **)v1;
      free(v18);
      v18 = v1;
    }
    while ( v1 );
  }
}
// 41148C: using guessed type char byte_41148C;
// 4216A0: using guessed type int dword_4216A0;
// 432618: using guessed type int dword_432618;
// 43562C: using guessed type char byte_43562C;
// 435630: using guessed type int dword_435630;

//----- (0040E069) --------------------------------------------------------
void **__fastcall sub_40E069(
        int a1,
        wchar_t *a2,
        int a3,
        unsigned __int64 a4,
        _DWORD **a5,
        _DWORD *a6,
        _DWORD *a7,
        _DWORD *a8,
        wchar_t **a9)
{
  wchar_t *v11; // eax
  __int64 v12; // rax
  _DWORD *v13; // esi
  char v14; // dl
  int v15; // eax
  int v16; // eax
  unsigned int v17; // edx
  unsigned int v18; // ecx
  _DWORD *v19; // esi
  _DWORD *v20; // edx
  _DWORD *v21; // esi
  _DWORD *v22; // ebx
  unsigned int v23; // esi
  int v24; // eax
  void **result; // eax
  const wchar_t *v26; // [esp-8h] [ebp-298h]
  __int64 v27; // [esp+10h] [ebp-280h] BYREF
  _DWORD *v28; // [esp+1Ch] [ebp-274h] BYREF
  int v29; // [esp+20h] [ebp-270h]
  _DWORD *v30; // [esp+24h] [ebp-26Ch]
  _DWORD *v31; // [esp+28h] [ebp-268h]
  _DWORD **v32; // [esp+2Ch] [ebp-264h]
  _DWORD *v33; // [esp+30h] [ebp-260h]
  void **v34; // [esp+34h] [ebp-25Ch]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+38h] [ebp-258h] BYREF

  v32 = a5;
  v30 = a6;
  v26 = *(const wchar_t **)(a1 + 4);
  v31 = a7;
  v33 = a8;
  v11 = wcsrchr(v26, 0x2Eu);
  if ( !v11 )
    return 0;
  v34 = sub_40DA04(a2, 0x101u, *(wchar_t **)(a1 + 4), (int)v11, &FindFileData);
  if ( !v34 )
    return 0;
  v12 = sub_4079E0((char *)&FindFileData);
  *a9 = a2;
  v13 = v30;
  v27 = v12;
  while ( 1 )
  {
    v13 = (_DWORD *)*v13;
    if ( !v13 )
      break;
    if ( !wcsicmp((const wchar_t *)v13[1], a2) )
    {
      *(_BYTE *)(a1 + 8) &= ~1u;
      break;
    }
  }
  v14 = *(_BYTE *)(a1 + 8);
  v28 = 0;
  v15 = sub_4038EE(a2, v14, (unsigned int *)&v27, 0, &v28);
  v29 = v15;
  if ( v28 )
  {
    v16 = sub_404E5B(v28);
    v29 += v16;
    sub_404E79(&v28);
    v15 = v29;
  }
  v17 = v27;
  *v31 += v15;
  v18 = HIDWORD(v27);
  if ( (*(_BYTE *)(a1 + 8) & 0x10) != 0
    || a4 < __PAIR64__(HIDWORD(v27), v17)
    || byte_4216B6 && a4 == __PAIR64__(HIDWORD(v27), v17) )
  {
    if ( !v13 )
    {
      v19 = sub_40E215();
      v19[1] = sub_40E267((char *)a2);
      v20 = v19;
      v21 = v32;
      sub_40E36C(v32, v20);
      v17 = v27;
      if ( !*v30 )
        *v30 = *v21;
      v18 = HIDWORD(v27);
    }
    if ( (*(_BYTE *)(a1 + 8) & 0x11) == 1 )
    {
      sub_4054D0(3u, a2, *(_DWORD *)(a1 + 4));
      v18 = HIDWORD(v27);
      v17 = v27;
    }
  }
  v22 = v33;
  v23 = v33[1];
  v24 = *v33;
  if ( *(_QWORD *)v33 <= __PAIR64__(v18, v17) )
  {
    v24 = v17;
    v23 = v18;
  }
  *v33 = v24;
  result = v34;
  v22[1] = v23;
  return result;
}
// 4216B6: using guessed type char byte_4216B6;

//----- (0040E215) --------------------------------------------------------
_DWORD *sub_40E215()
{
  _DWORD *v0; // edx
  int v1; // esi
  _DWORD *result; // eax

  v0 = (_DWORD *)dword_432618;
  if ( dword_432618 )
  {
    dword_432618 = *(_DWORD *)dword_432618;
  }
  else
  {
    v1 = dword_435624;
    if ( (unsigned int)dword_435624 >= 8 )
    {
      v0 = (_DWORD *)dword_435620;
    }
    else
    {
      v1 = 0x8000;
      v0 = sub_40AC3C(0x8000u);
    }
    dword_435620 = (int)(v0 + 2);
    dword_435624 = v1 - 8;
  }
  *v0 = 0;
  result = v0;
  v0[1] = 0;
  return result;
}
// 432618: using guessed type int dword_432618;
// 435620: using guessed type int dword_435620;
// 435624: using guessed type int dword_435624;

//----- (0040E267) --------------------------------------------------------
void *__thiscall sub_40E267(char *Src)
{
  char *v2; // edi
  char *v3; // ecx
  __int16 v4; // ax
  int v5; // edi
  void *v6; // esi

  v2 = Src;
  v3 = Src + 2;
  do
  {
    v4 = *(_WORD *)v2;
    v2 += 2;
  }
  while ( v4 );
  v5 = ((v2 - v3) >> 1) + 1;
  v6 = sub_40AC3C((unsigned __int64)(unsigned int)v5 >> 31 != 0 ? -1 : 2 * v5);
  memcpy(v6, Src, 2 * v5);
  return v6;
}

//----- (0040E2AB) --------------------------------------------------------
_WORD *__thiscall sub_40E2AB(char *this)
{
  char *v1; // ebx
  char *v2; // ecx
  __int16 v3; // ax
  int v4; // ebx
  _WORD *v5; // edi

  v1 = this;
  v2 = this + 2;
  do
  {
    v3 = *(_WORD *)v1;
    v1 += 2;
  }
  while ( v3 );
  v4 = (v1 - v2) >> 1;
  v5 = sub_40AC3C((unsigned __int64)(unsigned int)(v4 + 3) >> 31 != 0 ? -1 : 2 * (v4 + 3));
  *v5 = 34;
  memcpy(v5 + 1, this, 2 * v4);
  v5[v4 + 1] = 34;
  v5[v4 + 2] = 0;
  return v5;
}

//----- (0040E311) --------------------------------------------------------
wchar_t *__fastcall sub_40E311(char *Block, const wchar_t *a2)
{
  char *v3; // esi
  char *v4; // ecx
  __int16 v5; // ax
  int v6; // esi
  const wchar_t *v7; // ecx
  int v8; // esi
  const wchar_t *v9; // edx
  unsigned int v11; // edi
  wchar_t *v12; // esi

  v3 = Block;
  v4 = Block + 2;
  do
  {
    v5 = *(_WORD *)v3;
    v3 += 2;
  }
  while ( v5 );
  v6 = v3 - v4;
  v7 = a2;
  v8 = v6 >> 1;
  v9 = a2 + 1;
  while ( *v7++ )
    ;
  v11 = v7 - v9 + v8 + 1;
  v12 = (wchar_t *)sub_41000E(Block, v11);
  wcscat_s(v12, v11, a2);
  return v12;
}

//----- (0040E36C) --------------------------------------------------------
_DWORD *__fastcall sub_40E36C(_DWORD **a1, _DWORD *a2)
{
  _DWORD *v2; // esi
  _DWORD *result; // eax

  v2 = *a1;
  if ( *a1 )
  {
    do
    {
      result = (_DWORD *)*v2;
      a1 = (_DWORD **)v2;
      v2 = result;
    }
    while ( result );
  }
  *a1 = a2;
  return result;
}

//----- (0040E381) --------------------------------------------------------
int __thiscall sub_40E381(wint_t *this, int a2)
{
  char v3; // si
  char v4; // al

  v3 = 0;
  while ( *this )
  {
    if ( *this == 47 )
      v4 = 92;
    else
      v4 = towupper(*this);
    v3 += v4;
    ++this;
  }
  return v3 & 0x7F;
}

//----- (0040E3B9) --------------------------------------------------------
_DWORD *__thiscall sub_40E3B9(wchar_t *Source, int a2, int a3)
{
  int v4; // eax
  _DWORD *result; // eax
  int v6; // ecx
  wchar_t *v7; // esi
  rsize_t v9; // esi
  wchar_t *v10; // ebx
  int v11; // eax
  int v12; // ecx
  _DWORD *v13; // esi
  int v14; // eax
  int v15; // ecx
  wchar_t *v16; // esi
  rsize_t v18; // esi
  int v19; // eax
  char v20; // [esp+Fh] [ebp-1h]

  v20 = 0;
  if ( *Source )
  {
    v4 = sub_40E381(Source, (int)Source);
    result = sub_40FD85(Source, v4);
    if ( result )
      return result;
    if ( !wcsncmp(Source, L".\\", 2u) || !wcsncmp(Source, L"./", 2u) )
    {
      v10 = Source + 2;
    }
    else
    {
      v7 = Source;
      while ( *v7++ )
        ;
      v9 = v7 - (Source + 1) + 3;
      v10 = (wchar_t *)sub_40AC3C((unsigned __int64)v9 >> 31 != 0 ? -1 : 2 * v9);
      wcscpy_s(v10, v9, L".\\");
      wcscat_s(v10, v9, Source);
      v20 = 1;
    }
    v11 = sub_40E381(v10, v6);
    v13 = sub_40FD85(v10, v11);
    if ( v13 )
    {
      if ( !v20 )
        return v13;
    }
    else
    {
      if ( v10 != Source + 2 )
        v10[1] = 47;
      v14 = sub_40E381(v10, v12);
      v13 = sub_40FD85(v10, v14);
      if ( v20 )
        free(v10);
      if ( v13 )
        return v13;
      if ( *Source == 34 )
      {
        v10 = sub_40FF51(Source);
      }
      else
      {
        v16 = Source;
        while ( *v16++ )
          ;
        v18 = v16 - (Source + 1) + 3;
        v10 = (wchar_t *)sub_40AC3C((unsigned __int64)v18 >> 31 != 0 ? -1 : 2 * v18);
        wcscpy_s(v10, v18, L"\"");
        wcscat_s(v10, v18, Source);
        wcscat_s(v10, v18, L"\"");
      }
      v19 = sub_40E381(v10, v15);
      v13 = sub_40FD85(v10, v19);
    }
    free(v10);
    return v13;
  }
  return 0;
}
// 40E465: variable 'v6' is possibly undefined
// 40E49E: variable 'v12' is possibly undefined
// 40E52C: variable 'v15' is possibly undefined

//----- (0040E549) --------------------------------------------------------
char __fastcall sub_40E549(_WORD *a1, int **a2, int *a3, const unsigned __int16 *a4, int a5, int a6, int a7)
{
  int *v7; // ebx
  char v9; // cl
  int *v10; // eax
  __int16 v11; // dx
  char v12; // al
  unsigned __int16 *v14; // esi
  int v15; // eax
  unsigned int v16; // kr00_4
  void *v17; // esp
  int *v18; // edi
  int v19; // eax
  char v20; // ch
  int v21; // edx
  int v22; // eax
  int v23; // edx
  _DWORD *v24; // eax
  void *v25; // eax
  char v26; // al
  char v27; // cl
  int **v28; // ecx
  void *v29; // eax
  int v30; // eax
  bool v31; // zf
  int v32; // eax
  wchar_t v33[6]; // [esp+0h] [ebp-23Ch] BYREF
  int v34[2]; // [esp+Ch] [ebp-230h] BYREF
  int *v35; // [esp+14h] [ebp-228h]
  int v36; // [esp+18h] [ebp-224h]
  int **v37; // [esp+1Ch] [ebp-220h]
  unsigned __int16 *v38; // [esp+20h] [ebp-21Ch]
  int **v39; // [esp+24h] [ebp-218h] BYREF
  char v40; // [esp+29h] [ebp-213h]
  char v41; // [esp+2Ah] [ebp-212h]
  char v42; // [esp+2Bh] [ebp-211h]
  wchar_t v43[2]; // [esp+2Ch] [ebp-210h] BYREF
  __int16 v44[4]; // [esp+230h] [ebp-Ch] BYREF

  v7 = a3;
  v37 = a2;
  v35 = a3;
  v9 = 0;
  if ( a2 )
  {
    if ( a3 )
    {
      v39 = (int **)*a3;
    }
    else
    {
      v10 = *a2;
      v39 = (int **)v10;
      if ( v10 )
      {
        while ( *v10 )
        {
          v10 = *v39;
          v39 = (int **)*v39;
        }
      }
    }
  }
  else
  {
    v39 = 0;
  }
  if ( !*a1 )
  {
LABEL_19:
    if ( v7 )
      *v7 = (int)v39;
    return 1;
  }
  v11 = *a1;
  v36 = 94;
  while ( 1 )
  {
    while ( 1 )
    {
      v12 = v9;
      v42 = v9;
      if ( v11 == 36 )
        break;
      if ( v11 == 34 )
        v9 = v9 == 0;
      if ( !v9 && v11 == (_WORD)v36 )
        v9 = *++a1 == 34;
      v11 = *++a1;
      if ( !*a1 )
        goto LABEL_19;
    }
    v14 = a1 + 1;
    v40 = a7 & 4;
    if ( !*v14 )
    {
      if ( (a7 & 4) != 0 )
        goto LABEL_91;
      sub_4053F6(dword_4216B0, 0x3EAu);
      v40 = 0;
      v12 = v42;
    }
    if ( !v12 && *v14 == 94 )
      break;
LABEL_30:
    v15 = *v14;
    if ( (_WORD)v15 == 36 )
    {
      v14 = sub_40EB81(v14);
    }
    else if ( v15 == 40 )
    {
      v14 = sub_40EA82(v14 + 1, v43);
      v38 = v14;
      if ( !wcschr(L"*@<?", v43[0]) )
        goto LABEL_47;
      if ( byte_43562C && (byte_41148C & 0x40) == 0 )
      {
        v16 = wcslen(v43);
        v17 = alloca(2 * (v16 + 4));
        sub_41005A(v33, v16 + 4, (wchar_t *)L"$(%s)", v43);
        sub_4053F6(0, 0x44Cu, v33, dword_435630);
        v14 = v38;
        goto LABEL_47;
      }
    }
    else
    {
      if ( !wcschr(L"*@<?", *v14) )
        goto LABEL_43;
      if ( byte_43562C && (byte_41148C & 0x40) == 0 && *v14 != 60 )
      {
        v44[1] = *v14;
        v44[2] = 0;
        v44[0] = 36;
        sub_4053F6(0, 0x44Cu, v44, dword_435630);
LABEL_43:
        if ( !sub_403702(*v14) )
        {
          if ( v40 )
            goto LABEL_91;
          sub_4053F6(dword_4216B0, 0x3EAu);
        }
        v43[0] = *v14;
        v43[1] = 0;
LABEL_47:
        if ( v37 )
        {
          v18 = sub_40E215();
        }
        else
        {
          v34[0] = 0;
          v34[1] = (int)sub_40E267((char *)L" ");
          v18 = v34;
        }
        v19 = sub_40AB97(v43);
        v20 = v42;
        v21 = v19;
        v38 = (unsigned __int16 *)v19;
        v41 = v42;
        if ( !v19 )
          goto LABEL_72;
        if ( a4 )
        {
          v22 = wcscmp(a4, v43);
          if ( v22 )
            v22 = v22 < 0 ? -1 : 1;
          v20 = v42;
          if ( !v22 )
          {
            v23 = a5;
            v7 = v35;
            v24 = (_DWORD *)*((_DWORD *)v38 + 2);
            v41 = v42;
            if ( a5 == a6 )
            {
LABEL_59:
              if ( !v24 )
                goto LABEL_61;
              v25 = (void *)v24[1];
            }
            else
            {
              v41 = v42;
              while ( v24 )
              {
                v24 = (_DWORD *)*v24;
                if ( --v23 == a6 )
                  goto LABEL_59;
              }
LABEL_61:
              v25 = sub_40E267((char *)&dword_401690);
            }
            v21 = (int)v38;
LABEL_71:
            v18[1] = (int)v25;
            goto LABEL_72;
          }
          v21 = (int)v38;
        }
        v26 = *(_BYTE *)(v21 + 12);
        if ( (v26 & 1) == 0 )
        {
          if ( (v26 & 0x10) != 0 )
          {
            v25 = sub_40E267((char *)&dword_401690);
            v27 = v42;
            v21 = (int)v38;
          }
          else
          {
            v27 = v20;
            v25 = *(void **)(*(_DWORD *)(v21 + 8) + 4);
          }
          v41 = v27;
          goto LABEL_71;
        }
        if ( v40 )
          goto LABEL_91;
        sub_4053F6(dword_4216B0, 0x42Eu, v43);
        v21 = (int)v38;
        v41 = v42;
LABEL_72:
        v28 = v37;
        if ( v37 )
        {
          if ( !v21 || (*(_BYTE *)(v21 + 12) & 0x10) != 0 )
          {
            v29 = sub_40E267((char *)&dword_401690);
            v21 = (int)v38;
            v28 = v37;
            v18[1] = (int)v29;
          }
          *v18 = 0;
          if ( v39 )
            *v39 = v18;
          else
            *v28 = v18;
          v39 = (int **)v18;
        }
        if ( v21 && wcschr((const wchar_t *)v18[1], 0x24u) )
        {
          *((_BYTE *)v38 + 12) |= 1u;
          if ( !a4 )
            goto LABEL_86;
          v30 = wcscmp(a4, v43);
          if ( v30 )
            v30 = v30 < 0 ? -1 : 1;
          v31 = v30 == 0;
          v32 = a5;
          if ( v31 )
LABEL_86:
            v32 = a6;
          sub_40E549(&v39, v43, a5 + 1, v32, a7);
          *((_BYTE *)v38 + 12) &= ~1u;
        }
        v9 = v41;
        goto LABEL_89;
      }
    }
    v9 = v42;
LABEL_89:
    a1 = v14 + 1;
    v11 = *a1;
    if ( !*a1 )
      goto LABEL_19;
  }
  if ( sub_403702(*++v14) || !v40 )
  {
    sub_4053F6(dword_4216B0, 0x3E9u, *v14);
    goto LABEL_30;
  }
LABEL_91:
  if ( v7 )
    *v7 = (int)v39;
  return 0;
}
// 401690: using guessed type int dword_401690;
// 41148C: using guessed type char byte_41148C;
// 4216B0: using guessed type int dword_4216B0;
// 43562C: using guessed type char byte_43562C;
// 435630: using guessed type int dword_435630;
// 40E549: using guessed type int **var_218;

//----- (0040EA82) --------------------------------------------------------
wint_t *__fastcall sub_40EA82(wint_t *a1, wint_t *a2)
{
  wint_t *v2; // esi
  wint_t *v3; // ebx
  wint_t *v4; // edi
  wint_t v5; // dx
  wint_t v6; // cx
  wint_t v7; // ax
  wint_t v8; // cx
  wint_t v9; // ax
  wint_t v10; // dx

  v2 = a1;
  v3 = a2;
  v4 = a2;
  v5 = *a1;
  if ( *a1 )
  {
    v6 = *a1;
    do
    {
      v5 = v6;
      if ( v6 == 41 )
        break;
      v5 = v6;
      if ( v6 == 58 )
        goto LABEL_10;
      if ( v6 == 94 && !sub_403702(*++v2) )
        sub_4053F6(dword_4216B0, 0x3E9u, *v2);
      v7 = *v2++;
      *v4++ = v7;
      v6 = *v2;
      v5 = *v2;
    }
    while ( *v2 );
  }
  if ( v5 != 41 )
  {
LABEL_10:
    v8 = v5;
    do
    {
      v9 = v8;
      if ( v8 == 94 )
        v9 = *++v2;
      v10 = v9;
      if ( !v9 )
        break;
      v8 = *++v2;
      v10 = *v2;
    }
    while ( *v2 != 41 );
    v3 = a2;
    if ( v10 != 41 )
      sub_4053F6(dword_4216B0, 0x3E8u);
  }
  *v4 = 0;
  if ( (int)(((char *)v4 - (char *)v3) & 0xFFFFFFFE) > 514 )
    sub_4053F6(dword_4216B0, 0x434u);
  return v2;
}
// 4216B0: using guessed type int dword_4216B0;

//----- (0040EB81) --------------------------------------------------------
_WORD *__thiscall sub_40EB81(_WORD *this)
{
  int v2; // eax
  _WORD *result; // eax
  int v4; // eax
  __int16 v5; // ax
  int v6; // eax
  __int16 v7; // ax
  bool v8; // zf

  if ( *this )
  {
    v2 = (unsigned __int16)this[1];
    if ( (_WORD)v2 == 94 )
      return this + 1;
    if ( v2 == 40 )
    {
      v4 = (unsigned __int16)this[2];
      if ( (_WORD)v4 == 94 || v4 != 64 )
        return this + 2;
      v5 = this[3];
      if ( v5 == 94 )
      {
        v6 = (unsigned __int16)this[4];
      }
      else
      {
        if ( v5 == 41 )
          return this + 3;
        if ( !wcschr(L"DFBR", this[3]) )
          return this;
        v7 = this[4];
        if ( v7 != 94 )
        {
          v8 = v7 == 41;
          result = this + 4;
          if ( v8 )
            return result;
          return this;
        }
        v6 = (unsigned __int16)this[5];
      }
      sub_4053F6(dword_4216B0, 0x3E9u, v6);
    }
  }
  return this;
}
// 4216B0: using guessed type int dword_4216B0;

//----- (0040EC1B) --------------------------------------------------------
wchar_t *__thiscall sub_40EC1B(wchar_t *Str)
{
  wchar_t *v1; // esi
  int *v2; // edi
  int *v3; // eax
  int v4; // ecx
  int *v6; // [esp+8h] [ebp-4h] BYREF

  v1 = Str;
  v6 = 0;
  if ( wcschr(Str, 0x24u) )
  {
    sub_40E549(v1, &v6, 0, 0, 0, 0, 0);
    v2 = v6;
    v1 = (wchar_t *)sub_40EC83((__int16 *)v1, 255, &v6);
    v3 = v2;
    v6 = v2;
    if ( v2 )
    {
      v4 = dword_432618;
      do
      {
        v2 = (int *)*v2;
        *v3 = v4;
        v4 = (int)v3;
        v3 = v2;
        v6 = v2;
      }
      while ( v2 );
      dword_432618 = v4;
    }
  }
  return v1;
}
// 432618: using guessed type int dword_432618;

//----- (0040EC83) --------------------------------------------------------
void *__fastcall sub_40EC83(__int16 *a1, char a2, _DWORD *a3)
{
  __int16 *v3; // ebx
  bool v4; // dl
  char *v5; // edi
  __int16 v6; // ax
  char *v7; // esi
  __int16 v8; // cx
  __int16 v9; // ax
  wchar_t *v10; // esi
  wchar_t v11; // ax
  int v12; // eax
  unsigned __int16 *v13; // esi
  int v14; // eax
  _DWORD **v15; // ebx
  _DWORD *v16; // eax
  bool v17; // zf
  _DWORD *v18; // eax
  wchar_t *v19; // esi
  int v20; // esi
  void *v21; // ebx
  int v23; // [esp-4h] [ebp-844h]
  char v24; // [esp+13h] [ebp-82Dh]
  char *v25; // [esp+14h] [ebp-82Ch] BYREF
  char v26; // [esp+1Bh] [ebp-825h]
  char *v27; // [esp+1Ch] [ebp-824h] BYREF
  char v28; // [esp+23h] [ebp-81Dh]
  char *v29; // [esp+24h] [ebp-81Ch] BYREF
  unsigned int v30; // [esp+28h] [ebp-818h] BYREF
  __int16 *v31; // [esp+2Ch] [ebp-814h] BYREF
  int v32; // [esp+30h] [ebp-810h]
  _DWORD *v33; // [esp+34h] [ebp-80Ch]
  char Src[2048]; // [esp+38h] [ebp-808h] BYREF
  char v35; // [esp+838h] [ebp-8h] BYREF

  v33 = a3;
  v3 = a1;
  v28 = a2;
  v4 = 0;
  v26 = 0;
  v31 = a1;
  v5 = Src;
  v27 = &v35;
  v6 = *a1;
  v7 = Src;
  v24 = 0;
  v30 = 1024;
  v29 = Src;
  v25 = Src;
  if ( !v6 )
    goto LABEL_51;
  v8 = v6;
  v32 = 34;
  while ( 1 )
  {
    do
    {
      if ( v8 == 36 )
        break;
      if ( v7 == v27 )
      {
        sub_40EFD8((const void **)&v29, &v25, &v27, &v30, Src);
        v7 = v25;
        v4 = v24;
      }
      v9 = *v3;
      if ( *v3 == 34 )
      {
        v4 = !v4;
        v24 = v4;
      }
      if ( !v4 && v9 == 94 )
      {
        *(_WORD *)v7 = 94;
        v7 += 2;
        v25 = v7;
        if ( v7 == v27 )
        {
          sub_40EFD8((const void **)&v29, &v25, &v27, &v30, Src);
          v7 = v25;
          v4 = v24;
        }
        v9 = *++v3;
        if ( *v3 == (_WORD)v32 )
        {
          v4 = 1;
          v24 = 1;
        }
      }
      *(_WORD *)v7 = v9;
      ++v3;
      v7 += 2;
      v25 = v7;
      v31 = v3;
      v8 = *v3;
    }
    while ( *v3 );
    if ( v7 == v27 )
    {
      sub_40EFD8((const void **)&v29, &v25, &v27, &v30, Src);
      v7 = v25;
    }
    if ( !*v3 )
      break;
    v10 = (wchar_t *)(v3 + 2);
    if ( v3[1] == 40 && wcschr(L"*@<?", *v10) )
    {
      sub_40F04C((const void **)&v29, &v31, &v25, &v27, &v30, (char *)3, Src);
    }
    else
    {
      v11 = v3[1];
      if ( v11 == 36 )
      {
        v12 = *v10;
        if ( (_WORD)v12 != 94 && v28 == 1 )
        {
          if ( v12 == 64 )
          {
            v23 = 2;
LABEL_36:
            sub_40F04C((const void **)&v29, &v31, &v25, &v27, &v30, (char *)v23, Src);
            goto LABEL_46;
          }
          if ( (_WORD)v12 == 40 )
            v10 = (wchar_t *)(v3 + 3);
          v13 = v10 + 1;
          v14 = *v13;
          if ( (v14 == 70 || v14 == 68 || v14 == 66 || v14 == 82) && v13[1] == 41 )
          {
            v23 = 4;
            goto LABEL_36;
          }
        }
        v23 = 5;
        goto LABEL_36;
      }
      if ( wcschr(L"*@<?", v11) )
      {
        sub_40F04C((const void **)&v29, &v31, &v25, &v27, &v30, (char *)1, Src);
      }
      else
      {
        v15 = (_DWORD **)v33;
        v16 = (_DWORD *)*v33;
        if ( !*v33 )
        {
          sub_4053F6(dword_4216B0, 0x410u);
          v16 = *v15;
        }
        v17 = wcschr((const wchar_t *)v16[1], 0x24u) == 0;
        v18 = (_DWORD *)**v15;
        if ( v17 )
        {
          v19 = (wchar_t *)(*v15)[1];
          *v15 = v18;
        }
        else
        {
          *v15 = v18;
          v19 = (wchar_t *)sub_40EC83(v15);
          v26 = 1;
        }
        sub_40F516((const void **)&v29, &v31, &v25, &v27, v19, &v30, Src);
        if ( v26 )
        {
          free(v19);
          v26 = 0;
        }
      }
    }
LABEL_46:
    v3 = v31;
    v7 = v25;
    v8 = *v31;
    if ( !*v31 )
      break;
    v4 = v24;
  }
  if ( v7 == v27 )
  {
    sub_40EFD8((const void **)&v29, &v25, &v27, &v30, Src);
    v7 = v25;
  }
  v5 = v29;
LABEL_51:
  *(_WORD *)v7 = 0;
  v20 = (v7 - v5 + 2) >> 1;
  v21 = sub_40AC3C((unsigned __int64)(unsigned int)v20 >> 31 != 0 ? -1 : 2 * v20);
  if ( !v21 )
    sub_4053F6(dword_4216B0, 0x419u);
  memcpy(v21, v5, 2 * v20);
  return v21;
}
// 4216B0: using guessed type int dword_4216B0;
// 40EC83: using guessed type char *var_82C;

//----- (0040EFD8) --------------------------------------------------------
char **__fastcall sub_40EFD8(const void **a1, _DWORD *a2, char **a3, unsigned int *a4, const void *a5)
{
  void *v6; // ebx
  unsigned int v7; // esi
  char *v8; // eax
  unsigned int v9; // ecx
  char *v10; // ecx
  char **result; // eax

  v6 = (void *)*a1;
  if ( *a1 == a5 )
  {
    v6 = sub_40AC3C((unsigned __int64)*a4 >> 31 != 0 ? -1 : 2 * *a4);
    memcpy(v6, *a1, 2 * *a4);
    *a1 = v6;
  }
  v7 = *a4 + 1024;
  v8 = (char *)sub_41000E(v6, v7);
  *a1 = v8;
  v9 = *a4;
  *a4 = v7;
  *a2 = &v8[2 * v9];
  v10 = &v8[2 * v7];
  result = a3;
  *a3 = v10;
  return result;
}

//----- (0040F04C) --------------------------------------------------------
void __fastcall sub_40F04C(
        const void **a1,
        __int16 **a2,
        char **a3,
        char **a4,
        unsigned int *a5,
        char *a6,
        const void *a7)
{
  char v9; // dl
  unsigned __int16 *v10; // esi
  unsigned int v11; // ecx
  char *v12; // eax
  __int16 *v13; // edi
  __int16 v14; // dx
  __int16 v15; // si
  __int16 v16; // si
  unsigned __int16 *v17; // ebx
  unsigned int v18; // ecx
  rsize_t v19; // edi
  wchar_t *v20; // eax
  wchar_t *v21; // ecx
  wchar_t *v22; // eax
  unsigned __int16 *v23; // ebx
  char *v24; // esi
  char *v25; // ecx
  unsigned __int16 *v26; // edi
  unsigned int v27; // kr00_4
  void *v28; // eax
  rsize_t v29; // edx
  wchar_t *v30; // eax
  unsigned __int16 v31; // ax
  const void **v32; // [esp+Ch] [ebp-38h]
  unsigned __int16 **v33; // [esp+10h] [ebp-34h]
  unsigned __int16 *v34; // [esp+1Ch] [ebp-28h]
  unsigned int v35; // [esp+20h] [ebp-24h] BYREF
  rsize_t v36; // [esp+24h] [ebp-20h]
  __int16 **v37; // [esp+28h] [ebp-1Ch]
  unsigned int v38; // [esp+2Ch] [ebp-18h]
  unsigned __int16 *v39; // [esp+30h] [ebp-14h] BYREF
  void *Block; // [esp+34h] [ebp-10h]
  unsigned int v41; // [esp+38h] [ebp-Ch]
  char *v42; // [esp+3Ch] [ebp-8h] BYREF
  char v43; // [esp+41h] [ebp-3h]
  char v44; // [esp+42h] [ebp-2h]
  char v45; // [esp+43h] [ebp-1h]

  v41 = 2;
  v44 = 0;
  v9 = 0;
  v43 = 0;
  Block = 0;
  v10 = 0;
  v36 = 0;
  v11 = 1;
  v37 = a2;
  v32 = a1;
  v45 = 0;
  v38 = 1;
  if ( a6 != (char *)1 )
  {
    if ( a6 == (char *)2 )
    {
LABEL_10:
      v10 = (unsigned __int16 *)dword_421EC8;
      goto LABEL_25;
    }
    if ( a6 != (char *)3 )
    {
      if ( a6 != (char *)4 )
      {
        if ( a6 == (char *)5 )
        {
          v12 = *a3;
          if ( *a3 == *a4 )
          {
            sub_40EFD8(a1, a3, a4, a5, a7);
            v12 = *a3;
          }
          *(_WORD *)v12 = 36;
          *a2 += 2;
          *a3 = v12 + 2;
        }
        return;
      }
      v38 = 4;
      v44 = 1;
      goto LABEL_10;
    }
    v11 = v41;
    v44 = 1;
  }
  switch ( (*a2)[v11] )
  {
    case '*':
      if ( (*a2)[v11 + 1] == 42 )
      {
        v10 = (unsigned __int16 *)dword_421EC4;
        ++v11;
LABEL_23:
        v9 = 1;
        goto LABEL_24;
      }
      v10 = (unsigned __int16 *)dword_421ED8;
      v43 = 1;
      break;
    case '<':
      v10 = (unsigned __int16 *)dword_421ECC;
      break;
    case '?':
      v10 = (unsigned __int16 *)dword_421ED0;
      goto LABEL_23;
    default:
      v9 = v45;
      if ( (*a2)[v11] == 64 )
        v10 = dword_421ED4;
      goto LABEL_24;
  }
  v9 = v45;
LABEL_24:
  v38 = v11 + 1;
LABEL_25:
  if ( v10 )
  {
    v17 = 0;
    if ( v9 )
    {
      v23 = v10;
      v35 = 1024;
      v34 = v10;
      v24 = (char *)sub_40AC3C(0x800u);
      v39 = (unsigned __int16 *)v24;
      a6 = v24;
      v25 = v24 + 2048;
      v42 = v24 + 2048;
      do
      {
        v26 = (unsigned __int16 *)*((_DWORD *)v23 + 1);
        v33 = (unsigned __int16 **)v23;
        if ( v44 )
        {
          v27 = wcslen(v26);
          v28 = Block;
          v29 = v27 + 1;
          if ( v27 + 1 > v36 )
          {
            if ( Block )
            {
              free(Block);
              v29 = v27 + 1;
            }
            v36 = v29;
            v28 = sub_40AC3C((v41 * (unsigned __int64)v29) >> 32 != 0 ? -1 : v41 * v29);
            Block = v28;
          }
          v30 = sub_40F3BE((*v37)[v38], (wchar_t *)v28, v36, v26);
          v25 = v42;
          v26 = v30;
        }
        if ( *v26 )
        {
          do
          {
            if ( v24 == v25 )
            {
              sub_40EFD8((const void **)&v39, &a6, &v42, &v35, 0);
              v24 = a6;
              v25 = v42;
            }
            v31 = *v26;
            v26 = (unsigned __int16 *)((char *)v26 + v41);
            *(_WORD *)v24 = v31;
            v24 += v41;
            a6 = v24;
          }
          while ( *v26 );
          v23 = v34;
        }
        if ( v24 == v25 )
        {
          sub_40EFD8((const void **)&v39, &a6, &v42, &v35, 0);
          v24 = a6;
          v25 = v42;
        }
        *(_WORD *)v24 = 0;
        v23 = *(unsigned __int16 **)v23;
        v34 = v23;
        if ( v23 )
        {
          *(_WORD *)v24 = 32;
          v24 += v41;
          a6 = v24;
          if ( v24 == v25 )
          {
            sub_40EFD8((const void **)&v39, &a6, &v42, &v35, 0);
            v24 = a6;
            v25 = v42;
          }
          *(_WORD *)v24 = 0;
          v23 = *v33;
          v34 = *v33;
        }
      }
      while ( v23 );
      v10 = v39;
      v17 = v39;
      goto LABEL_39;
    }
  }
  else
  {
    v13 = *a2;
    v14 = **a2;
    if ( v14 )
    {
      v15 = **a2;
      do
      {
        v14 = v15;
        if ( v15 == 32 )
          break;
        if ( v15 == 9 )
          break;
        v13 = (__int16 *)((char *)v13 + v41);
        v15 = *v13;
        v14 = *v13;
      }
      while ( *v13 );
      a2 = v37;
    }
    v16 = v14;
    *v13 = 0;
    sub_4053F6(dword_4216B0, 0xFA6u, *a2);
    *v13 = v16;
    v10 = (unsigned __int16 *)sub_40E267((char *)&dword_401690);
    v17 = v10;
  }
  v18 = wcslen(v10);
  v19 = v18 + 1;
  if ( !v18 )
    v19 = v41;
  v20 = (wchar_t *)sub_40AC3C((v41 * (unsigned __int64)v19) >> 32 != 0 ? -1 : v41 * v19);
  v21 = v20;
  Block = v20;
  if ( v43 )
  {
    v22 = sub_40F3BE(82, v20, v19, v10);
    v21 = (wchar_t *)Block;
    v10 = v22;
  }
  if ( v44 )
    v10 = sub_40F3BE((*v37)[v38], v21, v19, v10);
LABEL_39:
  sub_40F516(v32, v37, a3, a4, v10, a5, a7);
  if ( v17 )
    free(v17);
  if ( Block )
    free(Block);
}
// 40F28C: conditional instruction was optimized away because ebx.4!=0
// 401690: using guessed type int dword_401690;
// 4216B0: using guessed type int dword_4216B0;
// 421EC4: using guessed type int dword_421EC4;
// 421EC8: using guessed type int dword_421EC8;
// 421ED0: using guessed type int dword_421ED0;
// 421ED8: using guessed type int dword_421ED8;

//----- (0040F3BE) --------------------------------------------------------
wchar_t *__fastcall sub_40F3BE(__int16 a1, wchar_t *a2, rsize_t SizeInWords, wchar_t *Source)
{
  wchar_t *v4; // esi
  wchar_t *v5; // ebx
  wchar_t *v6; // edi
  wchar_t *i; // eax
  int v8; // ecx
  int v9; // eax
  wchar_t *v10; // eax
  unsigned __int16 Sourcea; // [esp+24h] [ebp+Ch]

  v4 = a2;
  v5 = 0;
  v6 = 0;
  if ( wcscpy_s(a2, SizeInWords, Source) )
    sub_4053F6(dword_4216B0, 0x410u);
  Sourcea = *v4;
  for ( i = &v4[wcslen(v4) - 1]; i >= v4; --i )
  {
    v8 = *i;
    if ( v8 == 92 || v8 == 47 )
    {
      v6 = i;
      break;
    }
    if ( v8 == 46 && !v5 )
      v5 = i;
  }
  if ( a1 == 66 )
  {
    if ( v5 )
      *v5 = 0;
LABEL_30:
    if ( v6 )
    {
      v4 = v6 + 1;
    }
    else if ( v4[1] == 58 )
    {
      v4 += 2;
    }
    goto LABEL_34;
  }
  if ( a1 != 68 )
  {
    if ( a1 != 70 )
    {
      if ( a1 == 82 && v5 )
        *v5 = 0;
      goto LABEL_34;
    }
    goto LABEL_30;
  }
  v9 = v4[1];
  if ( v6 )
  {
    if ( v9 == 58 && v6 == v4 + 2 )
      ++v6;
    *v6 = 0;
  }
  else if ( v9 == 58 )
  {
    v4[2] = 0;
  }
  else if ( wcscpy_s(v4, SizeInWords, L".") )
  {
    sub_4053F6(dword_4216B0, 0x410u);
  }
LABEL_34:
  if ( Sourcea == 34 )
  {
    if ( *v4 != 34 && v4 > a2 )
      *--v4 = 34;
    v10 = wcschr(v4, 0);
    if ( *(v10 - 1) != 34 )
      *(_DWORD *)v10 = 34;
  }
  return v4;
}
// 4216B0: using guessed type int dword_4216B0;

//----- (0040F516) --------------------------------------------------------
__int16 *__fastcall sub_40F516(
        const void **a1,
        __int16 **a2,
        char **a3,
        char **a4,
        wchar_t *String1,
        unsigned int *a6,
        const void *a7)
{
  __int16 **v7; // esi
  const wchar_t *v8; // eax
  __int16 *v9; // eax
  __int16 *v10; // ecx
  __int16 *v11; // ebx
  __int16 *v12; // edx
  __int16 v13; // di
  __int16 v14; // ax
  __int16 *result; // eax
  wchar_t *v16; // edi
  char *v17; // ecx
  __int16 v18; // ax
  __int16 v19; // dx
  __int16 *v22; // [esp+18h] [ebp-4h] BYREF

  v7 = a2;
  v8 = (const wchar_t *)++*a2;
  if ( **a2 == 94 )
    *a2 = (__int16 *)++v8;
  v9 = (__int16 *)wcschr(v8, 0x3Au);
  v10 = *v7;
  v11 = v9;
  v12 = *v7;
  v22 = v9;
  if ( *v12 )
  {
    v13 = *v12;
    do
    {
      if ( v13 == 41 )
        break;
      if ( v13 == 94 )
        ++v12;
      v13 = *++v12;
    }
    while ( *v12 );
    v7 = a2;
    v11 = v22;
  }
  v14 = *v10;
  if ( *v10 == 40 && v11 && v11 < v12 )
  {
    sub_40F646(a1, &v22, a3, a4, String1, a6, a7);
    result = v22;
  }
  else
  {
    v16 = String1;
    if ( *String1 )
    {
      v17 = *a3;
      do
      {
        if ( v17 == *a4 )
        {
          sub_40EFD8(a1, a3, a4, a6, a7);
          v17 = *a3;
        }
        v18 = *v16++;
        *(_WORD *)v17 = v18;
        v17 += 2;
        *a3 = v17;
      }
      while ( *v16 );
      v7 = a2;
      v10 = *a2;
      v14 = **a2;
    }
    v19 = v14;
    if ( v14 == 36 )
    {
      *v7 = ++v10;
      v19 = *v10;
    }
    if ( v19 == 40 )
    {
      do
        v10 = ++*v7;
      while ( **v7 != 41 );
    }
    else if ( v19 == 42 && v10[1] == 42 )
    {
      ++v10;
    }
    result = v10 + 1;
  }
  *v7 = result;
  return result;
}

//----- (0040F646) --------------------------------------------------------
void __fastcall sub_40F646(
        const void **a1,
        __int16 **a2,
        char **a3,
        char **a4,
        wchar_t *String1,
        unsigned int *a6,
        const void *a7)
{
  __int16 *i; // edi
  __int16 v9; // ax
  __int16 v10; // ax
  __int16 *v11; // ebx
  __int16 v12; // dx
  _WORD *v13; // eax
  __int16 *v14; // esi
  _WORD *v15; // edx
  __int16 j; // cx
  char *v17; // ecx
  char *v18; // edx
  __int16 v19; // ax
  __int16 *v20; // esi
  _WORD *v21; // ecx
  __int16 v22; // dx
  __int16 v23; // ax
  wchar_t *v24; // edi
  wchar_t v25; // ax
  size_t v26; // esi
  _WORD *v27; // ebx
  char *v28; // ecx
  int v29; // eax
  char *v30; // ecx
  _WORD *Block; // [esp+10h] [ebp-1Ch]
  __int16 *v34; // [esp+18h] [ebp-14h]
  int MaxCount; // [esp+1Ch] [ebp-10h]
  wchar_t *String2; // [esp+20h] [ebp-Ch]

  for ( i = ++*a2; ; ++i )
  {
    v9 = *i;
    if ( !*i )
      break;
    if ( v9 == 61 )
      goto LABEL_8;
    if ( v9 == 94 )
      ++i;
  }
  sub_4053F6(dword_4216A4, 0x3EBu);
LABEL_8:
  if ( i == *a2 )
    sub_4053F6(dword_4216A4, 0x3EDu);
  v10 = *i;
  v11 = i;
  v34 = i;
  v12 = *i;
  if ( *i )
  {
    while ( v10 != 41 )
    {
      if ( v10 == 94 )
        ++v11;
      v34 = ++v11;
      v10 = *v11;
      v12 = *v11;
      if ( !*v11 )
        goto LABEL_15;
    }
  }
  else
  {
LABEL_15:
    if ( v12 != 41 )
      sub_4053F6(dword_4216A4, 0x3E8u);
  }
  v13 = sub_40AC3C((unsigned __int64)(unsigned int)(i - *a2 + 1) >> 31 != 0 ? -1 : 2 * (i - *a2 + 1));
  v14 = *a2;
  v15 = v13;
  String2 = v13;
  for ( j = *v14; *v14 != 61; j = *v14 )
  {
    if ( j == 94 )
      ++v14;
    *v15++ = *v14++;
  }
  *v15 = 0;
  v17 = (char *)v13;
  v18 = (char *)(v13 + 1);
  do
  {
    v19 = *(_WORD *)v17;
    v17 += 2;
  }
  while ( v19 );
  MaxCount = (v17 - v18) >> 1;
  v20 = v14 + 1;
  Block = sub_40AC3C((unsigned __int64)(unsigned int)(v11 - i) >> 31 != 0 ? -1 : 2 * (v11 - i));
  v21 = Block;
  v22 = *v20;
  if ( *v20 != 41 )
  {
    do
    {
      if ( v22 == 94 )
        ++v20;
      v23 = *v20++;
      *v21++ = v23;
      v22 = *v20;
    }
    while ( *v20 != 41 );
    v11 = v34;
  }
  v24 = String1;
  *v21 = 0;
  *a2 = v11 + 1;
  v25 = *String1;
  if ( *String1 )
  {
    v26 = MaxCount;
    do
    {
      if ( v25 == *String2 && !wcsncmp(v24, String2, v26) )
      {
        v27 = Block;
        if ( *Block )
        {
          v28 = *a3;
          do
          {
            if ( v28 == *a4 )
            {
              sub_40EFD8(a1, a3, a4, a6, a7);
              v28 = *a3;
            }
            *(_WORD *)v28 = *v27;
            v28 += 2;
            ++v27;
            *a3 = v28;
          }
          while ( *v27 );
          v26 = MaxCount;
          v24 = String1;
        }
        v29 = 2 * v26;
      }
      else
      {
        v30 = *a3;
        if ( *a3 == *a4 )
        {
          sub_40EFD8(a1, a3, a4, a6, a7);
          v30 = *a3;
        }
        *(_WORD *)v30 = *v24;
        *a3 = v30 + 2;
        v29 = 2;
      }
      v24 = (wchar_t *)((char *)v24 + v29);
      String1 = v24;
      v25 = *v24;
    }
    while ( *v24 );
  }
  free(String2);
  free(Block);
}
// 4216A4: using guessed type int dword_4216A4;

//----- (0040F89E) --------------------------------------------------------
void *__fastcall sub_40F89E(wchar_t *FullPath, wchar_t *Filename)
{
  wchar_t Buffer[260]; // [esp+8h] [ebp-418h] BYREF
  wchar_t Dir[258]; // [esp+210h] [ebp-210h] BYREF
  wchar_t Drive[4]; // [esp+414h] [ebp-Ch] BYREF

  wsplitpath_s(FullPath, Drive, 3u, Dir, 0x100u, 0, 0, 0, 0);
  wmakepath_s(Buffer, 0x104u, Drive, Dir, Filename, 0);
  return sub_40E267((char *)Buffer);
}

//----- (0040F912) --------------------------------------------------------
char __thiscall sub_40F912(_WORD *this)
{
  _WORD *v1; // edx
  char v2; // bl
  __int16 v3; // cx
  __int16 v4; // si
  __int16 v5; // cx
  _WORD *v6; // ecx
  __int16 v7; // si
  _WORD *v8; // edx
  _WORD *v9; // ecx
  __int16 v10; // dx
  const wchar_t *v11; // esi
  wchar_t *v12; // eax
  _WORD *v14; // [esp+14h] [ebp-4h]

  v1 = this;
  v2 = 0;
  v14 = this;
  v3 = *this;
  if ( v3 == 123 )
  {
    v14 = ++v1;
    v4 = *v1;
    if ( *v1 )
    {
      v5 = *v1;
      do
      {
        v4 = v5;
        if ( v5 == 125 )
          break;
        if ( v5 == 94 )
          ++v1;
        v5 = *++v1;
        v4 = *v1;
      }
      while ( *v1 );
      v14 = v1;
      v2 = 0;
    }
    v3 = v4;
    if ( v4 )
    {
      v14 = ++v1;
      v3 = *v1;
    }
  }
  if ( v3 == 46 )
  {
    v6 = v1;
    v7 = 46;
    do
    {
      if ( v7 == 123 )
        break;
      if ( v7 == 94 )
        ++v6;
      v7 = *++v6;
    }
    while ( *v6 );
    v8 = v14;
    v2 = 0;
    while ( v8 < v6 && *v8 != 92 && *v8 != 47 )
      ++v8;
    if ( !*v6 || v8 != v6 )
    {
      v12 = wcspbrk(v14 + 1, L"./\\");
      if ( !v12 || *v12 != 46 )
        return v2;
      v11 = v12 + 1;
      goto LABEL_36;
    }
    v9 = v6 + 1;
    if ( *v9 )
    {
      v10 = *v9;
      while ( v10 != 125 )
      {
        if ( v10 == 94 )
          ++v9;
        v10 = *++v9;
        if ( !*v9 )
          return v2;
      }
      if ( v9[1] == 46 )
      {
        v11 = v9 + 2;
LABEL_36:
        if ( !wcschr(v11, 0x2Fu) && !wcschr(v11, 0x5Cu) )
        {
          if ( wcschr(v11, 0x2Eu) )
            sub_4053F6(dword_4216B0, 0x444u);
          else
            return 1;
        }
      }
    }
  }
  return v2;
}
// 4216B0: using guessed type int dword_4216B0;

//----- (0040FA87) --------------------------------------------------------
char __fastcall sub_40FA87(char *a1, int a2, unsigned __int16 *a3, const wchar_t *a4)
{
  unsigned __int16 *v4; // edi
  char *v5; // esi
  unsigned __int16 v6; // ax
  char *v7; // ebx
  unsigned __int16 *v8; // ecx
  int v9; // eax
  char v10; // bh
  char v11; // bl
  unsigned __int16 *v12; // edx
  const wchar_t *v13; // eax
  unsigned int v14; // kr00_4
  const wchar_t *v15; // ebx
  unsigned int v16; // kr04_4
  unsigned int v17; // kr08_4
  int v18; // ecx
  const wchar_t *j; // eax
  char result; // al
  unsigned int i; // [esp+14h] [ebp-21Ch]
  char v22; // [esp+1Eh] [ebp-212h]
  char v23; // [esp+1Fh] [ebp-211h]
  wchar_t Drive[262]; // [esp+20h] [ebp-210h] BYREF

  v4 = a3;
  v5 = a1;
  v6 = *a3;
  v7 = &a1[2 * a2];
  for ( i = (unsigned int)v7; *v4; v6 = *v4 )
  {
    v8 = v4;
    if ( v5 >= v7 )
      return 1;
    if ( v6 == 37 )
    {
      v9 = *++v4;
      if ( !(_WORD)v9 )
      {
        v4 = v8;
        goto LABEL_55;
      }
      if ( (_WORD)v9 == 37 )
      {
        *(_WORD *)v5 = 37;
        goto LABEL_11;
      }
      if ( v9 == 115 )
      {
        for ( j = a4; j; ++j )
        {
          if ( !*j )
            break;
          if ( v5 >= v7 )
            break;
          *(_WORD *)v5 = *j;
          v5 += 2;
        }
        goto LABEL_55;
      }
      if ( *v4 == 124 )
      {
        v22 = 0;
        v10 = 0;
        v23 = 0;
        v11 = 0;
        Drive[0] = 0;
        do
        {
          v12 = v4++;
          switch ( *v4 )
          {
            case 0u:
              v4 = v12;
LABEL_43:
              v7 = (char *)i;
              while ( v8 <= v4 && (unsigned int)v5 < i )
              {
                *(_WORD *)v5 = *v8;
                v5 += 2;
                ++v8;
              }
              goto LABEL_55;
            case 0x46u:
              if ( *(v4 - 1) == 124 )
              {
                v11 = 1;
                v10 = 1;
                v23 = 1;
                v22 = 1;
              }
              break;
            case 0x64u:
              v11 = 1;
              break;
            case 0x65u:
              v22 = 1;
              break;
            case 0x66u:
              v23 = 1;
              break;
            case 0x70u:
              v10 = 1;
              break;
            default:
              goto LABEL_43;
          }
        }
        while ( *v4 != 70 );
        v13 = a4;
        if ( !a4 )
        {
          sub_4053F6(0, 0x449u);
          v13 = 0;
        }
        if ( v11 )
          wsplitpath_s(v13, Drive, 0x104u, 0, 0, 0, 0, 0, 0);
        if ( v10 )
        {
          v14 = wcslen(Drive);
          v15 = a4;
          wsplitpath_s(a4, 0, 0, &Drive[v14], 260 - v14, 0, 0, 0, 0);
        }
        else
        {
          v15 = a4;
        }
        if ( v23 )
        {
          v16 = wcslen(Drive);
          wsplitpath_s(v15, 0, 0, 0, 0, &Drive[v16], 260 - v16, 0, 0);
        }
        if ( v22 )
        {
          v17 = wcslen(Drive);
          wsplitpath_s(v15, 0, 0, 0, 0, 0, 0, &Drive[v17], 260 - v17);
        }
        v7 = (char *)i;
        if ( Drive[0] )
        {
          v18 = (char *)Drive - v5;
          do
          {
            if ( (unsigned int)v5 >= i )
              break;
            *(_WORD *)v5 = *(_WORD *)&v5[v18];
            v5 += 2;
          }
          while ( *(_WORD *)&v5[v18] );
        }
        goto LABEL_55;
      }
      *(_WORD *)v5 = 37;
      v5 += 2;
      if ( v5 == v7 )
        return 1;
      v6 = *v4;
    }
    *(_WORD *)v5 = v6;
LABEL_11:
    v5 += 2;
LABEL_55:
    ++v4;
  }
  if ( v5 >= v7 )
    return 1;
  result = 0;
  *(_WORD *)v5 = 0;
  return result;
}
// 40FA87: using guessed type wchar_t Drive[262];

//----- (0040FD85) --------------------------------------------------------
_DWORD *__thiscall sub_40FD85(wint_t *this, int a2)
{
  _DWORD *v2; // edi
  wint_t *v3; // ebx
  wint_t *v4; // eax
  wint_t v5; // cx
  wint_t v6; // si
  bool v7; // zf
  wint_t *v9; // [esp+Ch] [ebp-8h]
  _DWORD *v10; // [esp+10h] [ebp-4h]
  wint_t *v11; // [esp+1Ch] [ebp+8h]

  v2 = (_DWORD *)dword_421490[a2];
  v9 = this;
  v10 = v2;
  if ( !v2 )
    return 0;
  while ( 1 )
  {
    v3 = this;
    v4 = (wint_t *)v2[1];
    v11 = v4;
    if ( *this )
    {
      do
      {
        v5 = *v4;
        if ( !*v4 )
          break;
        if ( *v3 == 92 || *v3 == 47 )
        {
          if ( v5 != 92 && v5 != 47 )
            break;
        }
        else
        {
          v6 = towupper(*v4);
          v7 = towupper(*v3) == v6;
          v4 = v11;
          if ( !v7 )
            break;
        }
        ++v3;
        v11 = ++v4;
      }
      while ( *v3 );
      v2 = v10;
      this = v9;
    }
    if ( !*v3 && !*v4 )
      return v2;
    v2 = (_DWORD *)*v2;
    v10 = v2;
    if ( !v2 )
      return 0;
  }
}
// 421490: using guessed type int dword_421490[128];

//----- (0040FE3D) --------------------------------------------------------
int __fastcall sub_40FE3D(_WORD *a1, int a2)
{
  __int16 *v2; // edi
  _WORD *v3; // edx
  char *v4; // esi
  void *v6; // esp
  __int16 *v7; // ecx
  __int16 v8; // ax
  void *v9; // esp
  wchar_t v10; // ax
  wchar_t v11; // cx
  wchar_t *v12; // eax
  int v13; // esi
  __int16 v14; // si
  wchar_t v15; // cx
  wchar_t *v16; // eax
  int v17; // edi
  wchar_t v18; // si
  wchar_t v20[6]; // [esp+0h] [ebp-1Ch] BYREF
  int v21; // [esp+Ch] [ebp-10h]
  __int16 *v22; // [esp+10h] [ebp-Ch]
  int v23; // [esp+14h] [ebp-8h]

  v2 = (__int16 *)a2;
  v22 = (__int16 *)a2;
  v3 = a1 + 1;
  v4 = (char *)a1;
  v23 = 0;
  while ( *a1++ )
    ;
  v6 = alloca(2 * (a1 - v3) + 2);
  v7 = v2;
  do
    v8 = *v7++;
  while ( v8 != (_WORD)v23 );
  v9 = alloca(2 * (v7 - (v2 + 1)) + 2);
  v10 = *(_WORD *)v4;
  v23 = 34;
  v11 = v10;
  if ( v10 == 34 )
  {
    v4 += 2;
    v11 = *(_WORD *)v4;
  }
  v12 = v20;
  if ( v11 )
  {
    v13 = v4 - (char *)v20;
    do
    {
      *v12++ = v11;
      v21 = v11;
      v11 = *(wchar_t *)((char *)v12 + v13);
    }
    while ( v11 );
    v2 = v22;
    v14 = v23;
    if ( v12 != v20 && (_WORD)v21 == (_WORD)v23 )
      --v12;
  }
  else
  {
    v14 = v23;
  }
  *v12 = 0;
  v15 = *v2;
  if ( *v2 == v14 )
    v15 = *++v2;
  v16 = v20;
  if ( v15 )
  {
    v17 = (char *)v2 - (char *)v20;
    do
    {
      *v16++ = v15;
      v18 = v15;
      v15 = *(wchar_t *)((char *)v16 + v17);
    }
    while ( v15 );
    if ( v16 != v20 && v18 == (_WORD)v23 )
      --v16;
  }
  *v16 = 0;
  return wcsicmp(v20, v20);
}

//----- (0040FF51) --------------------------------------------------------
_WORD *__fastcall sub_40FF51(_WORD *a1)
{
  char *v1; // esi
  _WORD *v2; // edx
  __int64 v4; // rax
  _WORD *v5; // edx
  __int16 v6; // ax
  _WORD *v7; // ecx
  int v8; // esi
  __int16 v9; // di

  v1 = (char *)a1;
  v2 = a1 + 1;
  while ( *a1++ )
    ;
  v4 = 2i64 * (unsigned int)(a1 - v2 + 1);
  v5 = sub_40AC3C(HIDWORD(v4) != 0 ? -1 : v4);
  v6 = *(_WORD *)v1;
  if ( *(_WORD *)v1 == 34 )
  {
    v1 += 2;
    v6 = *(_WORD *)v1;
  }
  v7 = v5;
  if ( v6 )
  {
    v8 = v1 - (char *)v5;
    v9 = v6;
    do
    {
      *v7++ = v9;
      v9 = *(_WORD *)((char *)v7 + v8);
    }
    while ( v9 );
  }
  if ( *(v7 - 1) == 34 )
    --v7;
  *v7 = 0;
  return v5;
}

//----- (0040FFC6) --------------------------------------------------------
FILE *__fastcall sub_40FFC6(wchar_t *FileName, wchar_t *Mode)
{
  wchar_t *v4; // eax
  wchar_t *v5; // edx
  wchar_t v6; // ax
  wchar_t *v7; // ecx

  if ( *FileName == 34 )
  {
    v4 = wcsrchr(FileName, 0x22u);
    v5 = FileName + 1;
    *v4 = 0;
    v6 = FileName[1];
    *FileName = v6;
    while ( v6 )
    {
      v7 = v5++;
      v6 = *v5;
      *v7 = *v5;
    }
  }
  return wfsopen(FileName, Mode, 32);
}

//----- (0041000E) --------------------------------------------------------
void *__fastcall sub_41000E(void *Block, unsigned int a2)
{
  void *v2; // esi
  void *v3; // eax

  v2 = 0;
  if ( Block )
  {
    if ( a2 <= 0x7FFFFFFC )
    {
      v3 = realloc(Block, 2 * a2);
      goto LABEL_6;
    }
LABEL_7:
    sub_4053F6(dword_4216B0, 0x41Bu);
    return v2;
  }
  if ( a2 > 0x7FFFFFFC )
    goto LABEL_7;
  v3 = malloc(2 * a2);
LABEL_6:
  v2 = v3;
  if ( !v3 )
    goto LABEL_7;
  return v2;
}
// 4216B0: using guessed type int dword_4216B0;

//----- (0041005A) --------------------------------------------------------
int sub_41005A(wchar_t *Buffer, size_t BufferCount, wchar_t *Format, ...)
{
  unsigned __int64 *v3; // eax
  int result; // eax
  va_list va; // [esp+14h] [ebp+14h] BYREF

  va_start(va, Format);
  v3 = (unsigned __int64 *)sub_40C84C();
  result = _stdio_common_vswprintf_s(*v3, Buffer, BufferCount, Format, 0, va);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (00410088) --------------------------------------------------------
WCHAR *__thiscall sub_410088(wchar_t *FullPath)
{
  WCHAR *result; // eax
  wchar_t *v3; // esi
  _DWORD *v4; // edi
  _DWORD *v5; // esi
  void *v6; // eax
  WCHAR *Filename; // [esp+10h] [ebp-260h]
  HANDLE hFindFile; // [esp+14h] [ebp-25Ch] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+18h] [ebp-258h] BYREF

  result = sub_4079FA(FullPath, &FindFileData, &hFindFile);
  v3 = result;
  if ( result )
  {
    v4 = sub_40E215();
    v4[1] = sub_40F89E(FullPath, v3);
    while ( 1 )
    {
      Filename = sub_407B86(&FindFileData, hFindFile);
      if ( !Filename )
        break;
      v5 = sub_40E215();
      v6 = sub_40F89E(FullPath, Filename);
      *v5 = v4;
      v4 = v5;
      v5[1] = v6;
    }
    return (WCHAR *)v4;
  }
  return result;
}

//----- (004101BF) --------------------------------------------------------
int sub_4101BF()
{
  __scrt_initialize_default_local_stdio_options();
  return 0;
}
// 4108C5: using guessed type int __scrt_initialize_default_local_stdio_options(void);

//----- (00410888) --------------------------------------------------------
int __cdecl UserMathErrorFunction()
{
  return 0;
}

//----- (0041088B) --------------------------------------------------------
int sub_41088B()
{
  return 1;
}

//----- (00410895) --------------------------------------------------------
void sub_410895()
{
  InitializeSListHead(&ListHead);
}

//----- (004108A1) --------------------------------------------------------
char sub_4108A1()
{
  return 1;
}

//----- (004108E2) --------------------------------------------------------
BOOL sub_4108E2()
{
  return dword_411004 == 0;
}
// 411004: using guessed type int dword_411004;

//----- (004108EE) --------------------------------------------------------
void *sub_4108EE()
{
  return &unk_435E70;
}

//----- (004108F4) --------------------------------------------------------
void *sub_4108F4()
{
  return &unk_435E6C;
}

//----- (00410A5D) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_410A5D()
{
  return SetUnhandledExceptionFilter(__scrt_unhandled_exception_filter);
}

//----- (00410ABF) --------------------------------------------------------
void sub_410ABF()
{
  dword_411468 = 0;
}
// 411468: using guessed type int dword_411468;

//----- (00410AC7) --------------------------------------------------------
void sub_410AC7()
{
  ;
}
// 410AC7: could not find valid save-restore pair for edi

//----- (00410AF3) --------------------------------------------------------
void __cdecl sub_410AF3()
{
  ;
}
// 410AF3: could not find valid save-restore pair for edi

//----- (00410DEA) --------------------------------------------------------
int sub_410DEA()
{
  _DWORD *v0; // eax
  int v1; // ecx
  _DWORD *v2; // eax
  int v3; // ecx

  v0 = sub_40C84C();
  v1 = v0[1];
  *v0 |= 4u;
  v0[1] = v1;
  v2 = sub_40C62E();
  v3 = v2[1];
  *v2 |= 2u;
  v2[1] = v3;
  return 0;
}

// nfuncs=251 queued=185 decompiled=185 lumina nreq=0 worse=0 better=0
// ALL OK, 185 function(s) have been successfully decompiled
